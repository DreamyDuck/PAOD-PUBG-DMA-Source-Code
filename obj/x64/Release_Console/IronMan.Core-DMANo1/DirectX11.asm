; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	?Font16px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA ; IronMan::Core::OverlayEngine::Font16px
PUBLIC	?Font14px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA ; IronMan::Core::OverlayEngine::Font14px
PUBLIC	?Font18px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA ; IronMan::Core::OverlayEngine::Font18px
PUBLIC	?Font20px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA ; IronMan::Core::OverlayEngine::Font20px
PUBLIC	?Font30px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA ; IronMan::Core::OverlayEngine::Font30px
PUBLIC	?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
PUBLIC	?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
PUBLIC	?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA ; IronMan::Core::OverlayEngine::mContext
PUBLIC	?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
PUBLIC	?mTargetScreenLeft@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenLeft
PUBLIC	?mTargetScreenTop@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenTop
PUBLIC	?mTargetScreenWidth@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenWidth
PUBLIC	?mTargetScreenHeight@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenHeight
PUBLIC	?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA ; IronMan::Core::OverlayEngine::mMainRenderTargetView
PUBLIC	?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mKeyMap
PUBLIC	?mApiKeyMap@OverlayEngine@Core@IronMan@@2PAGA	; IronMan::Core::OverlayEngine::mApiKeyMap
PUBLIC	?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mApiKeyStateMap
PUBLIC	CLSID_CUrlHistory
PUBLIC	CLSID_CUrlHistoryBoth
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	c_DwmMaxQueuedBuffers
PUBLIC	c_DwmMaxMonitors
PUBLIC	c_DwmMaxAdapters
PUBLIC	_Avx2WmemEnabledWeakValue
PUBLIC	?g_XMSinCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMSinCoefficients0
PUBLIC	?g_XMSinCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMSinCoefficients1
PUBLIC	?g_XMCosCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMCosCoefficients0
PUBLIC	?g_XMCosCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMCosCoefficients1
PUBLIC	?g_XMTanCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanCoefficients0
PUBLIC	?g_XMTanCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanCoefficients1
PUBLIC	?g_XMTanCoefficients2@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanCoefficients2
PUBLIC	?g_XMArcCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMArcCoefficients0
PUBLIC	?g_XMArcCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMArcCoefficients1
PUBLIC	?g_XMATanCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanCoefficients0
PUBLIC	?g_XMATanCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanCoefficients1
PUBLIC	?g_XMATanEstCoefficients0@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanEstCoefficients0
PUBLIC	?g_XMATanEstCoefficients1@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMATanEstCoefficients1
PUBLIC	?g_XMTanEstCoefficients@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMTanEstCoefficients
PUBLIC	?g_XMArcEstCoefficients@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMArcEstCoefficients
PUBLIC	?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMPiConstants0
PUBLIC	?g_XMIdentityR0@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR0
PUBLIC	?g_XMIdentityR1@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR1
PUBLIC	?g_XMIdentityR2@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR2
PUBLIC	?g_XMIdentityR3@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMIdentityR3
PUBLIC	?g_XMNegIdentityR0@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR0
PUBLIC	?g_XMNegIdentityR1@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR1
PUBLIC	?g_XMNegIdentityR2@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR2
PUBLIC	?g_XMNegIdentityR3@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegIdentityR3
PUBLIC	?g_XMNegativeZero@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMNegativeZero
PUBLIC	?g_XMNegate3@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMNegate3
PUBLIC	?g_XMMaskXY@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMMaskXY
PUBLIC	?g_XMMask3@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMMask3
PUBLIC	?g_XMMaskX@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMMaskX
PUBLIC	?g_XMMaskY@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMMaskY
PUBLIC	?g_XMMaskZ@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMMaskZ
PUBLIC	?g_XMMaskW@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMMaskW
PUBLIC	?g_XMOne@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMOne
PUBLIC	?g_XMOne3@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMOne3
PUBLIC	?g_XMZero@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMZero
PUBLIC	?g_XMTwo@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMTwo
PUBLIC	?g_XMFour@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMFour
PUBLIC	?g_XMSix@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMSix
PUBLIC	?g_XMNegativeOne@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativeOne
PUBLIC	?g_XMOneHalf@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMOneHalf
PUBLIC	?g_XMNegativeOneHalf@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativeOneHalf
PUBLIC	?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativeTwoPi
PUBLIC	?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNegativePi
PUBLIC	?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMHalfPi
PUBLIC	?g_XMPi@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMPi
PUBLIC	?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMReciprocalPi
PUBLIC	?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMTwoPi
PUBLIC	?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMReciprocalTwoPi
PUBLIC	?g_XMEpsilon@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMEpsilon
PUBLIC	?g_XMInfinity@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMInfinity
PUBLIC	?g_XMQNaN@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMQNaN
PUBLIC	?g_XMQNaNTest@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMQNaNTest
PUBLIC	?g_XMAbsMask@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMAbsMask
PUBLIC	?g_XMFltMin@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFltMin
PUBLIC	?g_XMFltMax@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMFltMax
PUBLIC	?g_XMNegOneMask@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMNegOneMask
PUBLIC	?g_XMMaskA8R8G8B8@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMMaskA8R8G8B8
PUBLIC	?g_XMFlipA8R8G8B8@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMFlipA8R8G8B8
PUBLIC	?g_XMFixAA8R8G8B8@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixAA8R8G8B8
PUBLIC	?g_XMNormalizeA8R8G8B8@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMNormalizeA8R8G8B8
PUBLIC	?g_XMMaskA2B10G10R10@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMMaskA2B10G10R10
PUBLIC	?g_XMFlipA2B10G10R10@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMFlipA2B10G10R10
PUBLIC	?g_XMFixAA2B10G10R10@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixAA2B10G10R10
PUBLIC	?g_XMNormalizeA2B10G10R10@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMNormalizeA2B10G10R10
PUBLIC	?g_XMMaskX16Y16@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMMaskX16Y16
PUBLIC	?g_XMFlipX16Y16@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMFlipX16Y16
PUBLIC	?g_XMFixX16Y16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixX16Y16
PUBLIC	?g_XMNormalizeX16Y16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNormalizeX16Y16
PUBLIC	?g_XMMaskX16Y16Z16W16@DirectX@@3UXMVECTORU32@1@B ; DirectX::g_XMMaskX16Y16Z16W16
PUBLIC	?g_XMFlipX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B ; DirectX::g_XMFlipX16Y16Z16W16
PUBLIC	?g_XMFixX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixX16Y16Z16W16
PUBLIC	?g_XMNormalizeX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B ; DirectX::g_XMNormalizeX16Y16Z16W16
PUBLIC	?g_XMNoFraction@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMNoFraction
PUBLIC	?g_XMMaskByte@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskByte
PUBLIC	?g_XMNegateX@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateX
PUBLIC	?g_XMNegateY@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateY
PUBLIC	?g_XMNegateZ@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateZ
PUBLIC	?g_XMNegateW@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMNegateW
PUBLIC	?g_XMSelect0101@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMSelect0101
PUBLIC	?g_XMSelect1010@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMSelect1010
PUBLIC	?g_XMOneHalfMinusEpsilon@DirectX@@3UXMVECTORI32@1@B ; DirectX::g_XMOneHalfMinusEpsilon
PUBLIC	?g_XMSelect1000@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMSelect1000
PUBLIC	?g_XMSelect1100@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMSelect1100
PUBLIC	?g_XMSelect1110@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMSelect1110
PUBLIC	?g_XMSelect1011@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMSelect1011
PUBLIC	?g_XMFixupY16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixupY16
PUBLIC	?g_XMFixupY16W16@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixupY16W16
PUBLIC	?g_XMFlipY@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMFlipY
PUBLIC	?g_XMFlipZ@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMFlipZ
PUBLIC	?g_XMFlipW@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMFlipW
PUBLIC	?g_XMFlipYZ@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMFlipYZ
PUBLIC	?g_XMFlipZW@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMFlipZW
PUBLIC	?g_XMFlipYW@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMFlipYW
PUBLIC	?g_XMMaskDec4@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMaskDec4
PUBLIC	?g_XMXorDec4@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMXorDec4
PUBLIC	?g_XMAddUDec4@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMAddUDec4
PUBLIC	?g_XMAddDec4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMAddDec4
PUBLIC	?g_XMMulDec4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMMulDec4
PUBLIC	?g_XMMaskByte4@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMMaskByte4
PUBLIC	?g_XMXorByte4@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMXorByte4
PUBLIC	?g_XMAddByte4@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMAddByte4
PUBLIC	?g_XMFixUnsigned@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMFixUnsigned
PUBLIC	?g_XMMaxInt@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMMaxInt
PUBLIC	?g_XMMaxUInt@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMMaxUInt
PUBLIC	?g_XMUnsignedFix@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMUnsignedFix
PUBLIC	?g_XMsrgbScale@DirectX@@3UXMVECTORF32@1@B	; DirectX::g_XMsrgbScale
PUBLIC	?g_XMsrgbA@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMsrgbA
PUBLIC	?g_XMsrgbA1@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMsrgbA1
PUBLIC	?g_XMExponentBias@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMExponentBias
PUBLIC	?g_XMSubnormalExponent@DirectX@@3UXMVECTORI32@1@B ; DirectX::g_XMSubnormalExponent
PUBLIC	?g_XMNumTrailing@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMNumTrailing
PUBLIC	?g_XMMinNormal@DirectX@@3UXMVECTORI32@1@B	; DirectX::g_XMMinNormal
PUBLIC	?g_XMNegInfinity@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMNegInfinity
PUBLIC	?g_XMNegQNaN@DirectX@@3UXMVECTORU32@1@B		; DirectX::g_XMNegQNaN
PUBLIC	?g_XMBin128@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XMBin128
PUBLIC	?g_XMBinNeg150@DirectX@@3UXMVECTORU32@1@B	; DirectX::g_XMBinNeg150
PUBLIC	?g_XM253@DirectX@@3UXMVECTORI32@1@B		; DirectX::g_XM253
PUBLIC	?g_XMExpEst1@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst1
PUBLIC	?g_XMExpEst2@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst2
PUBLIC	?g_XMExpEst3@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst3
PUBLIC	?g_XMExpEst4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst4
PUBLIC	?g_XMExpEst5@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst5
PUBLIC	?g_XMExpEst6@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst6
PUBLIC	?g_XMExpEst7@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMExpEst7
PUBLIC	?g_XMLogEst0@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst0
PUBLIC	?g_XMLogEst1@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst1
PUBLIC	?g_XMLogEst2@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst2
PUBLIC	?g_XMLogEst3@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst3
PUBLIC	?g_XMLogEst4@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst4
PUBLIC	?g_XMLogEst5@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst5
PUBLIC	?g_XMLogEst6@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst6
PUBLIC	?g_XMLogEst7@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLogEst7
PUBLIC	?g_XMLgE@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLgE
PUBLIC	?g_XMInvLgE@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMInvLgE
PUBLIC	?g_XMLg10@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMLg10
PUBLIC	?g_XMInvLg10@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_XMInvLg10
PUBLIC	?g_UByteMax@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_UByteMax
PUBLIC	?g_ByteMin@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_ByteMin
PUBLIC	?g_ByteMax@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_ByteMax
PUBLIC	?g_ShortMin@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_ShortMin
PUBLIC	?g_ShortMax@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_ShortMax
PUBLIC	?g_UShortMax@DirectX@@3UXMVECTORF32@1@B		; DirectX::g_UShortMax
PUBLIC	?AliceBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::AliceBlue
PUBLIC	?AntiqueWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::AntiqueWhite
PUBLIC	?Aqua@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Aqua
PUBLIC	?Aquamarine@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Aquamarine
PUBLIC	?Azure@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Azure
PUBLIC	?Beige@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Beige
PUBLIC	?Bisque@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Bisque
PUBLIC	?Black@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Black
PUBLIC	?BlanchedAlmond@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::BlanchedAlmond
PUBLIC	?Blue@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Blue
PUBLIC	?BlueViolet@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::BlueViolet
PUBLIC	?Brown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Brown
PUBLIC	?BurlyWood@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::BurlyWood
PUBLIC	?CadetBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::CadetBlue
PUBLIC	?Chartreuse@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Chartreuse
PUBLIC	?Chocolate@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Chocolate
PUBLIC	?Coral@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Coral
PUBLIC	?CornflowerBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::CornflowerBlue
PUBLIC	?Cornsilk@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Cornsilk
PUBLIC	?Crimson@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Crimson
PUBLIC	?Cyan@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Cyan
PUBLIC	?DarkBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkBlue
PUBLIC	?DarkCyan@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkCyan
PUBLIC	?DarkGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkGoldenrod
PUBLIC	?DarkGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkGray
PUBLIC	?DarkGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkGreen
PUBLIC	?DarkKhaki@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkKhaki
PUBLIC	?DarkMagenta@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkMagenta
PUBLIC	?DarkOliveGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkOliveGreen
PUBLIC	?DarkOrange@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkOrange
PUBLIC	?DarkOrchid@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkOrchid
PUBLIC	?DarkRed@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkRed
PUBLIC	?DarkSalmon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkSalmon
PUBLIC	?DarkSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkSeaGreen
PUBLIC	?DarkSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkSlateBlue
PUBLIC	?DarkSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkSlateGray
PUBLIC	?DarkTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::DarkTurquoise
PUBLIC	?DarkViolet@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DarkViolet
PUBLIC	?DeepPink@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DeepPink
PUBLIC	?DeepSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DeepSkyBlue
PUBLIC	?DimGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DimGray
PUBLIC	?DodgerBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::DodgerBlue
PUBLIC	?Firebrick@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Firebrick
PUBLIC	?FloralWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::FloralWhite
PUBLIC	?ForestGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::ForestGreen
PUBLIC	?Fuchsia@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Fuchsia
PUBLIC	?Gainsboro@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Gainsboro
PUBLIC	?GhostWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::GhostWhite
PUBLIC	?Gold@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Gold
PUBLIC	?Goldenrod@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Goldenrod
PUBLIC	?Gray@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Gray
PUBLIC	?Green@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Green
PUBLIC	?GreenYellow@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::GreenYellow
PUBLIC	?Honeydew@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Honeydew
PUBLIC	?HotPink@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::HotPink
PUBLIC	?IndianRed@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::IndianRed
PUBLIC	?Indigo@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Indigo
PUBLIC	?Ivory@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Ivory
PUBLIC	?Khaki@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Khaki
PUBLIC	?Lavender@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Lavender
PUBLIC	?LavenderBlush@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LavenderBlush
PUBLIC	?LawnGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LawnGreen
PUBLIC	?LemonChiffon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LemonChiffon
PUBLIC	?LightBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightBlue
PUBLIC	?LightCoral@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightCoral
PUBLIC	?LightCyan@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightCyan
PUBLIC	?LightGoldenrodYellow@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightGoldenrodYellow
PUBLIC	?LightGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightGray
PUBLIC	?LightGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightGreen
PUBLIC	?LightPink@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightPink
PUBLIC	?LightSalmon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightSalmon
PUBLIC	?LightSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightSeaGreen
PUBLIC	?LightSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightSkyBlue
PUBLIC	?LightSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightSlateGray
PUBLIC	?LightSteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::LightSteelBlue
PUBLIC	?LightYellow@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LightYellow
PUBLIC	?Lime@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Lime
PUBLIC	?LimeGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::LimeGreen
PUBLIC	?Linen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Linen
PUBLIC	?Magenta@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Magenta
PUBLIC	?Maroon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Maroon
PUBLIC	?MediumAquamarine@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumAquamarine
PUBLIC	?MediumBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MediumBlue
PUBLIC	?MediumOrchid@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MediumOrchid
PUBLIC	?MediumPurple@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MediumPurple
PUBLIC	?MediumSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumSeaGreen
PUBLIC	?MediumSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumSlateBlue
PUBLIC	?MediumSpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumSpringGreen
PUBLIC	?MediumTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumTurquoise
PUBLIC	?MediumVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::MediumVioletRed
PUBLIC	?MidnightBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MidnightBlue
PUBLIC	?MintCream@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MintCream
PUBLIC	?MistyRose@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::MistyRose
PUBLIC	?Moccasin@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Moccasin
PUBLIC	?NavajoWhite@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::NavajoWhite
PUBLIC	?Navy@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Navy
PUBLIC	?OldLace@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::OldLace
PUBLIC	?Olive@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Olive
PUBLIC	?OliveDrab@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::OliveDrab
PUBLIC	?Orange@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Orange
PUBLIC	?OrangeRed@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::OrangeRed
PUBLIC	?Orchid@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Orchid
PUBLIC	?PaleGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::PaleGoldenrod
PUBLIC	?PaleGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PaleGreen
PUBLIC	?PaleTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::PaleTurquoise
PUBLIC	?PaleVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::PaleVioletRed
PUBLIC	?PapayaWhip@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PapayaWhip
PUBLIC	?PeachPuff@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PeachPuff
PUBLIC	?Peru@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Peru
PUBLIC	?Pink@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Pink
PUBLIC	?Plum@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Plum
PUBLIC	?PowderBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::PowderBlue
PUBLIC	?Purple@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Purple
PUBLIC	?Red@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Red
PUBLIC	?RosyBrown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::RosyBrown
PUBLIC	?RoyalBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::RoyalBlue
PUBLIC	?SaddleBrown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SaddleBrown
PUBLIC	?Salmon@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Salmon
PUBLIC	?SandyBrown@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SandyBrown
PUBLIC	?SeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SeaGreen
PUBLIC	?SeaShell@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SeaShell
PUBLIC	?Sienna@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Sienna
PUBLIC	?Silver@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Silver
PUBLIC	?SkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SkyBlue
PUBLIC	?SlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SlateBlue
PUBLIC	?SlateGray@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SlateGray
PUBLIC	?Snow@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Snow
PUBLIC	?SpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SpringGreen
PUBLIC	?SteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::SteelBlue
PUBLIC	?Tan@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Tan
PUBLIC	?Teal@Colors@DirectX@@3UXMVECTORF32@2@B		; DirectX::Colors::Teal
PUBLIC	?Thistle@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Thistle
PUBLIC	?Tomato@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Tomato
PUBLIC	?Transparent@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Transparent
PUBLIC	?Turquoise@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Turquoise
PUBLIC	?Violet@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Violet
PUBLIC	?Wheat@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Wheat
PUBLIC	?White@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::White
PUBLIC	?WhiteSmoke@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::WhiteSmoke
PUBLIC	?Yellow@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::Yellow
PUBLIC	?YellowGreen@Colors@DirectX@@3UXMVECTORF32@2@B	; DirectX::Colors::YellowGreen
PUBLIC	?AliceBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::AliceBlue
PUBLIC	?AntiqueWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::AntiqueWhite
PUBLIC	?Aqua@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Aqua
PUBLIC	?Aquamarine@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Aquamarine
PUBLIC	?Azure@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Azure
PUBLIC	?Beige@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Beige
PUBLIC	?Bisque@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Bisque
PUBLIC	?Black@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Black
PUBLIC	?BlanchedAlmond@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::BlanchedAlmond
PUBLIC	?Blue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Blue
PUBLIC	?BlueViolet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::BlueViolet
PUBLIC	?Brown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Brown
PUBLIC	?BurlyWood@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::BurlyWood
PUBLIC	?CadetBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::CadetBlue
PUBLIC	?Chartreuse@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Chartreuse
PUBLIC	?Chocolate@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Chocolate
PUBLIC	?Coral@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Coral
PUBLIC	?CornflowerBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::CornflowerBlue
PUBLIC	?Cornsilk@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Cornsilk
PUBLIC	?Crimson@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Crimson
PUBLIC	?Cyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Cyan
PUBLIC	?DarkBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkBlue
PUBLIC	?DarkCyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkCyan
PUBLIC	?DarkGoldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkGoldenrod
PUBLIC	?DarkGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkGray
PUBLIC	?DarkGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkGreen
PUBLIC	?DarkKhaki@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkKhaki
PUBLIC	?DarkMagenta@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkMagenta
PUBLIC	?DarkOliveGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkOliveGreen
PUBLIC	?DarkOrange@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkOrange
PUBLIC	?DarkOrchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkOrchid
PUBLIC	?DarkRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkRed
PUBLIC	?DarkSalmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkSalmon
PUBLIC	?DarkSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkSeaGreen
PUBLIC	?DarkSlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkSlateBlue
PUBLIC	?DarkSlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkSlateGray
PUBLIC	?DarkTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkTurquoise
PUBLIC	?DarkViolet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DarkViolet
PUBLIC	?DeepPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DeepPink
PUBLIC	?DeepSkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DeepSkyBlue
PUBLIC	?DimGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DimGray
PUBLIC	?DodgerBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::DodgerBlue
PUBLIC	?Firebrick@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Firebrick
PUBLIC	?FloralWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::FloralWhite
PUBLIC	?ForestGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::ForestGreen
PUBLIC	?Fuchsia@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Fuchsia
PUBLIC	?Gainsboro@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Gainsboro
PUBLIC	?GhostWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::GhostWhite
PUBLIC	?Gold@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Gold
PUBLIC	?Goldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Goldenrod
PUBLIC	?Gray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Gray
PUBLIC	?Green@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Green
PUBLIC	?GreenYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::GreenYellow
PUBLIC	?Honeydew@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Honeydew
PUBLIC	?HotPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::HotPink
PUBLIC	?IndianRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::IndianRed
PUBLIC	?Indigo@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Indigo
PUBLIC	?Ivory@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Ivory
PUBLIC	?Khaki@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Khaki
PUBLIC	?Lavender@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Lavender
PUBLIC	?LavenderBlush@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LavenderBlush
PUBLIC	?LawnGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LawnGreen
PUBLIC	?LemonChiffon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LemonChiffon
PUBLIC	?LightBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightBlue
PUBLIC	?LightCoral@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightCoral
PUBLIC	?LightCyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightCyan
PUBLIC	?LightGoldenrodYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightGoldenrodYellow
PUBLIC	?LightGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightGray
PUBLIC	?LightGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightGreen
PUBLIC	?LightPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightPink
PUBLIC	?LightSalmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightSalmon
PUBLIC	?LightSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightSeaGreen
PUBLIC	?LightSkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightSkyBlue
PUBLIC	?LightSlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightSlateGray
PUBLIC	?LightSteelBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightSteelBlue
PUBLIC	?LightYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LightYellow
PUBLIC	?Lime@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Lime
PUBLIC	?LimeGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::LimeGreen
PUBLIC	?Linen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Linen
PUBLIC	?Magenta@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Magenta
PUBLIC	?Maroon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Maroon
PUBLIC	?MediumAquamarine@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumAquamarine
PUBLIC	?MediumBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumBlue
PUBLIC	?MediumOrchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumOrchid
PUBLIC	?MediumPurple@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumPurple
PUBLIC	?MediumSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumSeaGreen
PUBLIC	?MediumSlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumSlateBlue
PUBLIC	?MediumSpringGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumSpringGreen
PUBLIC	?MediumTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumTurquoise
PUBLIC	?MediumVioletRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MediumVioletRed
PUBLIC	?MidnightBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MidnightBlue
PUBLIC	?MintCream@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MintCream
PUBLIC	?MistyRose@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::MistyRose
PUBLIC	?Moccasin@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Moccasin
PUBLIC	?NavajoWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::NavajoWhite
PUBLIC	?Navy@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Navy
PUBLIC	?OldLace@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::OldLace
PUBLIC	?Olive@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Olive
PUBLIC	?OliveDrab@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::OliveDrab
PUBLIC	?Orange@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Orange
PUBLIC	?OrangeRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::OrangeRed
PUBLIC	?Orchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Orchid
PUBLIC	?PaleGoldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::PaleGoldenrod
PUBLIC	?PaleGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::PaleGreen
PUBLIC	?PaleTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::PaleTurquoise
PUBLIC	?PaleVioletRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::PaleVioletRed
PUBLIC	?PapayaWhip@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::PapayaWhip
PUBLIC	?PeachPuff@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::PeachPuff
PUBLIC	?Peru@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Peru
PUBLIC	?Pink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Pink
PUBLIC	?Plum@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Plum
PUBLIC	?PowderBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::PowderBlue
PUBLIC	?Purple@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Purple
PUBLIC	?Red@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Red
PUBLIC	?RosyBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::RosyBrown
PUBLIC	?RoyalBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::RoyalBlue
PUBLIC	?SaddleBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SaddleBrown
PUBLIC	?Salmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Salmon
PUBLIC	?SandyBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SandyBrown
PUBLIC	?SeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SeaGreen
PUBLIC	?SeaShell@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SeaShell
PUBLIC	?Sienna@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Sienna
PUBLIC	?Silver@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Silver
PUBLIC	?SkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SkyBlue
PUBLIC	?SlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SlateBlue
PUBLIC	?SlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SlateGray
PUBLIC	?Snow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Snow
PUBLIC	?SpringGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SpringGreen
PUBLIC	?SteelBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::SteelBlue
PUBLIC	?Tan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Tan
PUBLIC	?Teal@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Teal
PUBLIC	?Thistle@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Thistle
PUBLIC	?Tomato@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Tomato
PUBLIC	?Transparent@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Transparent
PUBLIC	?Turquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::Turquoise
PUBLIC	?Violet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Violet
PUBLIC	?Wheat@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Wheat
PUBLIC	?White@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::White
PUBLIC	?WhiteSmoke@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::WhiteSmoke
PUBLIC	?Yellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B	; DirectX::ColorsLinear::Yellow
PUBLIC	?YellowGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B ; DirectX::ColorsLinear::YellowGreen
EXTRN	?x86RegData@asmjit@@3UX86RegData@1@B:BYTE	; asmjit::x86RegData
_BSS	SEGMENT
?Font16px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::Font16px
?Font14px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::Font14px
?Font18px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::Font18px
?Font20px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::Font20px
?Font30px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::Font30px
?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::mDevice
?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::mSwapChain
?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::mContext
?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::mOverlayWindow
?mTargetScreenLeft@OverlayEngine@Core@IronMan@@2HA DD 01H DUP (?) ; IronMan::Core::OverlayEngine::mTargetScreenLeft
?mTargetScreenTop@OverlayEngine@Core@IronMan@@2HA DD 01H DUP (?) ; IronMan::Core::OverlayEngine::mTargetScreenTop
?mTargetScreenWidth@OverlayEngine@Core@IronMan@@2HA DD 01H DUP (?) ; IronMan::Core::OverlayEngine::mTargetScreenWidth
?mTargetScreenHeight@OverlayEngine@Core@IronMan@@2HA DD 01H DUP (?) ; IronMan::Core::OverlayEngine::mTargetScreenHeight
?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA DQ 01H DUP (?) ; IronMan::Core::OverlayEngine::mMainRenderTargetView
?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A DD 0100H DUP (?) ; IronMan::Core::OverlayEngine::mKeyMap
?mApiKeyMap@OverlayEngine@Core@IronMan@@2PAGA DW 0100H DUP (?) ; IronMan::Core::OverlayEngine::mApiKeyMap
?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A DD 0100H DUP (?) ; IronMan::Core::OverlayEngine::mApiKeyStateMap
_BSS	ENDS
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?YellowGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?YellowGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ea57308r ; 0.323143 ; DirectX::ColorsLinear::YellowGreen
	DD	03f1c4973r			; 0.610496
	DD	03d02a56cr			; 0.031896
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Yellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Yellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Yellow
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?WhiteSmoke@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?WhiteSmoke@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f69c0dbr ; 0.913099 ; DirectX::ColorsLinear::WhiteSmoke
	DD	03f69c0dbr			; 0.913099
	DD	03f69c0dbr			; 0.913099
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?White@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?White@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::White
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Wheat@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Wheat@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f69c0dbr ; 0.913099 ; DirectX::ColorsLinear::Wheat
	DD	03f3aff7er			; 0.730461
	DD	03ee6cd67r			; 0.450786
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Violet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Violet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5ae0cfr ; 0.854993 ; DirectX::ColorsLinear::Violet
	DD	03e6495e0r			; 0.223228
	DD	03f5ae0cfr			; 0.854993
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Turquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Turquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d51ffefr ; 0.0512695 ; DirectX::ColorsLinear::Turquoise
	DD	03f3ed2d4r			; 0.745404
	DD	03f217950r			; 0.630757
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Transparent@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Transparent@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Transparent
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?Tomato@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Tomato@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Tomato
	DD	03dff8864r			; 0.124772
	DD	03d810b67r			; 0.06301
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Thistle@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Thistle@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f2fca9er ; 0.686685 ; DirectX::ColorsLinear::Thistle
	DD	03f055ff9r			; 0.520996
	DD	03f2fca9er			; 0.686685
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Teal@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Teal@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Teal
	DD	03e5d0a8br			; 0.215861
	DD	03e5d0a8br			; 0.215861
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Tan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Tan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f24fca2r ; 0.64448 ; DirectX::ColorsLinear::Tan
	DD	03ee9aeb6r			; 0.456411
	DD	03e8645bar			; 0.262251
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SteelBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SteelBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d7add29r ; 0.0612461 ; DirectX::ColorsLinear::SteelBlue
	DD	03e6495e0r			; 0.223228
	DD	03ee9aeb6r			; 0.456411
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SpringGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SpringGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::SpringGreen
	DD	03f800000r			; 1
	DD	03e595307r			; 0.212231
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Snow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Snow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Snow
	DD	03f74baaer			; 0.955974
	DD	03f74baaer			; 0.955974
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e25eb0br ; 0.162029 ; DirectX::ColorsLinear::SlateGray
	DD	03e5d0a8br			; 0.215861
	DD	03e8ecb3dr			; 0.278894
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e13966cr ; 0.144129 ; DirectX::ColorsLinear::SlateBlue
	DD	03dd1641fr			; 0.102242
	DD	03f1c4973r			; 0.610496
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e781890r ; 0.242281 ; DirectX::ColorsLinear::SkyBlue
	DD	03f1e0143r			; 0.617207
	DD	03f54ad59r			; 0.83077
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Silver@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Silver@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f06f108r ; 0.527115 ; DirectX::ColorsLinear::Silver
	DD	03f06f108r			; 0.527115
	DD	03f06f108r			; 0.527115
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Sienna@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Sienna@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03eb3fc18r ; 0.351533 ; DirectX::ColorsLinear::Sienna
	DD	03daccd70r			; 0.0843762
	DD	03cd6f7d5r			; 0.0262412
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SeaShell@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SeaShell@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::SeaShell
	DD	03f69c0dbr			; 0.913099
	DD	03f5ae0cfr			; 0.854993
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03cdfd010r ; 0.0273209 ; DirectX::ColorsLinear::SeaGreen
	DD	03e84308dr			; 0.258183
	DD	03dc33092r			; 0.0953075
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SandyBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SandyBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f6797e3r ; 0.904661 ; DirectX::ColorsLinear::SandyBrown
	DD	03ebe12e1r			; 0.371238
	DD	03def8e55r			; 0.116971
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Salmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Salmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f74baaer ; 0.955974 ; DirectX::ColorsLinear::Salmon
	DD	03e5d0a8br			; 0.215861
	DD	03e2c4ed4r			; 0.168269
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SaddleBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SaddleBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e84308dr ; 0.258183 ; DirectX::ColorsLinear::SaddleBrown
	DD	03d73c20fr			; 0.0595112
	DD	03bd56361r			; 0.00651209
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?RoyalBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?RoyalBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d58846ar ; 0.0528607 ; DirectX::ColorsLinear::RoyalBlue
	DD	03e10a755r			; 0.141263
	DD	03f40c0d6r			; 0.752942
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?RosyBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?RosyBrown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f00bd2dr ; 0.502887 ; DirectX::ColorsLinear::RosyBrown
	DD	03e8ca283r			; 0.274677
	DD	03e8ca283r			; 0.274677
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Red@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Red@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Red
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Purple@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Purple@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e5d0a8br ; 0.215861 ; DirectX::ColorsLinear::Purple
	DD	000000000r			; 0
	DD	03e5d0a8br			; 0.215861
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PowderBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PowderBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ede4965r ; 0.434154 ; DirectX::ColorsLinear::PowderBlue
	DD	03f3ed2d4r			; 0.745404
	DD	03f4a9284r			; 0.791298
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Plum@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Plum@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f391a28r ; 0.723055 ; DirectX::ColorsLinear::Plum
	DD	03eb3fc18r			; 0.351533
	DD	03f391a28r			; 0.723055
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Pink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Pink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Pink
	DD	03f06f108r			; 0.527115
	DD	03f18e23br			; 0.597202
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Peru@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Peru@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f1c4973r ; 0.610496 ; DirectX::ColorsLinear::Peru
	DD	03e702e0cr			; 0.234551
	DD	03d4b991fr			; 0.0497066
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PeachPuff@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PeachPuff@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::PeachPuff
	DD	03f337b6er			; 0.701102
	DD	03ef86594r			; 0.48515
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PapayaWhip@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PapayaWhip@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::PapayaWhip
	DD	03f5cf7e2r			; 0.863157
	DD	03f2a56d5r			; 0.665387
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleVioletRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleVioletRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f355822r ; 0.708376 ; DirectX::ColorsLinear::PaleVioletRed
	DD	03e25eb0br			; 0.162029
	DD	03e9562f8r			; 0.291771
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03edb7d54r ; 0.428691 ; DirectX::ColorsLinear::PaleTurquoise
	DD	03f5ae0cfr			; 0.854993
	DD	03f5ae0cfr			; 0.854993
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ea0c322r ; 0.313989 ; DirectX::ColorsLinear::PaleGreen
	DD	03f76f5b3r			; 0.964687
	DD	03ea0c322r			; 0.313989
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleGoldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleGoldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5ae0cfr ; 0.854993 ; DirectX::ColorsLinear::PaleGoldenrod
	DD	03f4e9470r			; 0.806952
	DD	03ecdd00br			; 0.401978
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Orchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Orchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f337b6er ; 0.701102 ; DirectX::ColorsLinear::Orchid
	DD	03e25eb0br			; 0.162029
	DD	03f2c253fr			; 0.672443
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OrangeRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OrangeRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::OrangeRed
	DD	03d73c20fr			; 0.0595112
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Orange@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Orange@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Orange
	DD	03ec0a571r			; 0.376262
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OliveDrab@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OliveDrab@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e168e53r ; 0.147027 ; DirectX::ColorsLinear::OliveDrab
	DD	03e8a7eb2r			; 0.270498
	DD	03c89af9fr			; 0.0168074
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Olive@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Olive@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e5d0a8br ; 0.215861 ; DirectX::ColorsLinear::Olive
	DD	03e5d0a8br			; 0.215861
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OldLace@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OldLace@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f7b74cbr ; 0.982251 ; DirectX::ColorsLinear::OldLace
	DD	03f69c0dbr			; 0.913099
	DD	03f4a9284r			; 0.791298
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Navy@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Navy@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Navy
	DD	000000000r			; 0
	DD	03e5d0a8br			; 0.215861
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?NavajoWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?NavajoWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::NavajoWhite
	DD	03f3aff7er			; 0.730461
	DD	03ed5f50br			; 0.417885
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Moccasin@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Moccasin@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Moccasin
	DD	03f469c4dr			; 0.775822
	DD	03eec955dr			; 0.462077
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MistyRose@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MistyRose@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::MistyRose
	DD	03f469c4dr			; 0.775822
	DD	03f40c0d6r			; 0.752942
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MintCream@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MintCream@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f69c0dbr ; 0.913099 ; DirectX::ColorsLinear::MintCream
	DD	03f800000r			; 1
	DD	03f74baaer			; 0.955974
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MidnightBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MidnightBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03c1f45ber ; 0.00972122 ; DirectX::ColorsLinear::MidnightBlue
	DD	03c1f45ber			; 0.00972122
	DD	03e25eb0br			; 0.162029
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumVioletRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumVioletRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f123540r ; 0.571125 ; DirectX::ColorsLinear::MediumVioletRed
	DD	03bf5ba71r			; 0.00749903
	DD	03e702e0cr			; 0.234551
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d84b795r ; 0.0648033 ; DirectX::ColorsLinear::MediumTurquoise
	DD	03f23398fr			; 0.637597
	DD	03f1a9471r			; 0.603828
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSpringGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSpringGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::MediumSpringGreen
	DD	03f74baaer			; 0.955974
	DD	03ea57308r			; 0.323143
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e4ad2b1r ; 0.198069 ; DirectX::ColorsLinear::MediumSlateBlue
	DD	03e0dc107r			; 0.138432
	DD	03f5ae0cfr			; 0.854993
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d39152er ; 0.0451862 ; DirectX::ColorsLinear::MediumSeaGreen
	DD	03ee6cd67r			; 0.450786
	DD	03e29186dr			; 0.165132
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumPurple@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumPurple@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e9562f8r ; 0.291771 ; DirectX::ColorsLinear::MediumPurple
	DD	03e25eb0br			; 0.162029
	DD	03f355822r			; 0.708376
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumOrchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumOrchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03efb6717r ; 0.491021 ; DirectX::ColorsLinear::MediumOrchid
	DD	03dba0b3br			; 0.0908417
	DD	03f26c288r			; 0.651406
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::MediumBlue
	DD	000000000r			; 0
	DD	03f1c4973r			; 0.610496
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumAquamarine@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumAquamarine@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e080ea5r ; 0.132868 ; DirectX::ColorsLinear::MediumAquamarine
	DD	03f1c4973r			; 0.610496
	DD	03ecdd00br			; 0.401978
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Maroon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Maroon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e5d0a8br ; 0.215861 ; DirectX::ColorsLinear::Maroon
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Magenta@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Magenta@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Magenta
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Linen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Linen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f74baaer ; 0.955974 ; DirectX::ColorsLinear::Linen
	DD	03f5f11eer			; 0.871367
	DD	03f4a9284r			; 0.791298
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LimeGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LimeGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d02a56cr ; 0.031896 ; DirectX::ColorsLinear::LimeGreen
	DD	03f1c4973r			; 0.610496
	DD	03d02a56cr			; 0.031896
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Lime@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Lime@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Lime
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::LightYellow
	DD	03f800000r			; 1
	DD	03f3ed2d4r			; 0.745404
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSteelBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSteelBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ede4965r ; 0.434154 ; DirectX::ColorsLinear::LightSteelBlue
	DD	03f0d50a2r			; 0.552012
	DD	03f3aff7er			; 0.730461
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e3ce706r ; 0.184475 ; DirectX::ColorsLinear::LightSlateGray
	DD	03e7c1c38r			; 0.246201
	DD	03ea31892r			; 0.318547
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e781890r ; 0.242281 ; DirectX::ColorsLinear::LightSkyBlue
	DD	03f1e0143r			; 0.617207
	DD	03f74baaer			; 0.955974
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03c6ca5dfr ; 0.0144438 ; DirectX::ColorsLinear::LightSeaGreen
	DD	03ee3f16br			; 0.445201
	DD	03ecdd00br			; 0.401978
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSalmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSalmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::LightSalmon
	DD	03eb3fc18r			; 0.351533
	DD	03e4749e8r			; 0.194618
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::LightPink
	DD	03eef815dr			; 0.467784
	DD	03f0884d1r			; 0.533277
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e8ecb3dr ; 0.278894 ; DirectX::ColorsLinear::LightGreen
	DD	03f5ae0cfr			; 0.854993
	DD	03e8ecb3dr			; 0.278894
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f26c288r ; 0.651406 ; DirectX::ColorsLinear::LightGray
	DD	03f26c288r			; 0.651406
	DD	03f26c288r			; 0.651406
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGoldenrodYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGoldenrodYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f74baaer ; 0.955974 ; DirectX::ColorsLinear::LightGoldenrodYellow
	DD	03f74baaer			; 0.955974
	DD	03f24fca2r			; 0.64448
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightCyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightCyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f3ed2d4r ; 0.745404 ; DirectX::ColorsLinear::LightCyan
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightCoral@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightCoral@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5f11eer ; 0.871367 ; DirectX::ColorsLinear::LightCoral
	DD	03e5d0a8br			; 0.215861
	DD	03e5d0a8br			; 0.215861
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ed5f50br ; 0.417885 ; DirectX::ColorsLinear::LightBlue
	DD	03f2fca9er			; 0.686685
	DD	03f4a9284r			; 0.791298
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LemonChiffon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LemonChiffon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::LemonChiffon
	DD	03f74baaer			; 0.955974
	DD	03f1c4973r			; 0.610496
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LawnGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LawnGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e4e64c6r ; 0.201556 ; DirectX::ColorsLinear::LawnGreen
	DD	03f7933b9r			; 0.973445
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LavenderBlush@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LavenderBlush@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::LavenderBlush
	DD	03f5f11eer			; 0.871367
	DD	03f69c0dbr			; 0.913099
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Lavender@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Lavender@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f4a9284r ; 0.791298 ; DirectX::ColorsLinear::Lavender
	DD	03f4a9284r			; 0.791298
	DD	03f74baaer			; 0.955974
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Khaki@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Khaki@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5f11eer ; 0.871367 ; DirectX::ColorsLinear::Khaki
	DD	03f4a9284r			; 0.791298
	DD	03e8645bar			; 0.262251
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Ivory@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Ivory@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Ivory
	DD	03f800000r			; 1
	DD	03f5f11eer			; 0.871367
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Indigo@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Indigo@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d9018f6r ; 0.0703601 ; DirectX::ColorsLinear::Indigo
	DD	000000000r			; 0
	DD	03e6495e0r			; 0.223228
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?IndianRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?IndianRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f1c4973r ; 0.610496 ; DirectX::ColorsLinear::IndianRed
	DD	03ddb2eefr			; 0.107023
	DD	03ddb2eefr			; 0.107023
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?HotPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?HotPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::HotPink
	DD	03e10a755r			; 0.141263
	DD	03ee9aeb6r			; 0.456411
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Honeydew@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Honeydew@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5f11eer ; 0.871367 ; DirectX::ColorsLinear::Honeydew
	DD	03f800000r			; 1
	DD	03f5f11eer			; 0.871367
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?GreenYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?GreenYellow@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ed5f50br ; 0.417885 ; DirectX::ColorsLinear::GreenYellow
	DD	03f800000r			; 1
	DD	03ce8ddb9r			; 0.028426
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Green@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Green@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Green
	DD	03e5d0a8br			; 0.215861
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e5d0a8br ; 0.215861 ; DirectX::ColorsLinear::Gray
	DD	03e5d0a8br			; 0.215861
	DD	03e5d0a8br			; 0.215861
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Goldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Goldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f337b6er ; 0.701102 ; DirectX::ColorsLinear::Goldenrod
	DD	03ec0a571r			; 0.376262
	DD	03c6ca5dfr			; 0.0144438
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gold@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gold@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Gold
	DD	03f2df681r			; 0.679543
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?GhostWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?GhostWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f704db8r ; 0.938686 ; DirectX::ColorsLinear::GhostWhite
	DD	03f704db8r			; 0.938686
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gainsboro@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gainsboro@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f3737b5r ; 0.715694 ; DirectX::ColorsLinear::Gainsboro
	DD	03f3737b5r			; 0.715694
	DD	03f3737b5r			; 0.715694
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Fuchsia@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Fuchsia@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Fuchsia
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?ForestGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?ForestGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03c830aa8r ; 0.0159963 ; DirectX::ColorsLinear::ForestGreen
	DD	03e84308dr			; 0.258183
	DD	03c830aa8r			; 0.0159963
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?FloralWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?FloralWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::FloralWhite
	DD	03f74baaer			; 0.955974
	DD	03f5f11eer			; 0.871367
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Firebrick@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Firebrick@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ee3f16br ; 0.445201 ; DirectX::ColorsLinear::Firebrick
	DD	03c830aa8r			; 0.0159963
	DD	03c830aa8r			; 0.0159963
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DodgerBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DodgerBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03c54b6c7r ; 0.012983 ; DirectX::ColorsLinear::DodgerBlue
	DD	03e8ecb3dr			; 0.278894
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DimGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DimGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e10a755r ; 0.141263 ; DirectX::ColorsLinear::DimGray
	DD	03e10a755r			; 0.141263
	DD	03e10a755r			; 0.141263
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DeepSkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DeepSkyBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::DeepSkyBlue
	DD	03f055ff9r			; 0.520996
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DeepPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DeepPink@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::DeepPink
	DD	03be539c1r			; 0.00699541
	DD	03e9562f8r			; 0.291771
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkViolet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkViolet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e979f71r ; 0.296138 ; DirectX::ColorsLinear::DarkViolet
	DD	000000000r			; 0
	DD	03f26c288r			; 0.651406
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkTurquoise@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::DarkTurquoise
	DD	03f1e0143r			; 0.617207
	DD	03f23398fr			; 0.637597
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSlateGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ce8ddb9r ; 0.028426 ; DirectX::ColorsLinear::DarkSlateGray
	DD	03da020bbr			; 0.0781874
	DD	03da020bbr			; 0.0781874
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSlateBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03d84b795r ; 0.0648033 ; DirectX::ColorsLinear::DarkSlateBlue
	DD	03d3f23e6r			; 0.0466651
	DD	03e84308dr			; 0.258183
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSeaGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e8ca283r ; 0.274677 ; DirectX::ColorsLinear::DarkSeaGreen
	DD	03f00bd2dr			; 0.502887
	DD	03e84308dr			; 0.258183
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSalmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSalmon@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5099cdr ; 0.814847 ; DirectX::ColorsLinear::DarkSalmon
	DD	03e9c274er			; 0.304987
	DD	03e4749e8r			; 0.194618
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkRed@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e84308dr ; 0.258183 ; DirectX::ColorsLinear::DarkRed
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOrchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOrchid@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ea31892r ; 0.318547 ; DirectX::ColorsLinear::DarkOrchid
	DD	03d02a56cr			; 0.031896
	DD	03f1a9471r			; 0.603828
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOrange@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOrange@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::DarkOrange
	DD	03e8645bar			; 0.262251
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOliveGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOliveGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03dba0b3br ; 0.0908417 ; DirectX::ColorsLinear::DarkOliveGreen
	DD	03e168e53r			; 0.147027
	DD	03ce8ddb9r			; 0.028426
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkMagenta@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkMagenta@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e84308dr ; 0.258183 ; DirectX::ColorsLinear::DarkMagenta
	DD	000000000r			; 0
	DD	03e84308dr			; 0.258183
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkKhaki@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkKhaki@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f02460er ; 0.508881 ; DirectX::ColorsLinear::DarkKhaki
	DD	03ef272bar			; 0.473532
	DD	03e168e53r			; 0.147027
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGreen@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::DarkGreen
	DD	03e027f09r			; 0.127438
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGray@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ecb2383r ; 0.396755 ; DirectX::ColorsLinear::DarkGray
	DD	03ecb2383r			; 0.396755
	DD	03ecb2383r			; 0.396755
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGoldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGoldenrod@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ef56976r ; 0.47932 ; DirectX::ColorsLinear::DarkGoldenrod
	DD	03e741e84r			; 0.238398
	DD	03b5b518fr			; 0.00334654
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkCyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkCyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::DarkCyan
	DD	03e84308dr			; 0.258183
	DD	03e84308dr			; 0.258183
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::DarkBlue
	DD	000000000r			; 0
	DD	03e84308dr			; 0.258183
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Cyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Cyan@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Cyan
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Crimson@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Crimson@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f3737b5r ; 0.715694 ; DirectX::ColorsLinear::Crimson
	DD	03be539c1r			; 0.00699541
	DD	03d39152er			; 0.0451862
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Cornsilk@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Cornsilk@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Cornsilk
	DD	03f704db8r			; 0.938686
	DD	03f3737b5r			; 0.715694
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?CornflowerBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?CornflowerBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e027f09r ; 0.127438 ; DirectX::ColorsLinear::CornflowerBlue
	DD	03e99e0e2r			; 0.300544
	DD	03f58ccb3r			; 0.846873
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Coral@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Coral@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Coral
	DD	03e595307r			; 0.212231
	DD	03da44a4br			; 0.0802198
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Chocolate@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Chocolate@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f24fca2r ; 0.64448 ; DirectX::ColorsLinear::Chocolate
	DD	03e10a755r			; 0.141263
	DD	03c54b6c7r			; 0.012983
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Chartreuse@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Chartreuse@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e595307r ; 0.212231 ; DirectX::ColorsLinear::Chartreuse
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?CadetBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?CadetBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03dea5d19r ; 0.114435 ; DirectX::ColorsLinear::CadetBlue
	DD	03eaf0f69r			; 0.341914
	DD	03eb3fc18r			; 0.351533
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BurlyWood@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BurlyWood@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f3aff7er ; 0.730461 ; DirectX::ColorsLinear::BurlyWood
	DD	03ef56976r			; 0.47932
	DD	03e781890r			; 0.242281
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Brown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Brown@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03ec0a571r ; 0.376262 ; DirectX::ColorsLinear::Brown
	DD	03cbdac20r			; 0.0231534
	DD	03cbdac20r			; 0.0231534
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BlueViolet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BlueViolet@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e82203cr ; 0.254152 ; DirectX::ColorsLinear::BlueViolet
	DD	03cc5e639r			; 0.0241576
	DD	03f42b1c0r			; 0.760525
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Blue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Blue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Blue
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BlanchedAlmond@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BlanchedAlmond@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::BlanchedAlmond
	DD	03f54ad59r			; 0.83077
	DD	03f1c4973r			; 0.610496
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Black@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Black@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Black
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Bisque@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Bisque@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::ColorsLinear::Bisque
	DD	03f469c4dr			; 0.775822
	DD	03f0d50a2r			; 0.552012
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Beige@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Beige@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f69c0dbr ; 0.913099 ; DirectX::ColorsLinear::Beige
	DD	03f69c0dbr			; 0.913099
	DD	03f3737b5r			; 0.715694
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Azure@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Azure@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5f11eer ; 0.871367 ; DirectX::ColorsLinear::Azure
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Aquamarine@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Aquamarine@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03e595307r ; 0.212231 ; DirectX::ColorsLinear::Aquamarine
	DD	03f800000r			; 1
	DD	03f288b43r			; 0.658375
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Aqua@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Aqua@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::ColorsLinear::Aqua
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?AntiqueWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?AntiqueWhite@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f74baaer ; 0.955974 ; DirectX::ColorsLinear::AntiqueWhite
	DD	03f54ad59r			; 0.83077
	DD	03f2df681r			; 0.679543
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?AliceBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?AliceBlue@ColorsLinear@DirectX@@3UXMVECTORF32@2@B DD 03f5f11eer ; 0.871367 ; DirectX::ColorsLinear::AliceBlue
	DD	03f704db8r			; 0.938686
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?YellowGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?YellowGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f1a9a9br ; 0.603922 ; DirectX::Colors::YellowGreen
	DD	03f4dcdcfr			; 0.803922
	DD	03e48c8car			; 0.196078
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Yellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Yellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Yellow
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?WhiteSmoke@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?WhiteSmoke@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::WhiteSmoke
	DD	03f75f5f7r			; 0.960784
	DD	03f75f5f7r			; 0.960784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?White@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?White@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::White
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Wheat@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Wheat@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::Wheat
	DD	03f5edee0r			; 0.870588
	DD	03f33b3b4r			; 0.701961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Violet@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Violet@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f6eeef0r ; 0.933333 ; DirectX::Colors::Violet
	DD	03f028283r			; 0.509804
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Turquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Turquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e808081r ; 0.25098 ; DirectX::Colors::Turquoise
	DD	03f60e0e2r			; 0.878431
	DD	03f50d0d2r			; 0.815686
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Transparent@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Transparent@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Transparent
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?Tomato@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Tomato@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Tomato
	DD	03ec6c6c8r			; 0.388235
	DD	03e8e8e8fr			; 0.278431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Thistle@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Thistle@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f58d8dar ; 0.847059 ; DirectX::Colors::Thistle
	DD	03f3fbfc0r			; 0.74902
	DD	03f58d8dar			; 0.847059
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Teal@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Teal@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Teal
	DD	03f008081r			; 0.501961
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Tan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Tan@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f52d2d4r ; 0.823529 ; DirectX::Colors::Tan
	DD	03f34b4b5r			; 0.705882
	DD	03f0c8c8dr			; 0.54902
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e8c8c8dr ; 0.27451 ; DirectX::Colors::SteelBlue
	DD	03f028283r			; 0.509804
	DD	03f34b4b5r			; 0.705882
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::SpringGreen
	DD	03f800000r			; 1
	DD	03efeff00r			; 0.498039
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Snow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Snow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Snow
	DD	03f7afafcr			; 0.980392
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SlateGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SlateGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ee0e0e2r ; 0.439216 ; DirectX::Colors::SlateGray
	DD	03f008081r			; 0.501961
	DD	03f109091r			; 0.564706
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ed4d4d6r ; 0.415686 ; DirectX::Colors::SlateBlue
	DD	03eb4b4b5r			; 0.352941
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f078788r ; 0.529412 ; DirectX::Colors::SkyBlue
	DD	03f4eced0r			; 0.807843
	DD	03f6bebedr			; 0.921569
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Silver@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Silver@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f40c0c2r ; 0.752941 ; DirectX::Colors::Silver
	DD	03f40c0c2r			; 0.752941
	DD	03f40c0c2r			; 0.752941
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Sienna@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Sienna@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f20a0a1r ; 0.627451 ; DirectX::Colors::Sienna
	DD	03ea4a4a5r			; 0.321569
	DD	03e34b4b5r			; 0.176471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SeaShell@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SeaShell@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::SeaShell
	DD	03f75f5f7r			; 0.960784
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e38b8b9r ; 0.180392 ; DirectX::Colors::SeaGreen
	DD	03f0b8b8cr			; 0.545098
	DD	03eaeaeafr			; 0.341176
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SandyBrown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SandyBrown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f74f4f6r ; 0.956863 ; DirectX::Colors::SandyBrown
	DD	03f24a4a5r			; 0.643137
	DD	03ec0c0c2r			; 0.376471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Salmon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Salmon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::Salmon
	DD	03f008081r			; 0.501961
	DD	03ee4e4e6r			; 0.447059
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?SaddleBrown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?SaddleBrown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0b8b8cr ; 0.545098 ; DirectX::Colors::SaddleBrown
	DD	03e8a8a8br			; 0.270588
	DD	03d989899r			; 0.0745098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?RoyalBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?RoyalBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e828283r ; 0.254902 ; DirectX::Colors::RoyalBlue
	DD	03ed2d2d4r			; 0.411765
	DD	03f61e1e3r			; 0.882353
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?RosyBrown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?RosyBrown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f3cbcbdr ; 0.737255 ; DirectX::Colors::RosyBrown
	DD	03f0f8f90r			; 0.560784
	DD	03f0f8f90r			; 0.560784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Red@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Red@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Red
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Purple@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Purple@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Purple
	DD	000000000r			; 0
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PowderBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PowderBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f30b0b1r ; 0.690196 ; DirectX::Colors::PowderBlue
	DD	03f60e0e2r			; 0.878431
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Plum@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Plum@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5ddddfr ; 0.866667 ; DirectX::Colors::Plum
	DD	03f20a0a1r			; 0.627451
	DD	03f5ddddfr			; 0.866667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Pink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Pink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Pink
	DD	03f40c0c2r			; 0.752941
	DD	03f4bcbcdr			; 0.796079
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Peru@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Peru@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f4dcdcfr ; 0.803922 ; DirectX::Colors::Peru
	DD	03f058586r			; 0.521569
	DD	03e7cfcfer			; 0.247059
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PeachPuff@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PeachPuff@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::PeachPuff
	DD	03f5adadcr			; 0.854902
	DD	03f39b9bar			; 0.72549
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PapayaWhip@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PapayaWhip@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::PapayaWhip
	DD	03f6feff1r			; 0.937255
	DD	03f55d5d7r			; 0.835294
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5bdbddr ; 0.858824 ; DirectX::Colors::PaleVioletRed
	DD	03ee0e0e2r			; 0.439216
	DD	03f139394r			; 0.576471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f2fafb0r ; 0.686275 ; DirectX::Colors::PaleTurquoise
	DD	03f6eeef0r			; 0.933333
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f189899r ; 0.596078 ; DirectX::Colors::PaleGreen
	DD	03f7bfbfdr			; 0.984314
	DD	03f189899r			; 0.596078
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?PaleGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?PaleGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f6eeef0r ; 0.933333 ; DirectX::Colors::PaleGoldenrod
	DD	03f68e8ear			; 0.909804
	DD	03f2aaaabr			; 0.666667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Orchid@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Orchid@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5adadcr ; 0.854902 ; DirectX::Colors::Orchid
	DD	03ee0e0e2r			; 0.439216
	DD	03f56d6d8r			; 0.839216
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OrangeRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OrangeRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::OrangeRed
	DD	03e8a8a8br			; 0.270588
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Orange@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Orange@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Orange
	DD	03f25a5a6r			; 0.647059
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OliveDrab@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OliveDrab@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ed6d6d8r ; 0.419608 ; DirectX::Colors::OliveDrab
	DD	03f0e8e8fr			; 0.556863
	DD	03e0c8c8dr			; 0.137255
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Olive@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Olive@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Olive
	DD	03f008081r			; 0.501961
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?OldLace@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?OldLace@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7dfdffr ; 0.992157 ; DirectX::Colors::OldLace
	DD	03f75f5f7r			; 0.960784
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Navy@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Navy@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Navy
	DD	000000000r			; 0
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?NavajoWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?NavajoWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::NavajoWhite
	DD	03f5edee0r			; 0.870588
	DD	03f2dadaer			; 0.678431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Moccasin@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Moccasin@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Moccasin
	DD	03f64e4e6r			; 0.894118
	DD	03f35b5b6r			; 0.709804
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MistyRose@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MistyRose@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::MistyRose
	DD	03f64e4e6r			; 0.894118
	DD	03f61e1e3r			; 0.882353
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MintCream@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MintCream@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::MintCream
	DD	03f800000r			; 1
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MidnightBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MidnightBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03dc8c8car ; 0.0980392 ; DirectX::Colors::MidnightBlue
	DD	03dc8c8car			; 0.0980392
	DD	03ee0e0e2r			; 0.439216
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumVioletRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f47c7c9r ; 0.780392 ; DirectX::Colors::MediumVioletRed
	DD	03da8a8a9r			; 0.0823529
	DD	03f058586r			; 0.521569
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e909091r ; 0.282353 ; DirectX::Colors::MediumTurquoise
	DD	03f51d1d3r			; 0.819608
	DD	03f4ccccer			; 0.8
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSpringGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::MediumSpringGreen
	DD	03f7afafcr			; 0.980392
	DD	03f1a9a9br			; 0.603922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ef6f6f8r ; 0.482353 ; DirectX::Colors::MediumSlateBlue
	DD	03ed0d0d2r			; 0.407843
	DD	03f6eeef0r			; 0.933333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e70f0f2r ; 0.235294 ; DirectX::Colors::MediumSeaGreen
	DD	03f33b3b4r			; 0.701961
	DD	03ee2e2e4r			; 0.443137
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumPurple@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumPurple@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f139394r ; 0.576471 ; DirectX::Colors::MediumPurple
	DD	03ee0e0e2r			; 0.439216
	DD	03f5bdbddr			; 0.858824
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumOrchid@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumOrchid@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f3ababbr ; 0.729412 ; DirectX::Colors::MediumOrchid
	DD	03eaaaaabr			; 0.333333
	DD	03f53d3d5r			; 0.827451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::MediumBlue
	DD	000000000r			; 0
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?MediumAquamarine@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?MediumAquamarine@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ecccccer ; 0.4 ; DirectX::Colors::MediumAquamarine
	DD	03f4dcdcfr			; 0.803922
	DD	03f2aaaabr			; 0.666667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Maroon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Maroon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Maroon
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Magenta@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Magenta@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Magenta
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Linen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Linen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::Linen
	DD	03f70f0f2r			; 0.941177
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LimeGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LimeGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e48c8car ; 0.196078 ; DirectX::Colors::LimeGreen
	DD	03f4dcdcfr			; 0.803922
	DD	03e48c8car			; 0.196078
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Lime@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Lime@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Lime
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightYellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightYellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LightYellow
	DD	03f800000r			; 1
	DD	03f60e0e2r			; 0.878431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSteelBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f30b0b1r ; 0.690196 ; DirectX::Colors::LightSteelBlue
	DD	03f44c4c6r			; 0.768628
	DD	03f5edee0r			; 0.870588
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03eeeeef0r ; 0.466667 ; DirectX::Colors::LightSlateGray
	DD	03f088889r			; 0.533333
	DD	03f19999ar			; 0.6
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f078788r ; 0.529412 ; DirectX::Colors::LightSkyBlue
	DD	03f4eced0r			; 0.807843
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e008081r ; 0.12549 ; DirectX::Colors::LightSeaGreen
	DD	03f32b2b3r			; 0.698039
	DD	03f2aaaabr			; 0.666667
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightSalmon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightSalmon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LightSalmon
	DD	03f20a0a1r			; 0.627451
	DD	03ef4f4f6r			; 0.478431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightPink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightPink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LightPink
	DD	03f36b6b7r			; 0.713726
	DD	03f41c1c3r			; 0.756863
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f109091r ; 0.564706 ; DirectX::Colors::LightGreen
	DD	03f6eeef0r			; 0.933333
	DD	03f109091r			; 0.564706
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f53d3d5r ; 0.827451 ; DirectX::Colors::LightGray
	DD	03f53d3d5r			; 0.827451
	DD	03f53d3d5r			; 0.827451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightGoldenrodYellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightGoldenrodYellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::LightGoldenrodYellow
	DD	03f7afafcr			; 0.980392
	DD	03f52d2d4r			; 0.823529
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightCyan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightCyan@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f60e0e2r ; 0.878431 ; DirectX::Colors::LightCyan
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightCoral@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightCoral@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::LightCoral
	DD	03f008081r			; 0.501961
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LightBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LightBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f2dadaer ; 0.678431 ; DirectX::Colors::LightBlue
	DD	03f58d8dar			; 0.847059
	DD	03f66e6e8r			; 0.901961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LemonChiffon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LemonChiffon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LemonChiffon
	DD	03f7afafcr			; 0.980392
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LawnGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LawnGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ef8f8far ; 0.486275 ; DirectX::Colors::LawnGreen
	DD	03f7cfcfer			; 0.988235
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?LavenderBlush@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?LavenderBlush@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::LavenderBlush
	DD	03f70f0f2r			; 0.941177
	DD	03f75f5f7r			; 0.960784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Lavender@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Lavender@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f66e6e8r ; 0.901961 ; DirectX::Colors::Lavender
	DD	03f66e6e8r			; 0.901961
	DD	03f7afafcr			; 0.980392
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Khaki@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Khaki@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::Khaki
	DD	03f66e6e8r			; 0.901961
	DD	03f0c8c8dr			; 0.54902
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Ivory@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Ivory@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Ivory
	DD	03f800000r			; 1
	DD	03f70f0f2r			; 0.941177
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Indigo@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Indigo@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e969697r ; 0.294118 ; DirectX::Colors::Indigo
	DD	000000000r			; 0
	DD	03f028283r			; 0.509804
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?IndianRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?IndianRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f4dcdcfr ; 0.803922 ; DirectX::Colors::IndianRed
	DD	03eb8b8b9r			; 0.360784
	DD	03eb8b8b9r			; 0.360784
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?HotPink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?HotPink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::HotPink
	DD	03ed2d2d4r			; 0.411765
	DD	03f34b4b5r			; 0.705882
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Honeydew@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Honeydew@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::Honeydew
	DD	03f800000r			; 1
	DD	03f70f0f2r			; 0.941177
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?GreenYellow@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?GreenYellow@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f2dadaer ; 0.678431 ; DirectX::Colors::GreenYellow
	DD	03f800000r			; 1
	DD	03e3cbcbdr			; 0.184314
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Green@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Green@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Green
	DD	03f008081r			; 0.501961
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f008081r ; 0.501961 ; DirectX::Colors::Gray
	DD	03f008081r			; 0.501961
	DD	03f008081r			; 0.501961
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Goldenrod@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Goldenrod@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5adadcr ; 0.854902 ; DirectX::Colors::Goldenrod
	DD	03f25a5a6r			; 0.647059
	DD	03e008081r			; 0.12549
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gold@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gold@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Gold
	DD	03f57d7d9r			; 0.843137
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?GhostWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?GhostWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f78f8far ; 0.972549 ; DirectX::Colors::GhostWhite
	DD	03f78f8far			; 0.972549
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Gainsboro@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Gainsboro@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5cdcder ; 0.862745 ; DirectX::Colors::Gainsboro
	DD	03f5cdcder			; 0.862745
	DD	03f5cdcder			; 0.862745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Fuchsia@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Fuchsia@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Fuchsia
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?ForestGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?ForestGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e088889r ; 0.133333 ; DirectX::Colors::ForestGreen
	DD	03f0b8b8cr			; 0.545098
	DD	03e088889r			; 0.133333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?FloralWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?FloralWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::FloralWhite
	DD	03f7afafcr			; 0.980392
	DD	03f70f0f2r			; 0.941177
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Firebrick@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Firebrick@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f32b2b3r ; 0.698039 ; DirectX::Colors::Firebrick
	DD	03e088889r			; 0.133333
	DD	03e088889r			; 0.133333
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DodgerBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DodgerBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03df0f0f2r ; 0.117647 ; DirectX::Colors::DodgerBlue
	DD	03f109091r			; 0.564706
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DimGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DimGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ed2d2d4r ; 0.411765 ; DirectX::Colors::DimGray
	DD	03ed2d2d4r			; 0.411765
	DD	03ed2d2d4r			; 0.411765
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DeepSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DeepSkyBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DeepSkyBlue
	DD	03f3fbfc0r			; 0.74902
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DeepPink@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DeepPink@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::DeepPink
	DD	03da0a0a1r			; 0.0784314
	DD	03f139394r			; 0.576471
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkViolet@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkViolet@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f149495r ; 0.580392 ; DirectX::Colors::DarkViolet
	DD	000000000r			; 0
	DD	03f53d3d5r			; 0.827451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkTurquoise@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkTurquoise
	DD	03f4eced0r			; 0.807843
	DD	03f51d1d3r			; 0.819608
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSlateGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e3cbcbdr ; 0.184314 ; DirectX::Colors::DarkSlateGray
	DD	03e9e9e9fr			; 0.309804
	DD	03e9e9e9fr			; 0.309804
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSlateBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03e909091r ; 0.282353 ; DirectX::Colors::DarkSlateBlue
	DD	03e74f4f6r			; 0.239216
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSeaGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0f8f90r ; 0.560784 ; DirectX::Colors::DarkSeaGreen
	DD	03f3cbcbdr			; 0.737255
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkSalmon@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkSalmon@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f69e9ebr ; 0.913726 ; DirectX::Colors::DarkSalmon
	DD	03f169697r			; 0.588235
	DD	03ef4f4f6r			; 0.478431
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkRed@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkRed@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0b8b8cr ; 0.545098 ; DirectX::Colors::DarkRed
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOrchid@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOrchid@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f19999ar ; 0.6 ; DirectX::Colors::DarkOrchid
	DD	03e48c8car			; 0.196078
	DD	03f4ccccer			; 0.8
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOrange@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOrange@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::DarkOrange
	DD	03f0c8c8dr			; 0.54902
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkOliveGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkOliveGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 03eaaaaabr ; 0.333333 ; DirectX::Colors::DarkOliveGreen
	DD	03ed6d6d8r			; 0.419608
	DD	03e3cbcbdr			; 0.184314
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkMagenta@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkMagenta@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0b8b8cr ; 0.545098 ; DirectX::Colors::DarkMagenta
	DD	000000000r			; 0
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkKhaki@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkKhaki@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f3dbdber ; 0.741176 ; DirectX::Colors::DarkKhaki
	DD	03f37b7b8r			; 0.717647
	DD	03ed6d6d8r			; 0.419608
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGreen@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGreen@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkGreen
	DD	03ec8c8car			; 0.392157
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGray@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGray@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f29a9aar ; 0.662745 ; DirectX::Colors::DarkGray
	DD	03f29a9aar			; 0.662745
	DD	03f29a9aar			; 0.662745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkGoldenrod@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f38b8b9r ; 0.721569 ; DirectX::Colors::DarkGoldenrod
	DD	03f068687r			; 0.52549
	DD	03d30b0b1r			; 0.0431373
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkCyan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkCyan@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkCyan
	DD	03f0b8b8cr			; 0.545098
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?DarkBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?DarkBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::DarkBlue
	DD	000000000r			; 0
	DD	03f0b8b8cr			; 0.545098
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Cyan@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Cyan@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Cyan
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Crimson@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Crimson@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5cdcder ; 0.862745 ; DirectX::Colors::Crimson
	DD	03da0a0a1r			; 0.0784314
	DD	03e70f0f2r			; 0.235294
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Cornsilk@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Cornsilk@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Cornsilk
	DD	03f78f8far			; 0.972549
	DD	03f5cdcder			; 0.862745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?CornflowerBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?CornflowerBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ec8c8car ; 0.392157 ; DirectX::Colors::CornflowerBlue
	DD	03f159596r			; 0.584314
	DD	03f6dedefr			; 0.929412
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Coral@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Coral@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Coral
	DD	03efeff00r			; 0.498039
	DD	03ea0a0a1r			; 0.313726
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Chocolate@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Chocolate@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f52d2d4r ; 0.823529 ; DirectX::Colors::Chocolate
	DD	03ed2d2d4r			; 0.411765
	DD	03df0f0f2r			; 0.117647
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Chartreuse@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Chartreuse@Colors@DirectX@@3UXMVECTORF32@2@B DD 03efeff00r ; 0.498039 ; DirectX::Colors::Chartreuse
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?CadetBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?CadetBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03ebebebfr ; 0.372549 ; DirectX::Colors::CadetBlue
	DD	03f1e9e9fr			; 0.619608
	DD	03f20a0a1r			; 0.627451
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BurlyWood@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BurlyWood@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f5edee0r ; 0.870588 ; DirectX::Colors::BurlyWood
	DD	03f38b8b9r			; 0.721569
	DD	03f078788r			; 0.529412
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Brown@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Brown@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f25a5a6r ; 0.647059 ; DirectX::Colors::Brown
	DD	03e28a8a9r			; 0.164706
	DD	03e28a8a9r			; 0.164706
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BlueViolet@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BlueViolet@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f0a8a8br ; 0.541176 ; DirectX::Colors::BlueViolet
	DD	03e2cacadr			; 0.168627
	DD	03f62e2e4r			; 0.886275
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Blue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Blue@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Blue
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?BlanchedAlmond@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?BlanchedAlmond@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::BlanchedAlmond
	DD	03f6bebedr			; 0.921569
	DD	03f4dcdcfr			; 0.803922
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Black@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Black@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Black
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Bisque@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Bisque@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f800000r ; 1 ; DirectX::Colors::Bisque
	DD	03f64e4e6r			; 0.894118
	DD	03f44c4c6r			; 0.768628
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Beige@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Beige@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f75f5f7r ; 0.960784 ; DirectX::Colors::Beige
	DD	03f75f5f7r			; 0.960784
	DD	03f5cdcder			; 0.862745
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Azure@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Azure@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::Azure
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Aquamarine@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Aquamarine@Colors@DirectX@@3UXMVECTORF32@2@B DD 03efeff00r ; 0.498039 ; DirectX::Colors::Aquamarine
	DD	03f800000r			; 1
	DD	03f54d4d6r			; 0.831373
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?Aqua@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?Aqua@Colors@DirectX@@3UXMVECTORF32@2@B DD 000000000r ; 0 ; DirectX::Colors::Aqua
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?AntiqueWhite@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?AntiqueWhite@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f7afafcr ; 0.980392 ; DirectX::Colors::AntiqueWhite
	DD	03f6bebedr			; 0.921569
	DD	03f57d7d9r			; 0.843137
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?AliceBlue@Colors@DirectX@@3UXMVECTORF32@2@B
CONST	SEGMENT
?AliceBlue@Colors@DirectX@@3UXMVECTORF32@2@B DD 03f70f0f2r ; 0.941177 ; DirectX::Colors::AliceBlue
	DD	03f78f8far			; 0.972549
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_UShortMax@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_UShortMax@DirectX@@3UXMVECTORF32@1@B DD 0477fff00r ; 65535 ; DirectX::g_UShortMax
	DD	0477fff00r			; 65535
	DD	0477fff00r			; 65535
	DD	0477fff00r			; 65535
CONST	ENDS
;	COMDAT ?g_ShortMax@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_ShortMax@DirectX@@3UXMVECTORF32@1@B DD 046fffe00r ; 32767 ; DirectX::g_ShortMax
	DD	046fffe00r			; 32767
	DD	046fffe00r			; 32767
	DD	046fffe00r			; 32767
CONST	ENDS
;	COMDAT ?g_ShortMin@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_ShortMin@DirectX@@3UXMVECTORF32@1@B DD 0c6fffe00r ; -32767 ; DirectX::g_ShortMin
	DD	0c6fffe00r			; -32767
	DD	0c6fffe00r			; -32767
	DD	0c6fffe00r			; -32767
CONST	ENDS
;	COMDAT ?g_ByteMax@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_ByteMax@DirectX@@3UXMVECTORF32@1@B DD 042fe0000r ; 127 ; DirectX::g_ByteMax
	DD	042fe0000r			; 127
	DD	042fe0000r			; 127
	DD	042fe0000r			; 127
CONST	ENDS
;	COMDAT ?g_ByteMin@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_ByteMin@DirectX@@3UXMVECTORF32@1@B DD 0c2fe0000r ; -127 ; DirectX::g_ByteMin
	DD	0c2fe0000r			; -127
	DD	0c2fe0000r			; -127
	DD	0c2fe0000r			; -127
CONST	ENDS
;	COMDAT ?g_UByteMax@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_UByteMax@DirectX@@3UXMVECTORF32@1@B DD 0437f0000r ; 255 ; DirectX::g_UByteMax
	DD	0437f0000r			; 255
	DD	0437f0000r			; 255
	DD	0437f0000r			; 255
CONST	ENDS
;	COMDAT ?g_XMInvLg10@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMInvLg10@DirectX@@3UXMVECTORF32@1@B DD 03e9a209br ; 0.30103 ; DirectX::g_XMInvLg10
	DD	03e9a209br			; 0.30103
	DD	03e9a209br			; 0.30103
	DD	03e9a209br			; 0.30103
CONST	ENDS
;	COMDAT ?g_XMLg10@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLg10@DirectX@@3UXMVECTORF32@1@B DD 040549a78r ; 3.32193 ; DirectX::g_XMLg10
	DD	040549a78r			; 3.32193
	DD	040549a78r			; 3.32193
	DD	040549a78r			; 3.32193
CONST	ENDS
;	COMDAT ?g_XMInvLgE@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMInvLgE@DirectX@@3UXMVECTORF32@1@B DD 03f317218r ; 0.693147 ; DirectX::g_XMInvLgE
	DD	03f317218r			; 0.693147
	DD	03f317218r			; 0.693147
	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?g_XMLgE@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLgE@DirectX@@3UXMVECTORF32@1@B DD 03fb8aa3br ; 1.4427 ; DirectX::g_XMLgE
	DD	03fb8aa3br			; 1.4427
	DD	03fb8aa3br			; 1.4427
	DD	03fb8aa3br			; 1.4427
CONST	ENDS
;	COMDAT ?g_XMLogEst7@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst7@DirectX@@3UXMVECTORF32@1@B DD 0bc2d4f59r ; -0.010578 ; DirectX::g_XMLogEst7
	DD	0bc2d4f59r			; -0.010578
	DD	0bc2d4f59r			; -0.010578
	DD	0bc2d4f59r			; -0.010578
CONST	ENDS
;	COMDAT ?g_XMLogEst6@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst6@DirectX@@3UXMVECTORF32@1@B DD 03d6a1405r ; 0.057148 ; DirectX::g_XMLogEst6
	DD	03d6a1405r			; 0.057148
	DD	03d6a1405r			; 0.057148
	DD	03d6a1405r			; 0.057148
CONST	ENDS
;	COMDAT ?g_XMLogEst5@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst5@DirectX@@3UXMVECTORF32@1@B DD 0be153261r ; -0.1457 ; DirectX::g_XMLogEst5
	DD	0be153261r			; -0.1457
	DD	0be153261r			; -0.1457
	DD	0be153261r			; -0.1457
CONST	ENDS
;	COMDAT ?g_XMLogEst4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst4@DirectX@@3UXMVECTORF32@1@B DD 03e7e8e61r ; 0.24859 ; DirectX::g_XMLogEst4
	DD	03e7e8e61r			; 0.24859
	DD	03e7e8e61r			; 0.24859
	DD	03e7e8e61r			; 0.24859
CONST	ENDS
;	COMDAT ?g_XMLogEst3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst3@DirectX@@3UXMVECTORF32@1@B DD 0beb359der ; -0.350295 ; DirectX::g_XMLogEst3
	DD	0beb359der			; -0.350295
	DD	0beb359der			; -0.350295
	DD	0beb359der			; -0.350295
CONST	ENDS
;	COMDAT ?g_XMLogEst2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst2@DirectX@@3UXMVECTORF32@1@B DD 03ef571d2r ; 0.479384 ; DirectX::g_XMLogEst2
	DD	03ef571d2r			; 0.479384
	DD	03ef571d2r			; 0.479384
	DD	03ef571d2r			; 0.479384
CONST	ENDS
;	COMDAT ?g_XMLogEst1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst1@DirectX@@3UXMVECTORF32@1@B DD 0bf38a351r ; -0.721242 ; DirectX::g_XMLogEst1
	DD	0bf38a351r			; -0.721242
	DD	0bf38a351r			; -0.721242
	DD	0bf38a351r			; -0.721242
CONST	ENDS
;	COMDAT ?g_XMLogEst0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMLogEst0@DirectX@@3UXMVECTORF32@1@B DD 03fb8aa2ar ; 1.44269 ; DirectX::g_XMLogEst0
	DD	03fb8aa2ar			; 1.44269
	DD	03fb8aa2ar			; 1.44269
	DD	03fb8aa2ar			; 1.44269
CONST	ENDS
;	COMDAT ?g_XMExpEst7@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst7@DirectX@@3UXMVECTORF32@1@B DD 0b7364261r ; -1.08635e-05 ; DirectX::g_XMExpEst7
	DD	0b7364261r			; -1.08635e-05
	DD	0b7364261r			; -1.08635e-05
	DD	0b7364261r			; -1.08635e-05
CONST	ENDS
;	COMDAT ?g_XMExpEst6@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst6@DirectX@@3UXMVECTORF32@1@B DD 0391aa7d7r ; 0.000147491 ; DirectX::g_XMExpEst6
	DD	0391aa7d7r			; 0.000147491
	DD	0391aa7d7r			; 0.000147491
	DD	0391aa7d7r			; 0.000147491
CONST	ENDS
;	COMDAT ?g_XMExpEst5@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst5@DirectX@@3UXMVECTORF32@1@B DD 0baae1854r ; -0.00132824 ; DirectX::g_XMExpEst5
	DD	0baae1854r			; -0.00132824
	DD	0baae1854r			; -0.00132824
	DD	0baae1854r			; -0.00132824
CONST	ENDS
;	COMDAT ?g_XMExpEst4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst4@DirectX@@3UXMVECTORF32@1@B DD 03c1d8c54r ; 0.00961598 ; DirectX::g_XMExpEst4
	DD	03c1d8c54r			; 0.00961598
	DD	03c1d8c54r			; 0.00961598
	DD	03c1d8c54r			; 0.00961598
CONST	ENDS
;	COMDAT ?g_XMExpEst3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst3@DirectX@@3UXMVECTORF32@1@B DD 0bd6357car ; -0.0555036 ; DirectX::g_XMExpEst3
	DD	0bd6357car			; -0.0555036
	DD	0bd6357car			; -0.0555036
	DD	0bd6357car			; -0.0555036
CONST	ENDS
;	COMDAT ?g_XMExpEst2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst2@DirectX@@3UXMVECTORF32@1@B DD 03e75fdedr ; 0.240226 ; DirectX::g_XMExpEst2
	DD	03e75fdedr			; 0.240226
	DD	03e75fdedr			; 0.240226
	DD	03e75fdedr			; 0.240226
CONST	ENDS
;	COMDAT ?g_XMExpEst1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMExpEst1@DirectX@@3UXMVECTORF32@1@B DD 0bf317218r ; -0.693147 ; DirectX::g_XMExpEst1
	DD	0bf317218r			; -0.693147
	DD	0bf317218r			; -0.693147
	DD	0bf317218r			; -0.693147
CONST	ENDS
;	COMDAT ?g_XM253@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XM253@DirectX@@3UXMVECTORI32@1@B DD 0fdH		; DirectX::g_XM253
	DD	0fdH
	DD	0fdH
	DD	0fdH
CONST	ENDS
;	COMDAT ?g_XMBinNeg150@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMBinNeg150@DirectX@@3UXMVECTORU32@1@B DD 0c3160000H	; DirectX::g_XMBinNeg150
	DD	0c3160000H
	DD	0c3160000H
	DD	0c3160000H
CONST	ENDS
;	COMDAT ?g_XMBin128@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMBin128@DirectX@@3UXMVECTORI32@1@B DD 043000000H	; DirectX::g_XMBin128
	DD	043000000H
	DD	043000000H
	DD	043000000H
CONST	ENDS
;	COMDAT ?g_XMNegQNaN@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMNegQNaN@DirectX@@3UXMVECTORU32@1@B DD 0ffc00000H	; DirectX::g_XMNegQNaN
	DD	0ffc00000H
	DD	0ffc00000H
	DD	0ffc00000H
CONST	ENDS
;	COMDAT ?g_XMNegInfinity@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMNegInfinity@DirectX@@3UXMVECTORU32@1@B DD 0ff800000H ; DirectX::g_XMNegInfinity
	DD	0ff800000H
	DD	0ff800000H
	DD	0ff800000H
CONST	ENDS
;	COMDAT ?g_XMMinNormal@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMinNormal@DirectX@@3UXMVECTORI32@1@B DD 0800000H	; DirectX::g_XMMinNormal
	DD	0800000H
	DD	0800000H
	DD	0800000H
CONST	ENDS
;	COMDAT ?g_XMNumTrailing@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMNumTrailing@DirectX@@3UXMVECTORI32@1@B DD 017H	; DirectX::g_XMNumTrailing
	DD	017H
	DD	017H
	DD	017H
CONST	ENDS
;	COMDAT ?g_XMSubnormalExponent@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMSubnormalExponent@DirectX@@3UXMVECTORI32@1@B DD 0ffffff82H ; DirectX::g_XMSubnormalExponent
	DD	0ffffff82H
	DD	0ffffff82H
	DD	0ffffff82H
CONST	ENDS
;	COMDAT ?g_XMExponentBias@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMExponentBias@DirectX@@3UXMVECTORI32@1@B DD 07fH	; DirectX::g_XMExponentBias
	DD	07fH
	DD	07fH
	DD	07fH
CONST	ENDS
;	COMDAT ?g_XMsrgbA1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMsrgbA1@DirectX@@3UXMVECTORF32@1@B DD 03f870a3dr ; 1.055 ; DirectX::g_XMsrgbA1
	DD	03f870a3dr			; 1.055
	DD	03f870a3dr			; 1.055
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMsrgbA@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMsrgbA@DirectX@@3UXMVECTORF32@1@B DD 03d6147aer ; 0.055 ; DirectX::g_XMsrgbA
	DD	03d6147aer			; 0.055
	DD	03d6147aer			; 0.055
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMsrgbScale@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMsrgbScale@DirectX@@3UXMVECTORF32@1@B DD 0414eb852r ; 12.92 ; DirectX::g_XMsrgbScale
	DD	0414eb852r			; 12.92
	DD	0414eb852r			; 12.92
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMUnsignedFix@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMUnsignedFix@DirectX@@3UXMVECTORF32@1@B DD 04f000000r ; 2.14748e+09 ; DirectX::g_XMUnsignedFix
	DD	04f000000r			; 2.14748e+09
	DD	04f000000r			; 2.14748e+09
	DD	04f000000r			; 2.14748e+09
CONST	ENDS
;	COMDAT ?g_XMMaxUInt@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMMaxUInt@DirectX@@3UXMVECTORF32@1@B DD 04f7fffffr ; 4.29497e+09 ; DirectX::g_XMMaxUInt
	DD	04f7fffffr			; 4.29497e+09
	DD	04f7fffffr			; 4.29497e+09
	DD	04f7fffffr			; 4.29497e+09
CONST	ENDS
;	COMDAT ?g_XMMaxInt@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMMaxInt@DirectX@@3UXMVECTORF32@1@B DD 04effffffr ; 2.14748e+09 ; DirectX::g_XMMaxInt
	DD	04effffffr			; 2.14748e+09
	DD	04effffffr			; 2.14748e+09
	DD	04effffffr			; 2.14748e+09
CONST	ENDS
;	COMDAT ?g_XMFixUnsigned@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixUnsigned@DirectX@@3UXMVECTORF32@1@B DD 04f000000r ; 2.14748e+09 ; DirectX::g_XMFixUnsigned
	DD	04f000000r			; 2.14748e+09
	DD	04f000000r			; 2.14748e+09
	DD	04f000000r			; 2.14748e+09
CONST	ENDS
;	COMDAT ?g_XMAddByte4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMAddByte4@DirectX@@3UXMVECTORF32@1@B DD 0c3000000r ; -128 ; DirectX::g_XMAddByte4
	DD	0c7000000r			; -32768
	DD	0cb000000r			; -8.38861e+06
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMXorByte4@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMXorByte4@DirectX@@3UXMVECTORI32@1@B DD 080H	; DirectX::g_XMXorByte4
	DD	08000H
	DD	0800000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskByte4@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskByte4@DirectX@@3UXMVECTORU32@1@B DD 0ffH	; DirectX::g_XMMaskByte4
	DD	0ff00H
	DD	0ff0000H
	DD	0ff000000H
CONST	ENDS
;	COMDAT ?g_XMMulDec4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMMulDec4@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMMulDec4
	DD	03a800000r			; 0.000976562
	DD	035800000r			; 9.53674e-07
	DD	030800000r			; 9.31323e-10
CONST	ENDS
;	COMDAT ?g_XMAddDec4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMAddDec4@DirectX@@3UXMVECTORF32@1@B DD 0c4000000r ; -512 ; DirectX::g_XMAddDec4
	DD	0c9000000r			; -524288
	DD	0ce000000r			; -5.36871e+08
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMAddUDec4@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMAddUDec4@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMAddUDec4
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	04f000000r			; 2.14748e+09
CONST	ENDS
;	COMDAT ?g_XMXorDec4@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMXorDec4@DirectX@@3UXMVECTORI32@1@B DD 0200H	; DirectX::g_XMXorDec4
	DD	080000H
	DD	020000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskDec4@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskDec4@DirectX@@3UXMVECTORI32@1@B DD 03ffH	; DirectX::g_XMMaskDec4
	DD	0ffc00H
	DD	03ff00000H
	DD	0c0000000H
CONST	ENDS
;	COMDAT ?g_XMFlipYW@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipYW@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMFlipYW
	DD	080000000H
	DD	00H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMFlipZW@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipZW@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMFlipZW
	DD	00H
	DD	080000000H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMFlipYZ@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipYZ@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMFlipYZ
	DD	080000000H
	DD	080000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMFlipW@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipW@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMFlipW
	DD	00H
	DD	00H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMFlipZ@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipZ@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMFlipZ
	DD	00H
	DD	080000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMFlipY@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipY@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMFlipY
	DD	080000000H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMFixupY16W16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixupY16W16@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMFixupY16W16
	DD	03f800000r			; 1
	DD	037800000r			; 1.52588e-05
	DD	037800000r			; 1.52588e-05
CONST	ENDS
;	COMDAT ?g_XMFixupY16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixupY16@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMFixupY16
	DD	037800000r			; 1.52588e-05
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMSelect1011@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMSelect1011@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1011
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ?g_XMSelect1110@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMSelect1110@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1110
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMSelect1100@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMSelect1100@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1100
	DD	0ffffffffH
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMSelect1000@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMSelect1000@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1000
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMOneHalfMinusEpsilon@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMOneHalfMinusEpsilon@DirectX@@3UXMVECTORI32@1@B DD 03efffffdH ; DirectX::g_XMOneHalfMinusEpsilon
	DD	03efffffdH
	DD	03efffffdH
	DD	03efffffdH
CONST	ENDS
;	COMDAT ?g_XMSelect1010@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMSelect1010@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH ; DirectX::g_XMSelect1010
	DD	00H
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMSelect0101@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMSelect0101@DirectX@@3UXMVECTORU32@1@B DD 00H	; DirectX::g_XMSelect0101
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ?g_XMNegateW@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateW@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMNegateW
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	0bf800000r			; -1
CONST	ENDS
;	COMDAT ?g_XMNegateZ@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateZ@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMNegateZ
	DD	03f800000r			; 1
	DD	0bf800000r			; -1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMNegateY@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateY@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMNegateY
	DD	0bf800000r			; -1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMNegateX@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegateX@DirectX@@3UXMVECTORF32@1@B DD 0bf800000r ; -1 ; DirectX::g_XMNegateX
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMMaskByte@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMMaskByte@DirectX@@3UXMVECTORI32@1@B DD 0ffH	; DirectX::g_XMMaskByte
	DD	0ffH
	DD	0ffH
	DD	0ffH
CONST	ENDS
;	COMDAT ?g_XMNoFraction@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNoFraction@DirectX@@3UXMVECTORF32@1@B DD 04b000000r ; 8.38861e+06 ; DirectX::g_XMNoFraction
	DD	04b000000r			; 8.38861e+06
	DD	04b000000r			; 8.38861e+06
	DD	04b000000r			; 8.38861e+06
CONST	ENDS
;	COMDAT ?g_XMNormalizeX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B DD 038000100r ; 3.05185e-05 ; DirectX::g_XMNormalizeX16Y16Z16W16
	DD	038000100r			; 3.05185e-05
	DD	030000100r			; 4.65675e-10
	DD	030000100r			; 4.65675e-10
CONST	ENDS
;	COMDAT ?g_XMFixX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixX16Y16Z16W16@DirectX@@3UXMVECTORF32@1@B DD 0c7000000r ; -32768 ; DirectX::g_XMFixX16Y16Z16W16
	DD	0c7000000r			; -32768
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMFlipX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipX16Y16Z16W16@DirectX@@3UXMVECTORI32@1@B DD 08000H ; DirectX::g_XMFlipX16Y16Z16W16
	DD	08000H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskX16Y16Z16W16@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskX16Y16Z16W16@DirectX@@3UXMVECTORU32@1@B DD 0ffffH ; DirectX::g_XMMaskX16Y16Z16W16
	DD	0ffffH
	DD	0ffff0000H
	DD	0ffff0000H
CONST	ENDS
;	COMDAT ?g_XMNormalizeX16Y16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeX16Y16@DirectX@@3UXMVECTORF32@1@B DD 038000100r ; 3.05185e-05 ; DirectX::g_XMNormalizeX16Y16
	DD	030000100r			; 4.65675e-10
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMFixX16Y16@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixX16Y16@DirectX@@3UXMVECTORF32@1@B DD 0c7000000r ; -32768 ; DirectX::g_XMFixX16Y16
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMFlipX16Y16@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFlipX16Y16@DirectX@@3UXMVECTORI32@1@B DD 08000H	; DirectX::g_XMFlipX16Y16
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskX16Y16@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskX16Y16@DirectX@@3UXMVECTORU32@1@B DD 0ffffH	; DirectX::g_XMMaskX16Y16
	DD	0ffff0000H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMNormalizeA2B10G10R10@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeA2B10G10R10@DirectX@@3UXMVECTORF32@1@B DD 03b004020r ; 0.00195695 ; DirectX::g_XMNormalizeA2B10G10R10
	DD	036004020r			; 1.91108e-06
	DD	031004020r			; 1.86629e-09
	DD	02faaaaabr			; 3.10441e-10
CONST	ENDS
;	COMDAT ?g_XMFixAA2B10G10R10@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixAA2B10G10R10@DirectX@@3UXMVECTORF32@1@B DD 0c4000000r ; -512 ; DirectX::g_XMFixAA2B10G10R10
	DD	0c9000000r			; -524288
	DD	0ce000000r			; -5.36871e+08
	DD	04f000000r			; 2.14748e+09
CONST	ENDS
;	COMDAT ?g_XMFlipA2B10G10R10@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipA2B10G10R10@DirectX@@3UXMVECTORU32@1@B DD 0200H ; DirectX::g_XMFlipA2B10G10R10
	DD	080000H
	DD	020000000H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMMaskA2B10G10R10@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskA2B10G10R10@DirectX@@3UXMVECTORU32@1@B DD 03ffH ; DirectX::g_XMMaskA2B10G10R10
	DD	0ffc00H
	DD	03ff00000H
	DD	0c0000000H
CONST	ENDS
;	COMDAT ?g_XMNormalizeA8R8G8B8@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNormalizeA8R8G8B8@DirectX@@3UXMVECTORF32@1@B DD 033808081r ; 5.98384e-08 ; DirectX::g_XMNormalizeA8R8G8B8
	DD	037808081r			; 1.53186e-05
	DD	03b808081r			; 0.00392157
	DD	02f808081r			; 2.33744e-10
CONST	ENDS
;	COMDAT ?g_XMFixAA8R8G8B8@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFixAA8R8G8B8@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMFixAA8R8G8B8
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	04f000000r			; 2.14748e+09
CONST	ENDS
;	COMDAT ?g_XMFlipA8R8G8B8@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMFlipA8R8G8B8@DirectX@@3UXMVECTORU32@1@B DD 00H	; DirectX::g_XMFlipA8R8G8B8
	DD	00H
	DD	00H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMMaskA8R8G8B8@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskA8R8G8B8@DirectX@@3UXMVECTORU32@1@B DD 0ff0000H ; DirectX::g_XMMaskA8R8G8B8
	DD	0ff00H
	DD	0ffH
	DD	0ff000000H
CONST	ENDS
;	COMDAT ?g_XMNegOneMask@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMNegOneMask@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH ; DirectX::g_XMNegOneMask
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ?g_XMFltMax@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFltMax@DirectX@@3UXMVECTORI32@1@B DD 07f7fffffH	; DirectX::g_XMFltMax
	DD	07f7fffffH
	DD	07f7fffffH
	DD	07f7fffffH
CONST	ENDS
;	COMDAT ?g_XMFltMin@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMFltMin@DirectX@@3UXMVECTORI32@1@B DD 0800000H	; DirectX::g_XMFltMin
	DD	0800000H
	DD	0800000H
	DD	0800000H
CONST	ENDS
;	COMDAT ?g_XMAbsMask@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMAbsMask@DirectX@@3UXMVECTORI32@1@B DD 07fffffffH	; DirectX::g_XMAbsMask
	DD	07fffffffH
	DD	07fffffffH
	DD	07fffffffH
CONST	ENDS
;	COMDAT ?g_XMQNaNTest@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMQNaNTest@DirectX@@3UXMVECTORI32@1@B DD 07fffffH	; DirectX::g_XMQNaNTest
	DD	07fffffH
	DD	07fffffH
	DD	07fffffH
CONST	ENDS
;	COMDAT ?g_XMQNaN@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMQNaN@DirectX@@3UXMVECTORI32@1@B DD 07fc00000H	; DirectX::g_XMQNaN
	DD	07fc00000H
	DD	07fc00000H
	DD	07fc00000H
CONST	ENDS
;	COMDAT ?g_XMInfinity@DirectX@@3UXMVECTORI32@1@B
CONST	SEGMENT
?g_XMInfinity@DirectX@@3UXMVECTORI32@1@B DD 07f800000H	; DirectX::g_XMInfinity
	DD	07f800000H
	DD	07f800000H
	DD	07f800000H
CONST	ENDS
;	COMDAT ?g_XMEpsilon@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMEpsilon@DirectX@@3UXMVECTORF32@1@B DD 034000000r ; 1.19209e-07 ; DirectX::g_XMEpsilon
	DD	034000000r			; 1.19209e-07
	DD	034000000r			; 1.19209e-07
	DD	034000000r			; 1.19209e-07
CONST	ENDS
;	COMDAT ?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMReciprocalTwoPi@DirectX@@3UXMVECTORF32@1@B DD 03e22f983r ; 0.159155 ; DirectX::g_XMReciprocalTwoPi
	DD	03e22f983r			; 0.159155
	DD	03e22f983r			; 0.159155
	DD	03e22f983r			; 0.159155
CONST	ENDS
;	COMDAT ?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTwoPi@DirectX@@3UXMVECTORF32@1@B DD 040c90fdbr ; 6.28319 ; DirectX::g_XMTwoPi
	DD	040c90fdbr			; 6.28319
	DD	040c90fdbr			; 6.28319
	DD	040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT ?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMReciprocalPi@DirectX@@3UXMVECTORF32@1@B DD 03ea2f983r ; 0.31831 ; DirectX::g_XMReciprocalPi
	DD	03ea2f983r			; 0.31831
	DD	03ea2f983r			; 0.31831
	DD	03ea2f983r			; 0.31831
CONST	ENDS
;	COMDAT ?g_XMPi@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMPi@DirectX@@3UXMVECTORF32@1@B DD 040490fdbr ; 3.14159 ; DirectX::g_XMPi
	DD	040490fdbr			; 3.14159
	DD	040490fdbr			; 3.14159
	DD	040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT ?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMHalfPi@DirectX@@3UXMVECTORF32@1@B DD 03fc90fdbr ; 1.5708 ; DirectX::g_XMHalfPi
	DD	03fc90fdbr			; 1.5708
	DD	03fc90fdbr			; 1.5708
	DD	03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT ?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegativePi@DirectX@@3UXMVECTORF32@1@B DD 0c0490fdbr ; -3.14159 ; DirectX::g_XMNegativePi
	DD	0c0490fdbr			; -3.14159
	DD	0c0490fdbr			; -3.14159
	DD	0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT ?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegativeTwoPi@DirectX@@3UXMVECTORF32@1@B DD 0c0c90fdbr ; -6.28319 ; DirectX::g_XMNegativeTwoPi
	DD	0c0c90fdbr			; -6.28319
	DD	0c0c90fdbr			; -6.28319
	DD	0c0c90fdbr			; -6.28319
CONST	ENDS
;	COMDAT ?g_XMNegativeOneHalf@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegativeOneHalf@DirectX@@3UXMVECTORF32@1@B DD 0bf000000r ; -0.5 ; DirectX::g_XMNegativeOneHalf
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
CONST	ENDS
;	COMDAT ?g_XMOneHalf@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMOneHalf@DirectX@@3UXMVECTORF32@1@B DD 03f000000r ; 0.5 ; DirectX::g_XMOneHalf
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
CONST	ENDS
;	COMDAT ?g_XMNegativeOne@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegativeOne@DirectX@@3UXMVECTORF32@1@B DD 0bf800000r ; -1 ; DirectX::g_XMNegativeOne
	DD	0bf800000r			; -1
	DD	0bf800000r			; -1
	DD	0bf800000r			; -1
CONST	ENDS
;	COMDAT ?g_XMSix@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMSix@DirectX@@3UXMVECTORF32@1@B DD 040c00000r ; 6	; DirectX::g_XMSix
	DD	040c00000r			; 6
	DD	040c00000r			; 6
	DD	040c00000r			; 6
CONST	ENDS
;	COMDAT ?g_XMFour@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMFour@DirectX@@3UXMVECTORF32@1@B DD 040800000r ; 4	; DirectX::g_XMFour
	DD	040800000r			; 4
	DD	040800000r			; 4
	DD	040800000r			; 4
CONST	ENDS
;	COMDAT ?g_XMTwo@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTwo@DirectX@@3UXMVECTORF32@1@B DD 040000000r ; 2	; DirectX::g_XMTwo
	DD	040000000r			; 2
	DD	040000000r			; 2
	DD	040000000r			; 2
CONST	ENDS
;	COMDAT ?g_XMZero@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMZero@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0	; DirectX::g_XMZero
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMOne3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMOne3@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1	; DirectX::g_XMOne3
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMOne@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMOne@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1	; DirectX::g_XMOne
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMMaskW@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskW@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMMaskW
	DD	00H
	DD	00H
	DD	0ffffffffH
CONST	ENDS
;	COMDAT ?g_XMMaskZ@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskZ@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMMaskZ
	DD	00H
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskY@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskY@DirectX@@3UXMVECTORU32@1@B DD 00H		; DirectX::g_XMMaskY
	DD	0ffffffffH
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskX@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskX@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH	; DirectX::g_XMMaskX
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMask3@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMask3@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH	; DirectX::g_XMMask3
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMMaskXY@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMMaskXY@DirectX@@3UXMVECTORU32@1@B DD 0ffffffffH	; DirectX::g_XMMaskXY
	DD	0ffffffffH
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMNegate3@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMNegate3@DirectX@@3UXMVECTORU32@1@B DD 080000000H	; DirectX::g_XMNegate3
	DD	080000000H
	DD	080000000H
	DD	00H
CONST	ENDS
;	COMDAT ?g_XMNegativeZero@DirectX@@3UXMVECTORU32@1@B
CONST	SEGMENT
?g_XMNegativeZero@DirectX@@3UXMVECTORU32@1@B DD 080000000H ; DirectX::g_XMNegativeZero
	DD	080000000H
	DD	080000000H
	DD	080000000H
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR3@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMNegIdentityR3
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR2@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMNegIdentityR2
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR1@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMNegIdentityR1
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMNegIdentityR0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMNegIdentityR0@DirectX@@3UXMVECTORF32@1@B DD 0bf800000r ; -1 ; DirectX::g_XMNegIdentityR0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMIdentityR3@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR3@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMIdentityR3
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?g_XMIdentityR2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR2@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMIdentityR2
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMIdentityR1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR1@DirectX@@3UXMVECTORF32@1@B DD 000000000r ; 0 ; DirectX::g_XMIdentityR1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMIdentityR0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMIdentityR0@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMIdentityR0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMPiConstants0@DirectX@@3UXMVECTORF32@1@B DD 040490fdbr ; 3.14159 ; DirectX::g_XMPiConstants0
	DD	040c90fdbr			; 6.28319
	DD	03ea2f983r			; 0.31831
	DD	03e22f983r			; 0.159155
CONST	ENDS
;	COMDAT ?g_XMArcEstCoefficients@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMArcEstCoefficients@DirectX@@3UXMVECTORF32@1@B DD 03fc90da4r ; 1.57073 ; DirectX::g_XMArcEstCoefficients
	DD	0be593484r			; -0.212114
	DD	03d981627r			; 0.074261
	DD	0bc996e30r			; -0.0187293
CONST	ENDS
;	COMDAT ?g_XMTanEstCoefficients@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTanEstCoefficients@DirectX@@3UXMVECTORF32@1@B DD 0401ef9dbr ; 2.484 ; DirectX::g_XMTanEstCoefficients
	DD	0be482f23r			; -0.195492
	DD	0401de9e6r			; 2.4674
	DD	03ea2f983r			; 0.31831
CONST	ENDS
;	COMDAT ?g_XMATanEstCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanEstCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0bea91d04r ; -0.330299 ; DirectX::g_XMATanEstCoefficients1
	DD	03e3876e2r			; 0.180141
	DD	0bdae5a36r			; -0.085133
	DD	03caaae5fr			; 0.0208351
CONST	ENDS
;	COMDAT ?g_XMATanEstCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanEstCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 03f7ff738r ; 0.999866 ; DirectX::g_XMATanEstCoefficients0
	DD	03f7ff738r			; 0.999866
	DD	03f7ff738r			; 0.999866
	DD	03f7ff738r			; 0.999866
CONST	ENDS
;	COMDAT ?g_XMATanCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0bd9a3174r ; -0.0752896 ; DirectX::g_XMATanCoefficients1
	DD	03d2fc1fer			; 0.0429096
	DD	0bc846e02r			; -0.0161657
	DD	03b3bd74ar			; 0.00286623
CONST	ENDS
;	COMDAT ?g_XMATanCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMATanCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 0beaaaa6cr ; -0.333331 ; DirectX::g_XMATanCoefficients0
	DD	03e4cbbe5r			; 0.199936
	DD	0be117fc7r			; -0.142089
	DD	03dda3d83r			; 0.106563
CONST	ENDS
;	COMDAT ?g_XMArcCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMArcCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 03cfd10f8r ; 0.0308919 ; DirectX::g_XMArcCoefficients1
	DD	0bc8bfc66r			; -0.0170881
	DD	03bda90c5r			; 0.00667009
	DD	0baa57a2cr			; -0.00126249
CONST	ENDS
;	COMDAT ?g_XMArcCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMArcCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 03fc90fdar ; 1.5708 ; DirectX::g_XMArcCoefficients0
	DD	0be5bbfcar			; -0.214599
	DD	03db63a9er			; 0.088979
	DD	0bd4d8392r			; -0.0501743
CONST	ENDS
;	COMDAT ?g_XMTanCoefficients2@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTanCoefficients2@DirectX@@3UXMVECTORF32@1@B DD 03a1aac12r ; 0.000590027 ; DirectX::g_XMTanCoefficients2
	DD	0397abeb9r			; 0.000239129
	DD	038cb3f0cr			; 9.69154e-05
	DD	03824bec9r			; 3.92783e-05
CONST	ENDS
;	COMDAT ?g_XMTanCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTanCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 03cb327a4r ; 0.0218695 ; DirectX::g_XMTanCoefficients1
	DD	03c11371br			; 0.00886324
	DD	03b6b69e9r			; 0.00359213
	DD	03abed1b3r			; 0.00145583
CONST	ENDS
;	COMDAT ?g_XMTanCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMTanCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 03f800000r ; 1 ; DirectX::g_XMTanCoefficients0
	DD	03eaaaaabr			; 0.333333
	DD	03e088889r			; 0.133333
	DD	03d5d0dd1r			; 0.0539683
CONST	ENDS
;	COMDAT ?g_XMCosCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMCosCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0b48bdd11r ; -2.60516e-07 ; DirectX::g_XMCosCoefficients1
	DD	0befff67er			; -0.499927
	DD	03d29f587r			; 0.0414939
	DD	0baa69fdbr			; -0.00127124
CONST	ENDS
;	COMDAT ?g_XMCosCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMCosCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 0bf000000r ; -0.5 ; DirectX::g_XMCosCoefficients0
	DD	03d2aaaa3r			; 0.0416666
	DD	0bab609aar			; -0.00138884
	DD	037cfb4c2r			; 2.47605e-05
CONST	ENDS
;	COMDAT ?g_XMSinCoefficients1@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMSinCoefficients1@DirectX@@3UXMVECTORF32@1@B DD 0b2cd365br ; -2.38899e-08 ; DirectX::g_XMSinCoefficients1
	DD	0be2aa888r			; -0.166659
	DD	03c08373cr			; 0.00831395
	DD	0b9423ec8r			; -0.000185247
CONST	ENDS
;	COMDAT ?g_XMSinCoefficients0@DirectX@@3UXMVECTORF32@1@B
CONST	SEGMENT
?g_XMSinCoefficients0@DirectX@@3UXMVECTORF32@1@B DD 0be2aaaabr ; -0.166667 ; DirectX::g_XMSinCoefficients0
	DD	03c088886r			; 0.00833333
	DD	0b9500bf1r			; -0.000198409
	DD	03638b88er			; 2.75256e-06
CONST	ENDS
;	COMDAT c_DwmMaxAdapters
CONST	SEGMENT
c_DwmMaxAdapters DD 010H
CONST	ENDS
;	COMDAT c_DwmMaxMonitors
CONST	SEGMENT
c_DwmMaxMonitors DD 010H
CONST	ENDS
;	COMDAT c_DwmMaxQueuedBuffers
CONST	SEGMENT
c_DwmMaxQueuedBuffers DD 08H
CONST	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT CLSID_CUrlHistoryBoth
CONST	SEGMENT
CLSID_CUrlHistoryBoth DD 06659983cH
	DW	08476H
	DW	04eb4H
	DB	0b7H
	DB	08cH
	DB	0e5H
	DB	096H
	DB	08fH
	DB	032H
	DB	06bH
	DB	0a0H
CONST	ENDS
;	COMDAT CLSID_CUrlHistory
CONST	SEGMENT
CLSID_CUrlHistory DD 03c374a40H
	DW	0bae4H
	DW	011cfH
	DB	0bfH
	DB	07dH
	DB	00H
	DB	0aaH
	DB	00H
	DB	069H
	DB	046H
	DB	0eeH
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
CONST	SEGMENT
?stbi__jbias@@3QBHB DD 00H				; stbi__jbias
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
?NoInit@asmjit@@3U_NoInit@1@B	ORG $+1			; asmjit::NoInit
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z	; std::_Fnv1a_append_bytes
PUBLIC	ldexpf
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z		; std::tuple<>::tuple<>
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?_Decref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Decwref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?ldexp@@YAMMH@Z					; ldexp
PUBLIC	?pow@@YAMMM@Z					; pow
PUBLIC	?_Floor_of_log_2@std@@YAK_K@Z			; std::_Floor_of_log_2
PUBLIC	?_Ceiling_of_log_2@std@@YAK_K@Z			; std::_Ceiling_of_log_2
PUBLIC	??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z ; std::_Conditionally_enabled_hash<int,1>::operator()
PUBLIC	?_Do_hash@?$hash@H@std@@SA_KAEBH@Z		; std::hash<int>::_Do_hash
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	??0?$_Func_class@X$$V@std@@QEAA@XZ		; std::_Func_class<void>::_Func_class<void>
PUBLIC	??R?$_Func_class@X$$V@std@@QEBAXXZ		; std::_Func_class<void>::operator()
PUBLIC	??1?$_Func_class@X$$V@std@@QEAA@XZ		; std::_Func_class<void>::~_Func_class<void>
PUBLIC	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ	; std::_Func_class<void>::_Empty
PUBLIC	?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z ; std::_Func_class<void>::_Reset_copy
PUBLIC	?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z ; std::_Func_class<void>::_Reset_move
PUBLIC	?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ		; std::_Func_class<void>::_Tidy
PUBLIC	?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ	; std::_Func_class<void>::_Local
PUBLIC	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
PUBLIC	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
PUBLIC	??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	??B?$function@$$A6AXXZ@std@@QEBA_NXZ		; std::function<void __cdecl(void)>::operator bool
PUBLIC	??1?$function@$$A6AXXZ@std@@QEAA@XZ		; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
PUBLIC	??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z	; std::function<void __cdecl(void)>::`scalar deleting destructor'
PUBLIC	??$move@AEAV?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::move<std::function<void __cdecl(void)> &>
PUBLIC	??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >
PUBLIC	?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::deallocate
PUBLIC	?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size
PUBLIC	??0?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >
PUBLIC	?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::deallocate
PUBLIC	??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::begin
PUBLIC	?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::end
PUBLIC	?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear
PUBLIC	?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_Orphan_non_end
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	??0ImVec2@@QEAA@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QEAA@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QEAA@MMMM@Z				; ImVec4::ImVec4
PUBLIC	??0ImColor@@QEAA@HHHH@Z				; ImColor::ImColor
PUBLIC	??BImColor@@QEBA?AUImVec4@@XZ			; ImColor::operator ImVec4
PUBLIC	?Initialize@OverlayEngine@Core@IronMan@@SA_NXZ	; IronMan::Core::OverlayEngine::Initialize
PUBLIC	?InitWindow@OverlayEngine@Core@IronMan@@SAXXZ	; IronMan::Core::OverlayEngine::InitWindow
PUBLIC	?HideWindow@OverlayEngine@Core@IronMan@@SAXXZ	; IronMan::Core::OverlayEngine::HideWindow
PUBLIC	?Start@OverlayEngine@Core@IronMan@@SAXXZ	; IronMan::Core::OverlayEngine::Start
PUBLIC	?Shutdown@OverlayEngine@Core@IronMan@@SAXXZ	; IronMan::Core::OverlayEngine::Shutdown
PUBLIC	?bInitSuccess@OverlayEngine@Core@IronMan@@SA_NXZ ; IronMan::Core::OverlayEngine::bInitSuccess
PUBLIC	?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ ; IronMan::Core::OverlayEngine::UpdateTargetWindow
PUBLIC	?Transparent@OverlayEngine@Core@IronMan@@SAXXZ	; IronMan::Core::OverlayEngine::Transparent
PUBLIC	?UnTransparent@OverlayEngine@Core@IronMan@@SAXXZ ; IronMan::Core::OverlayEngine::UnTransparent
PUBLIC	?GetKeyState@OverlayEngine@Core@IronMan@@SAFI@Z	; IronMan::Core::OverlayEngine::GetKeyState
PUBLIC	?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z	; IronMan::Core::OverlayEngine::IsKeyDown
PUBLIC	?WasKeyPressed@OverlayEngine@Core@IronMan@@SA_NI@Z ; IronMan::Core::OverlayEngine::WasKeyPressed
PUBLIC	?SetKeyPressed@OverlayEngine@Core@IronMan@@SAXI_N@Z ; IronMan::Core::OverlayEngine::SetKeyPressed
PUBLIC	?UpdateKeyState@OverlayEngine@Core@IronMan@@SAXXZ ; IronMan::Core::OverlayEngine::UpdateKeyState
PUBLIC	?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z ; IronMan::Core::OverlayEngine::RegisterHotkey
PUBLIC	?RemoveHotkey@OverlayEngine@Core@IronMan@@SAXI@Z ; IronMan::Core::OverlayEngine::RemoveHotkey
PUBLIC	?ActiveWindow@OverlayEngine@Core@IronMan@@SAXPEAUHWND__@@@Z ; IronMan::Core::OverlayEngine::ActiveWindow
PUBLIC	?CreateTexture@OverlayEngine@Core@IronMan@@SAPEAXPEBD_K@Z ; IronMan::Core::OverlayEngine::CreateTexture
PUBLIC	?GetViewPort@OverlayEngine@Core@IronMan@@SA?AUImVec2@@XZ ; IronMan::Core::OverlayEngine::GetViewPort
PUBLIC	?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ ; IronMan::Core::OverlayEngine::ProcessFunction
PUBLIC	?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ	; IronMan::Core::OverlayEngine::SetupWindow
PUBLIC	?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ ; IronMan::Core::OverlayEngine::CreateDirect3D
PUBLIC	?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ ; IronMan::Core::OverlayEngine::InitializeImgui
PUBLIC	?Update@OverlayEngine@Core@IronMan@@CAXXZ	; IronMan::Core::OverlayEngine::Update
PUBLIC	?Tick@OverlayEngine@Core@IronMan@@CAXXZ		; IronMan::Core::OverlayEngine::Tick
PUBLIC	?Render@OverlayEngine@Core@IronMan@@CAXXZ	; IronMan::Core::OverlayEngine::Render
PUBLIC	?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ ; IronMan::Core::OverlayEngine::CreateRenderTarget
PUBLIC	?CleanupRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ ; IronMan::Core::OverlayEngine::CleanupRenderTarget
PUBLIC	?WindowProc@OverlayEngine@Core@IronMan@@CA_JPEAUHWND__@@I_K_J@Z ; IronMan::Core::OverlayEngine::WindowProc
PUBLIC	?ProcessMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ; IronMan::Core::OverlayEngine::ProcessMessage
PUBLIC	?ProcessMouseMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ; IronMan::Core::OverlayEngine::ProcessMouseMessage
PUBLIC	?ProcessKeybdMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ; IronMan::Core::OverlayEngine::ProcessKeybdMessage
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
PUBLIC	??1BaseProcessInfo@IronMan@@QEAA@XZ		; IronMan::BaseProcessInfo::~BaseProcessInfo
PUBLIC	?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
PUBLIC	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
PUBLIC	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ		; IronMan::GetDMA
PUBLIC	??0FName@SDK@Core@IronMan@@QEAA@H@Z		; IronMan::Core::SDK::FName::FName
PUBLIC	??R?$less@H@std@@QEBA_NAEBH0@Z			; std::less<int>::operator()
PUBLIC	??$move@AEAH@std@@YA$$QEAHAEAH@Z		; std::move<int &>
PUBLIC	stbi_load
PUBLIC	stbi_load_from_memory
PUBLIC	stbi_load_from_callbacks
PUBLIC	stbi_load_from_file
PUBLIC	stbi_loadf
PUBLIC	stbi_loadf_from_memory
PUBLIC	stbi_loadf_from_callbacks
PUBLIC	stbi_loadf_from_file
PUBLIC	stbi_hdr_to_ldr_gamma
PUBLIC	stbi_hdr_to_ldr_scale
PUBLIC	stbi_ldr_to_hdr_gamma
PUBLIC	stbi_ldr_to_hdr_scale
PUBLIC	stbi_is_hdr_from_callbacks
PUBLIC	stbi_is_hdr_from_memory
PUBLIC	stbi_is_hdr
PUBLIC	stbi_is_hdr_from_file
PUBLIC	stbi_failure_reason
PUBLIC	stbi_image_free
PUBLIC	stbi_info_from_memory
PUBLIC	stbi_info_from_callbacks
PUBLIC	stbi_info
PUBLIC	stbi_info_from_file
PUBLIC	stbi_set_unpremultiply_on_load
PUBLIC	stbi_convert_iphone_png_to_rgb
PUBLIC	stbi_set_flip_vertically_on_load
PUBLIC	stbi_zlib_decode_malloc_guesssize
PUBLIC	stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	stbi_zlib_decode_malloc
PUBLIC	stbi_zlib_decode_buffer
PUBLIC	stbi_zlib_decode_noheader_malloc
PUBLIC	stbi_zlib_decode_noheader_buffer
PUBLIC	??BXMVECTORF32@DirectX@@QEBAPEBMXZ		; DirectX::XMVECTORF32::operator float const *
PUBLIC	??0?$delegate@$$A6AXXZ@@QEAA@XZ			; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>
PUBLIC	??1?$delegate@$$A6AXXZ@@QEAA@XZ			; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>
PUBLIC	??R?$delegate@$$A6AXXZ@@QEAAXXZ			; delegate<void __cdecl(void)>::operator()
PUBLIC	??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::delegate<void __cdecl(IronMan::Core::WndEventArgs &)>
PUBLIC	??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::~delegate<void __cdecl(IronMan::Core::WndEventArgs &)>
PUBLIC	??0?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >
PUBLIC	?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::deallocate
PUBLIC	??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
PUBLIC	??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::~list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
PUBLIC	?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_end
PUBLIC	?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::clear
PUBLIC	?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Orphan_non_end
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Get_first
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::max_size
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::end
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::max_size
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getcomp
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Insert_node
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Get_first
PUBLIC	??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
PUBLIC	??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::operator[]
PUBLIC	??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::~map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
PUBLIC	?ThreadInitGui@Core@IronMan@@YAKPEAX@Z		; IronMan::Core::ThreadInitGui
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >
PUBLIC	??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::operator()
PUBLIC	??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::~_Func_class<void,IronMan::Core::WndEventArgs &>
PUBLIC	?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Empty
PUBLIC	?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Tidy
PUBLIC	?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Local
PUBLIC	?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Getimpl
PUBLIC	?_Set@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEAAXPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@@Z ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Set
PUBLIC	??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ ; std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::~function<void __cdecl(IronMan::Core::WndEventArgs &)>
PUBLIC	??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z ; std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::`scalar deleting destructor'
PUBLIC	??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back
PUBLIC	?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear
PUBLIC	?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_end
PUBLIC	?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size
PUBLIC	?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::capacity
PUBLIC	?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAXPEAV?$function@$$A6AXXZ@2@0@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
PUBLIC	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
PUBLIC	??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@H@std@@QEBA_NAEBH0@Z		; std::equal_to<int>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEBAAEBU?$equal_to@H@2@XZ ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEBAAEBU?$hash@H@2@XZ ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
PUBLIC	??0?$allocator@U?$pair@$$CBH_N@std@@@std@@QEAA@XZ ; std::allocator<std::pair<int const ,bool> >::allocator<std::pair<int const ,bool> >
PUBLIC	??0?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::max_size
PUBLIC	??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
PUBLIC	??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::~list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
PUBLIC	?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::end
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Make_iter
PUBLIC	?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::max_size
PUBLIC	?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
PUBLIC	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::max_load_factor
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Rehash_for_1
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::~_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >
PUBLIC	??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ; std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >
PUBLIC	??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ; std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::~unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator!=
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >
PUBLIC	??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
PUBLIC	??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::`scalar deleting destructor'
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::find<void>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator==
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator->
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
PUBLIC	??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::emplace<int const &,bool>
PUBLIC	??$constHash@$0?BGNOOJIGFPHBLFGF@@@YA_KXZ	; constHash<-1648011277000357221>
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z ; std::pointer_traits<std::pair<int const ,bool> *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > *>::pointer_to
PUBLIC	??$_Unfancy_maybe_null@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy_maybe_null<std::function<void __cdecl(void)> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_one_at_back<std::function<void __cdecl(void)> const &>
PUBLIC	??$forward@AEAUWndEventArgs@Core@IronMan@@@std@@YAAEAUWndEventArgs@Core@IronMan@@AEAU123@@Z ; std::forward<IronMan::Core::WndEventArgs &>
PUBLIC	??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Try_emplace<int>
PUBLIC	??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find<int>
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1><>
PUBLIC	??$forward@_N@std@@YA$$QEA_NAEA_N@Z		; std::forward<bool>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
PUBLIC	??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z ; std::addressof<std::pair<int const ,bool> >
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > ><std::allocator<std::pair<int const ,bool> > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >
PUBLIC	??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1><>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1><>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *,std::_List_node<std::function<void __cdecl(void)>,void *> * &>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
PUBLIC	??$_Hash_representation@H@std@@YA_KAEBH@Z	; std::_Hash_representation<int>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1><std::allocator<std::pair<int const ,bool> > const &>
PUBLIC	??$?0U?$pair@$$CBH_N@std@@@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocator<std::_List_node<std::pair<int const ,bool>,void *> ><std::pair<int const ,bool> >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *,std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z		; std::_Get_size_of_n<80>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * &>
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z		; std::_Get_size_of_n<24>
PUBLIC	??$forward@H@std@@YA$$QEAHAEAH@Z		; std::forward<int>
PUBLIC	??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
PUBLIC	??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find<int>
PUBLIC	?_Extract@?$_In_place_key_extract_map_impl@HH_N@std@@SAAEBHAEBHAEB_N@Z ; std::_In_place_key_extract_map_impl<int,int,bool>::_Extract
PUBLIC	??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find_last<int>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool,0>
PUBLIC	??$forward@AEBH@std@@YAAEBHAEBH@Z		; std::forward<int const &>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
PUBLIC	??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > ><int const &,bool>
PUBLIC	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
PUBLIC	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
PUBLIC	??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >
PUBLIC	??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z ; std::forward<std::function<void __cdecl(void)> const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_with_unused_capacity<std::function<void __cdecl(void)> const &>
PUBLIC	??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_reallocate<std::function<void __cdecl(void)> const &>
PUBLIC	??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find_lower_bound<int>
PUBLIC	??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Lower_bound_duplicate<int>
PUBLIC	??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &,bool,0>
PUBLIC	??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z ; std::forward_as_tuple<int>
PUBLIC	??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z		; std::tuple<int &&>::tuple<int &&>
PUBLIC	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
PUBLIC	??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool,0>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::forward<std::function<void __cdecl(void)> >
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBH_N@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<int const ,bool> > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1><std::allocator<std::pair<int const ,bool> > const &>
PUBLIC	??$?0U?$pair@$$CBH_N@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > ><std::pair<int const ,bool> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,bool>,void *> *>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$forward@M@std@@YA$$QEAMAEAM@Z		; std::forward<float>
PUBLIC	??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z ; std::forward<std::less<int> const &>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
PUBLIC	??$addressof@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::function<void __cdecl(void)>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::function<void __cdecl(void)>,void *> * &>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *>
PUBLIC	??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::addressof<std::function<void __cdecl(void)> >
PUBLIC	??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::destroy<std::function<void __cdecl(void)> >
PUBLIC	??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z	; std::_Fnv1a_append_value<int>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > * const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>
PUBLIC	??$addressof@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,bool>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * &>
PUBLIC	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
PUBLIC	??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::destroy<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
PUBLIC	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::nullptr_t>
PUBLIC	??$destroy@U?$pair@$$CBH_N@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::destroy<std::pair<int const ,bool> >
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<int const ,bool>,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * const &>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > const >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > const >
PUBLIC	??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z		; std::_Get_size_of_n<64>
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
PUBLIC	??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::construct<std::pair<int const ,bool>,int const &,bool>
PUBLIC	??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	??$_Kfn@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0>::_Kfn<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
PUBLIC	??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>
PUBLIC	??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z	; std::tuple<int &&>::tuple<int &&><int,0>
PUBLIC	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
PUBLIC	??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ; std::forward<std::tuple<int &&> >
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::construct<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
PUBLIC	??$forward@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
PUBLIC	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
PUBLIC	??$addressof@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@YAPEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@0@AEAV10@@Z ; std::addressof<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >
PUBLIC	??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::destroy<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
PUBLIC	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * const &>
PUBLIC	??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z ; std::pair<int const ,bool>::pair<int const ,bool><int const &,bool,0>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAV?$function@$$A6AXXZ@0@@Z ; std::_Get_unwrapped<std::function<void __cdecl(void)> * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@PEAV?$function@$$A6AXXZ@1@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::~_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Release
PUBLIC	??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back<std::function<void __cdecl(void)> >
PUBLIC	??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z ; std::tuple<int &&>::tuple<int &&><std::_Exact_args_t,int,0>
PUBLIC	??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><int &&>
PUBLIC	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
PUBLIC	??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> >
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z	; std::_Tuple_val<int &&>::_Tuple_val<int &&><int>
PUBLIC	??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><std::tuple<int &&>,std::tuple<>,0>
PUBLIC	??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ; std::move<std::tuple<int &&> &>
PUBLIC	??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z ; std::_Tuple_get<0,int &&>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1><>
PUBLIC	?piecewise_construct@std@@3Upiecewise_construct_t@1@B ; std::piecewise_construct
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnUpdate
PUBLIC	?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnTick
PUBLIC	?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPrePresent
PUBLIC	?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPresent
PUBLIC	?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPostPresent
PUBLIC	?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A ; IronMan::Core::OverlayEngine::OnWndProc
PUBLIC	?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
PUBLIC	?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A ; IronMan::DMAHandler::UpdateStartTime
PUBLIC	?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterWriteArray
PUBLIC	?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterReadArray
PUBLIC	?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A ; IronMan::DMAHandler::processInfo
PUBLIC	??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_04KBFEPHFH@S?$IA?v4@			; `string'
PUBLIC	??_C@_04ELNJHLFH@PICT@				; `string'
PUBLIC	??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@		; `string'
PUBLIC	??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@		; `string'
PUBLIC	??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@	; `string'
PUBLIC	??_C@_03HKAKGGJN@?9Y?5@				; `string'
PUBLIC	??_C@_03FOKDFDHG@?$CLX?5@			; `string'
PUBLIC	??_C@_0BJ@PFOBBMC@ImGui?g?$LL?$JI?e?$II?$LG?e?$IK?$KA?h?$LN?$LN?e?$KE?$LB?h?$LE?$KF?$CB@ ; `string'
PUBLIC	??_C@_1BO@ILCHKGLN@?$AAQ?$AAt?$AA5?$AAQ?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAI?$AAc?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_1M@IEELADJB@?$AAo?$AAb?$AAs?$AA6?$AA4@	; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR@				; `string'
PUBLIC	??_C@_0CF@JAIMGOII@Error?5D3D11CreateDeviceAndSwapC@ ; `string'
PUBLIC	_GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
PUBLIC	??_C@_0BF@JMJNPNKE@RenderTarget?5Failed?$CB@	; `string'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Min_buckets
PUBLIC	??_C@_0FN@EFNFJFIJ@Cannot?5find?5TTC?5font?5file?5?$CCmsyh@ ; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	__real@3b808081
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e6b851f
PUBLIC	__real@3e75c28f
PUBLIC	__real@3e800000
PUBLIC	__real@3e947ae1
PUBLIC	__real@3edc28f6
PUBLIC	__real@3f000000
PUBLIC	__real@3f400000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f6147ae
PUBLIC	__real@3f68f5c3
PUBLIC	__real@3f6b851f
PUBLIC	__real@3f733333
PUBLIC	__real@3f7ae148
PUBLIC	__real@3f800000
PUBLIC	__real@3fa00000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@41000000
PUBLIC	__real@41600000
PUBLIC	__real@41800000
PUBLIC	__real@41900000
PUBLIC	__real@41a00000
PUBLIC	__real@41a80000
PUBLIC	__real@41b00000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@437f0000
PUBLIC	__real@5f000000
PUBLIC	__real@bf800000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	_Init_thread_header:PROC
EXTRN	_Init_thread_abort:PROC
EXTRN	_Init_thread_footer:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	fopen_s:PROC
EXTRN	fclose:PROC
EXTRN	feof:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	strncmp:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	realloc:PROC
EXTRN	_lrotl:PROC
EXTRN	abs:PROC
EXTRN	ldexp:PROC
EXTRN	ceilf:PROC
EXTRN	powf:PROC
EXTRN	strtol:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_TerminateProcess:PROC
EXTRN	__imp_CreateThread:PROC
EXTRN	__imp_GetModuleHandleW:PROC
EXTRN	__imp_AttachThreadInput:PROC
EXTRN	__imp_DefWindowProcW:PROC
EXTRN	__imp_PostQuitMessage:PROC
EXTRN	__imp_RegisterClassExW:PROC
EXTRN	__imp_GetClassInfoExW:PROC
EXTRN	__imp_CreateWindowExW:PROC
EXTRN	__imp_ShowWindow:PROC
EXTRN	__imp_SetLayeredWindowAttributes:PROC
EXTRN	__imp_GetAsyncKeyState:PROC
EXTRN	__imp_GetSystemMetrics:PROC
EXTRN	__imp_UpdateWindow:PROC
EXTRN	__imp_GetForegroundWindow:PROC
EXTRN	__imp_SetForegroundWindow:PROC
EXTRN	__imp_MessageBoxA:PROC
EXTRN	__imp_SetWindowLongW:PROC
EXTRN	__imp_GetWindowThreadProcessId:PROC
EXTRN	__imp_LoadCursorW:PROC
EXTRN	__imp_GetSystemDefaultLangID:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	?_Xbad_function_call@std@@YAXXZ:PROC		; std::_Xbad_function_call
EXTRN	_Xtime_get_ticks:PROC
EXTRN	?Print@Console@IronMan@@YA_NPEBDZZ:PROC		; IronMan::Console::Print
EXTRN	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ:PROC ; IronMan::Utils::FormatString
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	D3D11CreateDeviceAndSwapChain:PROC
EXTRN	?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z:PROC ; ImGui::CreateContext
EXTRN	?GetIO@ImGui@@YAAEAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?NewFrame@ImGui@@YAXXZ:PROC			; ImGui::NewFrame
EXTRN	?Render@ImGui@@YAXXZ:PROC			; ImGui::Render
EXTRN	?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ:PROC	; ImGui::GetDrawData
EXTRN	?SetColorEditOptions@ImGui@@YAXH@Z:PROC		; ImGui::SetColorEditOptions
EXTRN	??0ImFontConfig@@QEAA@XZ:PROC			; ImFontConfig::ImFontConfig
EXTRN	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z:PROC ; ImFontAtlas::AddFontFromMemoryTTF
EXTRN	?Build@ImFontAtlas@@QEAA_NXZ:PROC		; ImFontAtlas::Build
EXTRN	?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ:PROC ; ImFontAtlas::GetGlyphRangesKorean
EXTRN	?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ:PROC ; ImFontAtlas::GetGlyphRangesChineseFull
EXTRN	?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ:PROC ; ImFontAtlas::GetGlyphRangesCyrillic
EXTRN	?ImGui_ImplDX11_Init@@YA_NPEAUID3D11Device@@PEAUID3D11DeviceContext@@@Z:PROC ; ImGui_ImplDX11_Init
EXTRN	?ImGui_ImplDX11_NewFrame@@YAXXZ:PROC		; ImGui_ImplDX11_NewFrame
EXTRN	?ImGui_ImplDX11_RenderDrawData@@YAXPEAUImDrawData@@@Z:PROC ; ImGui_ImplDX11_RenderDrawData
EXTRN	?ImGui_ImplWin32_Init@@YA_NPEAXHH@Z:PROC	; ImGui_ImplWin32_Init
EXTRN	?ImGui_ImplWin32_NewFrame@@YAXXZ:PROC		; ImGui_ImplWin32_NewFrame
EXTRN	?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ:PROC ; IronMan::Core::Package::GetPackage
EXTRN	?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z:PROC ; IronMan::Core::Package::FindFile
EXTRN	__imp_SHGetSpecialFolderPathA:PROC
EXTRN	?Instance@DMAHandler@IronMan@@SAAEAV12@XZ:PROC	; IronMan::DMAHandler::Instance
EXTRN	?IsKeyDown@DMAHandler@IronMan@@QEAA_NI@Z:PROC	; IronMan::DMAHandler::IsKeyDown
EXTRN	?WasKeyPressed@DMAHandler@IronMan@@QEAA_NI@Z:PROC ; IronMan::DMAHandler::WasKeyPressed
EXTRN	__imp_DwmEnableBlurBehindWindow:PROC
EXTRN	__imp_DwmExtendFrameIntoClientArea:PROC
EXTRN	?ImGui_ImplWin32_WndProcHandler@@YA_JPEAUHWND__@@I_K_J@Z:PROC ; ImGui_ImplWin32_WndProcHandler
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?Vars@Core@IronMan@@3UVariables@12@A:BYTE	; IronMan::Core::Vars
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
	ALIGN	8

?XYZMask@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?)	; IronMan::Core::Math::XYZMask
?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?) ; IronMan::Core::Math::QINV_SIGN_MASK
?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A DB 010H DUP (?) ; IronMan::Core::OverlayEngine::OnUpdate
?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A DB 010H DUP (?) ; IronMan::Core::OverlayEngine::OnTick
?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A DB 010H DUP (?) ; IronMan::Core::OverlayEngine::OnPrePresent
?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A DB 010H DUP (?) ; IronMan::Core::OverlayEngine::OnPresent
?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A DB 010H DUP (?) ; IronMan::Core::OverlayEngine::OnPostPresent
?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A DB 010H DUP (?) ; IronMan::Core::OverlayEngine::OnWndProc
?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A DB 010H DUP (?) ; IronMan::Core::OverlayEngine::mHotkeys
_BSS	ENDS
;	COMDAT ?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A
_BSS	SEGMENT
?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A DQ 01H DUP (?) ; IronMan::DMAHandler::UpdateStartTime
_BSS	ENDS
;	COMDAT ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A
_BSS	SEGMENT
?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A DB 038H DUP (?) ; IronMan::DMAHandler::processInfo
_BSS	ENDS
_BSS	SEGMENT
?NAME_None@SDK@Core@IronMan@@3UFName@123@A DQ 01H DUP (?) ; IronMan::Core::SDK::NAME_None
?stbi__g_failure_reason@@3PEBDEB DQ 01H DUP (?)		; stbi__g_failure_reason
?stbi__vertically_flip_on_load@@3HA DD 01H DUP (?)	; stbi__vertically_flip_on_load
?stbi__zdefault_length@@3PAEA DB 0120H DUP (?)		; stbi__zdefault_length
?stbi__zdefault_distance@@3PAEA DB 020H DUP (?)		; stbi__zdefault_distance
?stbi__unpremultiply_on_load@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load
?stbi__de_iphone_flag@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag
?InitImGui@Core@IronMan@@3_NA DB 01H DUP (?)		; IronMan::Core::InitImGui
_BSS	ENDS
;	COMDAT ?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A
_BSS	SEGMENT
?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A DB 040H DUP (?) ; `IronMan::Core::OverlayEngine::ProcessFunction'::`2'::KeyPress_
_BSS	ENDS
;	COMDAT ?$TSS0@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA DD 01H DUP (?) ; `IronMan::Core::OverlayEngine::ProcessFunction'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ldexpf DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$ldexpf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decwref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Decwref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ldexp@@YAMMH@Z DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?ldexp@@YAMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pow@@YAMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?pow@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Floor_of_log_2@std@@YAK_K@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?_Floor_of_log_2@std@@YAK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ceiling_of_log_2@std@@YAK_K@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?_Ceiling_of_log_2@std@@YAK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Do_hash@?$hash@H@std@@SA_KAEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Do_hash@?$hash@H@std@@SA_KAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_tree_length_error@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Throw_tree_length_error@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Func_class@X$$V@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0?$_Func_class@X$$V@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Func_class@X$$V@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$??R?$_Func_class@X$$V@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Func_class@X$$V@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Func_class@X$$V@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z DD imagerel $LN6
	DD	imagerel $LN6+168
	DD	imagerel $unwind$?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$function@$$A6AXXZ@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$??B?$function@$$A6AXXZ@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$function@$$A6AXXZ@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$function@$$A6AXXZ@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ+40
	DD	imagerel $unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ+53
	DD	imagerel $unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImColor@@QEAA@HHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+147
	DD	imagerel $unwind$??0ImColor@@QEAA@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??BImColor@@QEBA?AUImVec4@@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??BImColor@@QEBA?AUImVec4@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Initialize@OverlayEngine@Core@IronMan@@SA_NXZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$?Initialize@OverlayEngine@Core@IronMan@@SA_NXZ
$pdata$?InitWindow@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?InitWindow@OverlayEngine@Core@IronMan@@SAXXZ
$pdata$?HideWindow@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$?HideWindow@OverlayEngine@Core@IronMan@@SAXXZ
$pdata$?Start@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$?Start@OverlayEngine@Core@IronMan@@SAXXZ
$pdata$?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ
$pdata$?Transparent@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?Transparent@OverlayEngine@Core@IronMan@@SAXXZ
$pdata$?UnTransparent@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?UnTransparent@OverlayEngine@Core@IronMan@@SAXXZ
$pdata$?GetKeyState@OverlayEngine@Core@IronMan@@SAFI@Z DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$?GetKeyState@OverlayEngine@Core@IronMan@@SAFI@Z
$pdata$?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z
$pdata$?WasKeyPressed@OverlayEngine@Core@IronMan@@SA_NI@Z DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$?WasKeyPressed@OverlayEngine@Core@IronMan@@SA_NI@Z
$pdata$?UpdateKeyState@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN10
	DD	imagerel $LN10+185
	DD	imagerel $unwind$?UpdateKeyState@OverlayEngine@Core@IronMan@@SAXXZ
$pdata$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA DD imagerel ?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?RemoveHotkey@OverlayEngine@Core@IronMan@@SAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?RemoveHotkey@OverlayEngine@Core@IronMan@@SAXI@Z
$pdata$?ActiveWindow@OverlayEngine@Core@IronMan@@SAXPEAUHWND__@@@Z DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?ActiveWindow@OverlayEngine@Core@IronMan@@SAXPEAUHWND__@@@Z
$pdata$?CreateTexture@OverlayEngine@Core@IronMan@@SAPEAXPEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+509
	DD	imagerel $unwind$?CreateTexture@OverlayEngine@Core@IronMan@@SAPEAXPEBD_K@Z
$pdata$?GetViewPort@OverlayEngine@Core@IronMan@@SA?AUImVec2@@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?GetViewPort@OverlayEngine@Core@IronMan@@SA?AUImVec2@@XZ
$pdata$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ DD imagerel $LN18
	DD	imagerel $LN18+606
	DD	imagerel $unwind$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA DD imagerel ?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA
	DD	imagerel ?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+633
	DD	imagerel $unwind$?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ
$pdata$?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ DD imagerel $LN4
	DD	imagerel $LN4+402
	DD	imagerel $unwind$?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ
$pdata$?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ DD imagerel $LN13
	DD	imagerel $LN13+4848
	DD	imagerel $unwind$?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ
$pdata$?Update@OverlayEngine@Core@IronMan@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?Update@OverlayEngine@Core@IronMan@@CAXXZ
$pdata$?Render@OverlayEngine@Core@IronMan@@CAXXZ DD imagerel $LN7
	DD	imagerel $LN7+293
	DD	imagerel $unwind$?Render@OverlayEngine@Core@IronMan@@CAXXZ
$pdata$?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ DD imagerel $LN5
	DD	imagerel $LN5+148
	DD	imagerel $unwind$?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ
$pdata$?CleanupRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?CleanupRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ
$pdata$?WindowProc@OverlayEngine@Core@IronMan@@CA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN22
	DD	imagerel $LN22+668
	DD	imagerel $unwind$?WindowProc@OverlayEngine@Core@IronMan@@CA_JPEAUHWND__@@I_K_J@Z
$pdata$?ProcessMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z DD imagerel $LN24
	DD	imagerel $LN24+228
	DD	imagerel $unwind$?ProcessMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z
$pdata$?ProcessMouseMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z DD imagerel $LN30
	DD	imagerel $LN30+440
	DD	imagerel $unwind$?ProcessMouseMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z
$pdata$?ProcessKeybdMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z DD imagerel $LN16
	DD	imagerel $LN16+321
	DD	imagerel $unwind$?ProcessKeybdMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1BaseProcessInfo@IronMan@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1BaseProcessInfo@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ DD imagerel ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
	DD	imagerel ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD imagerel ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ+78
	DD	imagerel $unwind$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD imagerel ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$less@H@std@@QEBA_NAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??R?$less@H@std@@QEBA_NAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ENAME_None@SDK@Core@IronMan@@YAXXZ DD imagerel ??__ENAME_None@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__ENAME_None@SDK@Core@IronMan@@YAXXZ+24
	DD	imagerel $unwind$??__ENAME_None@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$stbi_load DD imagerel $LN4
	DD	imagerel $LN4+116
	DD	imagerel $unwind$stbi_load
$pdata$stbi_load_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_load_from_memory
$pdata$stbi_load_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_load_from_callbacks
$pdata$stbi_load_from_file DD imagerel $LN4
	DD	imagerel $LN4+196
	DD	imagerel $unwind$stbi_load_from_file
$pdata$stbi_loadf DD imagerel $LN4
	DD	imagerel $LN4+116
	DD	imagerel $unwind$stbi_loadf
$pdata$stbi_loadf_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_loadf_from_memory
$pdata$stbi_loadf_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_loadf_from_callbacks
$pdata$stbi_loadf_from_file DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$stbi_loadf_from_file
$pdata$stbi_is_hdr_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$stbi_is_hdr_from_callbacks
$pdata$stbi_is_hdr_from_memory DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$stbi_is_hdr_from_memory
$pdata$stbi_is_hdr DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$stbi_is_hdr
$pdata$stbi_is_hdr_from_file DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$stbi_is_hdr_from_file
$pdata$stbi_image_free DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$stbi_image_free
$pdata$stbi_info_from_memory DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$stbi_info_from_memory
$pdata$stbi_info_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$stbi_info_from_callbacks
$pdata$stbi_info DD imagerel $LN4
	DD	imagerel $LN4+106
	DD	imagerel $unwind$stbi_info
$pdata$stbi_info_from_file DD imagerel $LN3
	DD	imagerel $LN3+166
	DD	imagerel $unwind$stbi_info_from_file
$pdata$stbi_zlib_decode_malloc_guesssize DD imagerel $LN7
	DD	imagerel $LN7+249
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize
$pdata$stbi_zlib_decode_malloc_guesssize_headerflag DD imagerel $LN7
	DD	imagerel $LN7+252
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize_headerflag
$pdata$stbi_zlib_decode_malloc DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$stbi_zlib_decode_malloc
$pdata$stbi_zlib_decode_buffer DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$stbi_zlib_decode_buffer
$pdata$stbi_zlib_decode_noheader_malloc DD imagerel $LN7
	DD	imagerel $LN7+236
	DD	imagerel $unwind$stbi_zlib_decode_noheader_malloc
$pdata$stbi_zlib_decode_noheader_buffer DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$stbi_zlib_decode_noheader_buffer
$pdata$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
	DD	imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z+192
	DD	imagerel $unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
$pdata$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z DD imagerel ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z
	DD	imagerel ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z+132
	DD	imagerel $unwind$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z
$pdata$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
	DD	imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z+142
	DD	imagerel $unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
$pdata$?stbi__stdio_read@@YAHPEAXPEADH@Z DD imagerel ?stbi__stdio_read@@YAHPEAXPEADH@Z
	DD	imagerel ?stbi__stdio_read@@YAHPEAXPEADH@Z+52
	DD	imagerel $unwind$?stbi__stdio_read@@YAHPEAXPEADH@Z
$pdata$?stbi__stdio_skip@@YAXPEAXH@Z DD imagerel ?stbi__stdio_skip@@YAXPEAXH@Z
	DD	imagerel ?stbi__stdio_skip@@YAXPEAXH@Z+39
	DD	imagerel $unwind$?stbi__stdio_skip@@YAXPEAXH@Z
$pdata$?stbi__stdio_eof@@YAHPEAX@Z DD imagerel ?stbi__stdio_eof@@YAHPEAX@Z
	DD	imagerel ?stbi__stdio_eof@@YAHPEAX@Z+24
	DD	imagerel $unwind$?stbi__stdio_eof@@YAHPEAX@Z
$pdata$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z DD imagerel ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z
	DD	imagerel ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z+42
	DD	imagerel $unwind$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z
$pdata$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z+119
	DD	imagerel $unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+143
	DD	imagerel $unwind$?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z+122
	DD	imagerel $unwind$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+75
	DD	imagerel $unwind$?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z+64
	DD	imagerel $unwind$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+4187
	DD	imagerel $unwind$?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z+300
	DD	imagerel $unwind$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+287
	DD	imagerel $unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+1973
	DD	imagerel $unwind$?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z+375
	DD	imagerel $unwind$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z+71
	DD	imagerel $unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+1315
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z+260
	DD	imagerel $unwind$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z+1486
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z+487
	DD	imagerel $unwind$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+381
	DD	imagerel $unwind$?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z+581
	DD	imagerel $unwind$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+288
	DD	imagerel $unwind$?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z+54
	DD	imagerel $unwind$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z+91
	DD	imagerel $unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z+310
	DD	imagerel $unwind$?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z+296
	DD	imagerel $unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__malloc@@YAPEAX_K@Z DD imagerel ?stbi__malloc@@YAPEAX_K@Z
	DD	imagerel ?stbi__malloc@@YAPEAX_K@Z+24
	DD	imagerel $unwind$?stbi__malloc@@YAPEAX_K@Z
$pdata$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z DD imagerel ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z
	DD	imagerel ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z+361
	DD	imagerel $unwind$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z
$pdata$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+492
	DD	imagerel $unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
$pdata$?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z+556
	DD	imagerel $unwind$?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z+456
	DD	imagerel $unwind$?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z DD imagerel ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z
	DD	imagerel ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z+393
	DD	imagerel $unwind$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z
$pdata$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
	DD	imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z+57
	DD	imagerel $unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
$pdata$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z+253
	DD	imagerel $unwind$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__get8@@YAEPEAUstbi__context@@@Z DD imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z+169
	DD	imagerel $unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z
$pdata$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z+127
	DD	imagerel $unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__skip@@YAXPEAUstbi__context@@H@Z DD imagerel ?stbi__skip@@YAXPEAUstbi__context@@H@Z
	DD	imagerel ?stbi__skip@@YAXPEAUstbi__context@@H@Z+204
	DD	imagerel $unwind$?stbi__skip@@YAXPEAUstbi__context@@H@Z
$pdata$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
	DD	imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z+355
	DD	imagerel $unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
$pdata$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z+63
	DD	imagerel $unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z+57
	DD	imagerel $unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z
$pdata$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z+55
	DD	imagerel $unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z+49
	DD	imagerel $unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z
$pdata$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+2484
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
$pdata$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+649
	DD	imagerel $unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
$pdata$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z+368
	DD	imagerel $unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
$pdata$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z+232
	DD	imagerel $unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z+532
	DD	imagerel $unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
$pdata$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z+210
	DD	imagerel $unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z+165
	DD	imagerel $unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z+111
	DD	imagerel $unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z DD imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z+737
	DD	imagerel $unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z
$pdata$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+356
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
$pdata$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z+1651
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
$pdata$?stbi__idct_block@@YAXPEAEHQEAF@Z DD imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z
	DD	imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z+2703
	DD	imagerel $unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z
$pdata$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+137
	DD	imagerel $unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z+212
	DD	imagerel $unwind$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z+3193
	DD	imagerel $unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z DD imagerel ?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z
	DD	imagerel ?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z+88
	DD	imagerel $unwind$?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z
$pdata$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+465
	DD	imagerel $unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z+1107
	DD	imagerel $unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+742
	DD	imagerel $unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+1959
	DD	imagerel $unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+292
	DD	imagerel $unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z+403
	DD	imagerel $unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+110
	DD	imagerel $unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z+474
	DD	imagerel $unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z+383
	DD	imagerel $unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z+131
	DD	imagerel $unwind$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z
$pdata$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+451
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
$pdata$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z+346
	DD	imagerel $unwind$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z
$pdata$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+2174
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
$pdata$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z DD imagerel ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z
	DD	imagerel ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z+147
	DD	imagerel $unwind$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z
$pdata$?stbi__bit_reverse@@YAHHH@Z DD imagerel ?stbi__bit_reverse@@YAHHH@Z
	DD	imagerel ?stbi__bit_reverse@@YAHHH@Z+37
	DD	imagerel $unwind$?stbi__bit_reverse@@YAHHH@Z
$pdata$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z+877
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z
$pdata$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z DD imagerel ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z+74
	DD	imagerel $unwind$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z
$pdata$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z DD imagerel ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z+122
	DD	imagerel $unwind$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z
$pdata$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z+144
	DD	imagerel $unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
$pdata$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD imagerel ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
	DD	imagerel ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z+242
	DD	imagerel $unwind$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
$pdata$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
	DD	imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z+170
	DD	imagerel $unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
$pdata$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+244
	DD	imagerel $unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
$pdata$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z+686
	DD	imagerel $unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z+761
	DD	imagerel $unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z+451
	DD	imagerel $unwind$?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z+120
	DD	imagerel $unwind$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__init_zdefaults@@YAXXZ DD imagerel ?stbi__init_zdefaults@@YAXXZ
	DD	imagerel ?stbi__init_zdefaults@@YAXXZ+200
	DD	imagerel $unwind$?stbi__init_zdefaults@@YAXXZ
$pdata$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z+329
	DD	imagerel $unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
$pdata$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z DD imagerel ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z
	DD	imagerel ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z+108
	DD	imagerel $unwind$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z
$pdata$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
	DD	imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z+47
	DD	imagerel $unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
$pdata$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z+85
	DD	imagerel $unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__paeth@@YAHHHH@Z DD imagerel ?stbi__paeth@@YAHHHH@Z
	DD	imagerel ?stbi__paeth@@YAHHHH@Z+157
	DD	imagerel $unwind$?stbi__paeth@@YAHHHH@Z
$pdata$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
	DD	imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z+5648
	DD	imagerel $unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
$pdata$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1204
	DD	imagerel $unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
$pdata$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z DD imagerel ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z
	DD	imagerel ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z+397
	DD	imagerel $unwind$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z
$pdata$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
	DD	imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z+554
	DD	imagerel $unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
$pdata$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+647
	DD	imagerel $unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
$pdata$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
	DD	imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z+2601
	DD	imagerel $unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
$pdata$?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z DD imagerel ?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z
	DD	imagerel ?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z+372
	DD	imagerel $unwind$?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z
$pdata$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z DD imagerel ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z
	DD	imagerel ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z+150
	DD	imagerel $unwind$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z
$pdata$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z+180
	DD	imagerel $unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__high_bit@@YAHI@Z DD imagerel ?stbi__high_bit@@YAHI@Z
	DD	imagerel ?stbi__high_bit@@YAHI@Z+179
	DD	imagerel $unwind$?stbi__high_bit@@YAHI@Z
$pdata$?stbi__shiftsigned@@YAHHHH@Z DD imagerel ?stbi__shiftsigned@@YAHHHH@Z
	DD	imagerel ?stbi__shiftsigned@@YAHHHH@Z+139
	DD	imagerel $unwind$?stbi__shiftsigned@@YAHHHH@Z
$pdata$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
	DD	imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z+88
	DD	imagerel $unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
$pdata$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+109
	DD	imagerel $unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
	DD	imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z+132
	DD	imagerel $unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
$pdata$?stbi__copyval@@YAXHPEAEPEBE@Z DD imagerel ?stbi__copyval@@YAXHPEAEPEBE@Z
	DD	imagerel ?stbi__copyval@@YAXHPEAEPEBE@Z+108
	DD	imagerel $unwind$?stbi__copyval@@YAXHPEAEPEBE@Z
$pdata$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
	DD	imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z+1251
	DD	imagerel $unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
$pdata$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z+152
	DD	imagerel $unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+235
	DD	imagerel $unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
$pdata$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+414
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
$pdata$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z+183
	DD	imagerel $unwind$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
	DD	imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z+628
	DD	imagerel $unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
$pdata$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
	DD	imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z+953
	DD	imagerel $unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
$pdata$?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z DD imagerel ?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z
	DD	imagerel ?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z+294
	DD	imagerel $unwind$?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z
$pdata$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+2001
	DD	imagerel $unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
$pdata$?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z+106
	DD	imagerel $unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z+179
	DD	imagerel $unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
$pdata$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z
	DD	imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z+604
	DD	imagerel $unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z
$pdata$?stbi__pnm_isspace@@YAHD@Z DD imagerel ?stbi__pnm_isspace@@YAHD@Z
	DD	imagerel ?stbi__pnm_isspace@@YAHD@Z+92
	DD	imagerel $unwind$?stbi__pnm_isspace@@YAHD@Z
$pdata$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z+69
	DD	imagerel $unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
$pdata$?stbi__pnm_isdigit@@YAHD@Z DD imagerel ?stbi__pnm_isdigit@@YAHD@Z
	DD	imagerel ?stbi__pnm_isdigit@@YAHD@Z+52
	DD	imagerel $unwind$?stbi__pnm_isdigit@@YAHD@Z
$pdata$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z+102
	DD	imagerel $unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
$pdata$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z+370
	DD	imagerel $unwind$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$delegate@$$A6AXXZ@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??0?$delegate@$$A6AXXZ@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$delegate@$$A6AXXZ@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1?$delegate@$$A6AXXZ@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$delegate@$$A6AXXZ@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+129
	DD	imagerel $unwind$??R?$delegate@$$A6AXXZ@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA DD imagerel ?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA
	DD	imagerel ?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA+27
	DD	imagerel $unwind$?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+34
	DD	imagerel $unwind$??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+34
	DD	imagerel $unwind$??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+34
	DD	imagerel $unwind$??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+34
	DD	imagerel $unwind$??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+34
	DD	imagerel $unwind$??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD imagerel ??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
	DD	imagerel ??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ DD imagerel ??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ
	DD	imagerel ??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ+34
	DD	imagerel $unwind$??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ DD imagerel ??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ
	DD	imagerel ??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+212
	DD	imagerel $unwind$?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+215
	DD	imagerel $unwind$?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z DD imagerel $LN19
	DD	imagerel $LN19+744
	DD	imagerel $unwind$?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ DD imagerel ??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ
	DD	imagerel ??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ+34
	DD	imagerel $unwind$??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ DD imagerel ??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ
	DD	imagerel ??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z DD imagerel $LN10
	DD	imagerel $LN10+71
	DD	imagerel $unwind$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA DD imagerel ?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
	DD	imagerel ?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA+167
	DD	imagerel $unwind$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
$pdata$?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA DD imagerel ?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z DD imagerel $LN4
	DD	imagerel $LN4+104
	DD	imagerel $unwind$??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+248
	DD	imagerel $unwind$?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+205
	DD	imagerel $unwind$?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@H@std@@QEBA_NAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??R?$equal_to@H@std@@QEBA_NAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN26
	DD	imagerel $LN26+783
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+195
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z DD imagerel $LN8
	DD	imagerel $LN8+335
	DD	imagerel $unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+205
	DD	imagerel $unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+870
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ DD imagerel ??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ
	DD	imagerel ??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ+22
	DD	imagerel $unwind$??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z DD imagerel $LN6
	DD	imagerel $LN6+565
	DD	imagerel $unwind$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA DD imagerel ?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA
	DD	imagerel ?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z DD imagerel $LN5
	DD	imagerel $LN5+444
	DD	imagerel $unwind$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA DD imagerel ?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Hash_representation@H@std@@YA_KAEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$_Hash_representation@H@std@@YA_KAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z DD imagerel $LN3
	DD	imagerel $LN3+176
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z DD imagerel $LN8
	DD	imagerel $LN8+653
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z DD imagerel $LN7
	DD	imagerel $LN7+282
	DD	imagerel $unwind$??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z DD imagerel $LN5
	DD	imagerel $LN5+124
	DD	imagerel $unwind$??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+287
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+164
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+195
	DD	imagerel $unwind$??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@5f000000
CONST	SEGMENT
__real@5f000000 DD 05f000000r			; 9.22337e+18
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
CONST	ENDS
;	COMDAT __real@41a80000
CONST	SEGMENT
__real@41a80000 DD 041a80000r			; 21
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41600000
CONST	SEGMENT
__real@41600000 DD 041600000r			; 14
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ae148
CONST	SEGMENT
__real@3f7ae148 DD 03f7ae148r			; 0.98
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f6b851f
CONST	SEGMENT
__real@3f6b851f DD 03f6b851fr			; 0.92
CONST	ENDS
;	COMDAT __real@3f68f5c3
CONST	SEGMENT
__real@3f68f5c3 DD 03f68f5c3r			; 0.91
CONST	ENDS
;	COMDAT __real@3f6147ae
CONST	SEGMENT
__real@3f6147ae DD 03f6147aer			; 0.88
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3edc28f6
CONST	SEGMENT
__real@3edc28f6 DD 03edc28f6r			; 0.43
CONST	ENDS
;	COMDAT __real@3e947ae1
CONST	SEGMENT
__real@3e947ae1 DD 03e947ae1r			; 0.29
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e75c28f
CONST	SEGMENT
__real@3e75c28f DD 03e75c28fr			; 0.24
CONST	ENDS
;	COMDAT __real@3e6b851f
CONST	SEGMENT
__real@3e6b851f DD 03e6b851fr			; 0.23
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ DB 'unordered_map/set t'
	DB	'oo long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@EFNFJFIJ@Cannot?5find?5TTC?5font?5file?5?$CCmsyh@
CONST	SEGMENT
??_C@_0FN@EFNFJFIJ@Cannot?5find?5TTC?5font?5file?5?$CCmsyh@ DB 'Cannot fi'
	DB	'nd TTC font file "msyh.ttc" in configured font directories.', 0dH
	DB	0aH, 'Click OK to terminate.', 00H		; `string'
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_C@_0BF@JMJNPNKE@RenderTarget?5Failed?$CB@
CONST	SEGMENT
??_C@_0BF@JMJNPNKE@RenderTarget?5Failed?$CB@ DB 'RenderTarget Failed!', 00H ; `string'
CONST	ENDS
;	COMDAT _GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
CONST	SEGMENT
_GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c DD 06f15aaf2H
	DW	0d208H
	DW	04e89H
	DB	09aH
	DB	0b4H
	DB	048H
	DB	095H
	DB	035H
	DB	0d3H
	DB	04fH
	DB	09cH
CONST	ENDS
;	COMDAT ??_C@_0CF@JAIMGOII@Error?5D3D11CreateDeviceAndSwapC@
CONST	SEGMENT
??_C@_0CF@JAIMGOII@Error?5D3D11CreateDeviceAndSwapC@ DB 'Error D3D11Creat'
	DB	'eDeviceAndSwapChain!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR@ DB 'ERROR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IEELADJB@?$AAo?$AAb?$AAs?$AA6?$AA4@
CONST	SEGMENT
??_C@_1M@IEELADJB@?$AAo?$AAb?$AAs?$AA6?$AA4@ DB 'o', 00H, 'b', 00H, 's', 00H
	DB	'6', 00H, '4', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@ILCHKGLN@?$AAQ?$AAt?$AA5?$AAQ?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAI?$AAc?$AAo?$AAn@
CONST	SEGMENT
??_C@_1BO@ILCHKGLN@?$AAQ?$AAt?$AA5?$AAQ?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAI?$AAc?$AAo?$AAn@ DB 'Q'
	DB	00H, 't', 00H, '5', 00H, 'Q', 00H, 'W', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 'o', 00H, 'w', 00H, 'I', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PFOBBMC@ImGui?g?$LL?$JI?e?$II?$LG?e?$IK?$KA?h?$LN?$LN?e?$KE?$LB?h?$LE?$KF?$CB@
CONST	SEGMENT
??_C@_0BJ@PFOBBMC@ImGui?g?$LL?$JI?e?$II?$LG?e?$IK?$KA?h?$LN?$LN?e?$KE?$LB?h?$LE?$KF?$CB@ DB 'I'
	DB	'mGui', 0e7H, 0bbH, 098H, 0e5H, 088H, 0b6H, 0e5H, 08aH, 0a0H, 0e8H
	DB	0bdH, 0bdH, 0e5H, 0a4H, 0b1H, 0e8H, 0b4H, 0a5H, '!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03FOKDFDHG@?$CLX?5@
CONST	SEGMENT
??_C@_03FOKDFDHG@?$CLX?5@ DB '+X ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKAKGGJN@?9Y?5@
CONST	SEGMENT
??_C@_03HKAKGGJN@?9Y?5@ DB '-Y ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
CONST	SEGMENT
??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@ DB 'FORMAT=32-bit_rle_rgbe'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
CONST	SEGMENT
??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@ DB '#?RADIANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
CONST	SEGMENT
??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@ DB '#?RADIANCE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELNJHLFH@PICT@
CONST	SEGMENT
??_C@_04ELNJHLFH@PICT@ DB 'PICT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBFEPHFH@S?$IA?v4@
CONST	SEGMENT
??_C@_04KBFEPHFH@S?$IA?v4@ DB 'S', 080H, 0f6H, '4', 00H	; `string'
CONST	ENDS
;	COMDAT ?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4PAEA
_DATA	SEGMENT
?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4PAEA DB 089H ; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
_DATA	ENDS
;	COMDAT ?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4PAEA
_DATA	SEGMENT
?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4PAEA DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
_DATA	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A DQ FLAT:?stbi__stdio_read@@YAHPEAXPEADH@Z ; stbi__stdio_callbacks
	DQ	FLAT:?stbi__stdio_skip@@YAXPEAXH@Z
	DQ	FLAT:?stbi__stdio_eof@@YAHPEAX@Z
?stbi__h2l_gamma_i@@3MA DD 03ee8ba2er		; 0.454545 ; stbi__h2l_gamma_i
?stbi__h2l_scale_i@@3MA DD 03f800000r		; 1	; stbi__h2l_scale_i
?stbi__l2h_gamma@@3MA DD 0400ccccdr		; 2.2	; stbi__l2h_gamma
?stbi__l2h_scale@@3MA DD 03f800000r		; 1	; stbi__l2h_scale
?first_row_filter@@3PAEA DB 00H				; first_row_filter
	DB	01H
	DB	00H
	DB	05H
	DB	06H
	ORG $+3
?stbi__bmask@@3PAIA DD 00H				; stbi__bmask
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
	ORG $+12
?stbi__jpeg_dezigzag@@3PAEA DB 00H			; stbi__jpeg_dezigzag
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
?stbi__zlength_base@@3PAHA DD 03H			; stbi__zlength_base
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zlength_extra@@3PAHA DD 00H			; stbi__zlength_extra
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zdist_base@@3PAHA DD 01H				; stbi__zdist_base
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
?stbi__zdist_extra@@3PAHA DD 00H			; stbi__zdist_extra
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
?stbi__depth_scale_table@@3PAEA DB 00H			; stbi__depth_scale_table
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
_DATA	ENDS
;	COMDAT ??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
CONST	SEGMENT
??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ DB '['
	DB	0e8H, 0beH, 093H, 0e5H, 087H, 0baH, 0e4H, 0bfH, 0a1H, 0e6H, 081H
	DB	0afH, '] %s', 00H				; `string'
CONST	ENDS
;	COMDAT ?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A
_DATA	SEGMENT
?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A DQ 0000000000000000H ; IronMan::DMAHandler::ScatterReadArray
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A
_DATA	SEGMENT
?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A DQ 0000000000000000H ; IronMan::DMAHandler::ScatterWriteArray
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
	DD	imagerel $ip2state$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 011811H
	DD	04218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z DD 021811H
	DD	070147218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z DB 040H
	DD	imagerel $ip2state$??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DB 06H
	DB	00H
	DB	00H
	DB	096H
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	0b5H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DD 011811H
	DD	0c218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	0fcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z DD 031501H
	DD	07011c215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z DB 06H
	DB	00H
	DB	00H
	DB	0c1H, 04H
	DB	02H
	DB	01H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	0d2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z
	DD	imagerel $ip2state$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	086H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Hash_representation@H@std@@YA_KAEBH@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z DB 06H
	DB	00H
	DB	00H
	DB	0ddH, 04H
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z
	DD	imagerel $ip2state$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z DD 041811H
	DD	0190118H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DB 040H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z DB 06H
	DB	00H
	DB	00H
	DB	0edH, 04H
	DB	02H
	DB	'i', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z DB 08H
	DD	imagerel $stateUnwindMap$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z
	DD	imagerel $ip2state$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z DD 041d11H
	DD	019011dH
	DD	060157016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 06H
	DB	00H
	DB	00H
	DB	089H, 04H
	DB	02H
	DB	0c5H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
	DD	imagerel $ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021111H
	DD	0150111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 040H
	DD	imagerel $ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 040H
	DD	imagerel $ip2state$?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z DB 0eH
	DB	00H
	DB	00H
	DB	0f2H
	DB	02H
	DB	')', 04H
	DB	00H
	DB	'.'
	DB	02H
	DB	'Y', 04H
	DB	00H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z DB 048H
	DD	imagerel $stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z
	DD	imagerel $ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021611H
	DD	0170116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'<'
	DB	04H
	DB	0dcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@H@std@@QEBA_NAEBH0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
	DD	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
	DD	imagerel $ip2state$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
	DD	imagerel $ip2state$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R?$delegate@$$A6AXXZ@@QEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	0caH
	DB	02H
	DB	'&'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??R?$delegate@$$A6AXXZ@@QEAAXXZ DB 02H
	DB	00H
	DD	imagerel ?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??R?$delegate@$$A6AXXZ@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??R?$delegate@$$A6AXXZ@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R?$delegate@$$A6AXXZ@@QEAAXXZ DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R?$delegate@$$A6AXXZ@@QEAAXXZ DB 018H
	DD	imagerel $stateUnwindMap$??R?$delegate@$$A6AXXZ@@QEAAXXZ
	DD	imagerel $tryMap$??R?$delegate@$$A6AXXZ@@QEAAXXZ
	DD	imagerel $ip2state$??R?$delegate@$$A6AXXZ@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$delegate@$$A6AXXZ@@QEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R?$delegate@$$A6AXXZ@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$delegate@$$A6AXXZ@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$delegate@$$A6AXXZ@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$delegate@$$A6AXXZ@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$delegate@$$A6AXXZ@@QEAA@XZ
	DD	imagerel $ip2state$??1?$delegate@$$A6AXXZ@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$delegate@$$A6AXXZ@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$delegate@$$A6AXXZ@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$delegate@$$A6AXXZ@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$delegate@$$A6AXXZ@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$delegate@$$A6AXXZ@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$delegate@$$A6AXXZ@@QEAA@XZ
	DD	imagerel $ip2state$??0?$delegate@$$A6AXXZ@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$delegate@$$A6AXXZ@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$delegate@$$A6AXXZ@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ENAME_None@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$less@H@std@@QEBA_NAEBH0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 06H
	DB	00H
	DB	00H
	DB	':'
	DB	02H
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 08H
	DD	imagerel $stateUnwindMap$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel $ip2state$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD 020611H
	DD	070023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1BaseProcessInfo@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1BaseProcessInfo@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1BaseProcessInfo@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1BaseProcessInfo@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 010901H
	DD	06209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ThreadInitGui@Core@IronMan@@YAKPEAX@Z
	DD	013H
	DD	035H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z
	DD	02bH
	DD	09fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
	DD	024H
	DD	04cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
	DD	01fH
	DD	0a11H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	025H
	DD	049cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
	DD	016H
	DD	02e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z
	DD	020H
	DD	0355H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	026H
	DD	0865H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
	DD	01aH
	DD	043bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
	DD	016H
	DD	0c61H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__idct_block@@YAXPEAEHQEAF@Z
	DD	01fH
	DD	0a77H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	02bH
	DD	0108H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	022H
	DD	0233H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	025H
	DD	01cfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z
	DD	025H
	DD	05b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	025H
	DD	01043H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	02bH
	DD	062H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	02bH
	DD	077H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
	DD	01cH
	DD	05fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_noheader_buffer
	DD	02aH
	DD	09cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_noheader_malloc
	DD	025H
	DD	0d4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_buffer
	DD	02aH
	DD	09cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_malloc_guesssize_headerflag
	DD	02aH
	DD	0e4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_zlib_decode_malloc_guesssize
	DD	02aH
	DD	0e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_file
	DD	025H
	DD	08eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_callbacks
	DD	025H
	DD	069H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_info_from_memory
	DD	024H
	DD	068H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_file
	DD	016H
	DD	03aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_memory
	DD	01aH
	DD	046H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_is_hdr_from_callbacks
	DD	01bH
	DD	047H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_file
	DD	025H
	DD	06cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_callbacks
	DD	025H
	DD	074H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_loadf_from_memory
	DD	024H
	DD	073H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_file
	DD	025H
	DD	0acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_callbacks
	DD	025H
	DD	074H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:stbi_load_from_memory
	DD	024H
	DD	073H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ
	DD	014H
	DD	012d6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ
	DD	013H
	DD	0179H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ
	DD	013H
	DD	0260H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CreateTexture@OverlayEngine@Core@IronMan@@SAPEAXPEBD_K@Z
	DD	01cH
	DD	01e4H
voltbl	ENDS
xdata	SEGMENT
$unwind$?Initialize@OverlayEngine@Core@IronMan@@SA_NXZ DD 010401H
	DD	04204H
$unwind$?InitWindow@OverlayEngine@Core@IronMan@@SAXXZ DD 010401H
	DD	04204H
$unwind$?HideWindow@OverlayEngine@Core@IronMan@@SAXXZ DD 010401H
	DD	04204H
$unwind$?Start@OverlayEngine@Core@IronMan@@SAXXZ DD 010401H
	DD	04204H
$unwind$?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ DD 010401H
	DD	04204H
$unwind$?Transparent@OverlayEngine@Core@IronMan@@SAXXZ DD 010401H
	DD	04204H
$unwind$?UnTransparent@OverlayEngine@Core@IronMan@@SAXXZ DD 010401H
	DD	04204H
$unwind$?GetKeyState@OverlayEngine@Core@IronMan@@SAFI@Z DD 010801H
	DD	04208H
$unwind$?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z DD 010801H
	DD	06208H
$unwind$?WasKeyPressed@OverlayEngine@Core@IronMan@@SA_NI@Z DD 010801H
	DD	06208H
$unwind$?UpdateKeyState@OverlayEngine@Core@IronMan@@SAXXZ DD 010401H
	DD	06204H
$unwind$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z DD 010d11H
	DD	0820dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z
$cppxdata$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z
	DD	imagerel $ip2state$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z
$stateUnwindMap$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA
$ip2state$?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z DB 06H
	DB	00H
	DB	00H
	DB	01aH
	DB	02H
	DB	'p'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?RemoveHotkey@OverlayEngine@Core@IronMan@@SAXI@Z DD 010801H
	DD	06208H
$unwind$?ActiveWindow@OverlayEngine@Core@IronMan@@SAXPEAUHWND__@@@Z DD 010901H
	DD	06209H
$unwind$?CreateTexture@OverlayEngine@Core@IronMan@@SAPEAXPEBD_K@Z DD 032419H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$?GetViewPort@OverlayEngine@Core@IronMan@@SA?AUImVec2@@XZ DD 010901H
	DD	04209H
$unwind$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ DD 020711H
	DD	0110107H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ
$cppxdata$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ DB 08H
	DD	imagerel $stateUnwindMap$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ
	DD	imagerel $ip2state$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ
$stateUnwindMap$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA
$ip2state$?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ DB 06H
	DB	00H
	DB	00H
	DB	082H
	DB	02H
	DB	'2'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA DD 020601H
	DD	050023206H
$unwind$?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ DD 031b19H
	DD	02c0109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ DD 031b19H
	DD	01c0109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ DD 041c19H
	DD	0c9010aH
	DD	060027003H
	DD	imagerel __GSHandlerCheck
	DD	0630H
$unwind$?Update@OverlayEngine@Core@IronMan@@CAXXZ DD 010401H
	DD	06204H
$unwind$?Render@OverlayEngine@Core@IronMan@@CAXXZ DD 010401H
	DD	0c204H
$unwind$?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ DD 010401H
	DD	08204H
$unwind$?CleanupRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ DD 010401H
	DD	04204H
$unwind$?WindowProc@OverlayEngine@Core@IronMan@@CA_JPEAUHWND__@@I_K_J@Z DD 021a01H
	DD	013011aH
$unwind$?ProcessMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z DD 011201H
	DD	06212H
$unwind$?ProcessMouseMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z DD 011201H
	DD	04212H
$unwind$?ProcessKeybdMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z DD 011201H
	DD	0c212H
$unwind$stbi_load DD 011801H
	DD	08218H
$unwind$stbi_load_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_from_file DD 022d19H
	DD	027011bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_loadf DD 011801H
	DD	08218H
$unwind$stbi_loadf_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_loadf_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_loadf_from_file DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_is_hdr_from_callbacks DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_hdr_from_memory DD 022219H
	DD	0230110H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_hdr DD 010901H
	DD	06209H
$unwind$stbi_is_hdr_from_file DD 021e19H
	DD	023010cH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_image_free DD 010901H
	DD	04209H
$unwind$stbi_info_from_memory DD 022c19H
	DD	023011aH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_info_from_callbacks DD 022d19H
	DD	023011bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_info DD 011801H
	DD	06218H
$unwind$stbi_info_from_file DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_zlib_decode_malloc_guesssize DD 023219H
	DD	020b0120H
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$stbi_zlib_decode_malloc_guesssize_headerflag DD 023219H
	DD	020b0120H
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$stbi_zlib_decode_malloc DD 011201H
	DD	04212H
$unwind$stbi_zlib_decode_buffer DD 023219H
	DD	02090120H
	DD	imagerel __GSHandlerCheck
	DD	01030H
$unwind$stbi_zlib_decode_noheader_malloc DD 022d19H
	DD	020b011bH
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$stbi_zlib_decode_noheader_buffer DD 023219H
	DD	02090120H
	DD	imagerel __GSHandlerCheck
	DD	01030H
$unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z DD 011301H
	DD	02213H
$unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD 031501H
	DD	070114215H
	DD	06010H
$unwind$?stbi__stdio_read@@YAHPEAXPEADH@Z DD 011301H
	DD	04213H
$unwind$?stbi__stdio_skip@@YAXPEAXH@Z DD 010d01H
	DD	0420dH
$unwind$?stbi__stdio_eof@@YAHPEAX@Z DD 010901H
	DD	04209H
$unwind$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z DD 010e01H
	DD	0420eH
$unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD 022419H
	DD	08f90112H
	DD	imagerel __GSHandlerCheck
	DD	047b0H
$unwind$?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 023319H
	DD	08f90121H
	DD	imagerel __GSHandlerCheck
	DD	047b0H
$unwind$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z DD 023319H
	DD	08f70121H
	DD	imagerel __GSHandlerCheck
	DD	047a0H
$unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 011801H
	DD	0a218H
$unwind$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	08218H
$unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 022d19H
	DD	0a1011bH
	DD	imagerel __GSHandlerCheck
	DD	04f0H
$unwind$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 021b01H
	DD	01b011bH
$unwind$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 021b01H
	DD	011011bH
$unwind$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD 022d19H
	DD	093011bH
	DD	imagerel __GSHandlerCheck
	DD	0480H
$unwind$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z DD 022d19H
	DD	089011bH
	DD	imagerel __GSHandlerCheck
	DD	0430H
$unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 011801H
	DD	0a218H
$unwind$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z DD 012719H
	DD	0e218H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 023319H
	DD	09170121H
	DD	imagerel __GSHandlerCheck
	DD	048a0H
$unwind$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 011801H
	DD	08218H
$unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__malloc@@YAPEAX_K@Z DD 010901H
	DD	04209H
$unwind$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 011801H
	DD	08218H
$unwind$?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 011801H
	DD	0c218H
$unwind$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z DD 011801H
	DD	04218H
$unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD 011801H
	DD	0a218H
$unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__skip@@YAXPEAUstbi__context@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD 011301H
	DD	08213H
$unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 011701H
	DD	0c217H
$unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD 010e01H
	DD	0a20eH
$unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD 010e01H
	DD	0a20eH
$unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z DD 011801H
	DD	0c218H
$unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD 011801H
	DD	08218H
$unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD 021b01H
	DD	015011bH
$unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z DD 022719H
	DD	0390115H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	02209H
$unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD 021e19H
	DD	041010cH
	DD	imagerel __GSHandlerCheck
	DD	01f0H
$unwind$?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z DD 010e01H
	DD	0220eH
$unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	0a209H
$unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD 022219H
	DD	0190110H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0a20dH
$unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD 011801H
	DD	04218H
$unwind$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 032e19H
	DD	036011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__bit_reverse@@YAHHH@Z DD 010c01H
	DD	0420cH
$unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z DD 022819H
	DD	01d0116H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z DD 010901H
	DD	02209H
$unwind$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD 011301H
	DD	06213H
$unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD 021e19H
	DD	0149010cH
	DD	imagerel __GSHandlerCheck
	DD	0a30H
$unwind$?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__init_zdefaults@@YAXXZ DD 010401H
	DD	02204H
$unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z DD 011801H
	DD	04218H
$unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__paeth@@YAHHHH@Z DD 011101H
	DD	06211H
$unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD 021b01H
	DD	017011bH
$unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 022d19H
	DD	021011bH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z DD 011301H
	DD	04213H
$unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD 011801H
	DD	0a218H
$unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD 010901H
	DD	04209H
$unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD 022719H
	DD	09b0115H
	DD	imagerel __GSHandlerCheck
	DD	04c0H
$unwind$?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z DD 011801H
	DD	08218H
$unwind$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__high_bit@@YAHI@Z DD 010801H
	DD	02208H
$unwind$?stbi__shiftsigned@@YAHHHH@Z DD 011101H
	DD	02211H
$unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD 011201H
	DD	06212H
$unwind$?stbi__copyval@@YAXHPEAEPEBE@Z DD 011201H
	DD	02212H
$unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD 022c19H
	DD	019011aH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD 011801H
	DD	06218H
$unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 011801H
	DD	06218H
$unwind$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z DD 023319H
	DD	09130121H
	DD	imagerel __GSHandlerCheck
	DD	04880H
$unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD 010e01H
	DD	0e20eH
$unwind$?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z DD 011701H
	DD	04217H
$unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 021b01H
	DD	011011bH
$unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD 011301H
	DD	06213H
$unwind$?stbi__pnm_isspace@@YAHD@Z DD 010801H
	DD	02208H
$unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0420eH
$unwind$?stbi__pnm_isdigit@@YAHD@Z DD 010801H
	DD	02208H
$unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z
	DD	05bH
$cppxdata$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z DB 018H
	DD	imagerel $stateUnwindMap$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z
	DD	imagerel $tryMap$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z
	DD	imagerel $ip2state$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z
$stateUnwindMap$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z DB 04H
	DB	08H
	DB	016H
	DD	imagerel ?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
$tryMap$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z
$handlerMap$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z DB 02H
	DB	00H
	DD	imagerel ?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
$ip2state$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z DB 06H
	DB	00H
	DB	00H
	DB	'D'
	DB	02H
	DB	0aH
	DB	00H
	ORG $+3
$unwind$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
$cppxdata$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA DB 09H
	DD	imagerel $stateUnwindMap$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
	DD	imagerel $ip2state$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
	DB	'p'
$stateUnwindMap$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA DB 04H
	DB	08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA
$ip2state$?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA DB 0aH
	DB	00H
	DB	02H
	DB	01aH
	DB	02H
	DB	0a8H
	DB	04H
	DB	'$'
	DB	02H
	DB	'L'
	DB	02H
$unwind$?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??BImColor@@QEBA?AUImVec4@@XZ DD 020c01H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImColor@@QEAA@HHHH@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD 011c01H
	DD	0221cH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	062H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD 012519H
	DD	06216H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$function@$$A6AXXZ@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$function@$$A6AXXZ@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$function@$$A6AXXZ@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$function@$$A6AXXZ@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$function@$$A6AXXZ@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$function@$$A6AXXZ@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$function@$$A6AXXZ@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$function@$$A6AXXZ@std@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z
	DD	imagerel $ip2state$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Func_class@X$$V@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Func_class@X$$V@std@@QEBAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Func_class@X$$V@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_tree_length_error@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Do_hash@?$hash@H@std@@SA_KAEBH@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ceiling_of_log_2@std@@YAK_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Floor_of_log_2@std@@YAK_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?pow@@YAMMM@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?pow@@YAMMM@Z DB 040H
	DD	imagerel $ip2state$?pow@@YAMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pow@@YAMMM@Z DD 011019H
	DD	04210H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?pow@@YAMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ldexp@@YAMMH@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ldexp@@YAMMH@Z DB 040H
	DD	imagerel $ip2state$?ldexp@@YAMMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ldexp@@YAMMH@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ldexp@@YAMMH@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decwref@_Ref_count_base@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ldexpf DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?XYZMask$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EXYZMask@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::XYZMask$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?QINV_SIGN_MASK$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::QINV_SIGN_MASK$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??UpdateStartTime$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ ; IronMan::DMAHandler::pdateStartTime$initializer$::operator|
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ScatterWriteArray$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; IronMan::DMAHandler::catterWriteArray$initializer$::operator~
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ScatterReadArray$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; IronMan::DMAHandler::catterReadArray$initializer$::operator~
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??processInfo$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ; ??processInfo$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
CRT$XCU	SEGMENT
	ORG $-32
?NAME_None$initializer$@SDK@Core@IronMan@@3P6AXXZEA DQ FLAT:??__ENAME_None@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::NAME_None$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??OnUpdate$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; IronMan::Core::OverlayEngine::nUpdate$initializer$::operator>
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??OnTick$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; IronMan::Core::OverlayEngine::nTick$initializer$::operator>
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??OnPrePresent$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; IronMan::Core::OverlayEngine::nPrePresent$initializer$::operator>
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??OnPresent$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; IronMan::Core::OverlayEngine::nPresent$initializer$::operator>
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??OnPostPresent$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; IronMan::Core::OverlayEngine::nPostPresent$initializer$::operator>
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??OnWndProc$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ ; IronMan::Core::OverlayEngine::nWndProc$initializer$::operator>
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??mHotkeys$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ ; ??mHotkeys$initializer$@OverlayEngine@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z PROC ; std::_Tuple_get<0,int &&>, COMDAT

; 925  : _NODISCARD constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 926  :     // used by pair's piecewise constructor
; 927  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 928  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 929  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR _Tuple$[rsp]
	mov	rax, QWORD PTR [rax]

; 930  : }

	ret	0
??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z ENDP ; std::_Tuple_get<0,int &&>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z PROC ; std::move<std::tuple<int &&> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ENDP ; std::move<std::tuple<int &&> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
__formal$ = 72
__formal$ = 80
??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><std::tuple<int &&>,std::tuple<>,0>, COMDAT

; 478  :         : first(_STD _Tuple_get<_Indices1>(_STD move(_Val1))...),

$LN4:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ; std::move<std::tuple<int &&> &>
	mov	rcx, rax
	call	??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z ; std::_Tuple_get<0,int &&>
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 479  :           second(_STD _Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><std::tuple<int &&>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
__formal$ = 72
__formal$ = 80
?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA PROC ; `std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><std::tuple<int &&>,std::tuple<>,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA ENDP ; `std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><std::tuple<int &&>,std::tuple<>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z
_TEXT	SEGMENT
this$ = 48
_Arg$ = 56
??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z PROC	; std::_Tuple_val<int &&>::_Tuple_val<int &&><int>, COMDAT

; 132  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Arg$[rsp]
	call	??$forward@H@std@@YA$$QEAHAEAH@Z	; std::forward<int>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z ENDP	; std::_Tuple_val<int &&>::_Tuple_val<int &&><int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT

; 235  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> >, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 64					; 00000040H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::forward<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
this$ = 80
__formal$ = 88
_Val1$ = 96
_Val2$ = 104
??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z PROC ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><int &&>, COMDAT

; 331  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	eax, BYTE PTR $T1[rsp]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, BYTE PTR $T2[rsp]
	mov	r8, QWORD PTR _Val2$[rsp]
	mov	rdx, QWORD PTR _Val1$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><std::tuple<int &&>,std::tuple<>,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><int &&>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 49
this$ = 80
__formal$ = 88
_Val1$ = 96
_Val2$ = 104
?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA PROC ; `std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><int &&>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z@4HA ENDP ; `std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><int &&>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z
_TEXT	SEGMENT
$T1 = 32
tv77 = 40
this$ = 64
__formal$ = 72
_This_arg$ = 80
??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z PROC ; std::tuple<int &&>::tuple<int &&><std::_Exact_args_t,int,0>, COMDAT

; 301  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _This_arg$[rsp]
	call	??$forward@H@std@@YA$$QEAHAEAH@Z	; std::forward<int>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z ; std::_Tuple_val<int &&>::_Tuple_val<int &&><int>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z ENDP ; std::tuple<int &&>::tuple<int &&><std::_Exact_args_t,int,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back<std::function<void __cdecl(void)> >, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::forward<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@V?$function@$$A6AXXZ@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> >

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::~_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::~_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@PEAV?$function@$$A6AXXZ@1@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@PEAV?$function@$$A6AXXZ@1@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@PEAV?$function@$$A6AXXZ@1@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAV?$function@$$A6AXXZ@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAV?$function@$$A6AXXZ@0@@Z PROC ; std::_Get_unwrapped<std::function<void __cdecl(void)> * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAV?$function@$$A6AXXZ@0@@Z ENDP ; std::_Get_unwrapped<std::function<void __cdecl(void)> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z PROC ; std::pair<int const ,bool>::pair<int const ,bool><int const &,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBH@std@@YAAEBHAEBH@Z	; std::forward<int const &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+4], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z ENDP ; std::pair<int const ,bool>::pair<int const ,bool><int const &,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::destroy<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::destroy<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@YAPEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@YAPEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@0@AEAV10@@Z PROC ; std::addressof<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@YAPEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@0@AEAV10@@Z ENDP ; std::addressof<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 379  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 380  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 381  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::destroy<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >

; 382  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1

; 383  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 40
$T6 = 48
tv128 = 56
tv93 = 64
$T7 = 72
$T8 = 80
__formal$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
<_Args_1>$ = 136
<_Args_2>$ = 144
??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::construct<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T7[rsp], rax
	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rcx, QWORD PTR <_Args_2>$[rsp]
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
	mov	rdx, rax
	mov	rcx, QWORD PTR $T5[rsp]
	call	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z	; std::tuple<>::tuple<>
	mov	QWORD PTR tv128[rsp], rax
	lea	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T6[rsp], rax
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	call	??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ; std::forward<std::tuple<int &&> >
	mov	rdx, rax
	mov	rcx, QWORD PTR $T6[rsp]
	call	??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z	; std::tuple<int &&>::tuple<int &&>
	mov	QWORD PTR tv93[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	movzx	eax, BYTE PTR $T1[rsp]
	mov	BYTE PTR $T2[rsp], al
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T3[rsp], al
	mov	r9, QWORD PTR tv128[rsp]
	mov	r8, QWORD PTR tv93[rsp]
	movzx	edx, BYTE PTR $T3[rsp]
	mov	rcx, QWORD PTR $T7[rsp]
	call	??$?0$$QEAH$$Z$$V@?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > ><int &&>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 104				; 00000068H
	ret	0
??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::construct<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z PROC ; std::forward<std::tuple<int &&> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ENDP ; std::forward<std::tuple<int &&> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv72 = 40
this$ = 64
_This_arg$ = 72
??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z PROC	; std::tuple<int &&>::tuple<int &&><int,0>, COMDAT

; 349  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _This_arg$[rsp]
	call	??$forward@H@std@@YA$$QEAHAEAH@Z	; std::forward<int>
	mov	QWORD PTR tv72[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv72[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z ; std::tuple<int &&>::tuple<int &&><std::_Exact_args_t,int,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z ENDP	; std::tuple<int &&>::tuple<int &&><int,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??$_Kfn@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z PROC ; std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0>::_Kfn<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >, COMDAT

; 66   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 67   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 68   :     }

	ret	0
??$_Kfn@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ENDP ; std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0>::_Kfn<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z PROC ; std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAV?$function@$$A6AXXZ@0@@Z ; std::_Get_unwrapped<std::function<void __cdecl(void)> * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$function@$$A6AXXZ@std@@@std@@YA?A_TAEBQEAV?$function@$$A6AXXZ@0@@Z ; std::_Get_unwrapped<std::function<void __cdecl(void)> * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@PEAV?$function@$$A6AXXZ@1@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >
	npad	1

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAV?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::move<std::function<void __cdecl(void)> &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@V?$function@$$A6AXXZ@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAX$$QEAV?$function@$$A6AXXZ@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back<std::function<void __cdecl(void)> >
	npad	1

; 1963 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1964 : 
; 1965 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::~_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >
	mov	rax, QWORD PTR $T1[rsp]

; 1966 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >::~_Uninitialized_backout_al<std::allocator<std::function<void __cdecl(void)> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv79 = 32
this$ = 64
??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :             if (_New_begin != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >

; 608  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::deallocate
	npad	1
$LN2@Reallocati:

; 609  :             }
; 610  :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 64					; 00000040H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z ; std::forward<std::function<void __cdecl(void)> const &>
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z
_TEXT	SEGMENT
tv81 = 32
tv79 = 40
$T1 = 48
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
<_Args_1>$ = 104
??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::construct<std::pair<int const ,bool>,int const &,bool>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBH@std@@YAAEBHAEBH@Z	; std::forward<int const &>
	mov	QWORD PTR tv79[rsp], rax
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEBH_N$0A@@?$pair@$$CBH_N@std@@QEAA@AEBH$$QEA_N@Z ; std::pair<int const ,bool>::pair<int const ,bool><int const &,bool,0>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::construct<std::pair<int const ,bool>,int const &,bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1017 :         ~_Range_eraser() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1018 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax], rcx

; 1019 :             _Next->_Prev        = _Predecessor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 1020 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldnext$ = 32
this$ = 64
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1010 :         void _Bump_erased() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1011 :             const auto _Oldnext = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldnext$[rsp], rax

; 1012 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rcx

; 1013 :             _Node::_Freenode(_List._Getal(), _Oldnext);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
	mov	rdx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, rax
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >

; 1014 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1015 :         }

	add	rsp, 56					; 00000038H
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1008 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _List_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z
_TEXT	SEGMENT
tv76 = 32
tv73 = 40
this$ = 64
_Keyval1$ = 72
_Keyval2$ = 80
??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>, COMDAT

; 155  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  :         // test if _Keyval1 NOT equal to _Keyval2
; 157  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEBAAEBU?$equal_to@H@2@XZ ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR _Keyval2$[rsp]
	mov	rdx, QWORD PTR _Keyval1$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??R?$equal_to@H@std@@QEBA_NAEBH0@Z	; std::equal_to<int>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv76[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv76[rsp]

; 158  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 484  :         ~_Clear_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 485  :             if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Clear_guar

; 486  :                 _Target->clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::clear
	npad	1
$LN2@Clear_guar:

; 487  :             }
; 488  :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 479  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Target_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<64>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 64		; 00000040H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,bool>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<int const ,bool>,void *> *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<int const ,bool>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBH_N@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@U?$pair@$$CBH_N@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::destroy<std::pair<int const ,bool> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();
; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	ret	0
??$destroy@U?$pair@$$CBH_N@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::destroy<std::pair<int const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::destroy<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::destroy<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<int const ,bool>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<int const ,bool>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z
_TEXT	SEGMENT
_Val$ = 48
_Keyval$ = 56
??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z PROC		; std::_Fnv1a_append_value<int>, COMDAT

; 2310 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2311 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2312 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	mov	r8d, 4
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	call	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ; std::_Fnv1a_append_bytes

; 2313 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z ENDP		; std::_Fnv1a_append_value<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::destroy<std::function<void __cdecl(void)> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::destroy<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z PROC ; std::addressof<std::function<void __cdecl(void)> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z ENDP ; std::addressof<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::function<void __cdecl(void)>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::function<void __cdecl(void)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::function<void __cdecl(void)>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::function<void __cdecl(void)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@YAPEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@0@AEAV10@@Z ; std::addressof<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@QEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::destroy<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z PROC ; std::forward<std::less<int> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z ENDP ; std::forward<std::less<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,bool>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,bool>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z ; std::addressof<std::pair<int const ,bool> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CBH_N@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::destroy<std::pair<int const ,bool> >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBH_N@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CBH_N@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > ><std::pair<int const ,bool> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CBH_N@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > ><std::pair<int const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1><std::allocator<std::pair<int const ,bool> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBH_N@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<int const ,bool> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CBH_N@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > ><std::pair<int const ,bool> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1><std::allocator<std::pair<int const ,bool> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBH_N@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBH_N@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<int const ,bool> > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBH_N@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<int const ,bool> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z PROC ; std::forward<std::function<void __cdecl(void)> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ENDP ; std::forward<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 370  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 371  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 372  :         _Destroy_in_place(_Ptr->_Left);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>

; 373  :         _Destroy_in_place(_Ptr->_Parent);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>

; 374  :         _Destroy_in_place(_Ptr->_Right);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>

; 375  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::deallocate
	npad	1

; 376  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
_Rootnode$ = 64
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 757  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
$LN2@Erase_tree:

; 758  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	mov	rax, QWORD PTR _Rootnode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN3@Erase_tree

; 759  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	rax, QWORD PTR _Rootnode$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >

; 760  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

	mov	rax, QWORD PTR _Rootnode$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Rootnode$[rsp]
	call	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1

; 761  :         }

	jmp	SHORT $LN2@Erase_tree
$LN3@Erase_tree:

; 762  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
tv141 = 48
tv139 = 56
tv137 = 64
tv135 = 72
tv133 = 80
this$ = 112
_Al_$ = 120
_Myhead$ = 128
<_Vals_0>$ = 136
<_Vals_1>$ = 144
<_Vals_2>$ = 152
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >, COMDAT

; 819  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1

; 820  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_2>$[rsp]
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ; std::forward<std::tuple<int &&> >
	mov	QWORD PTR tv139[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
	mov	QWORD PTR tv135[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv133[rsp], rax
	mov	rax, QWORD PTR tv141[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv139[rsp]
	mov	r8, QWORD PTR tv137[rsp]
	mov	rdx, QWORD PTR tv135[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	??$construct@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::construct<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >

; 821  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	lea	rdx, QWORD PTR _Myhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>

; 822  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	lea	rdx, QWORD PTR _Myhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>

; 823  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	lea	rdx, QWORD PTR _Myhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * &>

; 824  :         this->_Ptr->_Color = _Red;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 825  :         this->_Ptr->_Isnil = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+25], 0

; 826  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv141 = 48
tv139 = 56
tv137 = 64
tv135 = 72
tv133 = 80
this$ = 112
_Al_$ = 120
_Myhead$ = 128
<_Vals_0>$ = 136
<_Vals_1>$ = 144
<_Vals_2>$ = 152
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv146 = 32
tv144 = 40
this$ = 64
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 831  :     ~_Tree_temp_node() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 832  :         if (this->_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Tree_temp_

; 833  :             _Destroy_in_place(this->_Ptr->_Left);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>

; 834  :             _Destroy_in_place(this->_Ptr->_Parent);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>

; 835  :             _Destroy_in_place(this->_Ptr->_Right);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *>

; 836  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
	mov	QWORD PTR tv146[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv144[rsp], rax
	mov	rdx, QWORD PTR tv146[rsp]
	mov	rcx, QWORD PTR tv144[rsp]
	call	??$destroy@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::destroy<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
	npad	1
$LN2@Tree_temp_:

; 837  :         }
; 838  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv146 = 32
tv144 = 40
this$ = 64
?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 798  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1

; 799  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Allocate
	npad	1

; 800  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA PROC ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 1167 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1168 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Alloc_cons

; 1169 :             _Al.deallocate(_Ptr, 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, 1
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::deallocate
	npad	1
$LN2@Alloc_cons:

; 1170 :         }
; 1171 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 32
this$ = 64
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Allocate, COMDAT

; 1162 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1164 :         _Ptr = _Al.allocate(1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv73[rsp]
	call	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocate
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1165 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Release, COMDAT

; 1158 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1159 :         return _STD exchange(_Ptr, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::nullptr_t>

; 1160 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 1004 : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

	mov	QWORD PTR [rsp+8], rcx

; 1005 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1006 : }

	ret	0
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z PROC		; std::tuple<int &&>::tuple<int &&>, COMDAT

; 352  :     tuple(tuple&&)      = default;

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z	; std::tuple<>::tuple<>
	mov	rax, QWORD PTR __that$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z ENDP		; std::tuple<int &&>::tuple<int &&>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
<_Args_0>$ = 56
??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z PROC ; std::forward_as_tuple<int>, COMDAT

; 1004 : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1005 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@H@std@@YA$$QEAHAEAH@Z	; std::forward<int>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z ; std::tuple<int &&>::tuple<int &&><int,0>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1006 : }

	add	rsp, 40					; 00000028H
	ret	0
??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z ENDP ; std::forward_as_tuple<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z
_TEXT	SEGMENT
tv82 = 32
tv77 = 40
tv79 = 48
this$ = 80
_Bound$ = 88
_Keyval$ = 96
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Lower_bound_duplicate<int>, COMDAT

; 1613 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	mov	rax, QWORD PTR _Bound$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN3@Lower_boun
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getcomp
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Bound$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??$_Kfn@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0>::_Kfn<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv77[rsp]
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??R?$less@H@std@@QEBA_NAEBH0@Z		; std::less<int>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Lower_boun
	mov	DWORD PTR tv82[rsp], 1
	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:
	mov	DWORD PTR tv82[rsp], 0
$LN4@Lower_boun:
	movzx	eax, BYTE PTR tv82[rsp]

; 1615 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Lower_bound_duplicate<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z
_TEXT	SEGMENT
_Trynode$ = 32
_Scary$ = 40
tv82 = 48
tv84 = 56
_Result$ = 64
this$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find_lower_bound<int>, COMDAT

; 1618 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 1619 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1620 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Result$[rsp], rax
	mov	DWORD PTR _Result$[rsp+8], 0
	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp+16], rax

; 1621 :         _Nodeptr _Trynode = _Result._Location._Parent;

	mov	rax, QWORD PTR _Result$[rsp]
	mov	QWORD PTR _Trynode$[rsp], rax
$LN2@Find_lower:

; 1622 :         while (!_Trynode->_Isnil) {

	mov	rax, QWORD PTR _Trynode$[rsp]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	$LN3@Find_lower

; 1623 :             _Result._Location._Parent = _Trynode;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 1624 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getcomp
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Trynode$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??$_Kfn@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0>::_Kfn<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
	mov	QWORD PTR tv82[rsp], rax
	mov	r8, QWORD PTR _Keyval$[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	??R?$less@H@std@@QEBA_NAEBH0@Z		; std::less<int>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Find_lower

; 1625 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR _Result$[rsp+8], 0

; 1626 :                 _Trynode                 = _Trynode->_Right;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Trynode$[rsp], rax

; 1627 :             } else {

	jmp	SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1628 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR _Result$[rsp+8], 1

; 1629 :                 _Result._Bound           = _Trynode;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	QWORD PTR _Result$[rsp+16], rax

; 1630 :                 _Trynode                 = _Trynode->_Left;

	mov	rax, QWORD PTR _Trynode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Trynode$[rsp], rax
$LN5@Find_lower:

; 1631 :             }
; 1632 :         }

	jmp	$LN2@Find_lower
$LN3@Find_lower:

; 1633 : 
; 1634 :         return _Result;

	lea	rax, QWORD PTR _Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 24
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1635 :     }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find_lower_bound<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_reallocate<std::function<void __cdecl(void)> const &>, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 6
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 6
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::function<void __cdecl(void)> > >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rax, QWORD PTR _Whereoff$[rsp], 64	; 00000040H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+64]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z ; std::forward<std::function<void __cdecl(void)> const &>
	mov	QWORD PTR tv132[rsp], rax
	imul	rax, QWORD PTR _Whereoff$[rsp], 64	; 00000040H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 64	; 00000040H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	imul	rax, QWORD PTR _Whereoff$[rsp], 64	; 00000040H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+64]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAV?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@YAPEAV?$function@$$A6AXXZ@0@QEAV10@0PEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Uninitialized_move<std::function<void __cdecl(void)> *,std::allocator<std::function<void __cdecl(void)> > >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 64	; 00000040H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_reallocate<std::function<void __cdecl(void)> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA PROC ; `std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_reallocate<std::function<void __cdecl(void)> const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z@4HA ENDP ; `std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_reallocate<std::function<void __cdecl(void)> const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv81 = 48
tv79 = 56
tv77 = 64
_Result$ = 72
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_with_unused_capacity<std::function<void __cdecl(void)> const &>, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);
; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z ; std::forward<std::function<void __cdecl(void)> const &>
	mov	QWORD PTR tv81[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$construct@V?$function@$$A6AXXZ@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::construct<std::function<void __cdecl(void)>,std::function<void __cdecl(void)> const &>
	npad	1

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAXPEAV?$function@$$A6AXXZ@2@0@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 64					; 00000040H
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_with_unused_capacity<std::function<void __cdecl(void)> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z PROC ; std::forward<std::function<void __cdecl(void)> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z ENDP ; std::forward<std::function<void __cdecl(void)> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z PROC ; std::_Unfancy<std::function<void __cdecl(void)> >, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ENDP ; std::_Unfancy<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z PROC ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ENDP ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z
_TEXT	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > ><int const &,bool>, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	npad	1

; 584  :         this->_Allocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBH@std@@YAAEBHAEBH@Z	; std::forward<int const &>
	mov	QWORD PTR tv139[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z ; std::addressof<std::pair<int const ,bool> >
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv135[rsp], rax
	mov	r9, QWORD PTR tv141[rsp]
	mov	r8, QWORD PTR tv139[rsp]
	mov	rdx, QWORD PTR tv137[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	??$construct@U?$pair@$$CBH_N@std@@AEBH_N@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@AEBH$$QEA_N@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::construct<std::pair<int const ,bool>,int const &,bool>
	npad	1

; 586  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > ><int const &,bool>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > ><int const &,bool>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > ><int const &,bool>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 589  :         if (this->_Ptr != pointer{}) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z ; std::addressof<std::pair<int const ,bool> >
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	??$destroy@U?$pair@$$CBH_N@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@QEAU?$pair@$$CBH_N@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::destroy<std::pair<int const ,bool> >
	npad	1
$LN2@List_node_:

; 591  :         }
; 592  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >, COMDAT

; 1167 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1168 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Alloc_cons

; 1169 :             _Al.deallocate(_Ptr, 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, 1
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::deallocate
	npad	1
$LN2@Alloc_cons:

; 1170 :         }
; 1171 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 32
this$ = 64
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Allocate, COMDAT

; 1162 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1164 :         _Ptr = _Al.allocate(1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv73[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocate
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1165 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Release, COMDAT

; 1158 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1159 :         return _STD exchange(_Ptr, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<int const ,bool>,void *> *,std::nullptr_t>

; 1160 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >, COMDAT

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBH@std@@YAAEBHAEBH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBH@std@@YAAEBHAEBH@Z PROC			; std::forward<int const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBH@std@@YAAEBHAEBH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find_last<int>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find_last<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map_impl@HH_N@std@@SAAEBHAEBHAEB_N@Z
_TEXT	SEGMENT
_Val$ = 8
__formal$ = 16
?_Extract@?$_In_place_key_extract_map_impl@HH_N@std@@SAAEBHAEBHAEB_N@Z PROC ; std::_In_place_key_extract_map_impl<int,int,bool>::_Extract, COMDAT

; 2128 :     static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 2129 :         return _Val;

	mov	rax, QWORD PTR _Val$[rsp]

; 2130 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map_impl@HH_N@std@@SAAEBHAEBHAEB_N@Z ENDP ; std::_In_place_key_extract_map_impl<int,int,bool>::_Extract
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 40
this$ = 80
_Keyval$ = 88
_Hashval$ = 96
??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find<int>, COMDAT

; 1213 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1214 :         if constexpr (_Traits::_Multi) {
; 1215 :             return _Find_first(_Keyval, _Hashval);
; 1216 :         } else {
; 1217 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1218 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find_last<int>
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Target$1[rsp], rax

; 1219 :             if (_Target) {

	cmp	QWORD PTR _Target$1[rsp], 0
	je	SHORT $LN2@Find

; 1220 :                 return _Target;

	mov	rax, QWORD PTR _Target$1[rsp]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1221 :             }
; 1222 : 
; 1223 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@Find:

; 1224 :         }
; 1225 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z
_TEXT	SEGMENT
tv75 = 32
this$ = 64
_Keyval$ = 72
??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>, COMDAT

; 148  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 149  :         // hash _Keyval to size_t value
; 150  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEBAAEBU?$hash@H@2@XZ ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z ; std::_Conditionally_enabled_hash<int,1>::operator()

; 151  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@H@std@@YA$$QEAHAEAH@Z PROC			; std::forward<int>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@H@std@@YA$$QEAHAEAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<24>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 24
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,bool>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,bool>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<80>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 230584300921369395			; 0333333333333333H
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 230584300921369395			; 0333333333333333H
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 80		; 00000050H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<80>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *,std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *,std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Al$ = 64
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 343  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 344  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 345  :         const auto _Pnode = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocate
	mov	QWORD PTR _Pnode$[rsp], rax

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	rax, QWORD PTR _Pnode$[rsp]
	lea	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	rax, QWORD PTR _Pnode$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	rax, QWORD PTR _Pnode$[rsp]
	add	rax, 16
	lea	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &>

; 349  :         _Pnode->_Color = _Black;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+24], 1

; 350  :         _Pnode->_Isnil = true;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	BYTE PTR [rax+25], 1

; 351  :         return _Pnode;

	mov	rax, QWORD PTR _Pnode$[rsp]

; 352  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBH_N@std@@@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CBH_N@std@@@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocator<std::_List_node<std::pair<int const ,bool>,void *> ><std::pair<int const ,bool> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CBH_N@std@@@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocator<std::_List_node<std::pair<int const ,bool>,void *> ><std::pair<int const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1><std::allocator<std::pair<int const ,bool> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBH_N@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<int const ,bool> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CBH_N@std@@@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocator<std::_List_node<std::pair<int const ,bool>,void *> ><std::pair<int const ,bool> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1><std::allocator<std::pair<int const ,bool> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Hash_representation@H@std@@YA_KAEBH@Z
_TEXT	SEGMENT
_Keyval$ = 48
??$_Hash_representation@H@std@@YA_KAEBH@Z PROC		; std::_Hash_representation<int>, COMDAT

; 2316 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2317 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, -3750763034362895579		; cbf29ce484222325H
	call	??$_Fnv1a_append_value@H@std@@YA_K_KAEBH@Z ; std::_Fnv1a_append_value<int>

; 2318 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Hash_representation@H@std@@YA_KAEBH@Z ENDP		; std::_Hash_representation<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::addressof<std::function<void __cdecl(void)> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::destroy<std::function<void __cdecl(void)> >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *,std::_List_node<std::function<void __cdecl(void)>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::function<void __cdecl(void)>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::function<void __cdecl(void)>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *,std::_List_node<std::function<void __cdecl(void)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
__formal$ = 72
_Val1$ = 80
<_Val2_0>$ = 88
??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z ; std::forward<std::less<int> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	movzx	edx, BYTE PTR [rax]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1><>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx], xmm0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv81 = 48
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
<_Val2_1>$ = 104
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv79[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$?0M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,bool>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,bool>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<int const ,bool>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<int const ,bool>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv73 = 40
tv75 = 48
tv84 = 56
this$ = 80
_Al$ = 88
??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > ><std::allocator<std::pair<int const ,bool> > const &,0>, COMDAT

; 267  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBH_N@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<int const ,bool> > const &>
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1><std::allocator<std::pair<int const ,bool> > const &>
	npad	1

; 268  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 269  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > ><std::allocator<std::pair<int const ,bool> > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 107  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator++

; 108  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 109  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 99   :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator*

; 100  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z PROC ; std::addressof<std::pair<int const ,bool> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z ENDP ; std::addressof<std::pair<int const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QEA_NAEA_N@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_N@std@@YA$$QEA_NAEA_N@Z PROC		; std::forward<bool>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@_N@std@@YA$$QEA_NAEA_N@Z ENDP		; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
_Tmp$ = 32
this$ = 64
__$ReturnUdt$ = 72
__formal$ = 80
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++, COMDAT

; 250  :     _List_iterator operator++(int) noexcept {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 251  :         _List_iterator _Tmp = *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 252  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++

; 253  :         return _Tmp;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Tmp$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 254  :     }

	add	rsp, 56					; 00000038H
	ret	0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator!=, COMDAT

; 201  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 202  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 203  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++, COMDAT

; 157  :     _List_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 158  : #if _ITERATOR_DEBUG_LEVEL == 2
; 159  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 160  :         _STL_ASSERT(_Mycont, "cannot increment value-initialized list iterator");
; 161  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot increment end list iterator");
; 162  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 163  : 
; 164  :         this->_Ptr = this->_Ptr->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 165  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 166  :     }

	ret	0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEBV?$function@$$A6AXXZ@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >, COMDAT

; 765  :     void _Erase_head(_Alnode& _Al) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 766  :         this->_Orphan_all();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 767  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >

; 768  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1

; 769  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z
_TEXT	SEGMENT
_Loc$ = 32
this$ = 80
_Keyval$ = 88
??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find<int>, COMDAT

; 1373 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1374 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find_lower_bound<int>
	npad	1

; 1375 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

	mov	r8, QWORD PTR _Keyval$[rsp]
	mov	rdx, QWORD PTR _Loc$[rsp+16]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Lower_bound_duplicate<int>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Find

; 1376 :             return _Loc._Bound;

	mov	rax, QWORD PTR _Loc$[rsp+16]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1377 :         }
; 1378 : 
; 1379 :         return _Get_scary()->_Myhead;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	rax, QWORD PTR [rax]
$LN1@Find:

; 1380 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
_Scary$ = 56
tv158 = 64
tv156 = 72
tv154 = 80
tv152 = 88
tv173 = 96
tv172 = 104
_Inserted$ = 112
$T4 = 120
_Loc$ = 128
$T5 = 152
$T6 = 160
$T7 = 176
this$ = 224
__$ReturnUdt$ = 232
_Keyval$ = 240
??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z PROC ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Try_emplace<int>, COMDAT

; 196  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 197  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find_lower_bound<int>
	npad	1

; 198  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

	mov	r8, QWORD PTR _Keyval$[rsp]
	mov	rdx, QWORD PTR _Loc$[rsp+16]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Lower_bound_duplicate<int>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Try_emplac

; 199  :             return {_Loc._Bound, false};

	mov	BYTE PTR $T1[rsp], 0
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR _Loc$[rsp+16]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> * const &,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Try_emplac
$LN2@Try_emplac:

; 200  :         }
; 201  : 
; 202  :         _Mybase::_Check_grow_by_1();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Check_grow_by_1

; 203  : 
; 204  :         const auto _Scary    = _Mybase::_Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 205  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

	lea	rcx, QWORD PTR $T3[rsp]
	call	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
	mov	QWORD PTR tv158[rsp], rax
	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$forward@H@std@@YA$$QEAHAEAH@Z	; std::forward<int>
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z ; std::forward_as_tuple<int>
	mov	QWORD PTR tv156[rsp], rax
	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv154[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
	mov	QWORD PTR tv152[rsp], rax
	mov	rax, QWORD PTR tv158[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR tv156[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:?piecewise_construct@std@@3Upiecewise_construct_t@1@B ; std::piecewise_construct
	mov	r8, QWORD PTR tv154[rsp]
	mov	rdx, QWORD PTR tv152[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
	mov	QWORD PTR tv173[rsp], rax
	mov	rax, QWORD PTR tv173[rsp]
	mov	QWORD PTR tv172[rsp], rax
	mov	rcx, QWORD PTR tv172[rsp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::_Release
	mov	QWORD PTR _Inserted$[rsp], rax
	lea	rcx, QWORD PTR $T6[rsp]
	call	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1

; 206  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval)),
; 207  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...))
; 208  :                                    ._Release();
; 209  : 
; 210  :         // nothrow hereafter
; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	lea	rax, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR _Loc$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	mov	r8, QWORD PTR _Inserted$[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Insert_node
	mov	QWORD PTR $T4[rsp], rax
	mov	BYTE PTR $T2[rsp], 1
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool><std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> *,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Try_emplac:

; 212  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z ENDP ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Try_emplace<int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
_Scary$ = 56
tv158 = 64
tv156 = 72
tv154 = 80
tv152 = 88
tv173 = 96
tv172 = 104
_Inserted$ = 112
$T4 = 120
_Loc$ = 128
$T5 = 152
$T6 = 160
$T7 = 176
this$ = 224
__$ReturnUdt$ = 232
_Keyval$ = 240
?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA PROC ; `std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Try_emplace<int>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA ENDP ; `std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Try_emplace<int>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAUWndEventArgs@Core@IronMan@@@std@@YAAEAUWndEventArgs@Core@IronMan@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAUWndEventArgs@Core@IronMan@@@std@@YAAEAUWndEventArgs@Core@IronMan@@AEAU123@@Z PROC ; std::forward<IronMan::Core::WndEventArgs &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAUWndEventArgs@Core@IronMan@@@std@@YAAEAUWndEventArgs@Core@IronMan@@AEAU123@@Z ENDP ; std::forward<IronMan::Core::WndEventArgs &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_one_at_back<std::function<void __cdecl(void)> const &>, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z ; std::forward<std::function<void __cdecl(void)> const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_back_with_unused_capacity<std::function<void __cdecl(void)> const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBV?$function@$$A6AXXZ@std@@@std@@YAAEBV?$function@$$A6AXXZ@0@AEBV10@@Z ; std::forward<std::function<void __cdecl(void)> const &>
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAPEAV?$function@$$A6AXXZ@1@QEAV21@AEBV21@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_reallocate<std::function<void __cdecl(void)> const &>
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_one_at_back<std::function<void __cdecl(void)> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR _First$[rsp], rax
$LN4@Destroy_ra:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@Destroy_ra

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));

	mov	rcx, QWORD PTR _First$[rsp]
	call	??$_Unfancy@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy<std::function<void __cdecl(void)> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@V?$function@$$A6AXXZ@std@@@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SAXAEAV?$allocator@V?$function@$$A6AXXZ@std@@@1@QEAV?$function@$$A6AXXZ@1@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::destroy<std::function<void __cdecl(void)> >
	npad	1

; 1100 :         }

	jmp	SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 1101 :     }
; 1102 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z PROC ; std::_Unfancy_maybe_null<std::function<void __cdecl(void)> >, COMDAT

; 79   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 80   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 81   : }

	ret	0
??$_Unfancy_maybe_null@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ENDP ; std::_Unfancy_maybe_null<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,bool> *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CBH_N@std@@@std@@YAPEAU?$pair@$$CBH_N@0@AEAU10@@Z ; std::addressof<std::pair<int const ,bool> >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,bool> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ??$constHash@$0?BGNOOJIGFPHBLFGF@@@YA_KXZ
_TEXT	SEGMENT
??$constHash@$0?BGNOOJIGFPHBLFGF@@@YA_KXZ PROC		; constHash<-1648011277000357221>, COMDAT

; 243  : 	return hash;

	mov	rax, -1648011277000357221		; e9211679a08e4a9bH

; 244  : }

	ret	0
??$constHash@$0?BGNOOJIGFPHBLFGF@@@YA_KXZ ENDP		; constHash<-1648011277000357221>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Target$5 = 56
tv76 = 72
tv91 = 80
tv94 = 88
tv144 = 96
tv142 = 104
tv140 = 112
tv185 = 120
tv188 = 128
_Newnode$6 = 136
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::emplace<int const &,bool>, COMDAT

; 591  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 592  :         // try to insert value_type(_Vals...)
; 593  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Valtys...>;
; 594  :         if constexpr (_Multi) {
; 595  :             _Check_max_size();
; 596  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 597  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 598  :             const auto _Hashval = _Traitsobj(_Keyval);
; 599  :             if (_Check_rehash_required_1()) {
; 600  :                 _Rehash_for_1();
; 601  :             }
; 602  : 
; 603  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 604  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 605  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 606  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

	mov	rdx, QWORD PTR <_Vals_1>$[rsp]
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	?_Extract@?$_In_place_key_extract_map_impl@HH_N@std@@SAAEBHAEBHAEB_N@Z ; std::_In_place_key_extract_map_impl<int,int,bool>::_Extract
	mov	QWORD PTR _Keyval$4[rsp], rax

; 607  :             const auto _Hashval = _Traitsobj(_Keyval);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR _Keyval$4[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
	mov	QWORD PTR _Hashval$3[rsp], rax

; 608  :             auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, QWORD PTR _Keyval$4[rsp]
	lea	rdx, QWORD PTR _Target$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find_last<int>
	npad	1

; 609  :             if (_Target._Duplicate) {

	cmp	QWORD PTR _Target$5[rsp+8], 0
	je	SHORT $LN2@emplace

; 610  :                 return {_List._Make_iter(_Target._Duplicate), false};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv91[rsp], rax
	mov	r8, QWORD PTR _Target$5[rsp+8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Make_iter
	mov	QWORD PTR tv94[rsp], rax
	mov	BYTE PTR $T1[rsp], 0
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR tv94[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@emplace
$LN2@emplace:

; 611  :             }
; 612  : 
; 613  :             _Check_max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_max_size

; 614  :             // invalidates _Keyval:
; 615  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	QWORD PTR tv144[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBH@std@@YAAEBHAEBH@Z	; std::forward<int const &>
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
	mov	QWORD PTR tv140[rsp], rax
	mov	r9, QWORD PTR tv144[rsp]
	mov	r8, QWORD PTR tv142[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	??$?0AEBH_N@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH$$QEA_N@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > ><int const &,bool>
	npad	1

; 616  :             if (_Check_rehash_required_1()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_rehash_required_1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@emplace

; 617  :                 _Rehash_for_1();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Rehash_for_1
	npad	1

; 618  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	rax, QWORD PTR _Newnode$6[rsp+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find_last<int>
	lea	rcx, QWORD PTR _Target$5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN3@emplace:

; 619  :             }
; 620  : 
; 621  :             return {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv185[rsp], rax
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::_Release
	mov	r9, rax
	mov	r8, QWORD PTR _Target$5[rsp]
	mov	rdx, QWORD PTR _Hashval$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Insert_new_node_before
	mov	r8, rax
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR tv185[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Make_iter
	mov	QWORD PTR tv188[rsp], rax
	mov	BYTE PTR $T2[rsp], 1
	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, QWORD PTR tv188[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >,bool,0>
	npad	1
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@emplace:

; 622  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 623  :         } else {
; 624  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 625  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 626  :             const auto _Hashval = _Traitsobj(_Keyval);
; 627  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 628  :             if (_Target._Duplicate) {
; 629  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 630  :             }
; 631  : 
; 632  :             _Check_max_size();
; 633  :             if (_Check_rehash_required_1()) {
; 634  :                 _Rehash_for_1();
; 635  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);
; 636  :             }
; 637  : 
; 638  :             return {
; 639  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 640  :         }
; 641  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::emplace<int const &,bool>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Target$5 = 56
tv76 = 72
tv91 = 80
tv94 = 88
tv144 = 96
tv142 = 104
tv140 = 112
tv185 = 120
tv188 = 128
_Newnode$6 = 136
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::emplace<int const &,bool>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Newnode$6[rbp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::emplace<int const &,bool>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator->, COMDAT

; 241  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBH_N@std@@@std@@SAPEAU?$pair@$$CBH_N@2@AEAU32@@Z ; std::pointer_traits<std::pair<int const ,bool> *>::pointer_to

; 243  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator!=, COMDAT

; 76   :     _NODISCARD bool operator!=(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 77   :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 78   :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 73   :     }

	add	rsp, 24
	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator--, COMDAT

; 60   :     _List_unchecked_const_iterator& operator--() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax

; 62   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 51   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::find<void>, COMDAT

; 1229 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1230 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@H@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Find<int>
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Make_iter
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1231 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA PROC ; `std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >::~pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->, COMDAT

; 277  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 278  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > *>::pointer_to

; 279  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*, COMDAT

; 273  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 274  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*

; 275  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator!=, COMDAT

; 236  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 237  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 238  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator==, COMDAT

; 227  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 228  : #if _ITERATOR_DEBUG_LEVEL == 2
; 229  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 230  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 231  : 
; 232  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 233  :     }

	add	rsp, 24
	ret	0
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*, COMDAT

; 178  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 179  : #if _ITERATOR_DEBUG_LEVEL == 2
; 180  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 181  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 182  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 183  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 184  : 
; 185  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 32					; 00000020H

; 186  :     }

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>, COMDAT

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ
text$yd	SEGMENT
??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ PROC ; `IronMan::Core::OverlayEngine::ProcessFunction'::`2'::`dynamic atexit destructor for 'KeyPress_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A
	call	??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ ENDP ; `IronMan::Core::OverlayEngine::ProcessFunction'::`2'::`dynamic atexit destructor for 'KeyPress_''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::~unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::~unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::~unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::~unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@U?$pair@$$CBH_N@std@@@std@@QEAA@XZ ; std::allocator<std::pair<int const ,bool> >::allocator<std::pair<int const ,bool> >
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::~_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::~list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::~_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::~_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::~list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::~_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::~_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::~_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >, COMDAT

; 323  :     ~_Hash_vec() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Tidy
	npad	1

; 325  : #if _ITERATOR_DEBUG_LEVEL != 0
; 326  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());
; 327  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 328  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 329  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv92 = 48
this$ = 80
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Tidy, COMDAT

; 313  :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 314  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 315  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>

; 316  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::capacity
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::deallocate

; 317  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 318  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 319  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@Tidy:

; 320  :         }
; 321  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size, COMDAT

; 278  :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 279  :         return (_STD min)(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >,1>::_Get_first
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 280  :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Aliter_traits::max_size(_Mypair._Get_first()));
; 281  :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size, COMDAT

; 1776 :     const float& _Max_bucket_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1777 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size

; 1778 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size, COMDAT

; 1772 :     float& _Max_bucket_size() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1773 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size

; 1774 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Forced_rehash, COMDAT

; 1680 :     void _Forced_rehash(size_type _Buckets) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1681 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1682 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1683 :         // load_factor() <= max_load_factor().
; 1684 : 
; 1685 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1686 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1687 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::max_size
	shr	rax, 1
	mov	rcx, rax
	call	?_Floor_of_log_2@std@@YAK_K@Z		; std::_Floor_of_log_2
	mov	DWORD PTR _Max_storage_buckets_log2$[rsp], eax

; 1688 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, DWORD PTR _Max_storage_buckets_log2$[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv308[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv308[rsp]
	shl	rax, cl
	mov	QWORD PTR _Max_storage_buckets$[rsp], rax

; 1689 :         if (_Buckets > _Max_storage_buckets) {

	mov	rax, QWORD PTR _Max_storage_buckets$[rsp]
	cmp	QWORD PTR _Buckets$[rsp], rax
	jbe	SHORT $LN8@Forced_reh

; 1690 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN8@Forced_reh:

; 1691 :         }
; 1692 : 
; 1693 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1694 :         // 2 invariant
; 1695 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1696 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1697 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	mov	rcx, QWORD PTR _Buckets$[rsp]
	call	?_Ceiling_of_log_2@std@@YAK_K@Z		; std::_Ceiling_of_log_2
	mov	ecx, 1
	mov	QWORD PTR tv312[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv312[rsp]
	shl	rax, cl
	mov	QWORD PTR _Buckets$[rsp], rax

; 1698 :         const _Unchecked_iterator _End = _Unchecked_end();

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_end

; 1699 : 
; 1700 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Buckets$[rsp]
	shl	rax, 1
	mov	r8, QWORD PTR _End$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Assign_grow

; 1701 :         _Mask   = _Buckets - 1;

	mov	rax, QWORD PTR _Buckets$[rsp]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1702 :         _Maxidx = _Buckets;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Buckets$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 1703 : 
; 1704 :         _Clear_guard _Guard{this};

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??0_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::_Clear_guard
	npad	1

; 1705 : 
; 1706 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

	lea	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_begin
	npad	1

; 1707 : 
; 1708 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1709 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR _Next_inserted$2[rsp], rax
	jmp	SHORT $LN4@Forced_reh
$LN2@Forced_reh:
	mov	rax, QWORD PTR _Next_inserted$2[rsp]
	mov	QWORD PTR _Inserted$[rsp], rax
$LN4@Forced_reh:
	lea	rdx, QWORD PTR _End$[rsp]
	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN3@Forced_reh

; 1710 :             ++_Next_inserted;

	lea	rcx, QWORD PTR _Next_inserted$2[rsp]
	call	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator++

; 1711 : 
; 1712 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBH_N@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
	mov	QWORD PTR _Inserted_key$5[rsp], rax

; 1713 :             const size_type _Bucket = bucket(_Inserted_key);

	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1714 : 
; 1715 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1716 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1717 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$3[rsp], rax

; 1718 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$4[rsp], rax

; 1719 : 
; 1720 :             if (_Bucket_lo == _End) {

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Forced_reh

; 1721 :                 // The bucket was empty, set it to the inserted element.
; 1722 :                 _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1723 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1724 :                 continue;

	jmp	$LN2@Forced_reh
$LN9@Forced_reh:

; 1725 :             }
; 1726 : 
; 1727 :             // Search the bucket for the insertion location and move element if necessary.
; 1728 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Insert_before$1[rsp], rax

; 1729 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv194[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv194[rsp]
	call	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Forced_reh

; 1730 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1731 :                 // new bucket inclusive end.
; 1732 :                 ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator++
	npad	1

; 1733 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	lea	rdx, QWORD PTR _Inserted$[rsp]
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Forced_reh

; 1734 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Unchecked_splice
	npad	1
$LN11@Forced_reh:

; 1735 :                 }
; 1736 : 
; 1737 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1738 :                 continue;

	jmp	$LN2@Forced_reh
$LN5@Forced_reh:

; 1739 :             }
; 1740 : 
; 1741 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1742 :             // go backwards to maintain sortedness when !_Standard.
; 1743 :             for (;;) {
; 1744 :                 if (_Bucket_lo == _Insert_before) {

	lea	rdx, QWORD PTR _Insert_before$1[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Forced_reh

; 1745 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1746 :                     // Element can't be already in position here because:
; 1747 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1748 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1749 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Unchecked_splice

; 1750 :                     _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1751 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1752 :                 }
; 1753 : 
; 1754 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv258[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator--
	mov	rcx, rax
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBH_N@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv258[rsp]
	call	??$?RHH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_NAEBH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int,int>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@Forced_reh

; 1755 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1756 :                     ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,std::_Iterator_base0>::operator++

; 1757 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1758 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1759 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Unchecked_splice
	npad	1

; 1760 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1761 :                 }
; 1762 :             }

	jmp	$LN5@Forced_reh
$LN6@Forced_reh:

; 1763 :         }

	jmp	$LN2@Forced_reh
$LN3@Forced_reh:

; 1764 : 
; 1765 :         _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$[rsp], 0

; 1766 : 
; 1767 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1768 :         _Stl_internal_check_container_invariants();
; 1769 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1770 :     }

	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::~_Clear_guard
	npad	1
	add	rsp, 168				; 000000a8H
	ret	0
$LN16@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Forced_rehash'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Clear_guard::~_Clear_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Forced_rehash'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
_Old_buckets$ = 32
_Req_buckets$ = 40
$T1 = 48
this$ = 80
_For_size$ = 88
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Desired_grow_bucket_count, COMDAT

; 1659 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1660 :         const size_type _Old_buckets = bucket_count();

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket_count
	mov	QWORD PTR _Old_buckets$[rsp], rax

; 1661 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	rdx, QWORD PTR _For_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Min_load_factor_buckets
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?_Min_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@2_KB
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Req_buckets$[rsp], rax

; 1662 :         if (_Old_buckets >= _Req_buckets) {

	mov	rax, QWORD PTR _Req_buckets$[rsp]
	cmp	QWORD PTR _Old_buckets$[rsp], rax
	jb	SHORT $LN2@Desired_gr

; 1663 :             // we already have enough buckets so there's no need to change the count
; 1664 :             return _Old_buckets;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	jmp	SHORT $LN1@Desired_gr
$LN2@Desired_gr:

; 1665 :         }
; 1666 : 
; 1667 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	QWORD PTR _Old_buckets$[rsp], 512	; 00000200H
	jae	SHORT $LN3@Desired_gr
	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	cmp	rax, QWORD PTR _Req_buckets$[rsp]
	jb	SHORT $LN3@Desired_gr

; 1668 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1669 :             return _Old_buckets * 8;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	jmp	SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1670 :         }
; 1671 : 
; 1672 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1673 :         return _Req_buckets;

	mov	rax, QWORD PTR _Req_buckets$[rsp]
$LN1@Desired_gr:

; 1674 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
tv65 = 32
this$ = 64
_For_size$ = 72
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Min_load_factor_buckets, COMDAT

; 1654 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1655 :         // returns the minimum number of buckets necessary for the elements in _List
; 1656 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	mov	rax, QWORD PTR _For_size$[rsp]
	test	rax, rax
	jl	SHORT $LN4@Min_load_f
	cvtsi2ss xmm0, rax
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN5@Min_load_f
$LN4@Min_load_f:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR tv65[rsp], xmm0
$LN5@Min_load_f:
	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::max_load_factor
	movss	xmm1, DWORD PTR tv65[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	ceilf
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN3@Min_load_f
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN3@Min_load_f
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN3@Min_load_f:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx

; 1657 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Newsize$ = 40
this$ = 64
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Rehash_for_1, COMDAT

; 1630 :     void _Rehash_for_1() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1631 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1632 :         const auto _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1633 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Forced_rehash
	npad	1

; 1634 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv71 = 32
tv77 = 36
tv70 = 40
_Oldsize$ = 48
_Newsize$ = 56
this$ = 80
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_rehash_required_1, COMDAT

; 1624 :     bool _Check_rehash_required_1() const noexcept {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1625 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1626 :         const auto _Newsize      = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1627 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::max_load_factor
	movss	DWORD PTR tv70[rsp], xmm0
	mov	rax, QWORD PTR _Newsize$[rsp]
	test	rax, rax
	jl	SHORT $LN7@Check_reha
	cvtsi2ss xmm1, rax
	movss	DWORD PTR tv71[rsp], xmm1
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
	movss	DWORD PTR tv71[rsp], xmm1
$LN8@Check_reha:
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket_count
	test	rax, rax
	jl	SHORT $LN5@Check_reha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN6@Check_reha
$LN5@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN6@Check_reha:
	movss	xmm1, DWORD PTR tv71[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tv70[rsp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Check_reha
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN4@Check_reha
$LN3@Check_reha:
	mov	DWORD PTR tv77[rsp], 0
$LN4@Check_reha:
	movzx	eax, BYTE PTR tv77[rsp]

; 1628 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
this$ = 64
?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_max_size, COMDAT

; 1617 :     void _Check_max_size() const {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1618 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1619 :         if (_Oldsize == _List.max_size()) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Check_max_

; 1620 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Check_max_:
$LN3@Check_max_:

; 1621 :         }
; 1622 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Check_max_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
_Bucket_lo$ = 32
_Insert_after$ = 40
_Bucket_hi$ = 48
_Bucket$ = 56
_Bucket_array$ = 64
_Head$ = 72
this$ = 96
_Hashval$ = 104
_Insert_before$ = 112
_Newnode$ = 120
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Insert_new_node_before, COMDAT

; 1586 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1587 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Insert_after$[rsp], rax

; 1588 :         ++_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1589 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	rax, QWORD PTR _Newnode$[rsp]
	lea	rdx, QWORD PTR _Insert_before$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * const &>

; 1590 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	rax, QWORD PTR _Newnode$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Insert_after$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * const &>

; 1591 :         _Insert_after->_Next  = _Newnode;

	mov	rax, QWORD PTR _Insert_after$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1592 :         _Insert_before->_Prev = _Newnode;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 1593 : 
; 1594 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$[rsp], rax

; 1595 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_array$[rsp], rax

; 1596 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1597 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax

; 1598 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$[rsp], rax

; 1599 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@Insert_new

; 1600 :             // bucket is empty, set both
; 1601 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1602 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1603 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Insert_before$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN4@Insert_new

; 1604 :             // new node is the lowest element in the bucket
; 1605 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN5@Insert_new
$LN4@Insert_new:

; 1606 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Insert_after$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN6@Insert_new

; 1607 :             // new node is the highest element in the bucket
; 1608 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Insert_new:
$LN5@Insert_new:
$LN3@Insert_new:

; 1609 :         }
; 1610 : 
; 1611 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1612 :         _Stl_internal_check_container_invariants();
; 1613 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1614 :         return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]

; 1615 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Head$1 = 40
tv132 = 48
tv134 = 56
tv130 = 64
$T2 = 72
this$ = 96
?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::clear, COMDAT

; 1152 :     void clear() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1153 :         // TRANSITION, ABI:
; 1154 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1155 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1156 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1157 :         //   (2) The hash function operator() may throw exceptions, and
; 1158 :         //   (3) clear() is a noexcept function.
; 1159 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1160 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1161 :         if (_Oldsize == 0) {

	cmp	QWORD PTR _Oldsize$[rsp], 0
	jne	SHORT $LN2@clear

; 1162 :             return;

	jmp	$LN1@clear
$LN2@clear:

; 1163 :         }
; 1164 : 
; 1165 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1166 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1167 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1168 :             // as many buckets as elements, remove element-by-element.
; 1169 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket_count
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	cmp	rax, QWORD PTR _Oldsize$[rsp]
	jbe	SHORT $LN3@clear

; 1170 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$1[rsp], rax

; 1171 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	r8, QWORD PTR _Head$1[rsp]
	mov	rax, QWORD PTR _Head$1[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_erase
	npad	1

; 1172 :                 return;

	jmp	SHORT $LN1@clear
$LN3@clear:

; 1173 :             }
; 1174 :         }
; 1175 : 
; 1176 :         // Bulk destroy items and reset buckets
; 1177 :         _List.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::clear
	npad	1

; 1178 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_end
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv134[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > >
	npad	1
$LN1@clear:

; 1179 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_erase, COMDAT

; 1028 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1029 :         if (_First == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	jne	SHORT $LN10@Unchecked_

; 1030 :             return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	jmp	$LN1@Unchecked_
$LN10@Unchecked_:

; 1031 :         }
; 1032 : 
; 1033 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1034 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_bounds$[rsp], rax

; 1035 :         _Range_eraser _Eraser{_List, _First};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	r8, QWORD PTR _First$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??0_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Range_eraser
	npad	1

; 1036 :         {
; 1037 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1038 :             const auto _Predecessor = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Predecessor$12[rsp], rax

; 1039 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1040 :             // nothrow hereafter this block
; 1041 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$4[rsp], rax

; 1042 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$5[rsp], rax

; 1043 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN19@Unchecked_
	mov	BYTE PTR tv136[rsp], 1
	jmp	SHORT $LN20@Unchecked_
$LN19@Unchecked_:
	mov	BYTE PTR tv136[rsp], 0
$LN20@Unchecked_:
	movzx	eax, BYTE PTR tv136[rsp]
	mov	BYTE PTR _Update_lo$1[rsp], al

; 1044 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$10[rsp], rax
$LN2@Unchecked_:

; 1045 :             for (;;) { // remove elements until we hit the end of the bucket
; 1046 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$10[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN21@Unchecked_
	mov	BYTE PTR tv138[rsp], 1
	jmp	SHORT $LN22@Unchecked_
$LN21@Unchecked_:
	mov	BYTE PTR tv138[rsp], 0
$LN22@Unchecked_:
	movzx	eax, BYTE PTR tv138[rsp]
	mov	BYTE PTR _At_bucket_back$2[rsp], al

; 1047 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1048 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$2[rsp]
	test	eax, eax
	je	SHORT $LN11@Unchecked_

; 1049 :                     break;

	jmp	SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1050 :                 }
; 1051 : 
; 1052 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN12@Unchecked_

; 1053 :                     if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN13@Unchecked_

; 1054 :                         // erased the bucket's prefix
; 1055 :                         _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx
$LN13@Unchecked_:

; 1056 :                     }
; 1057 : 
; 1058 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T11[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN1@Unchecked_
$LN12@Unchecked_:

; 1059 :                 }
; 1060 :             }

	jmp	$LN2@Unchecked_
$LN3@Unchecked_:

; 1061 : 
; 1062 :             if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN14@Unchecked_

; 1063 :                 // emptied the bucket
; 1064 :                 _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1065 :                 _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1066 :             } else {

	jmp	SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1067 :                 _Bucket_hi = _Predecessor;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _Predecessor$12[rsp]
	mov	QWORD PTR [rax], rcx
$LN5@Unchecked_:

; 1068 :             }
; 1069 :         }
; 1070 : 
; 1071 :         // hereafter we are always erasing buckets' prefixes
; 1072 :         while (_Eraser._Next != _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	je	$LN6@Unchecked_

; 1073 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBH_N@?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBH_N@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Kfn<int const ,bool>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket
	mov	QWORD PTR _Bucket$7[rsp], rax

; 1074 :             // nothrow hereafter this block
; 1075 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$8[rsp], rax

; 1076 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$9[rsp], rax

; 1077 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$13[rsp], rax
$LN7@Unchecked_:

; 1078 :             for (;;) { // remove elements until we hit the end of the bucket
; 1079 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$13[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN23@Unchecked_
	mov	BYTE PTR tv172[rsp], 1
	jmp	SHORT $LN24@Unchecked_
$LN23@Unchecked_:
	mov	BYTE PTR tv172[rsp], 0
$LN24@Unchecked_:
	movzx	eax, BYTE PTR tv172[rsp]
	mov	BYTE PTR _At_bucket_back$3[rsp], al

; 1080 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1081 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$3[rsp]
	test	eax, eax
	je	SHORT $LN16@Unchecked_

; 1082 :                     break;

	jmp	SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1083 :                 }
; 1084 : 
; 1085 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN17@Unchecked_

; 1086 :                     // erased the bucket's prefix
; 1087 :                     _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx

; 1088 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T14[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T14[rsp]
	jmp	SHORT $LN1@Unchecked_
$LN17@Unchecked_:

; 1089 :                 }
; 1090 :             }

	jmp	SHORT $LN7@Unchecked_
$LN8@Unchecked_:

; 1091 : 
; 1092 :             // emptied the bucket
; 1093 :             _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1094 :             _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1095 :         }

	jmp	$LN5@Unchecked_
$LN6@Unchecked_:

; 1096 : 
; 1097 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T15[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T15[rsp]
$LN1@Unchecked_:

; 1098 :     }

	add	rsp, 184				; 000000b8H
	ret	0
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_erase'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Eraser$[rbp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Range_eraser::~_Range_eraser
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_erase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 48
?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::max_load_factor, COMDAT

; 912  :     _NODISCARD float max_load_factor() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         return _Max_bucket_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR [rax]

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z
_TEXT	SEGMENT
tv73 = 32
tv76 = 40
tv78 = 48
this$ = 80
_Keyval$ = 88
?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket, COMDAT

; 856  :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 857  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$?RH@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBA_KAEBH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()<int>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	and	rcx, rax
	mov	rax, rcx

; 858  :     }

	add	rsp, 72					; 00000048H
	ret	0
?bucket@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket_count, COMDAT

; 847  :     _NODISCARD size_type bucket_count() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 848  :         return _Maxidx;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]

; 849  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_end, COMDAT

; 812  :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 813  :         return _List._Unchecked_end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 814  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_begin, COMDAT

; 804  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 805  :         return _List._Unchecked_begin();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_begin
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 806  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::end, COMDAT

; 796  :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 797  :         return _List.end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 798  :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
_TEXT	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >, COMDAT

; 378  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > ><std::allocator<std::pair<int const ,bool> > const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 7
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 8

; 379  :         // construct empty hash table
; 380  :         _Max_bucket_size() = _Bucket_size;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 381  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_end
	mov	r8, QWORD PTR [rax]
	mov	edx, 16
	mov	rcx, QWORD PTR tv132[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::_Assign_grow
	npad	1

; 382  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 383  :         _Stl_internal_check_container_invariants();
; 384  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 385  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::~list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Last_prev$ = 0
_First_prev$ = 8
_Before_prev$ = 16
_Before$ = 48
_First$ = 56
_Last$ = 64
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Unchecked_splice, COMDAT

; 468  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _First_prev$[rsp], rax

; 475  :         _First_prev->_Next      = _Last;

	mov	rax, QWORD PTR _First_prev$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Last_prev$[rsp], rax

; 477  :         _Last_prev->_Next       = _Before;

	mov	rax, QWORD PTR _Last_prev$[rsp]
	mov	rcx, QWORD PTR _Before$[rsp]
	mov	QWORD PTR [rax], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Before_prev$[rsp], rax

; 479  :         _Before_prev->_Next     = _First;

	mov	rax, QWORD PTR _Before_prev$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rcx, QWORD PTR _Last_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 484  :         _First->_Prev  = _Before_prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Before_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 485  : 
; 486  :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 487  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	mov	QWORD PTR [rsp+8], rcx

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal, COMDAT

; 1858 :     const _Alnode& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1859 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first

; 1860 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,bool>,void *> *,std::_List_node<std::pair<int const ,bool>,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
tv75 = 40
tv73 = 48
this$ = 80
?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::clear, COMDAT

; 1494 :     void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1495 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1496 :         _My_data._Orphan_non_end();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >::_Orphan_non_end

; 1497 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,bool>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >

; 1498 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1499 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 1500 :         _My_data._Mysize        = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1501 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::max_size, COMDAT

; 1197 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1198 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1199 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1200 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Make_iter, COMDAT

; 1126 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1127 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > const >
	mov	r8, rax
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1128 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Make_iter@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@@Z ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_begin, COMDAT

; 1110 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1111 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1112 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::~list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::~list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Al$ = 72
??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z PROC ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >, COMDAT

; 806  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CBH_N@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > >,1><std::allocator<std::pair<int const ,bool> > const &>
	npad	1

; 807  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::_Alloc_sentinel_and_proxy
	npad	1

; 808  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@U?$pair@$$CBH_N@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBH_N@std@@@1@@Z ENDP ; std::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >::list<std::pair<int const ,bool>,std::allocator<std::pair<int const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 24
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,bool>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z	; std::_Get_size_of_n<24>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 24
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBH_N@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBH_N@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,bool>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z PROC ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR _Traits$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ENDP ; std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBH_N@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBH_N@std@@@std@@QEAA@XZ PROC	; std::allocator<std::pair<int const ,bool> >::allocator<std::pair<int const ,bool> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@$$CBH_N@std@@@std@@QEAA@XZ ENDP	; std::allocator<std::pair<int const ,bool> >::allocator<std::pair<int const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEBAAEBU?$hash@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEBAAEBU?$hash@H@2@XZ PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEBAAEBU?$hash@H@2@XZ ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEBAAEBU?$equal_to@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEBAAEBU?$equal_to@H@2@XZ PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QEBAAEBU?$equal_to@H@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??R?$equal_to@H@std@@QEBA_NAEBH0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$equal_to@H@std@@QEBA_NAEBH0@Z PROC			; std::equal_to<int>::operator(), COMDAT

; 634  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 635  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 636  :     }

	add	rsp, 24
	ret	0
??R?$equal_to@H@std@@QEBA_NAEBH0@Z ENDP			; std::equal_to<int>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size, COMDAT

; 164  :     _NODISCARD const float& _Get_max_bucket_size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 165  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 166  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size, COMDAT

; 160  :     _NODISCARD float& _Get_max_bucket_size() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 161  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 162  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
tv75 = 40
this$ = 64
??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >, COMDAT

; 137  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR $T3[rsp], xmm0
	lea	r9, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	movzx	edx, BYTE PTR $T2[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAXPEAV?$function@$$A6AXXZ@2@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAXPEAV?$function@$$A6AXXZ@2@0@Z PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_range, COMDAT

; 2208 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAXPEAV?$function@$$A6AXXZ@2@0@Z ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 6
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Change_array, COMDAT

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2047 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2048 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2049 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2050 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2051 : 
; 2052 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 6
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ; std::allocator<std::function<void __cdecl(void)> >::deallocate
	npad	1
$LN2@Change_arr:

; 2058 :         }
; 2059 : 
; 2060 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2061 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, QWORD PTR _Newsize$[rsp], 64	; 00000040H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

	imul	rax, QWORD PTR _Newcapacity$[rsp], 64	; 00000040H
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2063 :         _ASAN_VECTOR_CREATE;
; 2064 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXQEAV?$function@$$A6AXXZ@2@_K1@Z ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Calculate_growth, COMDAT

; 1991 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1992 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1993 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1994 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1995 : 
; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1997 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 2003 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2004 :         }
; 2005 : 
; 2006 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 2007 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::capacity, COMDAT

; 1907 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1908 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 6

; 1910 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEBAAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_end, COMDAT

; 1885 :     _NODISCARD _CONSTEXPR20 _Ty* _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1886 :         return _Unfancy_maybe_null(_Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy_maybe_null@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy_maybe_null<std::function<void __cdecl(void)> >

; 1887 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin, COMDAT

; 1877 :     _NODISCARD _CONSTEXPR20 _Ty* _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1878 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@V?$function@$$A6AXXZ@std@@@std@@YAPEAV?$function@$$A6AXXZ@0@PEAV10@@Z ; std::_Unfancy_maybe_null<std::function<void __cdecl(void)> >

; 1879 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
_Myfirst$ = 48
tv82 = 56
tv84 = 64
tv80 = 72
this$ = 96
?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear, COMDAT

; 1792 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1793 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1794 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1795 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1796 : 
; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;

	jmp	SHORT $LN1@clear
$LN2@clear:

; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@V?$function@$$A6AXXZ@std@@@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv80[rsp], rax
	mov	r8, QWORD PTR tv82[rsp]
	mov	rdx, QWORD PTR tv84[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$_Destroy_range@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@YAXPEAV?$function@$$A6AXXZ@0@QEAV10@AEAV?$allocator@V?$function@$$A6AXXZ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::function<void __cdecl(void)> > >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN1@clear:

; 1808 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back, COMDAT

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 918  :         _Emplace_one_at_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEBV?$function@$$A6AXXZ@std@@@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$function@$$A6AXXZ@1@AEBV21@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Emplace_one_at_back<std::function<void __cdecl(void)> const &>
	npad	1

; 919  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 655  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::function<void __cdecl(void)> >,std::_Vector_val<std::_Simple_types<std::function<void __cdecl(void)> > >,1><>
	npad	1

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 657  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z PROC ; std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAAPEAXI@Z ENDP ; std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ PROC ; std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::~function<void __cdecl(IronMan::Core::WndEventArgs &)>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::~_Func_class<void,IronMan::Core::WndEventArgs &>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ ENDP ; std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::~function<void __cdecl(IronMan::Core::WndEventArgs &)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA PROC ; `std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::~function<void __cdecl(IronMan::Core::WndEventArgs &)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::~_Func_class<void,IronMan::Core::WndEventArgs &>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@QEAA@XZ@4HA ENDP ; `std::function<void __cdecl(IronMan::Core::WndEventArgs &)>::~function<void __cdecl(IronMan::Core::WndEventArgs &)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Set@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEAAXPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Set@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEAAXPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@@Z PROC ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Set, COMDAT

; 1048 :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1049 :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 1050 :     }

	ret	0
?_Set@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEAAXPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@@Z ENDP ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ PROC ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Getimpl, COMDAT

; 1044 :     _Ptrt* _Getimpl() const noexcept { // get pointer to object

	mov	QWORD PTR [rsp+8], rcx

; 1045 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax]

; 1046 :     }

	ret	0
?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ ENDP ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ
_TEXT	SEGMENT
tv68 = 32
this$ = 64
?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ PROC ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Local, COMDAT

; 1032 :     bool _Local() const noexcept { // test for locally stored copy of object

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1033 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Getimpl
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, rcx
	jne	SHORT $LN3@Local
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@Local
$LN3@Local:
	mov	DWORD PTR tv68[rsp], 0
$LN4@Local:
	movzx	eax, BYTE PTR tv68[rsp]

; 1034 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ ENDP ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ
_TEXT	SEGMENT
tv78 = 32
tv71 = 40
tv81 = 48
this$ = 80
?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ PROC ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Tidy, COMDAT

; 1001 :     void _Tidy() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1002 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Tidy

; 1003 :             _Getimpl()->_Delete_this(!_Local());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Getimpl
	mov	QWORD PTR tv71[rsp], rax
	mov	rax, QWORD PTR tv71[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Local@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBA_NXZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Local
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@Tidy
	mov	BYTE PTR tv78[rsp], 1
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	BYTE PTR tv78[rsp], 0
$LN5@Tidy:
	movzx	edx, BYTE PTR tv78[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	QWORD PTR tv81[rsp]

; 1004 :             _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEAAXPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@@Z ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Set
	npad	1
$LN2@Tidy:

; 1005 :         }
; 1006 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ ENDP ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ PROC ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Empty, COMDAT

; 938  :     bool _Empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 939  :         return !_Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Getimpl
	test	rax, rax
	jne	SHORT $LN3@Empty
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv67[rsp], 0
$LN4@Empty:
	movzx	eax, BYTE PTR tv67[rsp]

; 940  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ ENDP ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ PROC ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::~_Func_class<void,IronMan::Core::WndEventArgs &>, COMDAT

; 928  :     ~_Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 929  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEAAXXZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Tidy
	npad	1

; 930  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEAA@XZ ENDP ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::~_Func_class<void,IronMan::Core::WndEventArgs &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z
_TEXT	SEGMENT
_Impl$ = 32
tv77 = 40
tv79 = 48
this$ = 80
<_Args_0>$ = 88
??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z PROC ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::operator(), COMDAT

; 920  :     _Ret operator()(_Types... _Args) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 921  :         if (_Empty()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@IEBA_NXZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator

; 922  :             _Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
	npad	1
$LN2@operator:

; 923  :         }
; 924  :         const auto _Impl = _Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@AEBAPEAV?$_Func_base@XAEAUWndEventArgs@Core@IronMan@@@2@XZ ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::_Getimpl
	mov	QWORD PTR _Impl$[rsp], rax

; 925  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR _Impl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAUWndEventArgs@Core@IronMan@@@std@@YAAEAUWndEventArgs@Core@IronMan@@AEAU123@@Z ; std::forward<IronMan::Core::WndEventArgs &>
	mov	QWORD PTR tv77[rsp], rax
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR _Impl$[rsp]
	call	QWORD PTR tv79[rsp]
	npad	1
$LN3@operator:

; 926  :     }

	add	rsp, 72					; 00000048H
	ret	0
??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z ENDP ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 107  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator++

; 108  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 109  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 99   :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator*

; 100  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator!=, COMDAT

; 76   :     _NODISCARD bool operator!=(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 77   :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 78   :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 73   :     }

	add	rsp, 24
	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 51   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
Init$ = 32
tv87 = 40
tv85 = 48
$T1 = 56
__$ArrayPad$ = 88
s$ = 112
?ThreadInitGui@Core@IronMan@@YAKPEAX@Z PROC		; IronMan::Core::ThreadInitGui

; 103  : 	{

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 104  : 		typedef bool(__stdcall* initGUI)();
; 105  : 		initGUI Init = (initGUI)s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR Init$[rsp], rax

; 106  : 		try
; 107  : 		{
; 108  : 			Init();

	call	QWORD PTR Init$[rsp]
	npad	1
	jmp	SHORT $LN7@ThreadInit
$LN8@ThreadInit:
$LN7@ThreadInit:

; 109  : 		}
; 110  : 		catch (...)
; 111  : 		{
; 112  : 			CONSOLE_INFO2(u8"ImGui!");
; 113  : 			InitImGui = false;
; 114  : 			TerminateProcess(GetCurrentProcess(), 1);
; 115  : 		}
; 116  : 		InitImGui = true;

	mov	BYTE PTR ?InitImGui@Core@IronMan@@3_NA, 1

; 117  : 		return 1;

	mov	eax, 1

; 118  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?ThreadInitGui@Core@IronMan@@YAKPEAX@Z ENDP		; IronMan::Core::ThreadInitGui
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
Init$ = 32
tv87 = 40
tv85 = 48
$T1 = 56
__$ArrayPad$ = 88
s$ = 112
?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA PROC ; `IronMan::Core::ThreadInitGui'::`1'::catch$1

; 111  : 		{

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?ThreadInitGui@Core@IronMan@@YAKPEAX@Z$0:

; 112  : 			CONSOLE_INFO2(u8"ImGui!");

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0BJ@PFOBBMC@ImGui?g?$LL?$JI?e?$II?$LG?e?$IK?$KA?h?$LN?$LN?e?$KE?$LB?h?$LE?$KF?$CB@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T1[rbp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv87[rbp], rax
	mov	rax, QWORD PTR tv87[rbp]
	mov	QWORD PTR tv85[rbp], rax
	mov	rcx, QWORD PTR tv85[rbp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 113  : 			InitImGui = false;

	mov	BYTE PTR ?InitImGui@Core@IronMan@@3_NA, 0

; 114  : 			TerminateProcess(GetCurrentProcess(), 1);

	call	QWORD PTR __imp_GetCurrentProcess
	mov	edx, 1
	mov	rcx, rax
	call	QWORD PTR __imp_TerminateProcess
	npad	1

; 115  : 		}

	lea	rax, $LN8@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA ENDP ; `IronMan::Core::ThreadInitGui'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
Init$ = 32
tv87 = 40
tv85 = 48
$T1 = 56
__$ArrayPad$ = 88
s$ = 112
?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA PROC ; `IronMan::Core::ThreadInitGui'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ThreadInitGui@Core@IronMan@@YAKPEAX@Z@4HA ENDP ; `IronMan::Core::ThreadInitGui'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::mHotkeys'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
	call	??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::mHotkeys''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
;	COMDAT ??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::OverlayEngine::mHotkeys'', COMDAT

; 56   : 	std::map<int, std::vector< std::function<void(void)>>> OverlayEngine::mHotkeys;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
	call	??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
	lea	rcx, OFFSET FLAT:??__F?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::mHotkeys''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::OverlayEngine::mHotkeys''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::~map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::~map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::~map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::~map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z PROC ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::operator[], COMDAT

; 174  :     mapped_type& operator[](key_type&& _Keyval) { // find element matching _Keyval or insert value-initialized value

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 175  :         return _Try_emplace(_STD move(_Keyval)).first->_Myval.second;

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$move@AEAH@std@@YA$$QEAHAEAH@Z	; std::move<int &>
	mov	r8, rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Try_emplace@H$$V@?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@_N@1@$$QEAH@Z ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Try_emplace<int>
	mov	rax, QWORD PTR [rax]
	add	rax, 40					; 00000028H

; 176  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z ENDP ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
;	COMDAT ??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >, COMDAT

; 106  :     map() : _Mybase(key_compare()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z
_TEXT	SEGMENT
_Pnode$1 = 32
_Head$ = 40
_Parent_sibling$2 = 48
_Parent_sibling$3 = 56
this$ = 80
_Loc$ = 88
_Newnode$ = 96
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Insert_node, COMDAT

; 659  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

$LN19:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 660  :         ++_Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 661  :         const auto _Head  = _Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Head$[rsp], rax

; 662  :         _Newnode->_Parent = _Loc._Parent;

	mov	rax, QWORD PTR _Newnode$[rsp]
	mov	rcx, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 663  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN5@Insert_nod

; 664  :             _Head->_Left     = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 665  :             _Head->_Parent   = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 666  :             _Head->_Right    = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 667  :             _Newnode->_Color = _Black; // the root is black

	mov	rax, QWORD PTR _Newnode$[rsp]
	mov	BYTE PTR [rax+24], 1

; 668  :             return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]
	jmp	$LN1@Insert_nod
$LN5@Insert_nod:

; 669  :         }
; 670  : 
; 671  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 672  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

	mov	rax, QWORD PTR _Loc$[rsp]
	cmp	DWORD PTR [rax+8], 0
	jne	SHORT $LN6@Insert_nod

; 673  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 674  :             _Loc._Parent->_Right = _Newnode;

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 675  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN8@Insert_nod

; 676  :                 _Head->_Right = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN8@Insert_nod:

; 677  :             }
; 678  :         } else { // add to left of _Loc._Parent

	jmp	SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 679  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 680  :             _Loc._Parent->_Left = _Newnode;

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 681  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

	mov	rax, QWORD PTR _Loc$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN9@Insert_nod

; 682  :                 _Head->_Left = _Newnode;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN9@Insert_nod:
$LN7@Insert_nod:

; 683  :             }
; 684  :         }
; 685  : 
; 686  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	rax, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR _Pnode$1[rsp], rax
$LN2@Insert_nod:
	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	$LN3@Insert_nod

; 687  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR [rcx+8], rax
	jne	$LN10@Insert_nod

; 688  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Parent_sibling$2[rsp], rax

; 689  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	mov	rax, QWORD PTR _Parent_sibling$2[rsp]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	SHORT $LN12@Insert_nod

; 690  :                     _Pnode->_Parent->_Color          = _Black;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 691  :                     _Parent_sibling->_Color          = _Black;

	mov	rax, QWORD PTR _Parent_sibling$2[rsp]
	mov	BYTE PTR [rax+24], 1

; 692  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 693  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 694  :                 } else { // parent's sibling has red and black children

	jmp	SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 695  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR _Pnode$1[rsp], rax
	jne	SHORT $LN14@Insert_nod

; 696  :                         _Pnode = _Pnode->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 697  :                         _Lrotate(_Pnode);

	mov	rdx, QWORD PTR _Pnode$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Lrotate
	npad	1
$LN14@Insert_nod:

; 698  :                     }
; 699  : 
; 700  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 701  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 702  :                     _Rrotate(_Pnode->_Parent->_Parent);

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Rrotate
	npad	1
$LN13@Insert_nod:

; 703  :                 }
; 704  :             } else { // fixup red-red in right subtree

	jmp	$LN11@Insert_nod
$LN10@Insert_nod:

; 705  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Parent_sibling$3[rsp], rax

; 706  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	mov	rax, QWORD PTR _Parent_sibling$3[rsp]
	movsx	eax, BYTE PTR [rax+24]
	test	eax, eax
	jne	SHORT $LN15@Insert_nod

; 707  :                     _Pnode->_Parent->_Color          = _Black;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 708  :                     _Parent_sibling->_Color          = _Black;

	mov	rax, QWORD PTR _Parent_sibling$3[rsp]
	mov	BYTE PTR [rax+24], 1

; 709  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 710  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 711  :                 } else { // parent's sibling has red and black children

	jmp	SHORT $LN16@Insert_nod
$LN15@Insert_nod:

; 712  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Pnode$1[rsp], rax
	jne	SHORT $LN17@Insert_nod

; 713  :                         _Pnode = _Pnode->_Parent;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnode$1[rsp], rax

; 714  :                         _Rrotate(_Pnode);

	mov	rdx, QWORD PTR _Pnode$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Rrotate
	npad	1
$LN17@Insert_nod:

; 715  :                     }
; 716  : 
; 717  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 718  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 0

; 719  :                     _Lrotate(_Pnode->_Parent->_Parent);

	mov	rax, QWORD PTR _Pnode$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Lrotate
	npad	1
$LN16@Insert_nod:
$LN11@Insert_nod:

; 720  :                 }
; 721  :             }
; 722  :         }

	jmp	$LN2@Insert_nod
$LN3@Insert_nod:

; 723  : 
; 724  :         _Head->_Parent->_Color = _Black; // root is always black

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	BYTE PTR [rax+24], 1

; 725  :         return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]
$LN1@Insert_nod:

; 726  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 0
this$ = 32
_Wherenode$ = 40
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Rrotate, COMDAT

; 495  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 496  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 497  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax], rcx

; 498  : 
; 499  :         if (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN2@Rrotate

; 500  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN2@Rrotate:

; 501  :         }
; 502  : 
; 503  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 504  : 
; 505  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN3@Rrotate

; 506  :             _Myhead->_Parent = _Pnode;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN4@Rrotate
$LN3@Rrotate:

; 507  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN5@Rrotate

; 508  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 509  :         } else {

	jmp	SHORT $LN6@Rrotate
$LN5@Rrotate:

; 510  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Rrotate:
$LN4@Rrotate:

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Right      = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 514  :         _Wherenode->_Parent = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 515  :     }

	add	rsp, 24
	ret	0
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 0
this$ = 32
_Wherenode$ = 40
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Lrotate, COMDAT

; 473  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 474  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Pnode$[rsp], rax

; 475  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rcx

; 476  : 
; 477  :         if (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	movsx	eax, BYTE PTR [rax+25]
	test	eax, eax
	jne	SHORT $LN2@Lrotate

; 478  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN2@Lrotate:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN3@Lrotate

; 484  :             _Myhead->_Parent = _Pnode;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx
	jmp	SHORT $LN4@Lrotate
$LN3@Lrotate:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Wherenode$[rsp], rax
	jne	SHORT $LN5@Lrotate

; 486  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 487  :         } else {

	jmp	SHORT $LN6@Lrotate
$LN5@Lrotate:

; 488  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN6@Lrotate:
$LN4@Lrotate:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Left       = _Wherenode;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Wherenode$[rsp]
	mov	QWORD PTR [rax], rcx

; 492  :         _Wherenode->_Parent = _Pnode;

	mov	rax, QWORD PTR _Wherenode$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 493  :     }

	add	rsp, 24
	ret	0
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >, COMDAT

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary, COMDAT

; 1976 :     const _Scary_val* _Get_scary() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1977 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > const >

; 1978 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary, COMDAT

; 1972 :     _Scary_val* _Get_scary() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1973 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >

; 1974 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal, COMDAT

; 1968 :     const _Alnode& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1969 :         return _Mypair._Myval2._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first

; 1970 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal, COMDAT

; 1964 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1965 :         return _Mypair._Myval2._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>::_Get_first

; 1966 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getcomp, COMDAT

; 1960 :     const key_compare& _Getcomp() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1961 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Get_first

; 1962 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getcomp@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Scary$ = 40
_Alproxy$ = 48
this$ = 80
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Alloc_sentinel_and_proxy, COMDAT

; 1943 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1944 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1945 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1946 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);

	mov	r8, QWORD PTR _Scary$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1947 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
	mov	rcx, rax
	call	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	mov	rcx, QWORD PTR _Scary$[rsp]
	mov	QWORD PTR [rcx], rax

; 1948 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1949 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Check_grow_by_1, COMDAT

; 1637 :     void _Check_grow_by_1() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1638 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::max_size
	mov	QWORD PTR tv65[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	rcx, QWORD PTR tv65[rsp]
	cmp	rcx, QWORD PTR [rax+8]
	jne	SHORT $LN2@Check_grow

; 1639 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	npad	1
$LN2@Check_grow:
$LN3@Check_grow:

; 1640 :         }
; 1641 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::find, COMDAT

; 1383 :     _NODISCARD iterator find(const key_type& _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1384 :         return iterator(_Find(_Keyval), _Get_scary());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@H@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Find<int>
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1385 :     }

	add	rsp, 56					; 00000038H
	ret	0
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::max_size, COMDAT

; 1202 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1203 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1204 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1205 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_Scary$ = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::end, COMDAT

; 1140 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1141 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1142 :         return iterator(_Scary->_Myhead, _Scary);

	mov	r8, QWORD PTR _Scary$[rsp]
	mov	rax, QWORD PTR _Scary$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1143 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Scary$ = 32
this$ = 64
??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >, COMDAT

; 1085 :     ~_Tree() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1086 :         const auto _Scary = _Get_scary();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Get_scary@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Get_scary
	mov	QWORD PTR _Scary$[rsp], rax

; 1087 :         _Scary->_Erase_head(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Getal
	mov	rdx, rax
	mov	rcx, QWORD PTR _Scary$[rsp]
	call	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >
	npad	1

; 1088 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1089 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1090 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1091 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1092 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv71 = 40
this$ = 64
_Parg$ = 72
??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >, COMDAT

; 894  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	lea	r9, QWORD PTR $T1[rsp]
	mov	r8, QWORD PTR _Parg$[rsp]
	movzx	edx, BYTE PTR $T2[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
	npad	1

; 895  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Alloc_sentinel_and_proxy
	npad	1

; 896  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 64		; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z	; std::_Get_size_of_n<64>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 64		; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >::allocator<std::_Tree_node<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > >,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ
text$yd	SEGMENT
??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnWndProc'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A ; IronMan::Core::OverlayEngine::OnWndProc
	call	??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::~delegate<void __cdecl(IronMan::Core::WndEventArgs &)>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnWndProc''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
;	COMDAT ??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ
text$di	SEGMENT
??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnWndProc'', COMDAT

; 36   : 	delegate<void(WndEventArgs&)> OverlayEngine::OnWndProc;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A ; IronMan::Core::OverlayEngine::OnWndProc
	call	??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::delegate<void __cdecl(IronMan::Core::WndEventArgs &)>
	lea	rcx, OFFSET FLAT:??__F?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnWndProc''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnWndProc''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	mov	QWORD PTR [rsp+8], rcx

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *,std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> *,std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
tv75 = 40
tv73 = 48
this$ = 80
?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::clear, COMDAT

; 1494 :     void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1495 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1496 :         _My_data._Orphan_non_end();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Orphan_non_end

; 1497 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >

; 1498 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1499 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 1500 :         _My_data._Mysize        = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1501 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_begin, COMDAT

; 1110 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1111 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1112 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::~list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::~list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >, COMDAT

; 802  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,1><>
	npad	1

; 803  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Alloc_sentinel_and_proxy
	npad	1

; 804  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 80		; 00000050H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z	; std::_Get_size_of_n<80>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$_List_node@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\delegate.hpp
;	COMDAT ??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ PROC ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::~delegate<void __cdecl(IronMan::Core::WndEventArgs &)>, COMDAT

; 67   : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 68   : 		func_list.clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAAXXZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::clear
	npad	1

; 69   : 	}

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::~list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ ENDP ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::~delegate<void __cdecl(IronMan::Core::WndEventArgs &)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA PROC ; `delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::~delegate<void __cdecl(IronMan::Core::WndEventArgs &)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::~list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA ENDP ; `delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::~delegate<void __cdecl(IronMan::Core::WndEventArgs &)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\delegate.hpp
;	COMDAT ??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ PROC ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::delegate<void __cdecl(IronMan::Core::WndEventArgs &)>, COMDAT

; 60   : 	delegate()

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 61   : 	{

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
	npad	1

; 62   : 		//OUTPUT( "function type:" << typeid( R( Args... ) ).name() )
; 63   : 		//	OUTPUT( "args count:" << sizeof...( Args ) )
; 64   : 	};

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ ENDP ; delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::delegate<void __cdecl(IronMan::Core::WndEventArgs &)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA PROC ; `delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::delegate<void __cdecl(IronMan::Core::WndEventArgs &)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::~list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@QEAA@XZ@4HA ENDP ; `delegate<void __cdecl(IronMan::Core::WndEventArgs &)>::delegate<void __cdecl(IronMan::Core::WndEventArgs &)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$yd	SEGMENT
??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPostPresent'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPostPresent
	call	??1?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPostPresent''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
;	COMDAT ??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$di	SEGMENT
??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnPostPresent'', COMDAT

; 35   : 	delegate<void()> OverlayEngine::OnPostPresent;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPostPresent
	call	??0?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>
	lea	rcx, OFFSET FLAT:??__F?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPostPresent''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnPostPresent''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$yd	SEGMENT
??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPresent'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPresent
	call	??1?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPresent''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
;	COMDAT ??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$di	SEGMENT
??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnPresent'', COMDAT

; 34   : 	delegate<void()> OverlayEngine::OnPresent;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPresent
	call	??0?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>
	lea	rcx, OFFSET FLAT:??__F?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPresent''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnPresent''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$yd	SEGMENT
??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPrePresent'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPrePresent
	call	??1?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPrePresent''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
;	COMDAT ??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$di	SEGMENT
??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnPrePresent'', COMDAT

; 33   : 	delegate<void()> OverlayEngine::OnPrePresent;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPrePresent
	call	??0?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>
	lea	rcx, OFFSET FLAT:??__F?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnPrePresent''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnPrePresent''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$yd	SEGMENT
??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnTick'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnTick
	call	??1?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnTick''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
;	COMDAT ??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$di	SEGMENT
??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnTick'', COMDAT

; 32   : 	delegate<void()> OverlayEngine::OnTick;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnTick
	call	??0?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>
	lea	rcx, OFFSET FLAT:??__F?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnTick''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?OnTick@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnTick''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$yd	SEGMENT
??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnUpdate'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnUpdate
	call	??1?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnUpdate''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
;	COMDAT ??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ
text$di	SEGMENT
??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnUpdate'', COMDAT

; 31   : 	delegate<void()> OverlayEngine::OnUpdate;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnUpdate
	call	??0?$delegate@$$A6AXXZ@@QEAA@XZ		; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>
	lea	rcx, OFFSET FLAT:??__F?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::Core::OverlayEngine::OnUpdate''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::OverlayEngine::OnUpdate''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\delegate.hpp
;	COMDAT ??R?$delegate@$$A6AXXZ@@QEAAXXZ
_TEXT	SEGMENT
itr$1 = 32
tv69 = 40
tv86 = 48
$T2 = 56
$T3 = 64
this$ = 96
??R?$delegate@$$A6AXXZ@@QEAAXXZ PROC			; delegate<void __cdecl(void)>::operator(), COMDAT

; 169  : 	{

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 170  : 		for (auto itr = func_list.begin(); itr != func_list.end(); itr++)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	lea	rdx, QWORD PTR itr$1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::begin
	npad	1
	jmp	SHORT $LN4@operator
$LN2@operator:
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR itr$1[rsp]
	call	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator++
	npad	1
$LN4@operator:
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv86[rsp], rax
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	call	?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR itr$1[rsp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator

; 171  : 		{
; 172  : 			try
; 173  : 			{
; 174  : 				(*itr)(args...);

	lea	rcx, QWORD PTR itr$1[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXXZ@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >::operator*
	mov	rcx, rax
	call	??R?$_Func_class@X$$V@std@@QEBAXXZ	; std::_Func_class<void>::operator()
	npad	1
	jmp	SHORT $LN9@operator
$LN10@operator:
$LN9@operator:

; 175  : 			}
; 176  : 			catch (...)
; 177  : 			{
; 178  : 			}
; 179  : 		}

	jmp	SHORT $LN2@operator
$LN3@operator:

; 180  : 	}

	add	rsp, 88					; 00000058H
	ret	0
??R?$delegate@$$A6AXXZ@@QEAAXXZ ENDP			; delegate<void __cdecl(void)>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
itr$1 = 32
tv69 = 40
tv86 = 48
$T2 = 56
$T3 = 64
this$ = 96
?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA PROC	; `delegate<void __cdecl(void)>::operator()'::`1'::catch$0

; 177  : 			{

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??R?$delegate@$$A6AXXZ@@QEAAXXZ$0:

; 178  : 			}

	lea	rax, $LN10@catch$0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0???R?$delegate@$$A6AXXZ@@QEAAXXZ@4HA ENDP	; `delegate<void __cdecl(void)>::operator()'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\delegate.hpp
;	COMDAT ??1?$delegate@$$A6AXXZ@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$delegate@$$A6AXXZ@@QEAA@XZ PROC			; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>, COMDAT

; 67   : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 68   : 		func_list.clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear
	npad	1

; 69   : 	}

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$delegate@$$A6AXXZ@@QEAA@XZ ENDP			; delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA PROC	; `delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$delegate@$$A6AXXZ@@QEAA@XZ@4HA ENDP	; `delegate<void __cdecl(void)>::~delegate<void __cdecl(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\delegate.hpp
;	COMDAT ??0?$delegate@$$A6AXXZ@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$delegate@$$A6AXXZ@@QEAA@XZ PROC			; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>, COMDAT

; 60   : 	delegate()

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 61   : 	{

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	npad	1

; 62   : 		//OUTPUT( "function type:" << typeid( R( Args... ) ).name() )
; 63   : 		//	OUTPUT( "args count:" << sizeof...( Args ) )
; 64   : 	};

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$delegate@$$A6AXXZ@@QEAA@XZ ENDP			; delegate<void __cdecl(void)>::delegate<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA PROC	; `delegate<void __cdecl(void)>::delegate<void __cdecl(void)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$delegate@$$A6AXXZ@@QEAA@XZ@4HA ENDP	; `delegate<void __cdecl(void)>::delegate<void __cdecl(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\DirectXMath.h
;	COMDAT ??BXMVECTORF32@DirectX@@QEBAPEBMXZ
_TEXT	SEGMENT
this$ = 8
??BXMVECTORF32@DirectX@@QEBAPEBMXZ PROC			; DirectX::XMVECTORF32::operator float const *, COMDAT

; 406  :         inline operator const float* () const noexcept { return f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??BXMVECTORF32@DirectX@@QEBAPEBMXZ ENDP			; DirectX::XMVECTORF32::operator float const *
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__info_main

; 6362 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 6363 : #ifndef STBI_NO_JPEG
; 6364 : 	if (stbi__jpeg_info(s, x, y, comp)) return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__jpeg_info
	test	eax, eax
	je	SHORT $LN2@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN2@stbi__info:

; 6365 : #endif
; 6366 : 
; 6367 : #ifndef STBI_NO_PNG
; 6368 : 	if (stbi__png_info(s, x, y, comp))  return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__png_info
	test	eax, eax
	je	SHORT $LN3@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN3@stbi__info:

; 6369 : #endif
; 6370 : 
; 6371 : #ifndef STBI_NO_GIF
; 6372 : 	if (stbi__gif_info(s, x, y, comp))  return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__gif_info
	test	eax, eax
	je	SHORT $LN4@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN4@stbi__info:

; 6373 : #endif
; 6374 : 
; 6375 : #ifndef STBI_NO_BMP
; 6376 : 	if (stbi__bmp_info(s, x, y, comp))  return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__bmp_info
	test	eax, eax
	je	SHORT $LN5@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN5@stbi__info:

; 6377 : #endif
; 6378 : 
; 6379 : #ifndef STBI_NO_PSD
; 6380 : 	if (stbi__psd_info(s, x, y, comp))  return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__psd_info
	test	eax, eax
	je	SHORT $LN6@stbi__info
	mov	eax, 1
	jmp	$LN1@stbi__info
$LN6@stbi__info:

; 6381 : #endif
; 6382 : 
; 6383 : #ifndef STBI_NO_PIC
; 6384 : 	if (stbi__pic_info(s, x, y, comp))  return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pic_info
	test	eax, eax
	je	SHORT $LN7@stbi__info
	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN7@stbi__info:

; 6385 : #endif
; 6386 : 
; 6387 : #ifndef STBI_NO_PNM
; 6388 : 	if (stbi__pnm_info(s, x, y, comp))  return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
	test	eax, eax
	je	SHORT $LN8@stbi__info
	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN8@stbi__info:

; 6389 : #endif
; 6390 : 
; 6391 : #ifndef STBI_NO_HDR
; 6392 : 	if (stbi__hdr_info(s, x, y, comp))  return 1;

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__hdr_info
	test	eax, eax
	je	SHORT $LN9@stbi__info
	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN9@stbi__info:

; 6393 : #endif
; 6394 : 
; 6395 : 	// test tga last because it's a crappy test!
; 6396 : #ifndef STBI_NO_TGA
; 6397 : 	if (stbi__tga_info(s, x, y, comp))

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__tga_info
	test	eax, eax
	je	SHORT $LN10@stbi__info

; 6398 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__info
$LN10@stbi__info:

; 6399 : #endif
; 6400 : 	return stbi__err("unknown image type", "Image not of any known type, or corrupt");

	xor	eax, eax
$LN1@stbi__info:

; 6401 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__info_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
value$ = 32
s$ = 64
c$ = 72
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_getinteger

; 6315 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6316 : 	int value = 0;

	mov	DWORD PTR value$[rsp], 0
$LN2@stbi__pnm_:

; 6317 : 
; 6318 : 	while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	jne	SHORT $LN3@stbi__pnm_
	mov	rax, QWORD PTR c$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?stbi__pnm_isdigit@@YAHD@Z		; stbi__pnm_isdigit
	test	eax, eax
	je	SHORT $LN3@stbi__pnm_

; 6319 : 		value = value * 10 + (*c - '0');

	imul	eax, DWORD PTR value$[rsp], 10
	mov	rcx, QWORD PTR c$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	lea	eax, DWORD PTR [rax+rcx-48]
	mov	DWORD PTR value$[rsp], eax

; 6320 : 		*c = (char)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR c$[rsp]
	mov	BYTE PTR [rcx], al

; 6321 : 	}

	jmp	SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 6322 : 
; 6323 : 	return value;

	mov	eax, DWORD PTR value$[rsp]

; 6324 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_getinteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv68 = 0
c$ = 32
?stbi__pnm_isdigit@@YAHD@Z PROC				; stbi__pnm_isdigit

; 6310 : {

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 6311 : 	return c >= '0' && c <= '9';

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@stbi__pnm_
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
	mov	DWORD PTR tv68[rsp], 0
$LN4@stbi__pnm_:
	mov	eax, DWORD PTR tv68[rsp]

; 6312 : }

	add	rsp, 24
	ret	0
?stbi__pnm_isdigit@@YAHD@Z ENDP				; stbi__pnm_isdigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
c$ = 56
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_skip_whitespace

; 6304 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
$LN2@stbi__pnm_:

; 6305 : 	while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	jne	SHORT $LN3@stbi__pnm_
	mov	rax, QWORD PTR c$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?stbi__pnm_isspace@@YAHD@Z		; stbi__pnm_isspace
	test	eax, eax
	je	SHORT $LN3@stbi__pnm_

; 6306 : 		*c = (char)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR c$[rsp]
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 6307 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_skip_whitespace
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv76 = 0
c$ = 32
?stbi__pnm_isspace@@YAHD@Z PROC				; stbi__pnm_isspace

; 6299 : {

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 6300 : 	return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 9
	je	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 10
	je	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 11
	je	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 12
	je	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 13
	je	SHORT $LN3@stbi__pnm_
	mov	DWORD PTR tv76[rsp], 0
	jmp	SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
	mov	DWORD PTR tv76[rsp], 1
$LN4@stbi__pnm_:
	mov	eax, DWORD PTR tv76[rsp]

; 6301 : }

	add	rsp, 24
	ret	0
?stbi__pnm_isspace@@YAHD@Z ENDP				; stbi__pnm_isspace
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
f1$1 = 32
tv151 = 36
output$ = 64
input$ = 72
req_comp$ = 80
?stbi__hdr_convert@@YAXPEAMPEAEH@Z PROC			; stbi__hdr_convert

; 5953 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5954 : 	if (input[3] != 0) {

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN4@stbi__hdr_

; 5955 : 		float f1;
; 5956 : 		// Exponent
; 5957 : 		f1 = (float)ldexp(1.0f, input[3] - (int)(128 + 8));

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 136				; 00000088H
	mov	edx, eax
	movss	xmm0, DWORD PTR __real@3f800000
	call	?ldexp@@YAMMH@Z				; ldexp
	movss	DWORD PTR f1$1[rsp], xmm0

; 5958 : 		if (req_comp <= 2)

	cmp	DWORD PTR req_comp$[rsp], 2
	jg	SHORT $LN6@stbi__hdr_

; 5959 : 			output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR input$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR input$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR f1$1[rsp]
	divss	xmm0, DWORD PTR __real@40400000
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR output$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0
	jmp	$LN7@stbi__hdr_
$LN6@stbi__hdr_:

; 5960 : 		else {
; 5961 : 			output[0] = input[0] * f1;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR f1$1[rsp]
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR output$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 5962 : 			output[1] = input[1] * f1;

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR f1$1[rsp]
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR output$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 5963 : 			output[2] = input[2] * f1;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR f1$1[rsp]
	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR output$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0
$LN7@stbi__hdr_:

; 5964 : 		}
; 5965 : 		if (req_comp == 2) output[1] = 1;

	cmp	DWORD PTR req_comp$[rsp], 2
	jne	SHORT $LN8@stbi__hdr_
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR output$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax], xmm0
$LN8@stbi__hdr_:

; 5966 : 		if (req_comp == 4) output[3] = 1;

	cmp	DWORD PTR req_comp$[rsp], 4
	jne	SHORT $LN9@stbi__hdr_
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR output$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax], xmm0
$LN9@stbi__hdr_:

; 5967 : 	}

	jmp	$LN5@stbi__hdr_
$LN4@stbi__hdr_:

; 5968 : 	else {
; 5969 : 		switch (req_comp) {

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR tv151[rsp], eax
	cmp	DWORD PTR tv151[rsp], 1
	je	$LN13@stbi__hdr_
	cmp	DWORD PTR tv151[rsp], 2
	je	SHORT $LN12@stbi__hdr_
	cmp	DWORD PTR tv151[rsp], 3
	je	SHORT $LN11@stbi__hdr_
	cmp	DWORD PTR tv151[rsp], 4
	je	SHORT $LN10@stbi__hdr_
	jmp	$LN2@stbi__hdr_
$LN10@stbi__hdr_:

; 5970 : 		case 4: output[3] = 1; /* fallthrough */

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR output$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax], xmm0
$LN11@stbi__hdr_:

; 5971 : 		case 3: output[0] = output[1] = output[2] = 0;

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR output$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rcx+rax], xmm0
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR output$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rcx+rax], xmm0
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR output$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rcx+rax], xmm0

; 5972 : 			break;

	jmp	SHORT $LN2@stbi__hdr_
$LN12@stbi__hdr_:

; 5973 : 		case 2: output[1] = 1; /* fallthrough */

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR output$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rcx+rax], xmm0
$LN13@stbi__hdr_:

; 5974 : 		case 1: output[0] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR output$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rcx+rax], xmm0
$LN2@stbi__hdr_:
$LN5@stbi__hdr_:

; 5975 : 			break;
; 5976 : 		}
; 5977 : 	}
; 5978 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__hdr_convert@@YAXPEAMPEAEH@Z ENDP			; stbi__hdr_convert
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
c$ = 32
len$ = 36
z$ = 64
buffer$ = 72
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z PROC ; stbi__hdr_gettoken

; 5931 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5932 : 	int len = 0;

	mov	DWORD PTR len$[rsp], 0

; 5933 : 	char c = '\0';

	mov	BYTE PTR c$[rsp], 0

; 5934 : 
; 5935 : 	c = (char)stbi__get8(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR c$[rsp], al
$LN2@stbi__hdr_:

; 5936 : 
; 5937 : 	while (!stbi__at_eof(z) && c != '\n') {

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	jne	SHORT $LN3@stbi__hdr_
	movsx	eax, BYTE PTR c$[rsp]
	cmp	eax, 10
	je	SHORT $LN3@stbi__hdr_

; 5938 : 		buffer[len++] = c;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	movzx	edx, BYTE PTR c$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	mov	DWORD PTR len$[rsp], eax

; 5939 : 		if (len == STBI__HDR_BUFLEN - 1) {

	cmp	DWORD PTR len$[rsp], 1023		; 000003ffH
	jne	SHORT $LN6@stbi__hdr_
$LN4@stbi__hdr_:

; 5940 : 			// flush to end of line
; 5941 : 			while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	jne	SHORT $LN5@stbi__hdr_
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 10
	je	SHORT $LN5@stbi__hdr_

; 5942 : 				;

	jmp	SHORT $LN4@stbi__hdr_
$LN5@stbi__hdr_:

; 5943 : 			break;

	jmp	SHORT $LN3@stbi__hdr_
$LN6@stbi__hdr_:

; 5944 : 		}
; 5945 : 		c = (char)stbi__get8(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR c$[rsp], al

; 5946 : 	}

	jmp	SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 5947 : 
; 5948 : 	buffer[len] = 0;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 5949 : 	return buffer;

	mov	rax, QWORD PTR buffer$[rsp]

; 5950 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ENDP ; stbi__hdr_gettoken
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
signature$ = 40
s$ = 64
?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z PROC	; stbi__hdr_test_core

; 5913 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5914 : 	const char* signature = "#?RADIANCE\n";

	lea	rax, OFFSET FLAT:??_C@_0M@HOIDFNFN@?$CD?$DPRADIANCE?6@
	mov	QWORD PTR signature$[rsp], rax

; 5915 : 	int i;
; 5916 : 	for (i = 0; signature[i]; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR signature$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@stbi__hdr_

; 5917 : 		if (stbi__get8(s) != signature[i])

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR signature$[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	je	SHORT $LN5@stbi__hdr_

; 5918 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__hdr_
$LN5@stbi__hdr_:
	jmp	SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 5919 : 	return 1;

	mov	eax, 1
$LN1@stbi__hdr_:

; 5920 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z ENDP	; stbi__hdr_test_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 48
len$1 = 52
tv86 = 56
tv194 = 60
prev_trans$2 = 64
prev_out$ = 72
x$3 = 80
y$4 = 84
w$5 = 88
h$6 = 92
tv251 = 96
tv480 = 100
o$7 = 104
tv186 = 112
s$ = 144
g$ = 152
comp$ = 160
req_comp$ = 168
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z PROC ; stbi__gif_load_next

; 5763 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 5764 : 	int i;
; 5765 : 	stbi_uc* prev_out = 0;

	mov	QWORD PTR prev_out$[rsp], 0

; 5766 : 
; 5767 : 	if (g->out == 0 && !stbi__gif_header(s, g, comp, 0))

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN14@stbi__gif_
	xor	r9d, r9d
	mov	r8, QWORD PTR comp$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_header
	test	eax, eax
	jne	SHORT $LN14@stbi__gif_

; 5768 : 		return 0; // stbi__g_failure_reason set by stbi__gif_header

	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN14@stbi__gif_:

; 5769 : 
; 5770 : 	prev_out = g->out;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR prev_out$[rsp], rax

; 5771 : 	g->out = (stbi_uc*)stbi__malloc(4 * g->w * g->h);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax]
	shl	eax, 2
	mov	rcx, QWORD PTR g$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	cdqe
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 5772 : 	if (g->out == 0) return stbi__errpuc("outofmem", "Out of memory");

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN15@stbi__gif_
	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN15@stbi__gif_:

; 5773 : 
; 5774 : 	switch ((g->eflags & 0x1C) >> 2) {

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+40]
	and	eax, 28
	sar	eax, 2
	mov	DWORD PTR tv86[rsp], eax
	cmp	DWORD PTR tv86[rsp], 0
	je	SHORT $LN16@stbi__gif_
	cmp	DWORD PTR tv86[rsp], 1
	je	SHORT $LN17@stbi__gif_
	cmp	DWORD PTR tv86[rsp], 2
	je	$LN19@stbi__gif_
	cmp	DWORD PTR tv86[rsp], 3
	je	$LN21@stbi__gif_
	jmp	$LN2@stbi__gif_
$LN16@stbi__gif_:

; 5775 : 	case 0: // unspecified (also always used on 1st frame)
; 5776 : 		stbi__fill_gif_background(g, 0, 0, 4 * g->w, 4 * g->w * g->h);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax]
	shl	eax, 2
	mov	rcx, QWORD PTR g$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx]
	shl	ecx, 2
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR g$[rsp]
	call	?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z ; stbi__fill_gif_background
	npad	1

; 5777 : 		break;

	jmp	$LN2@stbi__gif_
$LN17@stbi__gif_:

; 5778 : 	case 1: // do not dispose
; 5779 : 		if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);

	cmp	QWORD PTR prev_out$[rsp], 0
	je	SHORT $LN18@stbi__gif_
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax]
	shl	eax, 2
	mov	rcx, QWORD PTR g$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR prev_out$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy
	npad	1
$LN18@stbi__gif_:

; 5780 : 		g->old_out = prev_out;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR prev_out$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 5781 : 		break;

	jmp	$LN2@stbi__gif_
$LN19@stbi__gif_:

; 5782 : 	case 2: // dispose to background
; 5783 : 		if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);

	cmp	QWORD PTR prev_out$[rsp], 0
	je	SHORT $LN20@stbi__gif_
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax]
	shl	eax, 2
	mov	rcx, QWORD PTR g$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR prev_out$[rsp]
	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	memcpy
	npad	1
$LN20@stbi__gif_:

; 5784 : 		stbi__fill_gif_background(g, g->start_x, g->start_y, g->max_x, g->max_y);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18512]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR g$[rsp]
	mov	r9d, DWORD PTR [rax+18508]
	mov	rax, QWORD PTR g$[rsp]
	mov	r8d, DWORD PTR [rax+18504]
	mov	rax, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rax+18500]
	mov	rcx, QWORD PTR g$[rsp]
	call	?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z ; stbi__fill_gif_background
	npad	1

; 5785 : 		break;

	jmp	$LN2@stbi__gif_
$LN21@stbi__gif_:

; 5786 : 	case 3: // dispose to previous
; 5787 : 		if (g->old_out) {

	mov	rax, QWORD PTR g$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	$LN22@stbi__gif_

; 5788 : 			for (i = g->start_y; i < g->max_y; i += 4 * g->w)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18504]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN6@stbi__gif_
$LN4@stbi__gif_:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR i$[rsp]
	lea	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR i$[rsp], eax
$LN6@stbi__gif_:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18512]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN5@stbi__gif_

; 5789 : 				memcpy(&g->out[i + g->start_x], &g->old_out[i + g->start_x], g->max_x - g->start_x);

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18500]
	mov	eax, DWORD PTR [rax+18508]
	sub	eax, ecx
	cdqe
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18500]
	mov	edx, DWORD PTR i$[rsp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR g$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR g$[rsp]
	mov	edx, DWORD PTR [rdx+18500]
	mov	r8d, DWORD PTR i$[rsp]
	add	r8d, edx
	mov	edx, r8d
	movsxd	rdx, edx
	mov	r8, QWORD PTR g$[rsp]
	mov	r8, QWORD PTR [r8+8]
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv186[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv186[rsp]
	mov	rcx, rax
	call	memcpy
	npad	1
	jmp	$LN4@stbi__gif_
$LN5@stbi__gif_:
$LN22@stbi__gif_:
$LN2@stbi__gif_:
$LN7@stbi__gif_:

; 5790 : 		}
; 5791 : 		break;
; 5792 : 	}
; 5793 : 
; 5794 : 	for (;;) {
; 5795 : 		switch (stbi__get8(s)) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR tv194[rsp], al
	cmp	BYTE PTR tv194[rsp], 33			; 00000021H
	je	$LN35@stbi__gif_
	cmp	BYTE PTR tv194[rsp], 44			; 0000002cH
	je	SHORT $LN23@stbi__gif_
	cmp	BYTE PTR tv194[rsp], 59			; 0000003bH
	je	$LN39@stbi__gif_
	jmp	$LN40@stbi__gif_
$LN23@stbi__gif_:

; 5796 : 		case 0x2C: /* Image Descriptor */
; 5797 : 		{
; 5798 : 			int prev_trans = -1;

	mov	DWORD PTR prev_trans$2[rsp], -1

; 5799 : 			stbi__int32 x, y, w, h;
; 5800 : 			stbi_uc* o;
; 5801 : 
; 5802 : 			x = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR x$3[rsp], eax

; 5803 : 			y = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR y$4[rsp], eax

; 5804 : 			w = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR w$5[rsp], eax

; 5805 : 			h = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR h$6[rsp], eax

; 5806 : 			if (((x + w) > (g->w)) || ((y + h) > (g->h)))

	mov	eax, DWORD PTR w$5[rsp]
	mov	ecx, DWORD PTR x$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR g$[rsp]
	cmp	eax, DWORD PTR [rcx]
	jg	SHORT $LN25@stbi__gif_
	mov	eax, DWORD PTR h$6[rsp]
	mov	ecx, DWORD PTR y$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR g$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jle	SHORT $LN24@stbi__gif_
$LN25@stbi__gif_:

; 5807 : 				return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN24@stbi__gif_:

; 5808 : 
; 5809 : 			g->line_size = g->w * 4;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax]
	shl	eax, 2
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18524], eax

; 5810 : 			g->start_x = x * 4;

	mov	eax, DWORD PTR x$3[rsp]
	shl	eax, 2
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18500], eax

; 5811 : 			g->start_y = y * g->line_size;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR y$4[rsp]
	imul	ecx, DWORD PTR [rax+18524]
	mov	eax, ecx
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18504], eax

; 5812 : 			g->max_x = g->start_x + w * 4;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18500]
	mov	ecx, DWORD PTR w$5[rsp]
	lea	eax, DWORD PTR [rax+rcx*4]
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18508], eax

; 5813 : 			g->max_y = g->start_y + h * g->line_size;

	mov	rax, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR h$6[rsp]
	imul	ecx, DWORD PTR [rax+18524]
	mov	eax, ecx
	mov	rcx, QWORD PTR g$[rsp]
	add	eax, DWORD PTR [rcx+18504]
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18512], eax

; 5814 : 			g->cur_x = g->start_x;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18500]
	mov	DWORD PTR [rax+18516], ecx

; 5815 : 			g->cur_y = g->start_y;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18504]
	mov	DWORD PTR [rax+18520], ecx

; 5816 : 
; 5817 : 			g->lflags = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18496], eax

; 5818 : 
; 5819 : 			if (g->lflags & 0x40) {

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18496]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN26@stbi__gif_

; 5820 : 				g->step = 8 * g->line_size; // first interlaced spacing

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18524]
	shl	eax, 3
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18492], eax

; 5821 : 				g->parse = 3;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+18488], 3

; 5822 : 			}

	jmp	SHORT $LN27@stbi__gif_
$LN26@stbi__gif_:

; 5823 : 			else {
; 5824 : 				g->step = g->line_size;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18524]
	mov	DWORD PTR [rax+18492], ecx

; 5825 : 				g->parse = 0;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+18488], 0
$LN27@stbi__gif_:

; 5826 : 			}
; 5827 : 
; 5828 : 			if (g->lflags & 0x80) {

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18496]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN28@stbi__gif_

; 5829 : 				stbi__gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+40]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN42@stbi__gif_
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv251[rsp], eax
	jmp	SHORT $LN43@stbi__gif_
$LN42@stbi__gif_:
	mov	DWORD PTR tv251[rsp], -1
$LN43@stbi__gif_:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18496]
	and	eax, 7
	mov	ecx, 2
	mov	DWORD PTR tv480[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv480[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 1072				; 00000430H
	mov	r9d, DWORD PTR tv251[rsp]
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable

; 5830 : 				g->color_table = (stbi_uc*)g->lpal;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 1072				; 00000430H
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+18480], rax

; 5831 : 			}

	jmp	$LN29@stbi__gif_
$LN28@stbi__gif_:

; 5832 : 			else if (g->flags & 0x80) {

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN30@stbi__gif_

; 5833 : 				if (g->transparent >= 0 && (g->eflags & 0x01)) {

	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+36], 0
	jl	SHORT $LN32@stbi__gif_
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+40]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN32@stbi__gif_

; 5834 : 					prev_trans = g->pal[g->transparent][3];

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4+48]
	mov	ecx, 1
	imul	rcx, rcx, 3
	movzx	eax, BYTE PTR [rax+rcx]
	mov	DWORD PTR prev_trans$2[rsp], eax

; 5835 : 					g->pal[g->transparent][3] = 0;

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4+48]
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	BYTE PTR [rax+rcx], 0
$LN32@stbi__gif_:

; 5836 : 				}
; 5837 : 				g->color_table = (stbi_uc*)g->pal;

	mov	rax, QWORD PTR g$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR g$[rsp]
	mov	QWORD PTR [rcx+18480], rax

; 5838 : 			}

	jmp	SHORT $LN31@stbi__gif_
$LN30@stbi__gif_:

; 5839 : 			else
; 5840 : 				return stbi__errpuc("missing color table", "Corrupt GIF");

	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN31@stbi__gif_:
$LN29@stbi__gif_:

; 5841 : 
; 5842 : 			o = stbi__process_gif_raster(s, g);

	mov	rdx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ; stbi__process_gif_raster
	mov	QWORD PTR o$7[rsp], rax

; 5843 : 			if (o == NULL) return NULL;

	cmp	QWORD PTR o$7[rsp], 0
	jne	SHORT $LN33@stbi__gif_
	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN33@stbi__gif_:

; 5844 : 
; 5845 : 			if (prev_trans != -1)

	cmp	DWORD PTR prev_trans$2[rsp], -1
	je	SHORT $LN34@stbi__gif_

; 5846 : 				g->pal[g->transparent][3] = (stbi_uc)prev_trans;

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+36]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4+48]
	mov	ecx, 1
	imul	rcx, rcx, 3
	movzx	edx, BYTE PTR prev_trans$2[rsp]
	mov	BYTE PTR [rax+rcx], dl
$LN34@stbi__gif_:

; 5847 : 
; 5848 : 			return o;

	mov	rax, QWORD PTR o$7[rsp]
	jmp	$LN1@stbi__gif_
$LN35@stbi__gif_:

; 5849 : 		}
; 5850 : 
; 5851 : 		case 0x21: // Comment Extension.
; 5852 : 		{
; 5853 : 			int len;
; 5854 : 			if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 249				; 000000f9H
	jne	SHORT $LN36@stbi__gif_

; 5855 : 				len = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR len$1[rsp], eax

; 5856 : 				if (len == 4) {

	cmp	DWORD PTR len$1[rsp], 4
	jne	SHORT $LN37@stbi__gif_

; 5857 : 					g->eflags = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+40], eax

; 5858 : 					g->delay = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 5859 : 					g->transparent = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 5860 : 				}

	jmp	SHORT $LN38@stbi__gif_
$LN37@stbi__gif_:

; 5861 : 				else {
; 5862 : 					stbi__skip(s, len);

	mov	edx, DWORD PTR len$1[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 5863 : 					break;

	jmp	SHORT $LN10@stbi__gif_
$LN38@stbi__gif_:
$LN36@stbi__gif_:
$LN12@stbi__gif_:

; 5864 : 				}
; 5865 : 			}
; 5866 : 			while ((len = stbi__get8(s)) != 0)

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR len$1[rsp], eax
	cmp	DWORD PTR len$1[rsp], 0
	je	SHORT $LN13@stbi__gif_

; 5867 : 				stbi__skip(s, len);

	mov	edx, DWORD PTR len$1[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1
	jmp	SHORT $LN12@stbi__gif_
$LN13@stbi__gif_:

; 5868 : 			break;

	jmp	SHORT $LN10@stbi__gif_
$LN39@stbi__gif_:

; 5869 : 		}
; 5870 : 
; 5871 : 		case 0x3B: // gif stream termination code
; 5872 : 			return (stbi_uc*)s; // using '1' causes warning on some compilers

	mov	rax, QWORD PTR s$[rsp]
	jmp	SHORT $LN1@stbi__gif_
$LN40@stbi__gif_:

; 5873 : 
; 5874 : 		default:
; 5875 : 			return stbi__errpuc("unknown code", "Corrupt GIF");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN10@stbi__gif_:

; 5876 : 		}
; 5877 : 	}

	jmp	$LN7@stbi__gif_
$LN1@stbi__gif_:

; 5878 : 
; 5879 : 	STBI_NOTUSED(req_comp);
; 5880 : }

	add	rsp, 136				; 00000088H
	ret	0
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ENDP ; stbi__gif_load_next
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
x$ = 0
y$ = 4
p$1 = 8
c$ = 16
g$ = 48
x0$ = 56
y0$ = 64
x1$ = 72
y1$ = 80
?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z PROC ; stbi__fill_gif_background

; 5747 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5748 : 	int x, y;
; 5749 : 	stbi_uc* c = g->pal[g->bgindex];

	mov	rax, QWORD PTR g$[rsp]
	movsxd	rax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4+48]
	mov	QWORD PTR c$[rsp], rax

; 5750 : 	for (y = y0; y < y1; y += 4 * g->w) {

	mov	eax, DWORD PTR y0$[rsp]
	mov	DWORD PTR y$[rsp], eax
	jmp	SHORT $LN4@stbi__fill
$LN2@stbi__fill:
	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, DWORD PTR y$[rsp]
	lea	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR y$[rsp], eax
$LN4@stbi__fill:
	mov	eax, DWORD PTR y1$[rsp]
	cmp	DWORD PTR y$[rsp], eax
	jge	$LN3@stbi__fill

; 5751 : 		for (x = x0; x < x1; x += 4) {

	mov	eax, DWORD PTR x0$[rsp]
	mov	DWORD PTR x$[rsp], eax
	jmp	SHORT $LN7@stbi__fill
$LN5@stbi__fill:
	mov	eax, DWORD PTR x$[rsp]
	add	eax, 4
	mov	DWORD PTR x$[rsp], eax
$LN7@stbi__fill:
	mov	eax, DWORD PTR x1$[rsp]
	cmp	DWORD PTR x$[rsp], eax
	jge	$LN6@stbi__fill

; 5752 : 			stbi_uc* p = &g->out[y + x];

	mov	eax, DWORD PTR x$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$1[rsp], rax

; 5753 : 			p[0] = c[2];

	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$1[rsp]
	mov	r8, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5754 : 			p[1] = c[1];

	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$1[rsp]
	mov	r8, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5755 : 			p[2] = c[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$1[rsp]
	mov	r8, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5756 : 			p[3] = 0;

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR p$1[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 5757 : 		}

	jmp	$LN5@stbi__fill
$LN6@stbi__fill:

; 5758 : 	}

	jmp	$LN2@stbi__fill
$LN3@stbi__fill:

; 5759 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__fill_gif_background@@YAXPEAUstbi__gif@@HHHH@Z ENDP ; stbi__fill_gif_background
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
lzw_cs$ = 32
tv184 = 33
avail$ = 36
len$ = 40
codesize$ = 44
init_code$ = 48
code$1 = 52
valid_bits$ = 56
bits$ = 60
clear$ = 64
oldcode$ = 68
codemask$ = 72
first$ = 76
p$ = 80
tv216 = 88
tv220 = 92
tv247 = 96
tv274 = 100
tv167 = 104
s$ = 128
g$ = 136
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z PROC ; stbi__process_gif_raster

; 5662 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 5663 : 	stbi_uc lzw_cs;
; 5664 : 	stbi__int32 len, init_code;
; 5665 : 	stbi__uint32 first;
; 5666 : 	stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 5667 : 	stbi__gif_lzw* p;
; 5668 : 
; 5669 : 	lzw_cs = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR lzw_cs$[rsp], al

; 5670 : 	if (lzw_cs > 12) return NULL;

	movzx	eax, BYTE PTR lzw_cs$[rsp]
	cmp	eax, 12
	jle	SHORT $LN10@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN10@stbi__proc:

; 5671 : 	clear = 1 << lzw_cs;

	movzx	eax, BYTE PTR lzw_cs$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv216[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv216[rsp]
	shl	eax, cl
	mov	DWORD PTR clear$[rsp], eax

; 5672 : 	first = 1;

	mov	DWORD PTR first$[rsp], 1

; 5673 : 	codesize = lzw_cs + 1;

	movzx	eax, BYTE PTR lzw_cs$[rsp]
	inc	eax
	mov	DWORD PTR codesize$[rsp], eax

; 5674 : 	codemask = (1 << codesize) - 1;

	mov	eax, DWORD PTR codesize$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv220[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv220[rsp]
	shl	eax, cl
	dec	eax
	mov	DWORD PTR codemask$[rsp], eax

; 5675 : 	bits = 0;

	mov	DWORD PTR bits$[rsp], 0

; 5676 : 	valid_bits = 0;

	mov	DWORD PTR valid_bits$[rsp], 0

; 5677 : 	for (init_code = 0; init_code < clear; init_code++) {

	mov	DWORD PTR init_code$[rsp], 0
	jmp	SHORT $LN4@stbi__proc
$LN2@stbi__proc:
	mov	eax, DWORD PTR init_code$[rsp]
	inc	eax
	mov	DWORD PTR init_code$[rsp], eax
$LN4@stbi__proc:
	mov	eax, DWORD PTR clear$[rsp]
	cmp	DWORD PTR init_code$[rsp], eax
	jge	SHORT $LN3@stbi__proc

; 5678 : 		g->codes[init_code].prefix = -1;

	movsxd	rax, DWORD PTR init_code$[rsp]
	mov	ecx, -1
	mov	rdx, QWORD PTR g$[rsp]
	mov	WORD PTR [rdx+rax*4+2096], cx

; 5679 : 		g->codes[init_code].first = (stbi_uc)init_code;

	movsxd	rax, DWORD PTR init_code$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	edx, BYTE PTR init_code$[rsp]
	mov	BYTE PTR [rcx+rax*4+2098], dl

; 5680 : 		g->codes[init_code].suffix = (stbi_uc)init_code;

	movsxd	rax, DWORD PTR init_code$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	edx, BYTE PTR init_code$[rsp]
	mov	BYTE PTR [rcx+rax*4+2099], dl

; 5681 : 	}

	jmp	SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 5682 : 
; 5683 : 	// support no starting clear code
; 5684 : 	avail = clear + 2;

	mov	eax, DWORD PTR clear$[rsp]
	add	eax, 2
	mov	DWORD PTR avail$[rsp], eax

; 5685 : 	oldcode = -1;

	mov	DWORD PTR oldcode$[rsp], -1

; 5686 : 
; 5687 : 	len = 0;

	mov	DWORD PTR len$[rsp], 0
$LN5@stbi__proc:

; 5688 : 	for (;;) {
; 5689 : 		if (valid_bits < codesize) {

	mov	eax, DWORD PTR codesize$[rsp]
	cmp	DWORD PTR valid_bits$[rsp], eax
	jge	SHORT $LN11@stbi__proc

; 5690 : 			if (len == 0) {

	cmp	DWORD PTR len$[rsp], 0
	jne	SHORT $LN13@stbi__proc

; 5691 : 				len = stbi__get8(s); // start new block

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR len$[rsp], eax

; 5692 : 				if (len == 0)

	cmp	DWORD PTR len$[rsp], 0
	jne	SHORT $LN14@stbi__proc

; 5693 : 					return g->out;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	jmp	$LN1@stbi__proc
$LN14@stbi__proc:
$LN13@stbi__proc:

; 5694 : 			}
; 5695 : 			--len;

	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax

; 5696 : 			bits |= (stbi__int32)stbi__get8(s) << valid_bits;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	ecx, DWORD PTR valid_bits$[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR bits$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR bits$[rsp], eax

; 5697 : 			valid_bits += 8;

	mov	eax, DWORD PTR valid_bits$[rsp]
	add	eax, 8
	mov	DWORD PTR valid_bits$[rsp], eax

; 5698 : 		}

	jmp	$LN12@stbi__proc
$LN11@stbi__proc:

; 5699 : 		else {
; 5700 : 			stbi__int32 code = bits & codemask;

	mov	eax, DWORD PTR codemask$[rsp]
	mov	ecx, DWORD PTR bits$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR code$1[rsp], eax

; 5701 : 			bits >>= codesize;

	mov	eax, DWORD PTR codesize$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR bits$[rsp]
	sar	eax, cl
	mov	DWORD PTR bits$[rsp], eax

; 5702 : 			valid_bits -= codesize;

	mov	eax, DWORD PTR codesize$[rsp]
	mov	ecx, DWORD PTR valid_bits$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR valid_bits$[rsp], eax

; 5703 : 			// @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 5704 : 			if (code == clear) {  // clear code

	mov	eax, DWORD PTR clear$[rsp]
	cmp	DWORD PTR code$1[rsp], eax
	jne	SHORT $LN15@stbi__proc

; 5705 : 				codesize = lzw_cs + 1;

	movzx	eax, BYTE PTR lzw_cs$[rsp]
	inc	eax
	mov	DWORD PTR codesize$[rsp], eax

; 5706 : 				codemask = (1 << codesize) - 1;

	mov	eax, DWORD PTR codesize$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv247[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv247[rsp]
	shl	eax, cl
	dec	eax
	mov	DWORD PTR codemask$[rsp], eax

; 5707 : 				avail = clear + 2;

	mov	eax, DWORD PTR clear$[rsp]
	add	eax, 2
	mov	DWORD PTR avail$[rsp], eax

; 5708 : 				oldcode = -1;

	mov	DWORD PTR oldcode$[rsp], -1

; 5709 : 				first = 0;

	mov	DWORD PTR first$[rsp], 0

; 5710 : 			}

	jmp	$LN16@stbi__proc
$LN15@stbi__proc:

; 5711 : 			else if (code == clear + 1) { // end of stream code

	mov	eax, DWORD PTR clear$[rsp]
	inc	eax
	cmp	DWORD PTR code$1[rsp], eax
	jne	SHORT $LN17@stbi__proc

; 5712 : 				stbi__skip(s, len);

	mov	edx, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1
$LN8@stbi__proc:

; 5713 : 				while ((len = stbi__get8(s)) > 0)

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR len$[rsp], eax
	cmp	DWORD PTR len$[rsp], 0
	jle	SHORT $LN9@stbi__proc

; 5714 : 					stbi__skip(s, len);

	mov	edx, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1
	jmp	SHORT $LN8@stbi__proc
$LN9@stbi__proc:

; 5715 : 				return g->out;

	mov	rax, QWORD PTR g$[rsp]
	mov	rax, QWORD PTR [rax+8]
	jmp	$LN1@stbi__proc

; 5716 : 			}

	jmp	$LN18@stbi__proc
$LN17@stbi__proc:

; 5717 : 			else if (code <= avail) {

	mov	eax, DWORD PTR avail$[rsp]
	cmp	DWORD PTR code$1[rsp], eax
	jg	$LN19@stbi__proc

; 5718 : 				if (first) return stbi__errpuc("no clear code", "Corrupt GIF");

	cmp	DWORD PTR first$[rsp], 0
	je	SHORT $LN21@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN21@stbi__proc:

; 5719 : 
; 5720 : 				if (oldcode >= 0) {

	cmp	DWORD PTR oldcode$[rsp], 0
	jl	$LN22@stbi__proc

; 5721 : 					p = &g->codes[avail++];

	movsxd	rax, DWORD PTR avail$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4+2096]
	mov	QWORD PTR tv167[rsp], rax
	mov	eax, DWORD PTR avail$[rsp]
	inc	eax
	mov	DWORD PTR avail$[rsp], eax
	mov	rax, QWORD PTR tv167[rsp]
	mov	QWORD PTR p$[rsp], rax

; 5722 : 					if (avail > 4096)        return stbi__errpuc("too many codes", "Corrupt GIF");

	cmp	DWORD PTR avail$[rsp], 4096		; 00001000H
	jle	SHORT $LN24@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN24@stbi__proc:

; 5723 : 					p->prefix = (stbi__int16)oldcode;

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, WORD PTR oldcode$[rsp]
	mov	WORD PTR [rax], cx

; 5724 : 					p->first = g->codes[oldcode].first;

	movsxd	rax, DWORD PTR oldcode$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rdx+rax*4+2098]
	mov	BYTE PTR [rcx+2], al

; 5725 : 					p->suffix = (code == avail) ? p->first : g->codes[code].first;

	mov	eax, DWORD PTR avail$[rsp]
	cmp	DWORD PTR code$1[rsp], eax
	jne	SHORT $LN28@stbi__proc
	mov	rax, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rax+2]
	mov	BYTE PTR tv184[rsp], al
	jmp	SHORT $LN29@stbi__proc
$LN28@stbi__proc:
	movsxd	rax, DWORD PTR code$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+2098]
	mov	BYTE PTR tv184[rsp], al
$LN29@stbi__proc:
	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR tv184[rsp]
	mov	BYTE PTR [rax+3], cl

; 5726 : 				}

	jmp	SHORT $LN23@stbi__proc
$LN22@stbi__proc:

; 5727 : 				else if (code == avail)

	mov	eax, DWORD PTR avail$[rsp]
	cmp	DWORD PTR code$1[rsp], eax
	jne	SHORT $LN25@stbi__proc

; 5728 : 					return stbi__errpuc("illegal code in raster", "Corrupt GIF");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__proc
$LN25@stbi__proc:
$LN23@stbi__proc:

; 5729 : 
; 5730 : 				stbi__out_gif_code(g, (stbi__uint16)code);

	movzx	edx, WORD PTR code$1[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	call	?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code
	npad	1

; 5731 : 
; 5732 : 				if ((avail & codemask) == 0 && avail <= 0x0FFF) {

	mov	eax, DWORD PTR codemask$[rsp]
	mov	ecx, DWORD PTR avail$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN26@stbi__proc
	cmp	DWORD PTR avail$[rsp], 4095		; 00000fffH
	jg	SHORT $LN26@stbi__proc

; 5733 : 					codesize++;

	mov	eax, DWORD PTR codesize$[rsp]
	inc	eax
	mov	DWORD PTR codesize$[rsp], eax

; 5734 : 					codemask = (1 << codesize) - 1;

	mov	eax, DWORD PTR codesize$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv274[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv274[rsp]
	shl	eax, cl
	dec	eax
	mov	DWORD PTR codemask$[rsp], eax
$LN26@stbi__proc:

; 5735 : 				}
; 5736 : 
; 5737 : 				oldcode = code;

	mov	eax, DWORD PTR code$1[rsp]
	mov	DWORD PTR oldcode$[rsp], eax

; 5738 : 			}

	jmp	SHORT $LN20@stbi__proc
$LN19@stbi__proc:

; 5739 : 			else {
; 5740 : 				return stbi__errpuc("illegal code in raster", "Corrupt GIF");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__proc
$LN20@stbi__proc:
$LN18@stbi__proc:
$LN16@stbi__proc:
$LN12@stbi__proc:

; 5741 : 			}
; 5742 : 		}
; 5743 : 	}

	jmp	$LN5@stbi__proc
$LN1@stbi__proc:

; 5744 : }

	add	rsp, 120				; 00000078H
	ret	0
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ENDP ; stbi__process_gif_raster
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv246 = 32
c$ = 40
p$ = 48
g$ = 80
code$ = 88
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z PROC		; stbi__out_gif_code

; 5628 : {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 5629 : 	stbi_uc* p, * c;
; 5630 : 
; 5631 : 	// recurse to decode the prefixes, since the linked-list is backwards,
; 5632 : 	// and working backwards through an interleaved image would be nasty
; 5633 : 	if (g->codes[code].prefix >= 0)

	movzx	eax, WORD PTR code$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movsx	eax, WORD PTR [rcx+rax*4+2096]
	test	eax, eax
	jl	SHORT $LN4@stbi__out_

; 5634 : 		stbi__out_gif_code(g, g->codes[code].prefix);

	movzx	eax, WORD PTR code$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	edx, WORD PTR [rcx+rax*4+2096]
	mov	rcx, QWORD PTR g$[rsp]
	call	?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code
	npad	1
$LN4@stbi__out_:

; 5635 : 
; 5636 : 	if (g->cur_y >= g->max_y) return;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18512]
	cmp	DWORD PTR [rax+18520], ecx
	jl	SHORT $LN5@stbi__out_
	jmp	$LN1@stbi__out_
$LN5@stbi__out_:

; 5637 : 
; 5638 : 	p = &g->out[g->cur_x + g->cur_y];

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18516]
	mov	rcx, QWORD PTR g$[rsp]
	add	eax, DWORD PTR [rcx+18520]
	cdqe
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 5639 : 	c = &g->color_table[g->codes[code].suffix * 4];

	movzx	eax, WORD PTR code$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+2099]
	shl	eax, 2
	cdqe
	mov	rcx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR [rcx+18480]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR c$[rsp], rax

; 5640 : 
; 5641 : 	if (c[3] >= 128) {

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 128				; 00000080H
	jl	$LN6@stbi__out_

; 5642 : 		p[0] = c[2];

	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5643 : 		p[1] = c[1];

	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5644 : 		p[2] = c[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5645 : 		p[3] = c[3];

	mov	eax, 1
	imul	rax, rax, 3
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR c$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN6@stbi__out_:

; 5646 : 	}
; 5647 : 	g->cur_x += 4;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18516]
	add	eax, 4
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18516], eax

; 5648 : 
; 5649 : 	if (g->cur_x >= g->max_x) {

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18508]
	cmp	DWORD PTR [rax+18516], ecx
	jl	$LN7@stbi__out_

; 5650 : 		g->cur_x = g->start_x;

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18500]
	mov	DWORD PTR [rax+18516], ecx

; 5651 : 		g->cur_y += g->step;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18520]
	mov	rcx, QWORD PTR g$[rsp]
	add	eax, DWORD PTR [rcx+18492]
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18520], eax
$LN2@stbi__out_:

; 5652 : 
; 5653 : 		while (g->cur_y >= g->max_y && g->parse > 0) {

	mov	rax, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR g$[rsp]
	mov	ecx, DWORD PTR [rcx+18512]
	cmp	DWORD PTR [rax+18520], ecx
	jl	$LN3@stbi__out_
	mov	rax, QWORD PTR g$[rsp]
	cmp	DWORD PTR [rax+18488], 0
	jle	SHORT $LN3@stbi__out_

; 5654 : 			g->step = (1 << g->parse) * g->line_size;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18488]
	mov	ecx, 1
	mov	DWORD PTR tv246[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv246[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR g$[rsp]
	imul	eax, DWORD PTR [rcx+18524]
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18492], eax

; 5655 : 			g->cur_y = g->start_y + (g->step >> 1);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18492]
	sar	eax, 1
	mov	rcx, QWORD PTR g$[rsp]
	add	eax, DWORD PTR [rcx+18504]
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18520], eax

; 5656 : 			--g->parse;

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+18488]
	dec	eax
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+18488], eax

; 5657 : 		}

	jmp	$LN2@stbi__out_
$LN3@stbi__out_:
$LN7@stbi__out_:
$LN1@stbi__out_:

; 5658 : 	}
; 5659 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ENDP		; stbi__out_gif_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
g$ = 32
__$ArrayPad$ = 18560
s$ = 18592
x$ = 18600
y$ = 18608
comp$ = 18616
?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z PROC ; stbi__gif_info_raw

; 5616 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 18584				; 00004898H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5617 : 	stbi__gif g;
; 5618 : 	if (!stbi__gif_header(s, &g, comp, 1)) {

	mov	r9d, 1
	mov	r8, QWORD PTR comp$[rsp]
	lea	rdx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_header
	test	eax, eax
	jne	SHORT $LN2@stbi__gif_

; 5619 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 5620 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 5621 : 	}
; 5622 : 	if (x) *x = g.w;

	cmp	QWORD PTR x$[rsp], 0
	je	SHORT $LN3@stbi__gif_
	mov	rax, QWORD PTR x$[rsp]
	mov	ecx, DWORD PTR g$[rsp]
	mov	DWORD PTR [rax], ecx
$LN3@stbi__gif_:

; 5623 : 	if (y) *y = g.h;

	cmp	QWORD PTR y$[rsp], 0
	je	SHORT $LN4@stbi__gif_
	mov	rax, QWORD PTR y$[rsp]
	mov	ecx, DWORD PTR g$[rsp+4]
	mov	DWORD PTR [rax], ecx
$LN4@stbi__gif_:

; 5624 : 	return 1;

	mov	eax, 1
$LN1@stbi__gif_:

; 5625 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 18584				; 00004898H
	ret	0
?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z ENDP ; stbi__gif_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
version$ = 32
tv190 = 36
s$ = 64
g$ = 72
comp$ = 80
is_info$ = 88
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z PROC ; stbi__gif_header

; 5588 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5589 : 	stbi_uc version;
; 5590 : 	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 71					; 00000047H
	jne	SHORT $LN3@stbi__gif_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 73					; 00000049H
	jne	SHORT $LN3@stbi__gif_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN3@stbi__gif_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 56					; 00000038H
	je	SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 5591 : 		return stbi__err("not GIF", "Corrupt GIF");

	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN2@stbi__gif_:

; 5592 : 
; 5593 : 	version = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR version$[rsp], al

; 5594 : 	if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");

	movzx	eax, BYTE PTR version$[rsp]
	cmp	eax, 55					; 00000037H
	je	SHORT $LN4@stbi__gif_
	movzx	eax, BYTE PTR version$[rsp]
	cmp	eax, 57					; 00000039H
	je	SHORT $LN4@stbi__gif_
	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN4@stbi__gif_:

; 5595 : 	if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 97					; 00000061H
	je	SHORT $LN5@stbi__gif_
	xor	eax, eax
	jmp	$LN1@stbi__gif_
$LN5@stbi__gif_:

; 5596 : 
; 5597 : 	stbi__g_failure_reason = "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR ?stbi__g_failure_reason@@3PEBDEB, rax

; 5598 : 	g->w = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx], eax

; 5599 : 	g->h = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 5600 : 	g->flags = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 5601 : 	g->bgindex = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 5602 : 	g->ratio = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR g$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 5603 : 	g->transparent = -1;

	mov	rax, QWORD PTR g$[rsp]
	mov	DWORD PTR [rax+36], -1

; 5604 : 
; 5605 : 	if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN6@stbi__gif_
	mov	rax, QWORD PTR comp$[rsp]
	mov	DWORD PTR [rax], 4
$LN6@stbi__gif_:

; 5606 : 
; 5607 : 	if (is_info) return 1;

	cmp	DWORD PTR is_info$[rsp], 0
	je	SHORT $LN7@stbi__gif_
	mov	eax, 1
	jmp	SHORT $LN1@stbi__gif_
$LN7@stbi__gif_:

; 5608 : 
; 5609 : 	if (g->flags & 0x80)

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN8@stbi__gif_

; 5610 : 		stbi__gif_parse_colortable(s, g->pal, 2 << (g->flags & 7), -1);

	mov	rax, QWORD PTR g$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 7
	mov	ecx, 2
	mov	DWORD PTR tv190[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv190[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR g$[rsp]
	add	rcx, 48					; 00000030H
	mov	r9d, -1
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable
	npad	1
$LN8@stbi__gif_:

; 5611 : 
; 5612 : 	return 1;

	mov	eax, 1
$LN1@stbi__gif_:

; 5613 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ENDP ; stbi__gif_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv93 = 36
s$ = 64
pal$ = 72
num_entries$ = 80
transp$ = 88
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z PROC ; stbi__gif_parse_colortable

; 5577 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5578 : 	int i;
; 5579 : 	for (i = 0; i < num_entries; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__gif_:
	mov	eax, DWORD PTR num_entries$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbi__gif_

; 5580 : 		pal[i][2] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR pal$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*4]
	mov	edx, 1
	imul	rdx, rdx, 2
	mov	BYTE PTR [rcx+rdx], al

; 5581 : 		pal[i][1] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR pal$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*4]
	mov	edx, 1
	imul	rdx, rdx, 1
	mov	BYTE PTR [rcx+rdx], al

; 5582 : 		pal[i][0] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR pal$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*4]
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	BYTE PTR [rcx+rdx], al

; 5583 : 		pal[i][3] = transp == i ? 0 : 255;

	mov	eax, DWORD PTR i$[rsp]
	cmp	DWORD PTR transp$[rsp], eax
	jne	SHORT $LN6@stbi__gif_
	mov	DWORD PTR tv93[rsp], 0
	jmp	SHORT $LN7@stbi__gif_
$LN6@stbi__gif_:
	mov	DWORD PTR tv93[rsp], 255		; 000000ffH
$LN7@stbi__gif_:
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR pal$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 3
	movzx	edx, BYTE PTR tv93[rsp]
	mov	BYTE PTR [rax+rcx], dl

; 5584 : 	}

	jmp	$LN2@stbi__gif_
$LN3@stbi__gif_:

; 5585 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ENDP ; stbi__gif_parse_colortable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
sz$ = 32
s$ = 64
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__gif_test_raw

; 5560 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5561 : 	int sz;
; 5562 : 	if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 71					; 00000047H
	jne	SHORT $LN3@stbi__gif_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 73					; 00000049H
	jne	SHORT $LN3@stbi__gif_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN3@stbi__gif_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 56					; 00000038H
	je	SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:
	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 5563 : 	sz = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR sz$[rsp], eax

; 5564 : 	if (sz != '9' && sz != '7') return 0;

	cmp	DWORD PTR sz$[rsp], 57			; 00000039H
	je	SHORT $LN4@stbi__gif_
	cmp	DWORD PTR sz$[rsp], 55			; 00000037H
	je	SHORT $LN4@stbi__gif_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN4@stbi__gif_:

; 5565 : 	if (stbi__get8(s) != 'a') return 0;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 97					; 00000061H
	je	SHORT $LN5@stbi__gif_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__gif_
$LN5@stbi__gif_:

; 5566 : 	return 1;

	mov	eax, 1
$LN1@stbi__gif_:

; 5567 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__gif_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
count$1 = 32
count$2 = 36
i$3 = 40
dest$4 = 48
num_packets$ = 56
left$5 = 60
left$6 = 64
packet_idx$7 = 68
y$ = 72
act_comp$ = 76
tv142 = 80
x$8 = 84
i$9 = 88
packet$10 = 96
tv128 = 104
packet$11 = 112
chained$ = 120
value$12 = 124
value$13 = 128
tv71 = 136
packets$ = 144
__$ArrayPad$ = 176
s$ = 208
width$ = 216
height$ = 224
comp$ = 232
result$ = 240
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z PROC ; stbi__pic_load_core

; 5380 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5381 : 	int act_comp = 0, num_packets = 0, y, chained;

	mov	DWORD PTR act_comp$[rsp], 0
	mov	DWORD PTR num_packets$[rsp], 0
$LN4@stbi__pic_:

; 5382 : 	stbi__pic_packet packets[10];
; 5383 : 
; 5384 : 	// this will (should...) cater for even some bizarre stuff like having data
; 5385 : 	// for the same channel in multiple packets.
; 5386 : 	do {
; 5387 : 		stbi__pic_packet* packet;
; 5388 : 
; 5389 : 		if (num_packets == sizeof(packets) / sizeof(packets[0]))

	movsxd	rax, DWORD PTR num_packets$[rsp]
	cmp	rax, 10
	jne	SHORT $LN29@stbi__pic_

; 5390 : 			return stbi__errpuc("bad format", "too many packets");

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN29@stbi__pic_:

; 5391 : 
; 5392 : 		packet = &packets[num_packets++];

	movsxd	rax, DWORD PTR num_packets$[rsp]
	imul	rax, rax, 3
	lea	rax, QWORD PTR packets$[rsp+rax]
	mov	QWORD PTR tv71[rsp], rax
	mov	eax, DWORD PTR num_packets$[rsp]
	inc	eax
	mov	DWORD PTR num_packets$[rsp], eax
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR packet$11[rsp], rax

; 5393 : 
; 5394 : 		chained = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR chained$[rsp], eax

; 5395 : 		packet->size = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR packet$11[rsp]
	mov	BYTE PTR [rcx], al

; 5396 : 		packet->type = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR packet$11[rsp]
	mov	BYTE PTR [rcx+1], al

; 5397 : 		packet->channel = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR packet$11[rsp]
	mov	BYTE PTR [rcx+2], al

; 5398 : 
; 5399 : 		act_comp |= packet->channel;

	mov	rax, QWORD PTR packet$11[rsp]
	movzx	eax, BYTE PTR [rax+2]
	mov	ecx, DWORD PTR act_comp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR act_comp$[rsp], eax

; 5400 : 
; 5401 : 		if (stbi__at_eof(s))          return stbi__errpuc("bad file", "file too short (reading packets)");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN30@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN30@stbi__pic_:

; 5402 : 		if (packet->size != 8)  return stbi__errpuc("bad format", "packet isn't 8bpp");

	mov	rax, QWORD PTR packet$11[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 8
	je	SHORT $LN31@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN31@stbi__pic_:

; 5403 : 	} while (chained);

	cmp	DWORD PTR chained$[rsp], 0
	jne	$LN4@stbi__pic_

; 5404 : 
; 5405 : 	*comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

	mov	eax, DWORD PTR act_comp$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN50@stbi__pic_
	mov	DWORD PTR tv128[rsp], 4
	jmp	SHORT $LN51@stbi__pic_
$LN50@stbi__pic_:
	mov	DWORD PTR tv128[rsp], 3
$LN51@stbi__pic_:
	mov	rax, QWORD PTR comp$[rsp]
	mov	ecx, DWORD PTR tv128[rsp]
	mov	DWORD PTR [rax], ecx

; 5406 : 
; 5407 : 	for (y = 0; y < height; ++y) {

	mov	DWORD PTR y$[rsp], 0
	jmp	SHORT $LN7@stbi__pic_
$LN5@stbi__pic_:
	mov	eax, DWORD PTR y$[rsp]
	inc	eax
	mov	DWORD PTR y$[rsp], eax
$LN7@stbi__pic_:
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR y$[rsp], eax
	jge	$LN6@stbi__pic_

; 5408 : 		int packet_idx;
; 5409 : 
; 5410 : 		for (packet_idx = 0; packet_idx < num_packets; ++packet_idx) {

	mov	DWORD PTR packet_idx$7[rsp], 0
	jmp	SHORT $LN10@stbi__pic_
$LN8@stbi__pic_:
	mov	eax, DWORD PTR packet_idx$7[rsp]
	inc	eax
	mov	DWORD PTR packet_idx$7[rsp], eax
$LN10@stbi__pic_:
	mov	eax, DWORD PTR num_packets$[rsp]
	cmp	DWORD PTR packet_idx$7[rsp], eax
	jge	$LN9@stbi__pic_

; 5411 : 			stbi__pic_packet* packet = &packets[packet_idx];

	movsxd	rax, DWORD PTR packet_idx$7[rsp]
	imul	rax, rax, 3
	lea	rax, QWORD PTR packets$[rsp+rax]
	mov	QWORD PTR packet$10[rsp], rax

; 5412 : 			stbi_uc* dest = result + y * width * 4;

	mov	eax, DWORD PTR y$[rsp]
	imul	eax, DWORD PTR width$[rsp]
	shl	eax, 2
	cdqe
	mov	rcx, QWORD PTR result$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dest$4[rsp], rax

; 5413 : 
; 5414 : 			switch (packet->type) {

	mov	rax, QWORD PTR packet$10[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR tv142[rsp], al
	cmp	BYTE PTR tv142[rsp], 0
	je	SHORT $LN33@stbi__pic_
	cmp	BYTE PTR tv142[rsp], 1
	je	SHORT $LN35@stbi__pic_
	cmp	BYTE PTR tv142[rsp], 2
	je	$LN39@stbi__pic_

; 5415 : 			default:
; 5416 : 				return stbi__errpuc("bad format", "packet has bad compression type");

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN33@stbi__pic_:

; 5417 : 
; 5418 : 			case 0: {//uncompressed
; 5419 : 				int x;
; 5420 : 
; 5421 : 				for (x = 0; x < width; ++x, dest += 4)

	mov	DWORD PTR x$8[rsp], 0
	jmp	SHORT $LN15@stbi__pic_
$LN13@stbi__pic_:
	mov	eax, DWORD PTR x$8[rsp]
	inc	eax
	mov	DWORD PTR x$8[rsp], eax
	mov	rax, QWORD PTR dest$4[rsp]
	add	rax, 4
	mov	QWORD PTR dest$4[rsp], rax
$LN15@stbi__pic_:
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR x$8[rsp], eax
	jge	SHORT $LN14@stbi__pic_

; 5422 : 					if (!stbi__readval(s, packet->channel, dest))

	mov	rax, QWORD PTR packet$10[rsp]
	movzx	eax, BYTE PTR [rax+2]
	mov	r8, QWORD PTR dest$4[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	jne	SHORT $LN34@stbi__pic_

; 5423 : 						return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN34@stbi__pic_:
	jmp	SHORT $LN13@stbi__pic_
$LN14@stbi__pic_:

; 5424 : 				break;

	jmp	$LN11@stbi__pic_
$LN35@stbi__pic_:

; 5425 : 			}
; 5426 : 
; 5427 : 			case 1://Pure RLE
; 5428 : 			{
; 5429 : 				int left = width, i;

	mov	eax, DWORD PTR width$[rsp]
	mov	DWORD PTR left$5[rsp], eax
$LN16@stbi__pic_:

; 5430 : 
; 5431 : 				while (left > 0) {

	cmp	DWORD PTR left$5[rsp], 0
	jle	$LN17@stbi__pic_

; 5432 : 					stbi_uc count, value[4];
; 5433 : 
; 5434 : 					count = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR count$1[rsp], al

; 5435 : 					if (stbi__at_eof(s))   return stbi__errpuc("bad file", "file too short (pure read count)");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN36@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN36@stbi__pic_:

; 5436 : 
; 5437 : 					if (count > left)

	movzx	eax, BYTE PTR count$1[rsp]
	cmp	eax, DWORD PTR left$5[rsp]
	jle	SHORT $LN37@stbi__pic_

; 5438 : 						count = (stbi_uc)left;

	movzx	eax, BYTE PTR left$5[rsp]
	mov	BYTE PTR count$1[rsp], al
$LN37@stbi__pic_:

; 5439 : 
; 5440 : 					if (!stbi__readval(s, packet->channel, value))  return 0;

	mov	rax, QWORD PTR packet$10[rsp]
	movzx	eax, BYTE PTR [rax+2]
	lea	r8, QWORD PTR value$12[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	jne	SHORT $LN38@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN38@stbi__pic_:

; 5441 : 
; 5442 : 					for (i = 0; i < count; ++i, dest += 4)

	mov	DWORD PTR i$9[rsp], 0
	jmp	SHORT $LN20@stbi__pic_
$LN18@stbi__pic_:
	mov	eax, DWORD PTR i$9[rsp]
	inc	eax
	mov	DWORD PTR i$9[rsp], eax
	mov	rax, QWORD PTR dest$4[rsp]
	add	rax, 4
	mov	QWORD PTR dest$4[rsp], rax
$LN20@stbi__pic_:
	movzx	eax, BYTE PTR count$1[rsp]
	cmp	DWORD PTR i$9[rsp], eax
	jge	SHORT $LN19@stbi__pic_

; 5443 : 						stbi__copyval(packet->channel, dest, value);

	mov	rax, QWORD PTR packet$10[rsp]
	movzx	eax, BYTE PTR [rax+2]
	lea	r8, QWORD PTR value$12[rsp]
	mov	rdx, QWORD PTR dest$4[rsp]
	mov	ecx, eax
	call	?stbi__copyval@@YAXHPEAEPEBE@Z		; stbi__copyval
	npad	1
	jmp	SHORT $LN18@stbi__pic_
$LN19@stbi__pic_:

; 5444 : 					left -= count;

	movzx	eax, BYTE PTR count$1[rsp]
	mov	ecx, DWORD PTR left$5[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR left$5[rsp], eax

; 5445 : 				}

	jmp	$LN16@stbi__pic_
$LN17@stbi__pic_:

; 5446 : 			}
; 5447 : 			break;

	jmp	$LN11@stbi__pic_
$LN39@stbi__pic_:

; 5448 : 
; 5449 : 			case 2: {//Mixed RLE
; 5450 : 				int left = width;

	mov	eax, DWORD PTR width$[rsp]
	mov	DWORD PTR left$6[rsp], eax
$LN21@stbi__pic_:

; 5451 : 				while (left > 0) {

	cmp	DWORD PTR left$6[rsp], 0
	jle	$LN22@stbi__pic_

; 5452 : 					int count = stbi__get8(s), i;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR count$2[rsp], eax

; 5453 : 					if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (mixed read count)");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN40@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN40@stbi__pic_:

; 5454 : 
; 5455 : 					if (count >= 128) { // Repeated

	cmp	DWORD PTR count$2[rsp], 128		; 00000080H
	jl	$LN41@stbi__pic_

; 5456 : 						stbi_uc value[4];
; 5457 : 
; 5458 : 						if (count == 128)

	cmp	DWORD PTR count$2[rsp], 128		; 00000080H
	jne	SHORT $LN43@stbi__pic_

; 5459 : 							count = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR count$2[rsp], eax
	jmp	SHORT $LN44@stbi__pic_
$LN43@stbi__pic_:

; 5460 : 						else
; 5461 : 							count -= 127;

	mov	eax, DWORD PTR count$2[rsp]
	sub	eax, 127				; 0000007fH
	mov	DWORD PTR count$2[rsp], eax
$LN44@stbi__pic_:

; 5462 : 						if (count > left)

	mov	eax, DWORD PTR left$6[rsp]
	cmp	DWORD PTR count$2[rsp], eax
	jle	SHORT $LN45@stbi__pic_

; 5463 : 							return stbi__errpuc("bad file", "scanline overrun");

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN45@stbi__pic_:

; 5464 : 
; 5465 : 						if (!stbi__readval(s, packet->channel, value))

	mov	rax, QWORD PTR packet$10[rsp]
	movzx	eax, BYTE PTR [rax+2]
	lea	r8, QWORD PTR value$13[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	jne	SHORT $LN46@stbi__pic_

; 5466 : 							return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN46@stbi__pic_:

; 5467 : 
; 5468 : 						for (i = 0; i < count; ++i, dest += 4)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN25@stbi__pic_
$LN23@stbi__pic_:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
	mov	rax, QWORD PTR dest$4[rsp]
	add	rax, 4
	mov	QWORD PTR dest$4[rsp], rax
$LN25@stbi__pic_:
	mov	eax, DWORD PTR count$2[rsp]
	cmp	DWORD PTR i$3[rsp], eax
	jge	SHORT $LN24@stbi__pic_

; 5469 : 							stbi__copyval(packet->channel, dest, value);

	mov	rax, QWORD PTR packet$10[rsp]
	movzx	eax, BYTE PTR [rax+2]
	lea	r8, QWORD PTR value$13[rsp]
	mov	rdx, QWORD PTR dest$4[rsp]
	mov	ecx, eax
	call	?stbi__copyval@@YAXHPEAEPEBE@Z		; stbi__copyval
	npad	1
	jmp	SHORT $LN23@stbi__pic_
$LN24@stbi__pic_:

; 5470 : 					}

	jmp	SHORT $LN42@stbi__pic_
$LN41@stbi__pic_:

; 5471 : 					else { // Raw
; 5472 : 						++count;

	mov	eax, DWORD PTR count$2[rsp]
	inc	eax
	mov	DWORD PTR count$2[rsp], eax

; 5473 : 						if (count > left) return stbi__errpuc("bad file", "scanline overrun");

	mov	eax, DWORD PTR left$6[rsp]
	cmp	DWORD PTR count$2[rsp], eax
	jle	SHORT $LN47@stbi__pic_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN47@stbi__pic_:

; 5474 : 
; 5475 : 						for (i = 0; i < count; ++i, dest += 4)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN28@stbi__pic_
$LN26@stbi__pic_:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
	mov	rax, QWORD PTR dest$4[rsp]
	add	rax, 4
	mov	QWORD PTR dest$4[rsp], rax
$LN28@stbi__pic_:
	mov	eax, DWORD PTR count$2[rsp]
	cmp	DWORD PTR i$3[rsp], eax
	jge	SHORT $LN27@stbi__pic_

; 5476 : 							if (!stbi__readval(s, packet->channel, dest))

	mov	rax, QWORD PTR packet$10[rsp]
	movzx	eax, BYTE PTR [rax+2]
	mov	r8, QWORD PTR dest$4[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
	test	rax, rax
	jne	SHORT $LN48@stbi__pic_

; 5477 : 								return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN48@stbi__pic_:
	jmp	SHORT $LN26@stbi__pic_
$LN27@stbi__pic_:
$LN42@stbi__pic_:

; 5478 : 					}
; 5479 : 					left -= count;

	mov	eax, DWORD PTR count$2[rsp]
	mov	ecx, DWORD PTR left$6[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR left$6[rsp], eax

; 5480 : 				}

	jmp	$LN21@stbi__pic_
$LN22@stbi__pic_:
$LN11@stbi__pic_:

; 5481 : 				break;
; 5482 : 			}
; 5483 : 			}
; 5484 : 		}

	jmp	$LN8@stbi__pic_
$LN9@stbi__pic_:

; 5485 : 	}

	jmp	$LN5@stbi__pic_
$LN6@stbi__pic_:

; 5486 : 
; 5487 : 	return result;

	mov	rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 5488 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	ret	0
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ENDP ; stbi__pic_load_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
mask$ = 4
channel$ = 32
dest$ = 40
src$ = 48
?stbi__copyval@@YAXHPEAEPEBE@Z PROC			; stbi__copyval

; 5371 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 5372 : 	int mask = 0x80, i;

	mov	DWORD PTR mask$[rsp], 128		; 00000080H

; 5373 : 
; 5374 : 	for (i = 0; i < 4; ++i, mask >>= 1)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__copy
$LN2@stbi__copy:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	eax, DWORD PTR mask$[rsp]
	sar	eax, 1
	mov	DWORD PTR mask$[rsp], eax
$LN4@stbi__copy:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@stbi__copy

; 5375 : 		if (channel & mask)

	mov	eax, DWORD PTR mask$[rsp]
	mov	ecx, DWORD PTR channel$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN5@stbi__copy

; 5376 : 			dest[i] = src[i];

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR dest$[rsp]
	mov	r8, QWORD PTR src$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN5@stbi__copy:
	jmp	SHORT $LN2@stbi__copy
$LN3@stbi__copy:

; 5377 : }

	add	rsp, 24
	ret	0
?stbi__copyval@@YAXHPEAEPEBE@Z ENDP			; stbi__copyval
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
mask$ = 36
s$ = 64
channel$ = 72
dest$ = 80
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z PROC	; stbi__readval

; 5357 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5358 : 	int mask = 0x80, i;

	mov	DWORD PTR mask$[rsp], 128		; 00000080H

; 5359 : 
; 5360 : 	for (i = 0; i < 4; ++i, mask >>= 1) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__read
$LN2@stbi__read:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	eax, DWORD PTR mask$[rsp]
	sar	eax, 1
	mov	DWORD PTR mask$[rsp], eax
$LN4@stbi__read:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@stbi__read

; 5361 : 		if (channel & mask) {

	mov	eax, DWORD PTR mask$[rsp]
	mov	ecx, DWORD PTR channel$[rsp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN5@stbi__read

; 5362 : 			if (stbi__at_eof(s)) return stbi__errpuc("bad file", "PIC file too short");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN6@stbi__read
	xor	eax, eax
	jmp	SHORT $LN1@stbi__read
$LN6@stbi__read:

; 5363 : 			dest[i] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR dest$[rsp]
	mov	BYTE PTR [rdx+rcx], al
$LN5@stbi__read:

; 5364 : 		}
; 5365 : 	}

	jmp	SHORT $LN2@stbi__read
$LN3@stbi__read:

; 5366 : 
; 5367 : 	return dest;

	mov	rax, QWORD PTR dest$[rsp]
$LN1@stbi__read:

; 5368 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ENDP	; stbi__readval
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z PROC	; stbi__pic_test_core

; 5336 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5337 : 	int i;
; 5338 : 
; 5339 : 	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34"))

	lea	rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	jne	SHORT $LN5@stbi__pic_

; 5340 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:

; 5341 : 
; 5342 : 	for (i = 0; i < 84; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
	cmp	DWORD PTR i$[rsp], 84			; 00000054H
	jge	SHORT $LN3@stbi__pic_

; 5343 : 		stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	npad	1
	jmp	SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 5344 : 
; 5345 : 	if (!stbi__pic_is4(s, "PICT"))

	lea	rdx, OFFSET FLAT:??_C@_04ELNJHLFH@PICT@
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	jne	SHORT $LN6@stbi__pic_

; 5346 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN6@stbi__pic_:

; 5347 : 
; 5348 : 	return 1;

	mov	eax, 1
$LN1@stbi__pic_:

; 5349 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z ENDP	; stbi__pic_test_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
str$ = 72
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z PROC	; stbi__pic_is4

; 5326 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5327 : 	int i;
; 5328 : 	for (i = 0; i < 4; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
	cmp	DWORD PTR i$[rsp], 4
	jge	SHORT $LN3@stbi__pic_

; 5329 : 		if (stbi__get8(s) != (stbi_uc)str[i])

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR str$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	je	SHORT $LN5@stbi__pic_

; 5330 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:
	jmp	SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 5331 : 
; 5332 : 	return 1;

	mov	eax, 1
$LN1@stbi__pic_:

; 5333 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ENDP	; stbi__pic_is4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
z$ = 0
result$ = 4
v$ = 32
shift$ = 40
bits$ = 48
?stbi__shiftsigned@@YAHHHH@Z PROC			; stbi__shiftsigned

; 4632 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 4633 : 	int result;
; 4634 : 	int z = 0;

	mov	DWORD PTR z$[rsp], 0

; 4635 : 
; 4636 : 	if (shift < 0) v <<= -shift;

	cmp	DWORD PTR shift$[rsp], 0
	jge	SHORT $LN4@stbi__shif
	mov	eax, DWORD PTR shift$[rsp]
	neg	eax
	movzx	ecx, al
	mov	eax, DWORD PTR v$[rsp]
	shl	eax, cl
	mov	DWORD PTR v$[rsp], eax
	jmp	SHORT $LN5@stbi__shif
$LN4@stbi__shif:

; 4637 : 	else v >>= shift;

	mov	eax, DWORD PTR shift$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, cl
	mov	DWORD PTR v$[rsp], eax
$LN5@stbi__shif:

; 4638 : 	result = v;

	mov	eax, DWORD PTR v$[rsp]
	mov	DWORD PTR result$[rsp], eax

; 4639 : 
; 4640 : 	z = bits;

	mov	eax, DWORD PTR bits$[rsp]
	mov	DWORD PTR z$[rsp], eax
$LN2@stbi__shif:

; 4641 : 	while (z < 8) {

	cmp	DWORD PTR z$[rsp], 8
	jge	SHORT $LN3@stbi__shif

; 4642 : 		result += v >> z;

	mov	eax, DWORD PTR z$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR v$[rsp]
	sar	eax, cl
	mov	ecx, DWORD PTR result$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR result$[rsp], eax

; 4643 : 		z += bits;

	mov	eax, DWORD PTR bits$[rsp]
	mov	ecx, DWORD PTR z$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR z$[rsp], eax

; 4644 : 	}

	jmp	SHORT $LN2@stbi__shif
$LN3@stbi__shif:

; 4645 : 	return result;

	mov	eax, DWORD PTR result$[rsp]

; 4646 : }

	add	rsp, 24
	ret	0
?stbi__shiftsigned@@YAHHHH@Z ENDP			; stbi__shiftsigned
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
a$ = 8
?stbi__bitcount@@YAHI@Z PROC				; stbi__bitcount

; 4622 : {

	mov	DWORD PTR [rsp+8], ecx

; 4623 : 	a = (a & 0x55555555) + ((a >> 1) & 0x55555555); // max 2

	mov	eax, DWORD PTR a$[rsp]
	and	eax, 1431655765				; 55555555H
	mov	ecx, DWORD PTR a$[rsp]
	shr	ecx, 1
	and	ecx, 1431655765				; 55555555H
	add	eax, ecx
	mov	DWORD PTR a$[rsp], eax

; 4624 : 	a = (a & 0x33333333) + ((a >> 2) & 0x33333333); // max 4

	mov	eax, DWORD PTR a$[rsp]
	and	eax, 858993459				; 33333333H
	mov	ecx, DWORD PTR a$[rsp]
	shr	ecx, 2
	and	ecx, 858993459				; 33333333H
	add	eax, ecx
	mov	DWORD PTR a$[rsp], eax

; 4625 : 	a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

	mov	eax, DWORD PTR a$[rsp]
	shr	eax, 4
	mov	ecx, DWORD PTR a$[rsp]
	add	ecx, eax
	mov	eax, ecx
	and	eax, 252645135				; 0f0f0f0fH
	mov	DWORD PTR a$[rsp], eax

; 4626 : 	a = (a + (a >> 8)); // max 16 per 8 bits

	mov	eax, DWORD PTR a$[rsp]
	shr	eax, 8
	mov	ecx, DWORD PTR a$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR a$[rsp], eax

; 4627 : 	a = (a + (a >> 16)); // max 32 per 8 bits

	mov	eax, DWORD PTR a$[rsp]
	shr	eax, 16
	mov	ecx, DWORD PTR a$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR a$[rsp], eax

; 4628 : 	return a & 0xff;

	mov	eax, DWORD PTR a$[rsp]
	and	eax, 255				; 000000ffH

; 4629 : }

	ret	0
?stbi__bitcount@@YAHI@Z ENDP				; stbi__bitcount
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
n$ = 0
z$ = 32
?stbi__high_bit@@YAHI@Z PROC				; stbi__high_bit

; 4610 : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 4611 : 	int n = 0;

	mov	DWORD PTR n$[rsp], 0

; 4612 : 	if (z == 0) return -1;

	cmp	DWORD PTR z$[rsp], 0
	jne	SHORT $LN2@stbi__high
	mov	eax, -1
	jmp	$LN1@stbi__high
$LN2@stbi__high:

; 4613 : 	if (z >= 0x10000) n += 16, z >>= 16;

	cmp	DWORD PTR z$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@stbi__high
	mov	eax, DWORD PTR n$[rsp]
	add	eax, 16
	mov	DWORD PTR n$[rsp], eax
	mov	eax, DWORD PTR z$[rsp]
	shr	eax, 16
	mov	DWORD PTR z$[rsp], eax
$LN3@stbi__high:

; 4614 : 	if (z >= 0x00100) n += 8, z >>= 8;

	cmp	DWORD PTR z$[rsp], 256			; 00000100H
	jb	SHORT $LN4@stbi__high
	mov	eax, DWORD PTR n$[rsp]
	add	eax, 8
	mov	DWORD PTR n$[rsp], eax
	mov	eax, DWORD PTR z$[rsp]
	shr	eax, 8
	mov	DWORD PTR z$[rsp], eax
$LN4@stbi__high:

; 4615 : 	if (z >= 0x00010) n += 4, z >>= 4;

	cmp	DWORD PTR z$[rsp], 16
	jb	SHORT $LN5@stbi__high
	mov	eax, DWORD PTR n$[rsp]
	add	eax, 4
	mov	DWORD PTR n$[rsp], eax
	mov	eax, DWORD PTR z$[rsp]
	shr	eax, 4
	mov	DWORD PTR z$[rsp], eax
$LN5@stbi__high:

; 4616 : 	if (z >= 0x00004) n += 2, z >>= 2;

	cmp	DWORD PTR z$[rsp], 4
	jb	SHORT $LN6@stbi__high
	mov	eax, DWORD PTR n$[rsp]
	add	eax, 2
	mov	DWORD PTR n$[rsp], eax
	mov	eax, DWORD PTR z$[rsp]
	shr	eax, 2
	mov	DWORD PTR z$[rsp], eax
$LN6@stbi__high:

; 4617 : 	if (z >= 0x00002) n += 1, z >>= 1;

	cmp	DWORD PTR z$[rsp], 2
	jb	SHORT $LN7@stbi__high
	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax
	mov	eax, DWORD PTR z$[rsp]
	shr	eax, 1
	mov	DWORD PTR z$[rsp], eax
$LN7@stbi__high:

; 4618 : 	return n;

	mov	eax, DWORD PTR n$[rsp]
$LN1@stbi__high:

; 4619 : }

	add	rsp, 24
	ret	0
?stbi__high_bit@@YAHI@Z ENDP				; stbi__high_bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
sz$ = 32
tv83 = 36
r$ = 40
s$ = 64
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__bmp_test_raw

; 4586 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4587 : 	int r;
; 4588 : 	int sz;
; 4589 : 	if (stbi__get8(s) != 'B') return 0;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 66					; 00000042H
	je	SHORT $LN2@stbi__bmp_
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 4590 : 	if (stbi__get8(s) != 'M') return 0;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 77					; 0000004dH
	je	SHORT $LN3@stbi__bmp_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 4591 : 	stbi__get32le(s); // discard filesize

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4592 : 	stbi__get16le(s); // discard reserved

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 4593 : 	stbi__get16le(s); // discard reserved

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 4594 : 	stbi__get32le(s); // discard data offset

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4595 : 	sz = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR sz$[rsp], eax

; 4596 : 	r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

	cmp	DWORD PTR sz$[rsp], 12
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR sz$[rsp], 40			; 00000028H
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR sz$[rsp], 56			; 00000038H
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR sz$[rsp], 108			; 0000006cH
	je	SHORT $LN5@stbi__bmp_
	cmp	DWORD PTR sz$[rsp], 124			; 0000007cH
	je	SHORT $LN5@stbi__bmp_
	mov	DWORD PTR tv83[rsp], 0
	jmp	SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
	mov	DWORD PTR tv83[rsp], 1
$LN6@stbi__bmp_:
	mov	eax, DWORD PTR tv83[rsp]
	mov	DWORD PTR r$[rsp], eax

; 4597 : 	return r;

	mov	eax, DWORD PTR r$[rsp]
$LN1@stbi__bmp_:

; 4598 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__bmp_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z PROC	; stbi__png_info_raw

; 4563 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4564 : 	if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {

	xor	r8d, r8d
	mov	edx, 2
	mov	rcx, QWORD PTR p$[rsp]
	call	?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
	test	eax, eax
	jne	SHORT $LN2@stbi__png_

; 4565 : 		stbi__rewind(p->s);

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4566 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 4567 : 	}
; 4568 : 	if (x) *x = p->s->img_x;

	cmp	QWORD PTR x$[rsp], 0
	je	SHORT $LN3@stbi__png_
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR x$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax
$LN3@stbi__png_:

; 4569 : 	if (y) *y = p->s->img_y;

	cmp	QWORD PTR y$[rsp], 0
	je	SHORT $LN4@stbi__png_
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR y$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rcx], eax
$LN4@stbi__png_:

; 4570 : 	if (comp) *comp = p->s->img_n;

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN5@stbi__png_
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rcx], eax
$LN5@stbi__png_:

; 4571 : 	return 1;

	mov	eax, 1
$LN1@stbi__png_:

; 4572 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ENDP	; stbi__png_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
result$ = 48
p$ = 80
x$ = 88
y$ = 96
n$ = 104
req_comp$ = 112
?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z PROC	; stbi__do_png

; 4525 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4526 : 	unsigned char* result = NULL;

	mov	QWORD PTR result$[rsp], 0

; 4527 : 	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	cmp	DWORD PTR req_comp$[rsp], 0
	jl	SHORT $LN3@stbi__do_p
	cmp	DWORD PTR req_comp$[rsp], 4
	jle	SHORT $LN2@stbi__do_p
$LN3@stbi__do_p:
	xor	eax, eax
	jmp	$LN1@stbi__do_p
$LN2@stbi__do_p:

; 4528 : 	if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

	mov	r8d, DWORD PTR req_comp$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR p$[rsp]
	call	?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
	test	eax, eax
	je	$LN4@stbi__do_p

; 4529 : 		result = p->out;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR result$[rsp], rax

; 4530 : 		p->out = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax+24], 0

; 4531 : 		if (req_comp && req_comp != p->s->img_out_n) {

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN5@stbi__do_p
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+12]
	cmp	DWORD PTR req_comp$[rsp], eax
	je	SHORT $LN5@stbi__do_p

; 4532 : 			result = stbi__convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR p$[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR [rcx]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	edx, DWORD PTR [rdx+12]
	mov	rcx, QWORD PTR result$[rsp]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	mov	QWORD PTR result$[rsp], rax

; 4533 : 			p->s->img_out_n = req_comp;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 4534 : 			if (result == NULL) return result;

	cmp	QWORD PTR result$[rsp], 0
	jne	SHORT $LN6@stbi__do_p
	mov	rax, QWORD PTR result$[rsp]
	jmp	$LN1@stbi__do_p
$LN6@stbi__do_p:
$LN5@stbi__do_p:

; 4535 : 		}
; 4536 : 		*x = p->s->img_x;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR x$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 4537 : 		*y = p->s->img_y;

	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR y$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rcx], eax

; 4538 : 		if (n) *n = p->s->img_out_n;

	cmp	QWORD PTR n$[rsp], 0
	je	SHORT $LN7@stbi__do_p
	mov	rax, QWORD PTR p$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR n$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx], eax
$LN7@stbi__do_p:
$LN4@stbi__do_p:

; 4539 : 	}
; 4540 : 	STBI_FREE(p->out);      p->out = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	free
	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax+24], 0

; 4541 : 	STBI_FREE(p->expanded); p->expanded = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	free
	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax+16], 0

; 4542 : 	STBI_FREE(p->idata);    p->idata = NULL;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	free
	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR [rax+8], 0

; 4543 : 
; 4544 : 	return result;

	mov	rax, QWORD PTR result$[rsp]
$LN1@stbi__do_p:

; 4545 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z ENDP	; stbi__do_png
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
pal_img_n$ = 64
s$ = 72
has_trans$ = 80
i$ = 84
c$1 = 88
ioff$ = 96
depth$ = 100
tv74 = 104
idata_limit$ = 108
color$ = 112
pal_len$ = 116
first$ = 120
k$ = 124
interlace$ = 128
raw_len$2 = 132
is_iphone$ = 136
tv159 = 140
tv156 = 144
tv261 = 148
tv301 = 152
tc$ = 156
comp$3 = 160
filter$4 = 164
bpl$5 = 168
p$6 = 176
palette$ = 192
__$ArrayPad$ = 1216
z$ = 1248
scan$ = 1256
req_comp$ = 1264
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z PROC	; stbi__parse_png_file

; 4366 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1240				; 000004d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4367 : 	stbi_uc palette[1024], pal_img_n = 0;

	mov	BYTE PTR pal_img_n$[rsp], 0

; 4368 : 	stbi_uc has_trans = 0, tc[3];

	mov	BYTE PTR has_trans$[rsp], 0

; 4369 : 	stbi__uint32 ioff = 0, idata_limit = 0, i, pal_len = 0;

	mov	DWORD PTR ioff$[rsp], 0
	mov	DWORD PTR idata_limit$[rsp], 0
	mov	DWORD PTR pal_len$[rsp], 0

; 4370 : 	int first = 1, k, interlace = 0, color = 0, depth = 0, is_iphone = 0;

	mov	DWORD PTR first$[rsp], 1
	mov	DWORD PTR interlace$[rsp], 0
	mov	DWORD PTR color$[rsp], 0
	mov	DWORD PTR depth$[rsp], 0
	mov	DWORD PTR is_iphone$[rsp], 0

; 4371 : 	stbi__context* s = z->s;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR s$[rsp], rax

; 4372 : 
; 4373 : 	z->expanded = NULL;

	mov	rax, QWORD PTR z$[rsp]
	mov	QWORD PTR [rax+16], 0

; 4374 : 	z->idata = NULL;

	mov	rax, QWORD PTR z$[rsp]
	mov	QWORD PTR [rax+8], 0

; 4375 : 	z->out = NULL;

	mov	rax, QWORD PTR z$[rsp]
	mov	QWORD PTR [rax+24], 0

; 4376 : 
; 4377 : 	if (!stbi__check_png_header(s)) return 0;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header
	test	eax, eax
	jne	SHORT $LN18@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN18@stbi__pars:

; 4378 : 
; 4379 : 	if (scan == STBI__SCAN_type) return 1;

	cmp	DWORD PTR scan$[rsp], 1
	jne	SHORT $LN19@stbi__pars
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN19@stbi__pars:
$LN2@stbi__pars:

; 4380 : 
; 4381 : 	for (;;) {
; 4382 : 		stbi__pngchunk c = stbi__get_chunk_header(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z ; stbi__get_chunk_header
	mov	QWORD PTR c$1[rsp], rax

; 4383 : 		switch (c.type) {

	mov	eax, DWORD PTR c$1[rsp+4]
	mov	DWORD PTR tv74[rsp], eax
	cmp	DWORD PTR tv74[rsp], 1229472850		; 49484452H
	ja	SHORT $LN92@stbi__pars
	cmp	DWORD PTR tv74[rsp], 1229472850		; 49484452H
	je	SHORT $LN21@stbi__pars
	cmp	DWORD PTR tv74[rsp], 1130840649		; 43674249H
	je	SHORT $LN20@stbi__pars
	cmp	DWORD PTR tv74[rsp], 1229209940		; 49444154H
	je	$LN55@stbi__pars
	cmp	DWORD PTR tv74[rsp], 1229278788		; 49454e44H
	je	$LN64@stbi__pars
	jmp	$LN80@stbi__pars
$LN92@stbi__pars:
	cmp	DWORD PTR tv74[rsp], 1347179589		; 504c5445H
	je	$LN41@stbi__pars
	cmp	DWORD PTR tv74[rsp], 1951551059		; 74524e53H
	je	$LN45@stbi__pars
	jmp	$LN80@stbi__pars
$LN20@stbi__pars:

; 4384 : 		case STBI__PNG_TYPE('C', 'g', 'B', 'I'):
; 4385 : 			is_iphone = 1;

	mov	DWORD PTR is_iphone$[rsp], 1

; 4386 : 			stbi__skip(s, c.length);

	mov	edx, DWORD PTR c$1[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 4387 : 			break;

	jmp	$LN5@stbi__pars
$LN21@stbi__pars:

; 4388 : 		case STBI__PNG_TYPE('I', 'H', 'D', 'R'): {
; 4389 : 			int comp, filter;
; 4390 : 			if (!first) return stbi__err("multiple IHDR", "Corrupt PNG");

	cmp	DWORD PTR first$[rsp], 0
	jne	SHORT $LN22@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN22@stbi__pars:

; 4391 : 			first = 0;

	mov	DWORD PTR first$[rsp], 0

; 4392 : 			if (c.length != 13) return stbi__err("bad IHDR len", "Corrupt PNG");

	cmp	DWORD PTR c$1[rsp], 13
	je	SHORT $LN23@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN23@stbi__pars:

; 4393 : 			s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax], 16777216		; 01000000H
	jbe	SHORT $LN24@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN24@stbi__pars:

; 4394 : 			s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large", "Very large image (corrupt?)");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+4], 16777216		; 01000000H
	jbe	SHORT $LN25@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN25@stbi__pars:

; 4395 : 			depth = stbi__get8(s);  if (depth != 1 && depth != 2 && depth != 4 && depth != 8)  return stbi__err("1/2/4/8-bit only", "PNG not supported: 1/2/4/8-bit only");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR depth$[rsp], eax
	cmp	DWORD PTR depth$[rsp], 1
	je	SHORT $LN26@stbi__pars
	cmp	DWORD PTR depth$[rsp], 2
	je	SHORT $LN26@stbi__pars
	cmp	DWORD PTR depth$[rsp], 4
	je	SHORT $LN26@stbi__pars
	cmp	DWORD PTR depth$[rsp], 8
	je	SHORT $LN26@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN26@stbi__pars:

; 4396 : 			color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype", "Corrupt PNG");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR color$[rsp], eax
	cmp	DWORD PTR color$[rsp], 6
	jle	SHORT $LN27@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN27@stbi__pars:

; 4397 : 			if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype", "Corrupt PNG");

	cmp	DWORD PTR color$[rsp], 3
	jne	SHORT $LN28@stbi__pars
	mov	BYTE PTR pal_img_n$[rsp], 3
	jmp	SHORT $LN29@stbi__pars
$LN28@stbi__pars:
	mov	eax, DWORD PTR color$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN30@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN30@stbi__pars:
$LN29@stbi__pars:

; 4398 : 			comp = stbi__get8(s);  if (comp) return stbi__err("bad comp method", "Corrupt PNG");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR comp$3[rsp], eax
	cmp	DWORD PTR comp$3[rsp], 0
	je	SHORT $LN31@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN31@stbi__pars:

; 4399 : 			filter = stbi__get8(s);  if (filter) return stbi__err("bad filter method", "Corrupt PNG");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR filter$4[rsp], eax
	cmp	DWORD PTR filter$4[rsp], 0
	je	SHORT $LN32@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN32@stbi__pars:

; 4400 : 			interlace = stbi__get8(s); if (interlace > 1) return stbi__err("bad interlace method", "Corrupt PNG");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR interlace$[rsp], eax
	cmp	DWORD PTR interlace$[rsp], 1
	jle	SHORT $LN33@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN33@stbi__pars:

; 4401 : 			if (!s->img_x || !s->img_y) return stbi__err("0-pixel image", "Corrupt PNG");

	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN35@stbi__pars
	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN34@stbi__pars
$LN35@stbi__pars:
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN34@stbi__pars:

; 4402 : 			if (!pal_img_n) {

	movzx	eax, BYTE PTR pal_img_n$[rsp]
	test	eax, eax
	jne	$LN36@stbi__pars

; 4403 : 				s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

	mov	eax, DWORD PTR color$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN84@stbi__pars
	mov	DWORD PTR tv156[rsp], 3
	jmp	SHORT $LN85@stbi__pars
$LN84@stbi__pars:
	mov	DWORD PTR tv156[rsp], 1
$LN85@stbi__pars:
	mov	eax, DWORD PTR color$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN86@stbi__pars
	mov	DWORD PTR tv159[rsp], 1
	jmp	SHORT $LN87@stbi__pars
$LN86@stbi__pars:
	mov	DWORD PTR tv159[rsp], 0
$LN87@stbi__pars:
	mov	eax, DWORD PTR tv159[rsp]
	mov	ecx, DWORD PTR tv156[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 4404 : 				if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

	xor	edx, edx
	mov	eax, 1073741824				; 40000000H
	mov	rcx, QWORD PTR s$[rsp]
	div	DWORD PTR [rcx]
	xor	edx, edx
	mov	rcx, QWORD PTR s$[rsp]
	div	DWORD PTR [rcx+8]
	mov	rcx, QWORD PTR s$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jae	SHORT $LN38@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN38@stbi__pars:

; 4405 : 				if (scan == STBI__SCAN_header) return 1;

	cmp	DWORD PTR scan$[rsp], 2
	jne	SHORT $LN39@stbi__pars
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN39@stbi__pars:

; 4406 : 			}

	jmp	SHORT $LN37@stbi__pars
$LN36@stbi__pars:

; 4407 : 			else {
; 4408 : 				// if paletted, then pal_n is our final components, and
; 4409 : 				// img_n is # components to decompress/filter.
; 4410 : 				s->img_n = 1;

	mov	rax, QWORD PTR s$[rsp]
	mov	DWORD PTR [rax+8], 1

; 4411 : 				if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large", "Corrupt PNG");

	xor	edx, edx
	mov	eax, 1073741824				; 40000000H
	mov	rcx, QWORD PTR s$[rsp]
	div	DWORD PTR [rcx]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	rcx, QWORD PTR s$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jae	SHORT $LN40@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN40@stbi__pars:
$LN37@stbi__pars:

; 4412 : 				// if SCAN_header, have to scan to see if we have a tRNS
; 4413 : 			}
; 4414 : 			break;

	jmp	$LN5@stbi__pars
$LN41@stbi__pars:

; 4415 : 		}
; 4416 : 
; 4417 : 		case STBI__PNG_TYPE('P', 'L', 'T', 'E'): {
; 4418 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR first$[rsp], 0
	je	SHORT $LN42@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN42@stbi__pars:

; 4419 : 			if (c.length > 256 * 3) return stbi__err("invalid PLTE", "Corrupt PNG");

	cmp	DWORD PTR c$1[rsp], 768			; 00000300H
	jbe	SHORT $LN43@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN43@stbi__pars:

; 4420 : 			pal_len = c.length / 3;

	xor	edx, edx
	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, 3
	div	ecx
	mov	DWORD PTR pal_len$[rsp], eax

; 4421 : 			if (pal_len * 3 != c.length) return stbi__err("invalid PLTE", "Corrupt PNG");

	imul	eax, DWORD PTR pal_len$[rsp], 3
	cmp	eax, DWORD PTR c$1[rsp]
	je	SHORT $LN44@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN44@stbi__pars:

; 4422 : 			for (i = 0; i < pal_len; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN9@stbi__pars
$LN7@stbi__pars:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@stbi__pars:
	mov	eax, DWORD PTR pal_len$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN8@stbi__pars

; 4423 : 				palette[i * 4 + 0] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR i$[rsp]
	shl	ecx, 2
	mov	ecx, ecx
	mov	BYTE PTR palette$[rsp+rcx], al

; 4424 : 				palette[i * 4 + 1] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx*4+1]
	mov	ecx, ecx
	mov	BYTE PTR palette$[rsp+rcx], al

; 4425 : 				palette[i * 4 + 2] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx*4+2]
	mov	ecx, ecx
	mov	BYTE PTR palette$[rsp+rcx], al

; 4426 : 				palette[i * 4 + 3] = 255;

	mov	eax, DWORD PTR i$[rsp]
	lea	eax, DWORD PTR [rax*4+3]
	mov	eax, eax
	mov	BYTE PTR palette$[rsp+rax], 255		; 000000ffH

; 4427 : 			}

	jmp	$LN7@stbi__pars
$LN8@stbi__pars:

; 4428 : 			break;

	jmp	$LN5@stbi__pars
$LN45@stbi__pars:

; 4429 : 		}
; 4430 : 
; 4431 : 		case STBI__PNG_TYPE('t', 'R', 'N', 'S'): {
; 4432 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR first$[rsp], 0
	je	SHORT $LN46@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN46@stbi__pars:

; 4433 : 			if (z->idata) return stbi__err("tRNS after IDAT", "Corrupt PNG");

	mov	rax, QWORD PTR z$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN47@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN47@stbi__pars:

; 4434 : 			if (pal_img_n) {

	movzx	eax, BYTE PTR pal_img_n$[rsp]
	test	eax, eax
	je	$LN48@stbi__pars

; 4435 : 				if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }

	cmp	DWORD PTR scan$[rsp], 2
	jne	SHORT $LN50@stbi__pars
	mov	rax, QWORD PTR s$[rsp]
	mov	DWORD PTR [rax+8], 4
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN50@stbi__pars:

; 4436 : 				if (pal_len == 0) return stbi__err("tRNS before PLTE", "Corrupt PNG");

	cmp	DWORD PTR pal_len$[rsp], 0
	jne	SHORT $LN51@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN51@stbi__pars:

; 4437 : 				if (c.length > pal_len) return stbi__err("bad tRNS len", "Corrupt PNG");

	mov	eax, DWORD PTR pal_len$[rsp]
	cmp	DWORD PTR c$1[rsp], eax
	jbe	SHORT $LN52@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN52@stbi__pars:

; 4438 : 				pal_img_n = 4;

	mov	BYTE PTR pal_img_n$[rsp], 4

; 4439 : 				for (i = 0; i < c.length; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN12@stbi__pars
$LN10@stbi__pars:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN12@stbi__pars:
	mov	eax, DWORD PTR c$1[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN11@stbi__pars

; 4440 : 					palette[i * 4 + 3] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx*4+3]
	mov	ecx, ecx
	mov	BYTE PTR palette$[rsp+rcx], al
	jmp	SHORT $LN10@stbi__pars
$LN11@stbi__pars:

; 4441 : 			}

	jmp	$LN49@stbi__pars
$LN48@stbi__pars:

; 4442 : 			else {
; 4443 : 				if (!(s->img_n & 1)) return stbi__err("tRNS with alpha", "Corrupt PNG");

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN53@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN53@stbi__pars:

; 4444 : 				if (c.length != (stbi__uint32)s->img_n * 2) return stbi__err("bad tRNS len", "Corrupt PNG");

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	shl	eax, 1
	cmp	DWORD PTR c$1[rsp], eax
	je	SHORT $LN54@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN54@stbi__pars:

; 4445 : 				has_trans = 1;

	mov	BYTE PTR has_trans$[rsp], 1

; 4446 : 				for (k = 0; k < s->img_n; ++k)

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN15@stbi__pars
$LN13@stbi__pars:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN15@stbi__pars:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN14@stbi__pars

; 4447 : 					tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[depth]; // non 8-bit images will be larger

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	and	eax, 255				; 000000ffH
	movzx	eax, al
	movsxd	rcx, DWORD PTR depth$[rsp]
	lea	rdx, OFFSET FLAT:?stbi__depth_scale_table@@3PAEA
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	eax, ecx
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	BYTE PTR tc$[rsp+rcx], al
	jmp	SHORT $LN13@stbi__pars
$LN14@stbi__pars:
$LN49@stbi__pars:

; 4448 : 			}
; 4449 : 			break;

	jmp	$LN5@stbi__pars
$LN55@stbi__pars:

; 4450 : 		}
; 4451 : 
; 4452 : 		case STBI__PNG_TYPE('I', 'D', 'A', 'T'): {
; 4453 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR first$[rsp], 0
	je	SHORT $LN56@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN56@stbi__pars:

; 4454 : 			if (pal_img_n && !pal_len) return stbi__err("no PLTE", "Corrupt PNG");

	movzx	eax, BYTE PTR pal_img_n$[rsp]
	test	eax, eax
	je	SHORT $LN57@stbi__pars
	cmp	DWORD PTR pal_len$[rsp], 0
	jne	SHORT $LN57@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN57@stbi__pars:

; 4455 : 			if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }

	cmp	DWORD PTR scan$[rsp], 2
	jne	SHORT $LN58@stbi__pars
	movzx	eax, BYTE PTR pal_img_n$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN58@stbi__pars:

; 4456 : 			if ((int)(ioff + c.length) < (int)ioff) return 0;

	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR ioff$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR ioff$[rsp]
	jge	SHORT $LN59@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN59@stbi__pars:

; 4457 : 			if (ioff + c.length > idata_limit) {

	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR ioff$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR idata_limit$[rsp]
	jbe	$LN60@stbi__pars

; 4458 : 				stbi_uc* p;
; 4459 : 				if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

	cmp	DWORD PTR idata_limit$[rsp], 0
	jne	SHORT $LN61@stbi__pars
	cmp	DWORD PTR c$1[rsp], 4096		; 00001000H
	jbe	SHORT $LN88@stbi__pars
	mov	eax, DWORD PTR c$1[rsp]
	mov	DWORD PTR tv261[rsp], eax
	jmp	SHORT $LN89@stbi__pars
$LN88@stbi__pars:
	mov	DWORD PTR tv261[rsp], 4096		; 00001000H
$LN89@stbi__pars:
	mov	eax, DWORD PTR tv261[rsp]
	mov	DWORD PTR idata_limit$[rsp], eax
$LN61@stbi__pars:
$LN16@stbi__pars:

; 4460 : 				while (ioff + c.length > idata_limit)

	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR ioff$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR idata_limit$[rsp]
	jbe	SHORT $LN17@stbi__pars

; 4461 : 					idata_limit *= 2;

	mov	eax, DWORD PTR idata_limit$[rsp]
	shl	eax, 1
	mov	DWORD PTR idata_limit$[rsp], eax
	jmp	SHORT $LN16@stbi__pars
$LN17@stbi__pars:

; 4462 : 				p = (stbi_uc*)STBI_REALLOC(z->idata, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

	mov	eax, DWORD PTR idata_limit$[rsp]
	mov	edx, eax
	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	realloc
	mov	QWORD PTR p$6[rsp], rax
	cmp	QWORD PTR p$6[rsp], 0
	jne	SHORT $LN62@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN62@stbi__pars:

; 4463 : 				z->idata = p;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR p$6[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN60@stbi__pars:

; 4464 : 			}
; 4465 : 			if (!stbi__getn(s, z->idata + ioff, c.length)) return stbi__err("outofdata", "Corrupt PNG");

	mov	eax, DWORD PTR ioff$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8d, DWORD PTR c$1[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	test	eax, eax
	jne	SHORT $LN63@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN63@stbi__pars:

; 4466 : 			ioff += c.length;

	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR ioff$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ioff$[rsp], eax

; 4467 : 			break;

	jmp	$LN5@stbi__pars
$LN64@stbi__pars:

; 4468 : 		}
; 4469 : 
; 4470 : 		case STBI__PNG_TYPE('I', 'E', 'N', 'D'): {
; 4471 : 			stbi__uint32 raw_len, bpl;
; 4472 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR first$[rsp], 0
	je	SHORT $LN65@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN65@stbi__pars:

; 4473 : 			if (scan != STBI__SCAN_load) return 1;

	cmp	DWORD PTR scan$[rsp], 0
	je	SHORT $LN66@stbi__pars
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN66@stbi__pars:

; 4474 : 			if (z->idata == NULL) return stbi__err("no IDAT", "Corrupt PNG");

	mov	rax, QWORD PTR z$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN67@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN67@stbi__pars:

; 4475 : 			// initial guess for decoded data size to avoid unnecessary reallocs
; 4476 : 			bpl = (s->img_x * depth + 7) / 8; // bytes per line, per component

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	imul	eax, DWORD PTR depth$[rsp]
	add	eax, 7
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR bpl$5[rsp], eax

; 4477 : 			raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR bpl$5[rsp]
	imul	ecx, DWORD PTR [rax+4]
	mov	eax, ecx
	mov	rcx, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rcx+8]
	mov	rcx, QWORD PTR s$[rsp]
	add	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR raw_len$2[rsp], eax

; 4478 : 			z->expanded = (stbi_uc*)stbi_zlib_decode_malloc_guesssize_headerflag((char*)z->idata, ioff, raw_len, (int*)&raw_len, !is_iphone);

	cmp	DWORD PTR is_iphone$[rsp], 0
	jne	SHORT $LN90@stbi__pars
	mov	DWORD PTR tv301[rsp], 1
	jmp	SHORT $LN91@stbi__pars
$LN90@stbi__pars:
	mov	DWORD PTR tv301[rsp], 0
$LN91@stbi__pars:
	mov	eax, DWORD PTR tv301[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR raw_len$2[rsp]
	mov	r8d, DWORD PTR raw_len$2[rsp]
	mov	edx, DWORD PTR ioff$[rsp]
	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	stbi_zlib_decode_malloc_guesssize_headerflag
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 4479 : 			if (z->expanded == NULL) return 0; // zlib should set error

	mov	rax, QWORD PTR z$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN68@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN68@stbi__pars:

; 4480 : 			STBI_FREE(z->idata); z->idata = NULL;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	free
	mov	rax, QWORD PTR z$[rsp]
	mov	QWORD PTR [rax+8], 0

; 4481 : 			if ((req_comp == s->img_n + 1 && req_comp != 3 && !pal_img_n) || has_trans)

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	cmp	DWORD PTR req_comp$[rsp], eax
	jne	SHORT $LN72@stbi__pars
	cmp	DWORD PTR req_comp$[rsp], 3
	je	SHORT $LN72@stbi__pars
	movzx	eax, BYTE PTR pal_img_n$[rsp]
	test	eax, eax
	je	SHORT $LN71@stbi__pars
$LN72@stbi__pars:
	movzx	eax, BYTE PTR has_trans$[rsp]
	test	eax, eax
	je	SHORT $LN69@stbi__pars
$LN71@stbi__pars:

; 4482 : 				s->img_out_n = s->img_n + 1;

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+12], eax
	jmp	SHORT $LN70@stbi__pars
$LN69@stbi__pars:

; 4483 : 			else
; 4484 : 				s->img_out_n = s->img_n;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+12], ecx
$LN70@stbi__pars:

; 4485 : 			if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, depth, color, interlace)) return 0;

	mov	eax, DWORD PTR interlace$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR color$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR depth$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR s$[rsp]
	mov	r9d, DWORD PTR [rax+12]
	mov	r8d, DWORD PTR raw_len$2[rsp]
	mov	rax, QWORD PTR z$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ; stbi__create_png_image
	test	eax, eax
	jne	SHORT $LN73@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN73@stbi__pars:

; 4486 : 			if (has_trans)

	movzx	eax, BYTE PTR has_trans$[rsp]
	test	eax, eax
	je	SHORT $LN74@stbi__pars

; 4487 : 				if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;

	mov	rax, QWORD PTR s$[rsp]
	mov	r8d, DWORD PTR [rax+12]
	lea	rdx, QWORD PTR tc$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z ; stbi__compute_transparency
	test	eax, eax
	jne	SHORT $LN75@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN75@stbi__pars:
$LN74@stbi__pars:

; 4488 : 			if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

	cmp	DWORD PTR is_iphone$[rsp], 0
	je	SHORT $LN76@stbi__pars
	cmp	DWORD PTR ?stbi__de_iphone_flag@@3HA, 0
	je	SHORT $LN76@stbi__pars
	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+12], 2
	jle	SHORT $LN76@stbi__pars

; 4489 : 				stbi__de_iphone(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__de_iphone@@YAXPEAUstbi__png@@@Z	; stbi__de_iphone
	npad	1
$LN76@stbi__pars:

; 4490 : 			if (pal_img_n) {

	movzx	eax, BYTE PTR pal_img_n$[rsp]
	test	eax, eax
	je	SHORT $LN77@stbi__pars

; 4491 : 				// pal_img_n == 3 or 4
; 4492 : 				s->img_n = pal_img_n; // record the actual colors we had

	movzx	eax, BYTE PTR pal_img_n$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 4493 : 				s->img_out_n = pal_img_n;

	movzx	eax, BYTE PTR pal_img_n$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 4494 : 				if (req_comp >= 3) s->img_out_n = req_comp;

	cmp	DWORD PTR req_comp$[rsp], 3
	jl	SHORT $LN78@stbi__pars
	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rax+12], ecx
$LN78@stbi__pars:

; 4495 : 				if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))

	mov	rax, QWORD PTR s$[rsp]
	mov	r9d, DWORD PTR [rax+12]
	mov	r8d, DWORD PTR pal_len$[rsp]
	lea	rdx, QWORD PTR palette$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z ; stbi__expand_png_palette
	test	eax, eax
	jne	SHORT $LN79@stbi__pars

; 4496 : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN79@stbi__pars:
$LN77@stbi__pars:

; 4497 : 			}
; 4498 : 			STBI_FREE(z->expanded); z->expanded = NULL;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	free
	mov	rax, QWORD PTR z$[rsp]
	mov	QWORD PTR [rax+16], 0

; 4499 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__pars
$LN80@stbi__pars:

; 4500 : 		}
; 4501 : 
; 4502 : 		default:
; 4503 : 			// if critical, fail
; 4504 : 			if (first) return stbi__err("first not IHDR", "Corrupt PNG");

	cmp	DWORD PTR first$[rsp], 0
	je	SHORT $LN81@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN81@stbi__pars:

; 4505 : 			if ((c.type & (1 << 29)) == 0) {

	mov	eax, DWORD PTR c$1[rsp+4]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	jne	SHORT $LN82@stbi__pars

; 4506 : #ifndef STBI_NO_FAILURE_STRINGS
; 4507 : 				// not threadsafe
; 4508 : 				static char invalid_chunk[] = "XXXX PNG chunk not known";
; 4509 : 				invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
; 4510 : 				invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
; 4511 : 				invalid_chunk[2] = STBI__BYTECAST(c.type >> 8);
; 4512 : 				invalid_chunk[3] = STBI__BYTECAST(c.type >> 0);
; 4513 : #endif
; 4514 : 				return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN82@stbi__pars:

; 4515 : 			}
; 4516 : 			stbi__skip(s, c.length);

	mov	edx, DWORD PTR c$1[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1
$LN5@stbi__pars:

; 4517 : 			break;
; 4518 : 		}
; 4519 : 		// end of PNG chunk, read and skip CRC
; 4520 : 		stbi__get32be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	npad	1

; 4521 : 	}

	jmp	$LN2@stbi__pars
$LN1@stbi__pars:

; 4522 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1240				; 000004d8H
	ret	0
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ENDP	; stbi__parse_png_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
a$1 = 0
t$2 = 1
t$3 = 2
t$4 = 3
i$ = 4
pixel_count$ = 8
p$ = 16
s$ = 24
z$ = 48
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z PROC		; stbi__de_iphone

; 4319 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4320 : 	stbi__context* s = z->s;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR s$[rsp], rax

; 4321 : 	stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	imul	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR pixel_count$[rsp], eax

; 4322 : 	stbi_uc* p = z->out;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR p$[rsp], rax

; 4323 : 
; 4324 : 	if (s->img_out_n == 3) {  // convert bgr to rgb

	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+12], 3
	jne	$LN11@stbi__de_i

; 4325 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__de_i
$LN2@stbi__de_i:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__de_i:
	mov	eax, DWORD PTR pixel_count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN3@stbi__de_i

; 4326 : 			stbi_uc t = p[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR t$3[rsp], al

; 4327 : 			p[0] = p[2];

	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4328 : 			p[2] = t;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR p$[rsp]
	movzx	edx, BYTE PTR t$3[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 4329 : 			p += 3;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 3
	mov	QWORD PTR p$[rsp], rax

; 4330 : 		}

	jmp	SHORT $LN2@stbi__de_i
$LN3@stbi__de_i:

; 4331 : 	}

	jmp	$LN12@stbi__de_i
$LN11@stbi__de_i:

; 4332 : 	else {
; 4333 : 		STBI_ASSERT(s->img_out_n == 4);
; 4334 : 		if (stbi__unpremultiply_on_load) {

	cmp	DWORD PTR ?stbi__unpremultiply_on_load@@3HA, 0
	je	$LN13@stbi__de_i

; 4335 : 			// convert bgr to rgb and unpremultiply
; 4336 : 			for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbi__de_i
$LN5@stbi__de_i:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__de_i:
	mov	eax, DWORD PTR pixel_count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN6@stbi__de_i

; 4337 : 				stbi_uc a = p[3];

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR a$1[rsp], al

; 4338 : 				stbi_uc t = p[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR t$2[rsp], al

; 4339 : 				if (a) {

	movzx	eax, BYTE PTR a$1[rsp]
	test	eax, eax
	je	$LN15@stbi__de_i

; 4340 : 					p[0] = p[2] * 255 / a;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 255				; 000000ffH
	movzx	ecx, BYTE PTR a$1[rsp]
	cdq
	idiv	ecx
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 4341 : 					p[1] = p[1] * 255 / a;

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 255				; 000000ffH
	movzx	ecx, BYTE PTR a$1[rsp]
	cdq
	idiv	ecx
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 4342 : 					p[2] = t * 255 / a;

	movzx	eax, BYTE PTR t$2[rsp]
	imul	eax, eax, 255				; 000000ffH
	movzx	ecx, BYTE PTR a$1[rsp]
	cdq
	idiv	ecx
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 4343 : 				}

	jmp	SHORT $LN16@stbi__de_i
$LN15@stbi__de_i:

; 4344 : 				else {
; 4345 : 					p[0] = p[2];

	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4346 : 					p[2] = t;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR p$[rsp]
	movzx	edx, BYTE PTR t$2[rsp]
	mov	BYTE PTR [rcx+rax], dl
$LN16@stbi__de_i:

; 4347 : 				}
; 4348 : 				p += 4;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 4
	mov	QWORD PTR p$[rsp], rax

; 4349 : 			}

	jmp	$LN5@stbi__de_i
$LN6@stbi__de_i:

; 4350 : 		}

	jmp	SHORT $LN14@stbi__de_i
$LN13@stbi__de_i:

; 4351 : 		else {
; 4352 : 			// convert bgr to rgb
; 4353 : 			for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@stbi__de_i
$LN8@stbi__de_i:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@stbi__de_i:
	mov	eax, DWORD PTR pixel_count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN9@stbi__de_i

; 4354 : 				stbi_uc t = p[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR t$4[rsp], al

; 4355 : 				p[0] = p[2];

	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4356 : 				p[2] = t;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR p$[rsp]
	movzx	edx, BYTE PTR t$4[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 4357 : 				p += 4;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 4
	mov	QWORD PTR p$[rsp], rax

; 4358 : 			}

	jmp	SHORT $LN8@stbi__de_i
$LN9@stbi__de_i:
$LN14@stbi__de_i:
$LN12@stbi__de_i:

; 4359 : 		}
; 4360 : 	}
; 4361 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z ENDP		; stbi__de_iphone
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
n$1 = 36
n$2 = 40
pixel_count$ = 44
p$ = 48
orig$ = 56
temp_out$ = 64
a$ = 96
palette$ = 104
len$ = 112
pal_img_n$ = 120
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z PROC ; stbi__expand_png_palette

; 4268 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4269 : 	stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	eax, DWORD PTR [rax]
	imul	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR pixel_count$[rsp], eax

; 4270 : 	stbi_uc* p, * temp_out, * orig = a->out;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR orig$[rsp], rax

; 4271 : 
; 4272 : 	p = (stbi_uc*)stbi__malloc(pixel_count * pal_img_n);

	mov	eax, DWORD PTR pixel_count$[rsp]
	imul	eax, DWORD PTR pal_img_n$[rsp]
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR p$[rsp], rax

; 4273 : 	if (p == NULL) return stbi__err("outofmem", "Out of memory");

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN8@stbi__expa
	xor	eax, eax
	jmp	$LN1@stbi__expa
$LN8@stbi__expa:

; 4274 : 
; 4275 : 	// between here and free(out) below, exitting would leak
; 4276 : 	temp_out = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR temp_out$[rsp], rax

; 4277 : 
; 4278 : 	if (pal_img_n == 3) {

	cmp	DWORD PTR pal_img_n$[rsp], 3
	jne	$LN9@stbi__expa

; 4279 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__expa
$LN2@stbi__expa:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__expa:
	mov	eax, DWORD PTR pixel_count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN3@stbi__expa

; 4280 : 			int n = orig[i] * 4;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR orig$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 2
	mov	DWORD PTR n$2[rsp], eax

; 4281 : 			p[0] = palette[n];

	movsxd	rax, DWORD PTR n$2[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR palette$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4282 : 			p[1] = palette[n + 1];

	mov	eax, DWORD PTR n$2[rsp]
	inc	eax
	cdqe
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR palette$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4283 : 			p[2] = palette[n + 2];

	mov	eax, DWORD PTR n$2[rsp]
	add	eax, 2
	cdqe
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR palette$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4284 : 			p += 3;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 3
	mov	QWORD PTR p$[rsp], rax

; 4285 : 		}

	jmp	$LN2@stbi__expa
$LN3@stbi__expa:

; 4286 : 	}

	jmp	$LN10@stbi__expa
$LN9@stbi__expa:

; 4287 : 	else {
; 4288 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbi__expa
$LN5@stbi__expa:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__expa:
	mov	eax, DWORD PTR pixel_count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN6@stbi__expa

; 4289 : 			int n = orig[i] * 4;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR orig$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 2
	mov	DWORD PTR n$1[rsp], eax

; 4290 : 			p[0] = palette[n];

	movsxd	rax, DWORD PTR n$1[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR palette$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4291 : 			p[1] = palette[n + 1];

	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	cdqe
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR palette$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4292 : 			p[2] = palette[n + 2];

	mov	eax, DWORD PTR n$1[rsp]
	add	eax, 2
	cdqe
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR palette$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4293 : 			p[3] = palette[n + 3];

	mov	eax, DWORD PTR n$1[rsp]
	add	eax, 3
	cdqe
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR palette$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4294 : 			p += 4;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 4
	mov	QWORD PTR p$[rsp], rax

; 4295 : 		}

	jmp	$LN5@stbi__expa
$LN6@stbi__expa:
$LN10@stbi__expa:

; 4296 : 	}
; 4297 : 	STBI_FREE(a->out);

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	free

; 4298 : 	a->out = temp_out;

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR temp_out$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 4299 : 
; 4300 : 	STBI_NOTUSED(len);
; 4301 : 
; 4302 : 	return 1;

	mov	eax, 1
$LN1@stbi__expa:

; 4303 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z ENDP ; stbi__expand_png_palette
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
tv81 = 4
pixel_count$ = 8
p$ = 16
s$ = 24
z$ = 48
tc$ = 56
out_n$ = 64
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z PROC ; stbi__compute_transparency

; 4242 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4243 : 	stbi__context* s = z->s;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR s$[rsp], rax

; 4244 : 	stbi__uint32 i, pixel_count = s->img_x * s->img_y;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	imul	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR pixel_count$[rsp], eax

; 4245 : 	stbi_uc* p = z->out;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR p$[rsp], rax

; 4246 : 
; 4247 : 	// compute color-based transparency, assuming we've
; 4248 : 	// already got 255 as the alpha value in the output
; 4249 : 	STBI_ASSERT(out_n == 2 || out_n == 4);
; 4250 : 
; 4251 : 	if (out_n == 2) {

	cmp	DWORD PTR out_n$[rsp], 2
	jne	SHORT $LN8@stbi__comp

; 4252 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__comp
$LN2@stbi__comp:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
	mov	eax, DWORD PTR pixel_count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN3@stbi__comp

; 4253 : 			p[1] = (p[0] == tc[0] ? 0 : 255);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tc$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN12@stbi__comp
	mov	DWORD PTR tv81[rsp], 0
	jmp	SHORT $LN13@stbi__comp
$LN12@stbi__comp:
	mov	DWORD PTR tv81[rsp], 255		; 000000ffH
$LN13@stbi__comp:
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR p$[rsp]
	movzx	edx, BYTE PTR tv81[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 4254 : 			p += 2;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 2
	mov	QWORD PTR p$[rsp], rax

; 4255 : 		}

	jmp	SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4256 : 	}

	jmp	$LN9@stbi__comp
$LN8@stbi__comp:

; 4257 : 	else {
; 4258 : 		for (i = 0; i < pixel_count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbi__comp
$LN5@stbi__comp:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__comp:
	mov	eax, DWORD PTR pixel_count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN6@stbi__comp

; 4259 : 			if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tc$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN10@stbi__comp
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR tc$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN10@stbi__comp
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR tc$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	jne	SHORT $LN10@stbi__comp

; 4260 : 				p[3] = 0;

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR p$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN10@stbi__comp:

; 4261 : 			p += 4;

	mov	rax, QWORD PTR p$[rsp]
	add	rax, 4
	mov	QWORD PTR p$[rsp], rax

; 4262 : 		}

	jmp	$LN5@stbi__comp
$LN6@stbi__comp:
$LN9@stbi__comp:

; 4263 : 	}
; 4264 : 	return 1;

	mov	eax, 1

; 4265 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z ENDP ; stbi__compute_transparency
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 64
j$1 = 68
x$2 = 72
i$3 = 76
y$4 = 80
img_len$5 = 84
out_y$6 = 88
out_x$7 = 92
final$ = 96
tv274 = 104
yspc$8 = 112
xspc$9 = 144
yorig$10 = 176
xorig$11 = 208
__$ArrayPad$ = 240
a$ = 272
image_data$ = 280
image_data_len$ = 288
out_n$ = 296
depth$ = 304
color$ = 312
interlaced$ = 320
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z PROC ; stbi__create_png_image

; 4200 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 264				; 00000108H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4201 : 	stbi_uc* final;
; 4202 : 	int p;
; 4203 : 	if (!interlaced)

	cmp	DWORD PTR interlaced$[rsp], 0
	jne	SHORT $LN11@stbi__crea

; 4204 : 		return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	edx, DWORD PTR color$[rsp]
	mov	DWORD PTR [rsp+56], edx
	mov	edx, DWORD PTR depth$[rsp]
	mov	DWORD PTR [rsp+48], edx
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR out_n$[rsp]
	mov	r8d, DWORD PTR image_data_len$[rsp]
	mov	rdx, QWORD PTR image_data$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw
	jmp	$LN1@stbi__crea
$LN11@stbi__crea:

; 4205 : 
; 4206 : 	// de-interlacing
; 4207 : 	final = (stbi_uc*)stbi__malloc(a->s->img_x * a->s->img_y * out_n);

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	eax, DWORD PTR [rax]
	imul	eax, DWORD PTR [rcx+4]
	imul	eax, DWORD PTR out_n$[rsp]
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR final$[rsp], rax

; 4208 : 	for (p = 0; p < 7; ++p) {

	mov	DWORD PTR p$[rsp], 0
	jmp	SHORT $LN4@stbi__crea
$LN2@stbi__crea:
	mov	eax, DWORD PTR p$[rsp]
	inc	eax
	mov	DWORD PTR p$[rsp], eax
$LN4@stbi__crea:
	cmp	DWORD PTR p$[rsp], 7
	jge	$LN3@stbi__crea

; 4209 : 		int xorig[] = { 0,4,0,2,0,1,0 };

	mov	DWORD PTR xorig$11[rsp], 0
	mov	DWORD PTR xorig$11[rsp+4], 4
	mov	DWORD PTR xorig$11[rsp+8], 0
	mov	DWORD PTR xorig$11[rsp+12], 2
	mov	DWORD PTR xorig$11[rsp+16], 0
	mov	DWORD PTR xorig$11[rsp+20], 1
	mov	DWORD PTR xorig$11[rsp+24], 0

; 4210 : 		int yorig[] = { 0,0,4,0,2,0,1 };

	mov	DWORD PTR yorig$10[rsp], 0
	mov	DWORD PTR yorig$10[rsp+4], 0
	mov	DWORD PTR yorig$10[rsp+8], 4
	mov	DWORD PTR yorig$10[rsp+12], 0
	mov	DWORD PTR yorig$10[rsp+16], 2
	mov	DWORD PTR yorig$10[rsp+20], 0
	mov	DWORD PTR yorig$10[rsp+24], 1

; 4211 : 		int xspc[] = { 8,8,4,4,2,2,1 };

	mov	DWORD PTR xspc$9[rsp], 8
	mov	DWORD PTR xspc$9[rsp+4], 8
	mov	DWORD PTR xspc$9[rsp+8], 4
	mov	DWORD PTR xspc$9[rsp+12], 4
	mov	DWORD PTR xspc$9[rsp+16], 2
	mov	DWORD PTR xspc$9[rsp+20], 2
	mov	DWORD PTR xspc$9[rsp+24], 1

; 4212 : 		int yspc[] = { 8,8,8,4,4,2,2 };

	mov	DWORD PTR yspc$8[rsp], 8
	mov	DWORD PTR yspc$8[rsp+4], 8
	mov	DWORD PTR yspc$8[rsp+8], 8
	mov	DWORD PTR yspc$8[rsp+12], 4
	mov	DWORD PTR yspc$8[rsp+16], 4
	mov	DWORD PTR yspc$8[rsp+20], 2
	mov	DWORD PTR yspc$8[rsp+24], 2

; 4213 : 		int i, j, x, y;
; 4214 : 		// pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4215 : 		x = (a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p];

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR p$[rsp]
	mov	ecx, DWORD PTR xorig$11[rsp+rcx*4]
	mov	eax, DWORD PTR [rax]
	sub	eax, ecx
	movsxd	rcx, DWORD PTR p$[rsp]
	mov	ecx, DWORD PTR xspc$9[rsp+rcx*4]
	lea	eax, DWORD PTR [rax+rcx-1]
	movsxd	rcx, DWORD PTR p$[rsp]
	xor	edx, edx
	div	DWORD PTR xspc$9[rsp+rcx*4]
	mov	DWORD PTR x$2[rsp], eax

; 4216 : 		y = (a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p];

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR p$[rsp]
	mov	ecx, DWORD PTR yorig$10[rsp+rcx*4]
	mov	eax, DWORD PTR [rax+4]
	sub	eax, ecx
	movsxd	rcx, DWORD PTR p$[rsp]
	mov	ecx, DWORD PTR yspc$8[rsp+rcx*4]
	lea	eax, DWORD PTR [rax+rcx-1]
	movsxd	rcx, DWORD PTR p$[rsp]
	xor	edx, edx
	div	DWORD PTR yspc$8[rsp+rcx*4]
	mov	DWORD PTR y$4[rsp], eax

; 4217 : 		if (x && y) {

	cmp	DWORD PTR x$2[rsp], 0
	je	$LN12@stbi__crea
	cmp	DWORD PTR y$4[rsp], 0
	je	$LN12@stbi__crea

; 4218 : 			stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	imul	eax, DWORD PTR x$2[rsp]
	imul	eax, DWORD PTR depth$[rsp]
	add	eax, 7
	sar	eax, 3
	inc	eax
	imul	eax, DWORD PTR y$4[rsp]
	mov	DWORD PTR img_len$5[rsp], eax

; 4219 : 			if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

	mov	eax, DWORD PTR color$[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR depth$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR y$4[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR x$2[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR out_n$[rsp]
	mov	r8d, DWORD PTR image_data_len$[rsp]
	mov	rdx, QWORD PTR image_data$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw
	test	eax, eax
	jne	SHORT $LN13@stbi__crea

; 4220 : 				STBI_FREE(final);

	mov	rcx, QWORD PTR final$[rsp]
	call	free

; 4221 : 				return 0;

	xor	eax, eax
	jmp	$LN1@stbi__crea
$LN13@stbi__crea:

; 4222 : 			}
; 4223 : 			for (j = 0; j < y; ++j) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN7@stbi__crea
$LN5@stbi__crea:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN7@stbi__crea:
	mov	eax, DWORD PTR y$4[rsp]
	cmp	DWORD PTR j$1[rsp], eax
	jge	$LN6@stbi__crea

; 4224 : 				for (i = 0; i < x; ++i) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN10@stbi__crea
$LN8@stbi__crea:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN10@stbi__crea:
	mov	eax, DWORD PTR x$2[rsp]
	cmp	DWORD PTR i$3[rsp], eax
	jge	$LN9@stbi__crea

; 4225 : 					int out_y = j * yspc[p] + yorig[p];

	movsxd	rax, DWORD PTR p$[rsp]
	mov	ecx, DWORD PTR j$1[rsp]
	imul	ecx, DWORD PTR yspc$8[rsp+rax*4]
	mov	eax, ecx
	movsxd	rcx, DWORD PTR p$[rsp]
	add	eax, DWORD PTR yorig$10[rsp+rcx*4]
	mov	DWORD PTR out_y$6[rsp], eax

; 4226 : 					int out_x = i * xspc[p] + xorig[p];

	movsxd	rax, DWORD PTR p$[rsp]
	mov	ecx, DWORD PTR i$3[rsp]
	imul	ecx, DWORD PTR xspc$9[rsp+rax*4]
	mov	eax, ecx
	movsxd	rcx, DWORD PTR p$[rsp]
	add	eax, DWORD PTR xorig$11[rsp+rcx*4]
	mov	DWORD PTR out_x$7[rsp], eax

; 4227 : 					memcpy(final + out_y * a->s->img_x * out_n + out_x * out_n,

	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	ecx, DWORD PTR j$1[rsp]
	imul	ecx, DWORD PTR x$2[rsp]
	add	ecx, DWORD PTR i$3[rsp]
	imul	ecx, DWORD PTR out_n$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR a$[rsp]
	add	rcx, QWORD PTR [rdx+24]
	mov	rdx, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	r8d, DWORD PTR out_y$6[rsp]
	imul	r8d, DWORD PTR [rdx]
	mov	edx, r8d
	imul	edx, DWORD PTR out_n$[rsp]
	mov	edx, edx
	mov	r8, QWORD PTR final$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, DWORD PTR out_x$7[rsp]
	imul	r8d, DWORD PTR out_n$[rsp]
	movsxd	r8, r8d
	add	rdx, r8
	mov	QWORD PTR tv274[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv274[rsp]
	mov	rcx, rax
	call	memcpy
	npad	1

; 4228 : 						a->out + (j * x + i) * out_n, out_n);
; 4229 : 				}

	jmp	$LN8@stbi__crea
$LN9@stbi__crea:

; 4230 : 			}

	jmp	$LN5@stbi__crea
$LN6@stbi__crea:

; 4231 : 			STBI_FREE(a->out);

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	free

; 4232 : 			image_data += img_len;

	mov	eax, DWORD PTR img_len$5[rsp]
	mov	rcx, QWORD PTR image_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR image_data$[rsp], rax

; 4233 : 			image_data_len -= img_len;

	mov	eax, DWORD PTR img_len$5[rsp]
	mov	ecx, DWORD PTR image_data_len$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR image_data_len$[rsp], eax
$LN12@stbi__crea:

; 4234 : 		}
; 4235 : 	}

	jmp	$LN2@stbi__crea
$LN3@stbi__crea:

; 4236 : 	a->out = final;

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR final$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 4237 : 
; 4238 : 	return 1;

	mov	eax, 1
$LN1@stbi__crea:

; 4239 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	ret	0
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ENDP ; stbi__create_png_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
scale$1 = 36
cur$2 = 40
img_n$ = 48
cur$3 = 56
i$ = 64
q$4 = 68
in$5 = 72
prior$6 = 80
j$ = 88
filter_bytes$7 = 92
nk$8 = 96
filter$9 = 100
stride$ = 104
img_width_bytes$ = 108
img_len$ = 112
tv144 = 116
width$10 = 120
tv235 = 124
tv368 = 128
tv608 = 132
tv130 = 136
tv192 = 140
tv321 = 144
tv304 = 148
tv352 = 152
tv518 = 156
tv501 = 160
tv573 = 164
s$ = 168
a$ = 192
raw$ = 200
raw_len$ = 208
out_n$ = 216
x$ = 224
y$ = 232
depth$ = 240
color$ = 248
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z PROC ; stbi__create_png_image_raw

; 4016 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 4017 : 	stbi__context* s = a->s;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR s$[rsp], rax

; 4018 : 	stbi__uint32 i, j, stride = x * out_n;

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR out_n$[rsp]
	mov	DWORD PTR stride$[rsp], eax

; 4019 : 	stbi__uint32 img_len, img_width_bytes;
; 4020 : 	int k;
; 4021 : 	int img_n = s->img_n; // copy it into a local for later

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR img_n$[rsp], eax

; 4022 : 
; 4023 : 	STBI_ASSERT(out_n == s->img_n || out_n == s->img_n + 1);
; 4024 : 	a->out = (stbi_uc*)stbi__malloc(x * y * out_n); // extra bytes to write off the end into

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	imul	eax, DWORD PTR out_n$[rsp]
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	rcx, QWORD PTR a$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 4025 : 	if (!a->out) return stbi__err("outofmem", "Out of memory");

	mov	rax, QWORD PTR a$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN92@stbi__crea
	xor	eax, eax
	jmp	$LN1@stbi__crea
$LN92@stbi__crea:

; 4026 : 
; 4027 : 	img_width_bytes = (((img_n * x * depth) + 7) >> 3);

	mov	eax, DWORD PTR img_n$[rsp]
	imul	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR depth$[rsp]
	add	eax, 7
	shr	eax, 3
	mov	DWORD PTR img_width_bytes$[rsp], eax

; 4028 : 	img_len = (img_width_bytes + 1) * y;

	mov	eax, DWORD PTR img_width_bytes$[rsp]
	inc	eax
	imul	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR img_len$[rsp], eax

; 4029 : 	if (s->img_x == x && s->img_y == y) {

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN93@stbi__crea
	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN93@stbi__crea

; 4030 : 		if (raw_len != img_len) return stbi__err("not enough pixels", "Corrupt PNG");

	mov	eax, DWORD PTR img_len$[rsp]
	cmp	DWORD PTR raw_len$[rsp], eax
	je	SHORT $LN95@stbi__crea
	xor	eax, eax
	jmp	$LN1@stbi__crea
$LN95@stbi__crea:

; 4031 : 	}

	jmp	SHORT $LN94@stbi__crea
$LN93@stbi__crea:

; 4032 : 	else { // interlaced:
; 4033 : 		if (raw_len < img_len) return stbi__err("not enough pixels", "Corrupt PNG");

	mov	eax, DWORD PTR img_len$[rsp]
	cmp	DWORD PTR raw_len$[rsp], eax
	jae	SHORT $LN96@stbi__crea
	xor	eax, eax
	jmp	$LN1@stbi__crea
$LN96@stbi__crea:
$LN94@stbi__crea:

; 4034 : 	}
; 4035 : 
; 4036 : 	for (j = 0; j < y; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN4@stbi__crea
$LN2@stbi__crea:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN4@stbi__crea:
	mov	eax, DWORD PTR y$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN3@stbi__crea

; 4037 : 		stbi_uc* cur = a->out + stride * j;

	mov	eax, DWORD PTR stride$[rsp]
	imul	eax, DWORD PTR j$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR a$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR cur$3[rsp], rax

; 4038 : 		stbi_uc* prior = cur - stride;

	mov	eax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax

; 4039 : 		int filter = *raw++;

	mov	rax, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv130[rsp], eax
	mov	rax, QWORD PTR raw$[rsp]
	inc	rax
	mov	QWORD PTR raw$[rsp], rax
	mov	eax, DWORD PTR tv130[rsp]
	mov	DWORD PTR filter$9[rsp], eax

; 4040 : 		int filter_bytes = img_n;

	mov	eax, DWORD PTR img_n$[rsp]
	mov	DWORD PTR filter_bytes$7[rsp], eax

; 4041 : 		int width = x;

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR width$10[rsp], eax

; 4042 : 		if (filter > 4)

	cmp	DWORD PTR filter$9[rsp], 4
	jle	SHORT $LN97@stbi__crea

; 4043 : 			return stbi__err("invalid filter", "Corrupt PNG");

	xor	eax, eax
	jmp	$LN1@stbi__crea
$LN97@stbi__crea:

; 4044 : 
; 4045 : 		if (depth < 8) {

	cmp	DWORD PTR depth$[rsp], 8
	jge	SHORT $LN98@stbi__crea

; 4046 : 			STBI_ASSERT(img_width_bytes <= x);
; 4047 : 			cur += x * out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR out_n$[rsp]
	sub	eax, DWORD PTR img_width_bytes$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax

; 4048 : 			filter_bytes = 1;

	mov	DWORD PTR filter_bytes$7[rsp], 1

; 4049 : 			width = img_width_bytes;

	mov	eax, DWORD PTR img_width_bytes$[rsp]
	mov	DWORD PTR width$10[rsp], eax
$LN98@stbi__crea:

; 4050 : 		}
; 4051 : 
; 4052 : 		// if first row, use special filter that doesn't sample previous row
; 4053 : 		if (j == 0) filter = first_row_filter[filter];

	cmp	DWORD PTR j$[rsp], 0
	jne	SHORT $LN99@stbi__crea
	movsxd	rax, DWORD PTR filter$9[rsp]
	lea	rcx, OFFSET FLAT:?first_row_filter@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR filter$9[rsp], eax
$LN99@stbi__crea:

; 4054 : 
; 4055 : 		// handle first byte explicitly
; 4056 : 		for (k = 0; k < filter_bytes; ++k) {

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN7@stbi__crea
$LN5@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN7@stbi__crea:
	mov	eax, DWORD PTR filter_bytes$7[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	$LN6@stbi__crea

; 4057 : 			switch (filter) {

	mov	eax, DWORD PTR filter$9[rsp]
	mov	DWORD PTR tv144[rsp], eax
	cmp	DWORD PTR tv144[rsp], 6
	ja	$LN8@stbi__crea
	movsxd	rax, DWORD PTR tv144[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN152@stbi__crea[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN100@stbi__crea:

; 4058 : 			case STBI__F_none: cur[k] = raw[k]; break;

	movsxd	rax, DWORD PTR k$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	r8, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN8@stbi__crea
$LN101@stbi__crea:

; 4059 : 			case STBI__F_sub: cur[k] = raw[k]; break;

	movsxd	rax, DWORD PTR k$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	r8, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN8@stbi__crea
$LN102@stbi__crea:

; 4060 : 			case STBI__F_up: cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN8@stbi__crea
$LN103@stbi__crea:

; 4061 : 			case STBI__F_avg: cur[k] = STBI__BYTECAST(raw[k] + (prior[k] >> 1)); break;

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	sar	ecx, 1
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN8@stbi__crea
$LN104@stbi__crea:

; 4062 : 			case STBI__F_paeth: cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0, prior[k], 0)); break;

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv192[rsp], eax
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	xor	r8d, r8d
	mov	edx, ecx
	xor	ecx, ecx
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	mov	ecx, DWORD PTR tv192[rsp]
	add	ecx, eax
	mov	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN8@stbi__crea
$LN105@stbi__crea:

; 4063 : 			case STBI__F_avg_first: cur[k] = raw[k]; break;

	movsxd	rax, DWORD PTR k$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	r8, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN8@stbi__crea
$LN106@stbi__crea:

; 4064 : 			case STBI__F_paeth_first: cur[k] = raw[k]; break;

	movsxd	rax, DWORD PTR k$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	r8, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN8@stbi__crea:

; 4065 : 			}
; 4066 : 		}

	jmp	$LN5@stbi__crea
$LN6@stbi__crea:

; 4067 : 
; 4068 : 		if (depth == 8) {

	cmp	DWORD PTR depth$[rsp], 8
	jne	SHORT $LN107@stbi__crea

; 4069 : 			if (img_n != out_n)

	mov	eax, DWORD PTR out_n$[rsp]
	cmp	DWORD PTR img_n$[rsp], eax
	je	SHORT $LN109@stbi__crea

; 4070 : 				cur[img_n] = 255; // first pixel

	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
$LN109@stbi__crea:

; 4071 : 			raw += img_n;

	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax

; 4072 : 			cur += out_n;

	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax

; 4073 : 			prior += out_n;

	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax

; 4074 : 		}

	jmp	SHORT $LN108@stbi__crea
$LN107@stbi__crea:

; 4075 : 		else {
; 4076 : 			raw += 1;

	mov	rax, QWORD PTR raw$[rsp]
	inc	rax
	mov	QWORD PTR raw$[rsp], rax

; 4077 : 			cur += 1;

	mov	rax, QWORD PTR cur$3[rsp]
	inc	rax
	mov	QWORD PTR cur$3[rsp], rax

; 4078 : 			prior += 1;

	mov	rax, QWORD PTR prior$6[rsp]
	inc	rax
	mov	QWORD PTR prior$6[rsp], rax
$LN108@stbi__crea:

; 4079 : 		}
; 4080 : 
; 4081 : 		// this is a little gross, so that we don't switch per-pixel or per-component
; 4082 : 		if (depth < 8 || img_n == out_n) {

	cmp	DWORD PTR depth$[rsp], 8
	jl	SHORT $LN112@stbi__crea
	mov	eax, DWORD PTR out_n$[rsp]
	cmp	DWORD PTR img_n$[rsp], eax
	jne	$LN110@stbi__crea
$LN112@stbi__crea:

; 4083 : 			int nk = (width - 1) * img_n;

	mov	eax, DWORD PTR width$10[rsp]
	dec	eax
	imul	eax, DWORD PTR img_n$[rsp]
	mov	DWORD PTR nk$8[rsp], eax

; 4084 : #define CASE(f) \
; 4085 :              case f:     \
; 4086 :                 for (k=0; k < nk; ++k)
; 4087 : 			switch (filter) {

	mov	eax, DWORD PTR filter$9[rsp]
	mov	DWORD PTR tv235[rsp], eax
	cmp	DWORD PTR tv235[rsp], 6
	ja	$LN10@stbi__crea
	movsxd	rax, DWORD PTR tv235[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN151@stbi__crea[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN113@stbi__crea:

; 4088 : 				// "none" filter turns into a memcpy here; make that explicit.
; 4089 : 			case STBI__F_none:         memcpy(cur, raw, nk); break;

	movsxd	rax, DWORD PTR nk$8[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR raw$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	call	memcpy
	npad	1
	jmp	$LN10@stbi__crea
$LN114@stbi__crea:

; 4090 : 				CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k - filter_bytes]); break;

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN14@stbi__crea
$LN12@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN14@stbi__crea:
	mov	eax, DWORD PTR nk$8[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN13@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR filter_bytes$7[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$3[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN12@stbi__crea
$LN13@stbi__crea:
	jmp	$LN10@stbi__crea
$LN115@stbi__crea:

; 4091 : 				CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN17@stbi__crea
$LN15@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN17@stbi__crea:
	mov	eax, DWORD PTR nk$8[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN16@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN15@stbi__crea
$LN16@stbi__crea:
	jmp	$LN10@stbi__crea
$LN116@stbi__crea:

; 4092 : 				CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)); break;

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN20@stbi__crea
$LN18@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN20@stbi__crea:
	mov	eax, DWORD PTR nk$8[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN19@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	edx, DWORD PTR filter_bytes$7[rsp]
	mov	r8d, DWORD PTR k$[rsp]
	sub	r8d, edx
	mov	edx, r8d
	movsxd	rdx, edx
	mov	r8, QWORD PTR cur$3[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	add	ecx, edx
	sar	ecx, 1
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN18@stbi__crea
$LN19@stbi__crea:
	jmp	$LN10@stbi__crea
$LN117@stbi__crea:

; 4093 : 				CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes])); break;

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN23@stbi__crea
$LN21@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN23@stbi__crea:
	mov	eax, DWORD PTR nk$8[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	$LN22@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv304[rsp], eax
	mov	ecx, DWORD PTR filter_bytes$7[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	movsxd	rdx, DWORD PTR k$[rsp]
	mov	r8, QWORD PTR prior$6[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	mov	r8d, DWORD PTR filter_bytes$7[rsp]
	mov	r9d, DWORD PTR k$[rsp]
	sub	r9d, r8d
	mov	r8d, r9d
	movsxd	r8, r8d
	mov	r9, QWORD PTR cur$3[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	mov	DWORD PTR tv321[rsp], r8d
	mov	r8d, ecx
	mov	ecx, DWORD PTR tv321[rsp]
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	mov	ecx, DWORD PTR tv304[rsp]
	add	ecx, eax
	mov	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN21@stbi__crea
$LN22@stbi__crea:
	jmp	$LN10@stbi__crea
$LN118@stbi__crea:

; 4094 : 				CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k - filter_bytes] >> 1)); break;

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN26@stbi__crea
$LN24@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN26@stbi__crea:
	mov	eax, DWORD PTR nk$8[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN25@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR filter_bytes$7[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$3[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	sar	ecx, 1
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN24@stbi__crea
$LN25@stbi__crea:
	jmp	SHORT $LN10@stbi__crea
$LN119@stbi__crea:

; 4095 : 				CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0)); break;

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN29@stbi__crea
$LN27@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN29@stbi__crea:
	mov	eax, DWORD PTR nk$8[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN28@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv352[rsp], eax
	mov	ecx, DWORD PTR filter_bytes$7[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$3[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	xor	r8d, r8d
	xor	edx, edx
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	mov	ecx, DWORD PTR tv352[rsp]
	add	ecx, eax
	mov	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN27@stbi__crea
$LN28@stbi__crea:
$LN10@stbi__crea:

; 4096 : 			}
; 4097 : #undef CASE
; 4098 : 			raw += nk;

	movsxd	rax, DWORD PTR nk$8[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax

; 4099 : 		}

	jmp	$LN111@stbi__crea
$LN110@stbi__crea:

; 4100 : 		else {
; 4101 : 			STBI_ASSERT(img_n + 1 == out_n);
; 4102 : #define CASE(f) \
; 4103 :              case f:     \
; 4104 :                 for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \
; 4105 :                    for (k=0; k < img_n; ++k)
; 4106 : 			switch (filter) {

	mov	eax, DWORD PTR filter$9[rsp]
	mov	DWORD PTR tv368[rsp], eax
	cmp	DWORD PTR tv368[rsp], 6
	ja	$LN30@stbi__crea
	movsxd	rax, DWORD PTR tv368[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN150@stbi__crea[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN120@stbi__crea:

; 4107 : 				CASE(STBI__F_none)         cur[k] = raw[k]; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN34@stbi__crea
$LN32@stbi__crea:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax
$LN34@stbi__crea:
	cmp	DWORD PTR i$[rsp], 1
	jb	SHORT $LN33@stbi__crea
	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN37@stbi__crea
$LN35@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN37@stbi__crea:
	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN36@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	r8, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN35@stbi__crea
$LN36@stbi__crea:
	jmp	$LN32@stbi__crea
$LN33@stbi__crea:
	jmp	$LN30@stbi__crea
$LN121@stbi__crea:

; 4108 : 				CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k - out_n]); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN40@stbi__crea
$LN38@stbi__crea:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax
$LN40@stbi__crea:
	cmp	DWORD PTR i$[rsp], 1
	jb	SHORT $LN39@stbi__crea
	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN43@stbi__crea
$LN41@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN43@stbi__crea:
	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN42@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR out_n$[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$3[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN41@stbi__crea
$LN42@stbi__crea:
	jmp	$LN38@stbi__crea
$LN39@stbi__crea:
	jmp	$LN30@stbi__crea
$LN122@stbi__crea:

; 4109 : 				CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN46@stbi__crea
$LN44@stbi__crea:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax
$LN46@stbi__crea:
	cmp	DWORD PTR i$[rsp], 1
	jb	SHORT $LN45@stbi__crea
	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN49@stbi__crea
$LN47@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN49@stbi__crea:
	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN48@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN47@stbi__crea
$LN48@stbi__crea:
	jmp	$LN44@stbi__crea
$LN45@stbi__crea:
	jmp	$LN30@stbi__crea
$LN123@stbi__crea:

; 4110 : 				CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k - out_n]) >> 1)); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN52@stbi__crea
$LN50@stbi__crea:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax
$LN52@stbi__crea:
	cmp	DWORD PTR i$[rsp], 1
	jb	SHORT $LN51@stbi__crea
	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN55@stbi__crea
$LN53@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN55@stbi__crea:
	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN54@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	edx, DWORD PTR out_n$[rsp]
	mov	r8d, DWORD PTR k$[rsp]
	sub	r8d, edx
	mov	edx, r8d
	movsxd	rdx, edx
	mov	r8, QWORD PTR cur$3[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	add	ecx, edx
	sar	ecx, 1
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN53@stbi__crea
$LN54@stbi__crea:
	jmp	$LN50@stbi__crea
$LN51@stbi__crea:
	jmp	$LN30@stbi__crea
$LN124@stbi__crea:

; 4111 : 				CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - out_n], prior[k], prior[k - out_n])); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN58@stbi__crea
$LN56@stbi__crea:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax
$LN58@stbi__crea:
	cmp	DWORD PTR i$[rsp], 1
	jb	$LN57@stbi__crea
	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN61@stbi__crea
$LN59@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN61@stbi__crea:
	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	$LN60@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv501[rsp], eax
	mov	ecx, DWORD PTR out_n$[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR prior$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	movsxd	rdx, DWORD PTR k$[rsp]
	mov	r8, QWORD PTR prior$6[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	mov	r8d, DWORD PTR out_n$[rsp]
	mov	r9d, DWORD PTR k$[rsp]
	sub	r9d, r8d
	mov	r8d, r9d
	movsxd	r8, r8d
	mov	r9, QWORD PTR cur$3[rsp]
	movzx	r8d, BYTE PTR [r9+r8]
	mov	DWORD PTR tv518[rsp], r8d
	mov	r8d, ecx
	mov	ecx, DWORD PTR tv518[rsp]
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	mov	ecx, DWORD PTR tv501[rsp]
	add	ecx, eax
	mov	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN59@stbi__crea
$LN60@stbi__crea:
	jmp	$LN56@stbi__crea
$LN57@stbi__crea:
	jmp	$LN30@stbi__crea
$LN125@stbi__crea:

; 4112 : 				CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k - out_n] >> 1)); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN64@stbi__crea
$LN62@stbi__crea:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax
$LN64@stbi__crea:
	cmp	DWORD PTR i$[rsp], 1
	jb	SHORT $LN63@stbi__crea
	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN67@stbi__crea
$LN65@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN67@stbi__crea:
	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN66@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR out_n$[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$3[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	sar	ecx, 1
	add	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN65@stbi__crea
$LN66@stbi__crea:
	jmp	$LN62@stbi__crea
$LN63@stbi__crea:
	jmp	$LN30@stbi__crea
$LN126@stbi__crea:

; 4113 : 				CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k - out_n], 0, 0)); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN70@stbi__crea
$LN68@stbi__crea:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	movsxd	rax, DWORD PTR img_n$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR raw$[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR cur$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cur$3[rsp], rax
	movsxd	rax, DWORD PTR out_n$[rsp]
	mov	rcx, QWORD PTR prior$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR prior$6[rsp], rax
$LN70@stbi__crea:
	cmp	DWORD PTR i$[rsp], 1
	jb	SHORT $LN69@stbi__crea
	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN73@stbi__crea
$LN71@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN73@stbi__crea:
	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN72@stbi__crea
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR raw$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv573[rsp], eax
	mov	ecx, DWORD PTR out_n$[rsp]
	mov	edx, DWORD PTR k$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$3[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	xor	r8d, r8d
	xor	edx, edx
	call	?stbi__paeth@@YAHHHH@Z			; stbi__paeth
	mov	ecx, DWORD PTR tv573[rsp]
	add	ecx, eax
	mov	eax, ecx
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR cur$3[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN71@stbi__crea
$LN72@stbi__crea:
	jmp	$LN68@stbi__crea
$LN69@stbi__crea:
$LN30@stbi__crea:
$LN111@stbi__crea:

; 4114 : 			}
; 4115 : #undef CASE
; 4116 : 		}
; 4117 : 	}

	jmp	$LN2@stbi__crea
$LN3@stbi__crea:

; 4118 : 
; 4119 : 	// we make a separate pass to expand bits to pixels; for performance,
; 4120 : 	// this could run two scanlines behind the above code, so it won't
; 4121 : 	// intefere with filtering but will still be in the cache.
; 4122 : 	if (depth < 8) {

	cmp	DWORD PTR depth$[rsp], 8
	jge	$LN127@stbi__crea

; 4123 : 		for (j = 0; j < y; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN76@stbi__crea
$LN74@stbi__crea:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN76@stbi__crea:
	mov	eax, DWORD PTR y$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jae	$LN75@stbi__crea

; 4124 : 			stbi_uc* cur = a->out + stride * j;

	mov	eax, DWORD PTR stride$[rsp]
	imul	eax, DWORD PTR j$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR a$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR cur$2[rsp], rax

; 4125 : 			stbi_uc* in = a->out + stride * j + x * out_n - img_width_bytes;

	mov	eax, DWORD PTR stride$[rsp]
	imul	eax, DWORD PTR j$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR x$[rsp]
	imul	ecx, DWORD PTR out_n$[rsp]
	mov	ecx, ecx
	add	rax, rcx
	mov	ecx, DWORD PTR img_width_bytes$[rsp]
	sub	rax, rcx
	mov	QWORD PTR in$5[rsp], rax

; 4126 : 			// unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
; 4127 : 			// png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
; 4128 : 			stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

	cmp	DWORD PTR color$[rsp], 0
	jne	SHORT $LN148@stbi__crea
	movsxd	rax, DWORD PTR depth$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__depth_scale_table@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv608[rsp], eax
	jmp	SHORT $LN149@stbi__crea
$LN148@stbi__crea:
	mov	DWORD PTR tv608[rsp], 1
$LN149@stbi__crea:
	movzx	eax, BYTE PTR tv608[rsp]
	mov	BYTE PTR scale$1[rsp], al

; 4129 : 
; 4130 : 			// note that the final byte might overshoot and write more data than desired.
; 4131 : 			// we can allocate enough data that this never writes out of memory, but it
; 4132 : 			// could also overwrite the next scanline. can it overwrite non-empty data
; 4133 : 			// on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
; 4134 : 			// so we need to explicitly clamp the final ones
; 4135 : 
; 4136 : 			if (depth == 4) {

	cmp	DWORD PTR depth$[rsp], 4
	jne	$LN128@stbi__crea

; 4137 : 				for (k = x * img_n; k >= 2; k -= 2, ++in) {

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR img_n$[rsp]
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN79@stbi__crea
$LN77@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	sub	eax, 2
	mov	DWORD PTR k$[rsp], eax
	mov	rax, QWORD PTR in$5[rsp]
	inc	rax
	mov	QWORD PTR in$5[rsp], rax
$LN79@stbi__crea:
	cmp	DWORD PTR k$[rsp], 2
	jl	SHORT $LN78@stbi__crea

; 4138 : 					*cur++ = scale * ((*in >> 4));

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 4
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4139 : 					*cur++ = scale * ((*in) & 0x0f);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	ecx, 15
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4140 : 				}

	jmp	SHORT $LN77@stbi__crea
$LN78@stbi__crea:

; 4141 : 				if (k > 0) *cur++ = scale * ((*in >> 4));

	cmp	DWORD PTR k$[rsp], 0
	jle	SHORT $LN130@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 4
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN130@stbi__crea:

; 4142 : 			}

	jmp	$LN129@stbi__crea
$LN128@stbi__crea:

; 4143 : 			else if (depth == 2) {

	cmp	DWORD PTR depth$[rsp], 2
	jne	$LN131@stbi__crea

; 4144 : 				for (k = x * img_n; k >= 4; k -= 4, ++in) {

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR img_n$[rsp]
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN82@stbi__crea
$LN80@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	sub	eax, 4
	mov	DWORD PTR k$[rsp], eax
	mov	rax, QWORD PTR in$5[rsp]
	inc	rax
	mov	QWORD PTR in$5[rsp], rax
$LN82@stbi__crea:
	cmp	DWORD PTR k$[rsp], 4
	jl	$LN81@stbi__crea

; 4145 : 					*cur++ = scale * ((*in >> 6));

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 6
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4146 : 					*cur++ = scale * ((*in >> 4) & 0x03);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 4
	and	ecx, 3
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4147 : 					*cur++ = scale * ((*in >> 2) & 0x03);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 2
	and	ecx, 3
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4148 : 					*cur++ = scale * ((*in) & 0x03);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	ecx, 3
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4149 : 				}

	jmp	$LN80@stbi__crea
$LN81@stbi__crea:

; 4150 : 				if (k > 0) *cur++ = scale * ((*in >> 6));

	cmp	DWORD PTR k$[rsp], 0
	jle	SHORT $LN133@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 6
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN133@stbi__crea:

; 4151 : 				if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);

	cmp	DWORD PTR k$[rsp], 1
	jle	SHORT $LN134@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 4
	and	ecx, 3
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN134@stbi__crea:

; 4152 : 				if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);

	cmp	DWORD PTR k$[rsp], 2
	jle	SHORT $LN135@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 2
	and	ecx, 3
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN135@stbi__crea:

; 4153 : 			}

	jmp	$LN132@stbi__crea
$LN131@stbi__crea:

; 4154 : 			else if (depth == 1) {

	cmp	DWORD PTR depth$[rsp], 1
	jne	$LN136@stbi__crea

; 4155 : 				for (k = x * img_n; k >= 8; k -= 8, ++in) {

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR img_n$[rsp]
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN85@stbi__crea
$LN83@stbi__crea:
	mov	eax, DWORD PTR k$[rsp]
	sub	eax, 8
	mov	DWORD PTR k$[rsp], eax
	mov	rax, QWORD PTR in$5[rsp]
	inc	rax
	mov	QWORD PTR in$5[rsp], rax
$LN85@stbi__crea:
	cmp	DWORD PTR k$[rsp], 8
	jl	$LN84@stbi__crea

; 4156 : 					*cur++ = scale * ((*in >> 7));

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 7
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4157 : 					*cur++ = scale * ((*in >> 6) & 0x01);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 6
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4158 : 					*cur++ = scale * ((*in >> 5) & 0x01);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 5
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4159 : 					*cur++ = scale * ((*in >> 4) & 0x01);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 4
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4160 : 					*cur++ = scale * ((*in >> 3) & 0x01);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 3
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4161 : 					*cur++ = scale * ((*in >> 2) & 0x01);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 2
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4162 : 					*cur++ = scale * ((*in >> 1) & 0x01);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 1
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4163 : 					*cur++ = scale * ((*in) & 0x01);

	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax

; 4164 : 				}

	jmp	$LN83@stbi__crea
$LN84@stbi__crea:

; 4165 : 				if (k > 0) *cur++ = scale * ((*in >> 7));

	cmp	DWORD PTR k$[rsp], 0
	jle	SHORT $LN137@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 7
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN137@stbi__crea:

; 4166 : 				if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);

	cmp	DWORD PTR k$[rsp], 1
	jle	SHORT $LN138@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 6
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN138@stbi__crea:

; 4167 : 				if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);

	cmp	DWORD PTR k$[rsp], 2
	jle	SHORT $LN139@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 5
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN139@stbi__crea:

; 4168 : 				if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);

	cmp	DWORD PTR k$[rsp], 3
	jle	SHORT $LN140@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 4
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN140@stbi__crea:

; 4169 : 				if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);

	cmp	DWORD PTR k$[rsp], 4
	jle	SHORT $LN141@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 3
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN141@stbi__crea:

; 4170 : 				if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);

	cmp	DWORD PTR k$[rsp], 5
	jle	SHORT $LN142@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 2
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN142@stbi__crea:

; 4171 : 				if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);

	cmp	DWORD PTR k$[rsp], 6
	jle	SHORT $LN143@stbi__crea
	movzx	eax, BYTE PTR scale$1[rsp]
	mov	rcx, QWORD PTR in$5[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sar	ecx, 1
	and	ecx, 1
	imul	eax, ecx
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR cur$2[rsp]
	inc	rax
	mov	QWORD PTR cur$2[rsp], rax
$LN143@stbi__crea:
$LN136@stbi__crea:
$LN132@stbi__crea:
$LN129@stbi__crea:

; 4172 : 			}
; 4173 : 			if (img_n != out_n) {

	mov	eax, DWORD PTR out_n$[rsp]
	cmp	DWORD PTR img_n$[rsp], eax
	je	$LN144@stbi__crea

; 4174 : 				int q;
; 4175 : 				// insert alpha = 255
; 4176 : 				cur = a->out + stride * j;

	mov	eax, DWORD PTR stride$[rsp]
	imul	eax, DWORD PTR j$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR a$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR cur$2[rsp], rax

; 4177 : 				if (img_n == 1) {

	cmp	DWORD PTR img_n$[rsp], 1
	jne	SHORT $LN145@stbi__crea

; 4178 : 					for (q = x - 1; q >= 0; --q) {

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR q$4[rsp], eax
	jmp	SHORT $LN88@stbi__crea
$LN86@stbi__crea:
	mov	eax, DWORD PTR q$4[rsp]
	dec	eax
	mov	DWORD PTR q$4[rsp], eax
$LN88@stbi__crea:
	cmp	DWORD PTR q$4[rsp], 0
	jl	SHORT $LN87@stbi__crea

; 4179 : 						cur[q * 2 + 1] = 255;

	mov	eax, DWORD PTR q$4[rsp]
	lea	eax, DWORD PTR [rax+rax+1]
	cdqe
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH

; 4180 : 						cur[q * 2 + 0] = cur[q];

	movsxd	rax, DWORD PTR q$4[rsp]
	mov	ecx, DWORD PTR q$4[rsp]
	add	ecx, ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$2[rsp]
	mov	r8, QWORD PTR cur$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4181 : 					}

	jmp	SHORT $LN86@stbi__crea
$LN87@stbi__crea:

; 4182 : 				}

	jmp	$LN146@stbi__crea
$LN145@stbi__crea:

; 4183 : 				else {
; 4184 : 					STBI_ASSERT(img_n == 3);
; 4185 : 					for (q = x - 1; q >= 0; --q) {

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR q$4[rsp], eax
	jmp	SHORT $LN91@stbi__crea
$LN89@stbi__crea:
	mov	eax, DWORD PTR q$4[rsp]
	dec	eax
	mov	DWORD PTR q$4[rsp], eax
$LN91@stbi__crea:
	cmp	DWORD PTR q$4[rsp], 0
	jl	$LN90@stbi__crea

; 4186 : 						cur[q * 4 + 3] = 255;

	mov	eax, DWORD PTR q$4[rsp]
	lea	eax, DWORD PTR [rax*4+3]
	cdqe
	mov	rcx, QWORD PTR cur$2[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH

; 4187 : 						cur[q * 4 + 2] = cur[q * 3 + 2];

	imul	eax, DWORD PTR q$4[rsp], 3
	add	eax, 2
	cdqe
	mov	ecx, DWORD PTR q$4[rsp]
	lea	ecx, DWORD PTR [rcx*4+2]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$2[rsp]
	mov	r8, QWORD PTR cur$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4188 : 						cur[q * 4 + 1] = cur[q * 3 + 1];

	imul	eax, DWORD PTR q$4[rsp], 3
	inc	eax
	cdqe
	mov	ecx, DWORD PTR q$4[rsp]
	lea	ecx, DWORD PTR [rcx*4+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$2[rsp]
	mov	r8, QWORD PTR cur$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4189 : 						cur[q * 4 + 0] = cur[q * 3 + 0];

	imul	eax, DWORD PTR q$4[rsp], 3
	cdqe
	mov	ecx, DWORD PTR q$4[rsp]
	shl	ecx, 2
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cur$2[rsp]
	mov	r8, QWORD PTR cur$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 4190 : 					}

	jmp	$LN89@stbi__crea
$LN90@stbi__crea:
$LN146@stbi__crea:
$LN144@stbi__crea:

; 4191 : 				}
; 4192 : 			}
; 4193 : 		}

	jmp	$LN74@stbi__crea
$LN75@stbi__crea:
$LN127@stbi__crea:

; 4194 : 	}
; 4195 : 
; 4196 : 	return 1;

	mov	eax, 1
$LN1@stbi__crea:

; 4197 : }

	add	rsp, 184				; 000000b8H
	ret	0
	npad	1
$LN152@stbi__crea:
	DD	$LN100@stbi__crea
	DD	$LN101@stbi__crea
	DD	$LN102@stbi__crea
	DD	$LN103@stbi__crea
	DD	$LN104@stbi__crea
	DD	$LN105@stbi__crea
	DD	$LN106@stbi__crea
$LN151@stbi__crea:
	DD	$LN113@stbi__crea
	DD	$LN114@stbi__crea
	DD	$LN115@stbi__crea
	DD	$LN116@stbi__crea
	DD	$LN117@stbi__crea
	DD	$LN118@stbi__crea
	DD	$LN119@stbi__crea
$LN150@stbi__crea:
	DD	$LN120@stbi__crea
	DD	$LN121@stbi__crea
	DD	$LN122@stbi__crea
	DD	$LN123@stbi__crea
	DD	$LN124@stbi__crea
	DD	$LN125@stbi__crea
	DD	$LN126@stbi__crea
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ENDP ; stbi__create_png_image_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 32
pa$ = 36
pc$ = 40
pb$ = 44
a$ = 64
b$ = 72
c$ = 80
?stbi__paeth@@YAHHHH@Z PROC				; stbi__paeth

; 4002 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 4003 : 	int p = a + b - c;

	mov	eax, DWORD PTR b$[rsp]
	mov	ecx, DWORD PTR a$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sub	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR p$[rsp], eax

; 4004 : 	int pa = abs(p - a);

	mov	eax, DWORD PTR a$[rsp]
	mov	ecx, DWORD PTR p$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, eax
	call	abs
	mov	DWORD PTR pa$[rsp], eax

; 4005 : 	int pb = abs(p - b);

	mov	eax, DWORD PTR b$[rsp]
	mov	ecx, DWORD PTR p$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, eax
	call	abs
	mov	DWORD PTR pb$[rsp], eax

; 4006 : 	int pc = abs(p - c);

	mov	eax, DWORD PTR c$[rsp]
	mov	ecx, DWORD PTR p$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, eax
	call	abs
	mov	DWORD PTR pc$[rsp], eax

; 4007 : 	if (pa <= pb && pa <= pc) return a;

	mov	eax, DWORD PTR pb$[rsp]
	cmp	DWORD PTR pa$[rsp], eax
	jg	SHORT $LN2@stbi__paet
	mov	eax, DWORD PTR pc$[rsp]
	cmp	DWORD PTR pa$[rsp], eax
	jg	SHORT $LN2@stbi__paet
	mov	eax, DWORD PTR a$[rsp]
	jmp	SHORT $LN1@stbi__paet
$LN2@stbi__paet:

; 4008 : 	if (pb <= pc) return b;

	mov	eax, DWORD PTR pc$[rsp]
	cmp	DWORD PTR pb$[rsp], eax
	jg	SHORT $LN3@stbi__paet
	mov	eax, DWORD PTR b$[rsp]
	jmp	SHORT $LN1@stbi__paet
$LN3@stbi__paet:

; 4009 : 	return c;

	mov	eax, DWORD PTR c$[rsp]
$LN1@stbi__paet:

; 4010 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__paeth@@YAHHHH@Z ENDP				; stbi__paeth
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z PROC	; stbi__check_png_header

; 3966 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3967 : 	static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 3968 : 	int i;
; 3969 : 	for (i = 0; i < 8; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__chec
$LN2@stbi__chec:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__chec:
	cmp	DWORD PTR i$[rsp], 8
	jge	SHORT $LN3@stbi__chec

; 3970 : 		if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig", "Not a PNG");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4PAEA
	movzx	ecx, BYTE PTR [rdx+rcx]
	cmp	eax, ecx
	je	SHORT $LN5@stbi__chec
	xor	eax, eax
	jmp	SHORT $LN1@stbi__chec
$LN5@stbi__chec:
	jmp	SHORT $LN2@stbi__chec
$LN3@stbi__chec:

; 3971 : 	return 1;

	mov	eax, 1
$LN1@stbi__chec:

; 3972 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ENDP	; stbi__check_png_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
c$ = 32
s$ = 64
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z PROC ; stbi__get_chunk_header

; 3958 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3959 : 	stbi__pngchunk c;
; 3960 : 	c.length = stbi__get32be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	DWORD PTR c$[rsp], eax

; 3961 : 	c.type = stbi__get32be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	DWORD PTR c$[rsp+4], eax

; 3962 : 	return c;

	mov	rax, QWORD PTR c$[rsp]

; 3963 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z ENDP ; stbi__get_chunk_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
a$ = 48
obuf$ = 56
olen$ = 64
exp$ = 72
parse_header$ = 80
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z PROC	; stbi__do_zlib

; 3852 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3853 : 	a->zout_start = obuf;

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR obuf$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 3854 : 	a->zout = obuf;

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR obuf$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3855 : 	a->zout_end = obuf + olen;

	movsxd	rax, DWORD PTR olen$[rsp]
	mov	rcx, QWORD PTR obuf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR a$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 3856 : 	a->z_expandable = exp;

	mov	rax, QWORD PTR a$[rsp]
	mov	ecx, DWORD PTR exp$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 3857 : 
; 3858 : 	return stbi__parse_zlib(a, parse_header);

	mov	edx, DWORD PTR parse_header$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ; stbi__parse_zlib

; 3859 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ENDP	; stbi__do_zlib
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
type$ = 32
final$ = 36
a$ = 64
parse_header$ = 72
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z PROC		; stbi__parse_zlib

; 3820 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3821 : 	int final, type;
; 3822 : 	if (parse_header)

	cmp	DWORD PTR parse_header$[rsp], 0
	je	SHORT $LN5@stbi__pars

; 3823 : 		if (!stbi__parse_zlib_header(a)) return 0;

	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_zlib_header
	test	eax, eax
	jne	SHORT $LN6@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN6@stbi__pars:
$LN5@stbi__pars:

; 3824 : 	a->num_bits = 0;

	mov	rax, QWORD PTR a$[rsp]
	mov	DWORD PTR [rax+16], 0

; 3825 : 	a->code_buffer = 0;

	mov	rax, QWORD PTR a$[rsp]
	mov	DWORD PTR [rax+20], 0
$LN4@stbi__pars:

; 3826 : 	do {
; 3827 : 		final = stbi__zreceive(a, 1);

	mov	edx, 1
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	mov	DWORD PTR final$[rsp], eax

; 3828 : 		type = stbi__zreceive(a, 2);

	mov	edx, 2
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	mov	DWORD PTR type$[rsp], eax

; 3829 : 		if (type == 0) {

	cmp	DWORD PTR type$[rsp], 0
	jne	SHORT $LN7@stbi__pars

; 3830 : 			if (!stbi__parse_uncomperssed_block(a)) return 0;

	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_uncomperssed_block
	test	eax, eax
	jne	SHORT $LN9@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN9@stbi__pars:

; 3831 : 		}

	jmp	$LN8@stbi__pars
$LN7@stbi__pars:

; 3832 : 		else if (type == 3) {

	cmp	DWORD PTR type$[rsp], 3
	jne	SHORT $LN10@stbi__pars

; 3833 : 			return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars

; 3834 : 		}

	jmp	$LN11@stbi__pars
$LN10@stbi__pars:

; 3835 : 		else {
; 3836 : 			if (type == 1) {

	cmp	DWORD PTR type$[rsp], 1
	jne	SHORT $LN12@stbi__pars

; 3837 : 				// use fixed code lengths
; 3838 : 				if (!stbi__zdefault_distance[31]) stbi__init_zdefaults();

	mov	eax, 1
	imul	rax, rax, 31
	lea	rcx, OFFSET FLAT:?stbi__zdefault_distance@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN14@stbi__pars
	call	?stbi__init_zdefaults@@YAXXZ		; stbi__init_zdefaults
	npad	1
$LN14@stbi__pars:

; 3839 : 				if (!stbi__zbuild_huffman(&a->z_length, stbi__zdefault_length, 288)) return 0;

	mov	rax, QWORD PTR a$[rsp]
	add	rax, 52					; 00000034H
	mov	r8d, 288				; 00000120H
	lea	rdx, OFFSET FLAT:?stbi__zdefault_length@@3PAEA
	mov	rcx, rax
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	jne	SHORT $LN15@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN15@stbi__pars:

; 3840 : 				if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance, 32)) return 0;

	mov	rax, QWORD PTR a$[rsp]
	add	rax, 2072				; 00000818H
	mov	r8d, 32					; 00000020H
	lea	rdx, OFFSET FLAT:?stbi__zdefault_distance@@3PAEA
	mov	rcx, rax
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	jne	SHORT $LN16@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN16@stbi__pars:

; 3841 : 			}

	jmp	SHORT $LN13@stbi__pars
$LN12@stbi__pars:

; 3842 : 			else {
; 3843 : 				if (!stbi__compute_huffman_codes(a)) return 0;

	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ; stbi__compute_huffman_codes
	test	eax, eax
	jne	SHORT $LN17@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN17@stbi__pars:
$LN13@stbi__pars:

; 3844 : 			}
; 3845 : 			if (!stbi__parse_huffman_block(a)) return 0;

	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_huffman_block
	test	eax, eax
	jne	SHORT $LN18@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN18@stbi__pars:
$LN11@stbi__pars:
$LN8@stbi__pars:

; 3846 : 		}
; 3847 : 	} while (!final);

	cmp	DWORD PTR final$[rsp], 0
	je	$LN4@stbi__pars

; 3848 : 	return 1;

	mov	eax, 1
$LN1@stbi__pars:

; 3849 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ENDP		; stbi__parse_zlib
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
?stbi__init_zdefaults@@YAXXZ PROC			; stbi__init_zdefaults

; 3809 : {

	sub	rsp, 24

; 3810 : 	int i;   // use <= to match clearly with spec
; 3811 : 	for (i = 0; i <= 143; ++i)     stbi__zdefault_length[i] = 8;

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__init
$LN2@stbi__init:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__init:
	cmp	DWORD PTR i$[rsp], 143			; 0000008fH
	jg	SHORT $LN3@stbi__init
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdefault_length@@3PAEA
	mov	BYTE PTR [rcx+rax], 8
	jmp	SHORT $LN2@stbi__init
$LN3@stbi__init:

; 3812 : 	for (; i <= 255; ++i)     stbi__zdefault_length[i] = 9;

	jmp	SHORT $LN7@stbi__init
$LN5@stbi__init:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__init:
	cmp	DWORD PTR i$[rsp], 255			; 000000ffH
	jg	SHORT $LN6@stbi__init
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdefault_length@@3PAEA
	mov	BYTE PTR [rcx+rax], 9
	jmp	SHORT $LN5@stbi__init
$LN6@stbi__init:

; 3813 : 	for (; i <= 279; ++i)     stbi__zdefault_length[i] = 7;

	jmp	SHORT $LN10@stbi__init
$LN8@stbi__init:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@stbi__init:
	cmp	DWORD PTR i$[rsp], 279			; 00000117H
	jg	SHORT $LN9@stbi__init
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdefault_length@@3PAEA
	mov	BYTE PTR [rcx+rax], 7
	jmp	SHORT $LN8@stbi__init
$LN9@stbi__init:

; 3814 : 	for (; i <= 287; ++i)     stbi__zdefault_length[i] = 8;

	jmp	SHORT $LN13@stbi__init
$LN11@stbi__init:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@stbi__init:
	cmp	DWORD PTR i$[rsp], 287			; 0000011fH
	jg	SHORT $LN12@stbi__init
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdefault_length@@3PAEA
	mov	BYTE PTR [rcx+rax], 8
	jmp	SHORT $LN11@stbi__init
$LN12@stbi__init:

; 3815 : 
; 3816 : 	for (i = 0; i <= 31; ++i)     stbi__zdefault_distance[i] = 5;

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN16@stbi__init
$LN14@stbi__init:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN16@stbi__init:
	cmp	DWORD PTR i$[rsp], 31
	jg	SHORT $LN15@stbi__init
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdefault_distance@@3PAEA
	mov	BYTE PTR [rcx+rax], 5
	jmp	SHORT $LN14@stbi__init
$LN15@stbi__init:

; 3817 : }

	add	rsp, 24
	ret	0
?stbi__init_zdefaults@@YAXXZ ENDP			; stbi__init_zdefaults
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
cmf$ = 32
flg$ = 36
cm$ = 40
a$ = 64
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_zlib_header

; 3794 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3795 : 	int cmf = stbi__zget8(a);

	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z	; stbi__zget8
	movzx	eax, al
	mov	DWORD PTR cmf$[rsp], eax

; 3796 : 	int cm = cmf & 15;

	mov	eax, DWORD PTR cmf$[rsp]
	and	eax, 15
	mov	DWORD PTR cm$[rsp], eax

; 3797 : 	/* int cinfo = cmf >> 4; */
; 3798 : 	int flg = stbi__zget8(a);

	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z	; stbi__zget8
	movzx	eax, al
	mov	DWORD PTR flg$[rsp], eax

; 3799 : 	if ((cmf * 256 + flg) % 31 != 0) return stbi__err("bad zlib header", "Corrupt PNG"); // zlib spec

	imul	eax, DWORD PTR cmf$[rsp], 256		; 00000100H
	add	eax, DWORD PTR flg$[rsp]
	cdq
	mov	ecx, 31
	idiv	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN2@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN2@stbi__pars:

; 3800 : 	if (flg & 32) return stbi__err("no preset dict", "Corrupt PNG"); // preset dictionary not allowed in png

	mov	eax, DWORD PTR flg$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN3@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN3@stbi__pars:

; 3801 : 	if (cm != 8) return stbi__err("bad compression", "Corrupt PNG"); // DEFLATE required for png

	cmp	DWORD PTR cm$[rsp], 8
	je	SHORT $LN4@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN4@stbi__pars:

; 3802 : 	// window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 3803 : 	return 1;

	mov	eax, 1
$LN1@stbi__pars:

; 3804 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_zlib_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
len$ = 36
header$ = 40
nlen$ = 44
a$ = 64
?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__parse_uncomperssed_block

; 3765 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3766 : 	stbi_uc header[4];
; 3767 : 	int len, nlen, k;
; 3768 : 	if (a->num_bits & 7)

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 7
	test	eax, eax
	je	SHORT $LN6@stbi__pars

; 3769 : 		stbi__zreceive(a, a->num_bits & 7); // discard

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 7
	mov	edx, eax
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	npad	1
$LN6@stbi__pars:

; 3770 : 	// drain the bit-packed data into header
; 3771 : 	k = 0;

	mov	DWORD PTR k$[rsp], 0
$LN2@stbi__pars:

; 3772 : 	while (a->num_bits > 0) {

	mov	rax, QWORD PTR a$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jle	SHORT $LN3@stbi__pars

; 3773 : 		header[k++] = (stbi_uc)(a->code_buffer & 255); // suppress MSVC run-time check

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+20]
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	BYTE PTR header$[rsp+rcx], al
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax

; 3774 : 		a->code_buffer >>= 8;

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+20]
	shr	eax, 8
	mov	rcx, QWORD PTR a$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 3775 : 		a->num_bits -= 8;

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, 8
	mov	rcx, QWORD PTR a$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 3776 : 	}

	jmp	SHORT $LN2@stbi__pars
$LN3@stbi__pars:
$LN4@stbi__pars:

; 3777 : 	STBI_ASSERT(a->num_bits == 0);
; 3778 : 	// now fill header the normal way
; 3779 : 	while (k < 4)

	cmp	DWORD PTR k$[rsp], 4
	jge	SHORT $LN5@stbi__pars

; 3780 : 		header[k++] = stbi__zget8(a);

	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z	; stbi__zget8
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	BYTE PTR header$[rsp+rcx], al
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN4@stbi__pars
$LN5@stbi__pars:

; 3781 : 	len = header[1] * 256 + header[0];

	mov	eax, 1
	imul	rax, rax, 1
	movzx	eax, BYTE PTR header$[rsp+rax]
	imul	eax, eax, 256				; 00000100H
	mov	ecx, 1
	imul	rcx, rcx, 0
	movzx	ecx, BYTE PTR header$[rsp+rcx]
	add	eax, ecx
	mov	DWORD PTR len$[rsp], eax

; 3782 : 	nlen = header[3] * 256 + header[2];

	mov	eax, 1
	imul	rax, rax, 3
	movzx	eax, BYTE PTR header$[rsp+rax]
	imul	eax, eax, 256				; 00000100H
	mov	ecx, 1
	imul	rcx, rcx, 2
	movzx	ecx, BYTE PTR header$[rsp+rcx]
	add	eax, ecx
	mov	DWORD PTR nlen$[rsp], eax

; 3783 : 	if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt", "Corrupt PNG");

	mov	eax, DWORD PTR len$[rsp]
	xor	eax, 65535				; 0000ffffH
	cmp	DWORD PTR nlen$[rsp], eax
	je	SHORT $LN7@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN7@stbi__pars:

; 3784 : 	if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer", "Corrupt PNG");

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR a$[rsp]
	cmp	rax, QWORD PTR [rcx+8]
	jbe	SHORT $LN8@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN8@stbi__pars:

; 3785 : 	if (a->zout + len > a->zout_end)

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR a$[rsp]
	cmp	rax, QWORD PTR [rcx+40]
	jbe	SHORT $LN9@stbi__pars

; 3786 : 		if (!stbi__zexpand(a, a->zout, len)) return 0;

	mov	r8d, DWORD PTR len$[rsp]
	mov	rax, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
	test	eax, eax
	jne	SHORT $LN10@stbi__pars
	xor	eax, eax
	jmp	SHORT $LN1@stbi__pars
$LN10@stbi__pars:
$LN9@stbi__pars:

; 3787 : 	memcpy(a->zout, a->zbuffer, len);

	movsxd	rax, DWORD PTR len$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR a$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	memcpy

; 3788 : 	a->zbuffer += len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR a$[rsp]
	mov	QWORD PTR [rcx], rax

; 3789 : 	a->zout += len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	add	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR a$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 3790 : 	return 1;

	mov	eax, 1
$LN1@stbi__pars:

; 3791 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__parse_uncomperssed_block@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__parse_uncomperssed_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
c$1 = 32
n$ = 36
i$ = 40
hlit$ = 44
hdist$ = 48
hclen$ = 52
s$2 = 56
tv154 = 64
z_codelength$ = 80
codelength_sizes$ = 2112
lencodes$ = 2144
__$ArrayPad$ = 2608
a$ = 2640
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__compute_huffman_codes

; 3717 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 2632				; 00000a48H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3718 : 	static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 3719 : 	stbi__zhuffman z_codelength;
; 3720 : 	stbi_uc lencodes[286 + 32 + 137];//padding for maximum single op
; 3721 : 	stbi_uc codelength_sizes[19];
; 3722 : 	int i, n;
; 3723 : 
; 3724 : 	int hlit = stbi__zreceive(a, 5) + 257;

	mov	edx, 5
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	eax, 257				; 00000101H
	mov	DWORD PTR hlit$[rsp], eax

; 3725 : 	int hdist = stbi__zreceive(a, 5) + 1;

	mov	edx, 5
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	inc	eax
	mov	DWORD PTR hdist$[rsp], eax

; 3726 : 	int hclen = stbi__zreceive(a, 4) + 4;

	mov	edx, 4
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	eax, 4
	mov	DWORD PTR hclen$[rsp], eax

; 3727 : 
; 3728 : 	memset(codelength_sizes, 0, sizeof(codelength_sizes));

	mov	r8d, 19
	xor	edx, edx
	lea	rcx, QWORD PTR codelength_sizes$[rsp]
	call	memset
	npad	1

; 3729 : 	for (i = 0; i < hclen; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__comp
$LN2@stbi__comp:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
	mov	eax, DWORD PTR hclen$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbi__comp

; 3730 : 		int s = stbi__zreceive(a, 3);

	mov	edx, 3
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	mov	DWORD PTR s$2[rsp], eax

; 3731 : 		codelength_sizes[length_dezigzag[i]] = (stbi_uc)s;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	movzx	ecx, BYTE PTR s$2[rsp]
	mov	BYTE PTR codelength_sizes$[rsp+rax], cl

; 3732 : 	}

	jmp	SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 3733 : 	if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

	mov	r8d, 19
	lea	rdx, QWORD PTR codelength_sizes$[rsp]
	lea	rcx, QWORD PTR z_codelength$[rsp]
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	jne	SHORT $LN7@stbi__comp
	xor	eax, eax
	jmp	$LN1@stbi__comp
$LN7@stbi__comp:

; 3734 : 
; 3735 : 	n = 0;

	mov	DWORD PTR n$[rsp], 0
$LN5@stbi__comp:

; 3736 : 	while (n < hlit + hdist) {

	mov	eax, DWORD PTR hdist$[rsp]
	mov	ecx, DWORD PTR hlit$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR n$[rsp], eax
	jge	$LN6@stbi__comp

; 3737 : 		int c = stbi__zhuffman_decode(a, &z_codelength);

	lea	rdx, QWORD PTR z_codelength$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
	mov	DWORD PTR c$1[rsp], eax

; 3738 : 		if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

	cmp	DWORD PTR c$1[rsp], 0
	jl	SHORT $LN9@stbi__comp
	cmp	DWORD PTR c$1[rsp], 19
	jl	SHORT $LN8@stbi__comp
$LN9@stbi__comp:
	xor	eax, eax
	jmp	$LN1@stbi__comp
$LN8@stbi__comp:

; 3739 : 		if (c < 16)

	cmp	DWORD PTR c$1[rsp], 16
	jge	SHORT $LN10@stbi__comp

; 3740 : 			lencodes[n++] = (stbi_uc)c;

	movsxd	rax, DWORD PTR n$[rsp]
	movzx	ecx, BYTE PTR c$1[rsp]
	mov	BYTE PTR lencodes$[rsp+rax], cl
	mov	eax, DWORD PTR n$[rsp]
	inc	eax
	mov	DWORD PTR n$[rsp], eax
	jmp	$LN11@stbi__comp
$LN10@stbi__comp:

; 3741 : 		else if (c == 16) {

	cmp	DWORD PTR c$1[rsp], 16
	jne	SHORT $LN12@stbi__comp

; 3742 : 			c = stbi__zreceive(a, 2) + 3;

	mov	edx, 2
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	eax, 3
	mov	DWORD PTR c$1[rsp], eax

; 3743 : 			memset(lencodes + n, lencodes[n - 1], c);

	movsxd	rax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	dec	ecx
	movsxd	rcx, ecx
	movzx	ecx, BYTE PTR lencodes$[rsp+rcx]
	movsxd	rdx, DWORD PTR n$[rsp]
	lea	rdx, QWORD PTR lencodes$[rsp+rdx]
	mov	QWORD PTR tv154[rsp], rdx
	mov	r8, rax
	mov	edx, ecx
	mov	rax, QWORD PTR tv154[rsp]
	mov	rcx, rax
	call	memset

; 3744 : 			n += c;

	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 3745 : 		}

	jmp	$LN13@stbi__comp
$LN12@stbi__comp:

; 3746 : 		else if (c == 17) {

	cmp	DWORD PTR c$1[rsp], 17
	jne	SHORT $LN14@stbi__comp

; 3747 : 			c = stbi__zreceive(a, 3) + 3;

	mov	edx, 3
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	eax, 3
	mov	DWORD PTR c$1[rsp], eax

; 3748 : 			memset(lencodes + n, 0, c);

	movsxd	rax, DWORD PTR c$1[rsp]
	movsxd	rcx, DWORD PTR n$[rsp]
	lea	rcx, QWORD PTR lencodes$[rsp+rcx]
	mov	r8, rax
	xor	edx, edx
	call	memset

; 3749 : 			n += c;

	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 3750 : 		}

	jmp	SHORT $LN15@stbi__comp
$LN14@stbi__comp:

; 3751 : 		else {
; 3752 : 			STBI_ASSERT(c == 18);
; 3753 : 			c = stbi__zreceive(a, 7) + 11;

	mov	edx, 7
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	add	eax, 11
	mov	DWORD PTR c$1[rsp], eax

; 3754 : 			memset(lencodes + n, 0, c);

	movsxd	rax, DWORD PTR c$1[rsp]
	movsxd	rcx, DWORD PTR n$[rsp]
	lea	rcx, QWORD PTR lencodes$[rsp+rcx]
	mov	r8, rax
	xor	edx, edx
	call	memset

; 3755 : 			n += c;

	mov	eax, DWORD PTR c$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rsp], eax
$LN15@stbi__comp:
$LN13@stbi__comp:
$LN11@stbi__comp:

; 3756 : 		}
; 3757 : 	}

	jmp	$LN5@stbi__comp
$LN6@stbi__comp:

; 3758 : 	if (n != hlit + hdist) return stbi__err("bad codelengths", "Corrupt PNG");

	mov	eax, DWORD PTR hdist$[rsp]
	mov	ecx, DWORD PTR hlit$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR n$[rsp], eax
	je	SHORT $LN16@stbi__comp
	xor	eax, eax
	jmp	SHORT $LN1@stbi__comp
$LN16@stbi__comp:

; 3759 : 	if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

	mov	rax, QWORD PTR a$[rsp]
	add	rax, 52					; 00000034H
	mov	r8d, DWORD PTR hlit$[rsp]
	lea	rdx, QWORD PTR lencodes$[rsp]
	mov	rcx, rax
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	jne	SHORT $LN17@stbi__comp
	xor	eax, eax
	jmp	SHORT $LN1@stbi__comp
$LN17@stbi__comp:

; 3760 : 	if (!stbi__zbuild_huffman(&a->z_distance, lencodes + hlit, hdist)) return 0;

	movsxd	rax, DWORD PTR hlit$[rsp]
	lea	rax, QWORD PTR lencodes$[rsp+rax]
	mov	rcx, QWORD PTR a$[rsp]
	add	rcx, 2072				; 00000818H
	mov	r8d, DWORD PTR hdist$[rsp]
	mov	rdx, rax
	call	?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z ; stbi__zbuild_huffman
	test	eax, eax
	jne	SHORT $LN18@stbi__comp
	xor	eax, eax
	jmp	SHORT $LN1@stbi__comp
$LN18@stbi__comp:

; 3761 : 	return 1;

	mov	eax, 1
$LN1@stbi__comp:

; 3762 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2632				; 00000a48H
	ret	0
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__compute_huffman_codes
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
v$1 = 32
tv173 = 33
z$2 = 36
len$3 = 40
dist$4 = 44
zout$ = 48
p$5 = 56
a$ = 80
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_huffman_block

; 3673 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3674 : 	char* zout = a->zout;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR zout$[rsp], rax
$LN2@stbi__pars:

; 3675 : 	for (;;) {
; 3676 : 		int z = stbi__zhuffman_decode(a, &a->z_length);

	mov	rax, QWORD PTR a$[rsp]
	add	rax, 52					; 00000034H
	mov	rdx, rax
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
	mov	DWORD PTR z$2[rsp], eax

; 3677 : 		if (z < 256) {

	cmp	DWORD PTR z$2[rsp], 256			; 00000100H
	jge	SHORT $LN11@stbi__pars

; 3678 : 			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG"); // error in huffman codes

	cmp	DWORD PTR z$2[rsp], 0
	jge	SHORT $LN13@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN13@stbi__pars:

; 3679 : 			if (zout >= a->zout_end) {

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax+40]
	cmp	QWORD PTR zout$[rsp], rax
	jb	SHORT $LN14@stbi__pars

; 3680 : 				if (!stbi__zexpand(a, zout, 1)) return 0;

	mov	r8d, 1
	mov	rdx, QWORD PTR zout$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
	test	eax, eax
	jne	SHORT $LN15@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN15@stbi__pars:

; 3681 : 				zout = a->zout;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR zout$[rsp], rax
$LN14@stbi__pars:

; 3682 : 			}
; 3683 : 			*zout++ = (char)z;

	mov	rax, QWORD PTR zout$[rsp]
	movzx	ecx, BYTE PTR z$2[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR zout$[rsp]
	inc	rax
	mov	QWORD PTR zout$[rsp], rax

; 3684 : 		}

	jmp	$LN12@stbi__pars
$LN11@stbi__pars:

; 3685 : 		else {
; 3686 : 			stbi_uc* p;
; 3687 : 			int len, dist;
; 3688 : 			if (z == 256) {

	cmp	DWORD PTR z$2[rsp], 256			; 00000100H
	jne	SHORT $LN16@stbi__pars

; 3689 : 				a->zout = zout;

	mov	rax, QWORD PTR a$[rsp]
	mov	rcx, QWORD PTR zout$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3690 : 				return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN16@stbi__pars:

; 3691 : 			}
; 3692 : 			z -= 257;

	mov	eax, DWORD PTR z$2[rsp]
	sub	eax, 257				; 00000101H
	mov	DWORD PTR z$2[rsp], eax

; 3693 : 			len = stbi__zlength_base[z];

	movsxd	rax, DWORD PTR z$2[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zlength_base@@3PAHA
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR len$3[rsp], eax

; 3694 : 			if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

	movsxd	rax, DWORD PTR z$2[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zlength_extra@@3PAHA
	cmp	DWORD PTR [rcx+rax*4], 0
	je	SHORT $LN17@stbi__pars
	movsxd	rax, DWORD PTR z$2[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zlength_extra@@3PAHA
	mov	edx, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	mov	ecx, DWORD PTR len$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$3[rsp], eax
$LN17@stbi__pars:

; 3695 : 			z = stbi__zhuffman_decode(a, &a->z_distance);

	mov	rax, QWORD PTR a$[rsp]
	add	rax, 2072				; 00000818H
	mov	rdx, rax
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
	mov	DWORD PTR z$2[rsp], eax

; 3696 : 			if (z < 0) return stbi__err("bad huffman code", "Corrupt PNG");

	cmp	DWORD PTR z$2[rsp], 0
	jge	SHORT $LN18@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN18@stbi__pars:

; 3697 : 			dist = stbi__zdist_base[z];

	movsxd	rax, DWORD PTR z$2[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdist_base@@3PAHA
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR dist$4[rsp], eax

; 3698 : 			if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

	movsxd	rax, DWORD PTR z$2[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdist_extra@@3PAHA
	cmp	DWORD PTR [rcx+rax*4], 0
	je	SHORT $LN19@stbi__pars
	movsxd	rax, DWORD PTR z$2[rsp]
	lea	rcx, OFFSET FLAT:?stbi__zdist_extra@@3PAHA
	mov	edx, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z	; stbi__zreceive
	mov	ecx, DWORD PTR dist$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR dist$4[rsp], eax
$LN19@stbi__pars:

; 3699 : 			if (zout - a->zout_start < dist) return stbi__err("bad dist", "Corrupt PNG");

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR zout$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR dist$4[rsp]
	cmp	rax, rcx
	jge	SHORT $LN20@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN20@stbi__pars:

; 3700 : 			if (zout + len > a->zout_end) {

	movsxd	rax, DWORD PTR len$3[rsp]
	mov	rcx, QWORD PTR zout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR a$[rsp]
	cmp	rax, QWORD PTR [rcx+40]
	jbe	SHORT $LN21@stbi__pars

; 3701 : 				if (!stbi__zexpand(a, zout, len)) return 0;

	mov	r8d, DWORD PTR len$3[rsp]
	mov	rdx, QWORD PTR zout$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
	test	eax, eax
	jne	SHORT $LN22@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN22@stbi__pars:

; 3702 : 				zout = a->zout;

	mov	rax, QWORD PTR a$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR zout$[rsp], rax
$LN21@stbi__pars:

; 3703 : 			}
; 3704 : 			p = (stbi_uc*)(zout - dist);

	movsxd	rax, DWORD PTR dist$4[rsp]
	mov	rcx, QWORD PTR zout$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$5[rsp], rax

; 3705 : 			if (dist == 1) { // run of one byte; common in images.

	cmp	DWORD PTR dist$4[rsp], 1
	jne	SHORT $LN23@stbi__pars

; 3706 : 				stbi_uc v = *p;

	mov	rax, QWORD PTR p$5[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR v$1[rsp], al

; 3707 : 				if (len) { do *zout++ = v; while (--len); }

	cmp	DWORD PTR len$3[rsp], 0
	je	SHORT $LN25@stbi__pars
$LN7@stbi__pars:
	mov	rax, QWORD PTR zout$[rsp]
	movzx	ecx, BYTE PTR v$1[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR zout$[rsp]
	inc	rax
	mov	QWORD PTR zout$[rsp], rax
	mov	eax, DWORD PTR len$3[rsp]
	dec	eax
	mov	DWORD PTR len$3[rsp], eax
	cmp	DWORD PTR len$3[rsp], 0
	jne	SHORT $LN7@stbi__pars
$LN25@stbi__pars:

; 3708 : 			}

	jmp	SHORT $LN24@stbi__pars
$LN23@stbi__pars:

; 3709 : 			else {
; 3710 : 				if (len) { do *zout++ = *p++; while (--len); }

	cmp	DWORD PTR len$3[rsp], 0
	je	SHORT $LN26@stbi__pars
$LN10@stbi__pars:
	mov	rax, QWORD PTR p$5[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv173[rsp], al
	mov	rax, QWORD PTR p$5[rsp]
	inc	rax
	mov	QWORD PTR p$5[rsp], rax
	mov	rax, QWORD PTR zout$[rsp]
	movzx	ecx, BYTE PTR tv173[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR zout$[rsp]
	inc	rax
	mov	QWORD PTR zout$[rsp], rax
	mov	eax, DWORD PTR len$3[rsp]
	dec	eax
	mov	DWORD PTR len$3[rsp], eax
	cmp	DWORD PTR len$3[rsp], 0
	jne	SHORT $LN10@stbi__pars
$LN26@stbi__pars:
$LN24@stbi__pars:
$LN12@stbi__pars:

; 3711 : 			}
; 3712 : 		}
; 3713 : 	}

	jmp	$LN2@stbi__pars
$LN1@stbi__pars:

; 3714 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_huffman_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
limit$ = 32
cur$ = 36
q$ = 40
z$ = 64
zout$ = 72
n$ = 80
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z PROC		; stbi__zexpand

; 3641 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3642 : 	char* q;
; 3643 : 	int cur, limit;
; 3644 : 	z->zout = zout;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR zout$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3645 : 	if (!z->z_expandable) return stbi__err("output buffer limit", "Corrupt PNG");

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+48], 0
	jne	SHORT $LN4@stbi__zexp
	xor	eax, eax
	jmp	$LN1@stbi__zexp
$LN4@stbi__zexp:

; 3646 : 	cur = (int)(z->zout - z->zout_start);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	mov	DWORD PTR cur$[rsp], eax

; 3647 : 	limit = (int)(z->zout_end - z->zout_start);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rax+40]
	sub	rax, rcx
	mov	DWORD PTR limit$[rsp], eax
$LN2@stbi__zexp:

; 3648 : 	while (cur + n > limit)

	mov	eax, DWORD PTR n$[rsp]
	mov	ecx, DWORD PTR cur$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR limit$[rsp]
	jle	SHORT $LN3@stbi__zexp

; 3649 : 		limit *= 2;

	mov	eax, DWORD PTR limit$[rsp]
	shl	eax, 1
	mov	DWORD PTR limit$[rsp], eax
	jmp	SHORT $LN2@stbi__zexp
$LN3@stbi__zexp:

; 3650 : 	q = (char*)STBI_REALLOC(z->zout_start, limit);

	movsxd	rax, DWORD PTR limit$[rsp]
	mov	rdx, rax
	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax+32]
	call	realloc
	mov	QWORD PTR q$[rsp], rax

; 3651 : 	if (q == NULL) return stbi__err("outofmem", "Out of memory");

	cmp	QWORD PTR q$[rsp], 0
	jne	SHORT $LN5@stbi__zexp
	xor	eax, eax
	jmp	SHORT $LN1@stbi__zexp
$LN5@stbi__zexp:

; 3652 : 	z->zout_start = q;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 3653 : 	z->zout = q + cur;

	movsxd	rax, DWORD PTR cur$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 3654 : 	z->zout_end = q + limit;

	movsxd	rax, DWORD PTR limit$[rsp]
	mov	rcx, QWORD PTR q$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 3655 : 	return 1;

	mov	eax, 1
$LN1@stbi__zexp:

; 3656 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ENDP		; stbi__zexpand
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
b$ = 32
s$ = 36
tv95 = 40
a$ = 64
z$ = 72
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode

; 3627 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3628 : 	int b, s;
; 3629 : 	if (a->num_bits < 16) stbi__fill_bits(a);

	mov	rax, QWORD PTR a$[rsp]
	cmp	DWORD PTR [rax+16], 16
	jge	SHORT $LN2@stbi__zhuf
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
	npad	1
$LN2@stbi__zhuf:

; 3630 : 	b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

	mov	rax, QWORD PTR a$[rsp]
	mov	eax, DWORD PTR [rax+20]
	and	eax, 511				; 000001ffH
	mov	eax, eax
	mov	rcx, QWORD PTR z$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR b$[rsp], eax

; 3631 : 	if (b) {

	cmp	DWORD PTR b$[rsp], 0
	je	SHORT $LN3@stbi__zhuf

; 3632 : 		s = b >> 9;

	mov	eax, DWORD PTR b$[rsp]
	sar	eax, 9
	mov	DWORD PTR s$[rsp], eax

; 3633 : 		a->code_buffer >>= s;

	mov	eax, DWORD PTR s$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	mov	QWORD PTR tv95[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv95[rsp]
	mov	eax, DWORD PTR [rax+20]
	shr	eax, cl
	mov	rcx, QWORD PTR a$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 3634 : 		a->num_bits -= s;

	mov	rax, QWORD PTR a$[rsp]
	mov	ecx, DWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, ecx
	mov	rcx, QWORD PTR a$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 3635 : 		return b & 511;

	mov	eax, DWORD PTR b$[rsp]
	and	eax, 511				; 000001ffH
	jmp	SHORT $LN1@stbi__zhuf
$LN3@stbi__zhuf:

; 3636 : 	}
; 3637 : 	return stbi__zhuffman_decode_slowpath(a, z);

	mov	rdx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
$LN1@stbi__zhuf:

; 3638 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 32
k$ = 36
b$ = 40
tv150 = 48
a$ = 80
z$ = 88
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode_slowpath

; 3609 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3610 : 	int b, s, k;
; 3611 : 	// not resolved by fast table, so compute it the slow way
; 3612 : 	// use jpeg approach, which requires MSbits at top
; 3613 : 	k = stbi__bit_reverse(a->code_buffer, 16);

	mov	edx, 16
	mov	rax, QWORD PTR a$[rsp]
	mov	ecx, DWORD PTR [rax+20]
	call	?stbi__bit_reverse@@YAHHH@Z		; stbi__bit_reverse
	mov	DWORD PTR k$[rsp], eax

; 3614 : 	for (s = STBI__ZFAST_BITS + 1; ; ++s)

	mov	DWORD PTR s$[rsp], 10
	jmp	SHORT $LN4@stbi__zhuf
$LN2@stbi__zhuf:
	mov	eax, DWORD PTR s$[rsp]
	inc	eax
	mov	DWORD PTR s$[rsp], eax
$LN4@stbi__zhuf:

; 3615 : 		if (k < z->maxcode[s])

	movsxd	rax, DWORD PTR s$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+1056]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN5@stbi__zhuf

; 3616 : 			break;

	jmp	SHORT $LN3@stbi__zhuf
$LN5@stbi__zhuf:
	jmp	SHORT $LN2@stbi__zhuf
$LN3@stbi__zhuf:

; 3617 : 	if (s == 16) return -1; // invalid code!

	cmp	DWORD PTR s$[rsp], 16
	jne	SHORT $LN6@stbi__zhuf
	mov	eax, -1
	jmp	$LN1@stbi__zhuf
$LN6@stbi__zhuf:

; 3618 : 	// code size is s, so:
; 3619 : 	b = (k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s];

	mov	eax, 16
	sub	eax, DWORD PTR s$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR k$[rsp]
	sar	eax, cl
	movsxd	rcx, DWORD PTR s$[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx*2+1024]
	sub	eax, ecx
	movsxd	rcx, DWORD PTR s$[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx*2+1124]
	add	eax, ecx
	mov	DWORD PTR b$[rsp], eax

; 3620 : 	STBI_ASSERT(z->size[b] == s);
; 3621 : 	a->code_buffer >>= s;

	mov	eax, DWORD PTR s$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	mov	QWORD PTR tv150[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv150[rsp]
	mov	eax, DWORD PTR [rax+20]
	shr	eax, cl
	mov	rcx, QWORD PTR a$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 3622 : 	a->num_bits -= s;

	mov	rax, QWORD PTR a$[rsp]
	mov	ecx, DWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, ecx
	mov	rcx, QWORD PTR a$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 3623 : 	return z->value[b];

	movsxd	rax, DWORD PTR b$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2+1444]
$LN1@stbi__zhuf:

; 3624 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode_slowpath
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv83 = 32
k$ = 36
tv89 = 40
z$ = 64
n$ = 72
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z PROC		; stbi__zreceive

; 3599 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3600 : 	unsigned int k;
; 3601 : 	if (z->num_bits < n) stbi__fill_bits(z);

	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN2@stbi__zrec
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z	; stbi__fill_bits
	npad	1
$LN2@stbi__zrec:

; 3602 : 	k = z->code_buffer & ((1 << n) - 1);

	mov	eax, DWORD PTR n$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv83[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv83[rsp]
	shl	eax, cl
	dec	eax
	mov	rcx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 3603 : 	z->code_buffer >>= n;

	mov	eax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR tv89[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv89[rsp]
	mov	eax, DWORD PTR [rax+20]
	shr	eax, cl
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 3604 : 	z->num_bits -= n;

	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, ecx
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 3605 : 	return k;

	mov	eax, DWORD PTR k$[rsp]

; 3606 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ENDP		; stbi__zreceive
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv70 = 32
tv72 = 36
tv78 = 40
tv76 = 44
z$ = 64
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z PROC		; stbi__fill_bits

; 3590 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN4@stbi__fill:

; 3591 : 	do {
; 3592 : 		STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
; 3593 : 		z->code_buffer |= (unsigned int)stbi__zget8(z) << z->num_bits;

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z	; stbi__zget8
	movzx	eax, al
	mov	DWORD PTR tv72[rsp], eax
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv70[rsp], eax
	mov	eax, DWORD PTR tv70[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR tv72[rsp]
	shl	eax, cl
	mov	DWORD PTR tv78[rsp], eax
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR tv76[rsp], eax
	mov	eax, DWORD PTR tv78[rsp]
	mov	ecx, DWORD PTR tv76[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 3594 : 		z->num_bits += 8;

	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+16]
	add	eax, 8
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 3595 : 	} while (z->num_bits <= 24);

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+16], 24
	jle	SHORT $LN4@stbi__fill

; 3596 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ENDP		; stbi__fill_bits
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv72 = 0
z$ = 32
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z PROC		; stbi__zget8

; 3584 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 3585 : 	if (z->zbuffer >= z->zbuffer_end) return 0;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax], rcx
	jb	SHORT $LN2@stbi__zget
	xor	al, al
	jmp	SHORT $LN1@stbi__zget
$LN2@stbi__zget:

; 3586 : 	return *z->zbuffer++;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv72[rsp], al
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR tv72[rsp]
$LN1@stbi__zget:

; 3587 : }

	add	rsp, 24
	ret	0
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ENDP		; stbi__zget8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$1 = 36
code$ = 40
j$2 = 44
fastv$3 = 48
k$ = 52
c$4 = 56
tv280 = 60
sizes$ = 64
next_code$ = 144
__$ArrayPad$ = 208
z$ = 240
sizelist$ = 248
num$ = 256
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z PROC ; stbi__zbuild_huffman

; 3517 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3518 : 	int i, k = 0;

	mov	DWORD PTR k$[rsp], 0

; 3519 : 	int code, next_code[16], sizes[17];
; 3520 : 
; 3521 : 	// DEFLATE spec for generating codes
; 3522 : 	memset(sizes, 0, sizeof(sizes));

	mov	r8d, 68					; 00000044H
	xor	edx, edx
	lea	rcx, QWORD PTR sizes$[rsp]
	call	memset

; 3523 : 	memset(z->fast, 0, sizeof(z->fast));

	mov	rax, QWORD PTR z$[rsp]
	mov	r8d, 1024				; 00000400H
	xor	edx, edx
	mov	rcx, rax
	call	memset
	npad	1

; 3524 : 	for (i = 0; i < num; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__zbui
$LN2@stbi__zbui:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__zbui:
	mov	eax, DWORD PTR num$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbi__zbui

; 3525 : 		++sizes[sizelist[i]];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sizelist$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	eax, DWORD PTR sizes$[rsp+rax*4]
	inc	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR sizelist$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	DWORD PTR sizes$[rsp+rcx*4], eax
	jmp	SHORT $LN2@stbi__zbui
$LN3@stbi__zbui:

; 3526 : 	sizes[0] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	DWORD PTR sizes$[rsp+rax], 0

; 3527 : 	for (i = 1; i < 16; ++i)

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN7@stbi__zbui
$LN5@stbi__zbui:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__zbui:
	cmp	DWORD PTR i$[rsp], 16
	jge	SHORT $LN6@stbi__zbui

; 3528 : 		if (sizes[i] > (1 << i))

	movsxd	rax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	cmp	DWORD PTR sizes$[rsp+rax*4], ecx
	jle	SHORT $LN16@stbi__zbui

; 3529 : 			return stbi__err("bad sizes", "Corrupt PNG");

	xor	eax, eax
	jmp	$LN1@stbi__zbui
$LN16@stbi__zbui:
	jmp	SHORT $LN5@stbi__zbui
$LN6@stbi__zbui:

; 3530 : 	code = 0;

	mov	DWORD PTR code$[rsp], 0

; 3531 : 	for (i = 1; i < 16; ++i) {

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN10@stbi__zbui
$LN8@stbi__zbui:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@stbi__zbui:
	cmp	DWORD PTR i$[rsp], 16
	jge	$LN9@stbi__zbui

; 3532 : 		next_code[i] = code;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR code$[rsp]
	mov	DWORD PTR next_code$[rsp+rax*4], ecx

; 3533 : 		z->firstcode[i] = (stbi__uint16)code;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	movzx	edx, WORD PTR code$[rsp]
	mov	WORD PTR [rcx+rax*2+1024], dx

; 3534 : 		z->firstsymbol[i] = (stbi__uint16)k;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	movzx	edx, WORD PTR k$[rsp]
	mov	WORD PTR [rcx+rax*2+1124], dx

; 3535 : 		code = (code + sizes[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	eax, DWORD PTR sizes$[rsp+rax*4]
	mov	ecx, DWORD PTR code$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR code$[rsp], eax

; 3536 : 		if (sizes[i])

	movsxd	rax, DWORD PTR i$[rsp]
	cmp	DWORD PTR sizes$[rsp+rax*4], 0
	je	SHORT $LN17@stbi__zbui

; 3537 : 			if (code - 1 >= (1 << i)) return stbi__err("bad codelengths", "Corrupt PNG");

	mov	eax, DWORD PTR code$[rsp]
	dec	eax
	mov	ecx, DWORD PTR i$[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	cmp	eax, ecx
	jl	SHORT $LN18@stbi__zbui
	xor	eax, eax
	jmp	$LN1@stbi__zbui
$LN18@stbi__zbui:
$LN17@stbi__zbui:

; 3538 : 		z->maxcode[i] = code << (16 - i); // preshift for inner loop

	mov	eax, 16
	sub	eax, DWORD PTR i$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR code$[rsp]
	shl	eax, cl
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx*4+1056], eax

; 3539 : 		code <<= 1;

	mov	eax, DWORD PTR code$[rsp]
	shl	eax, 1
	mov	DWORD PTR code$[rsp], eax

; 3540 : 		k += sizes[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	eax, DWORD PTR sizes$[rsp+rax*4]
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 3541 : 	}

	jmp	$LN8@stbi__zbui
$LN9@stbi__zbui:

; 3542 : 	z->maxcode[16] = 0x10000; // sentinel

	mov	eax, 4
	imul	rax, rax, 16
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+rax+1056], 65536		; 00010000H

; 3543 : 	for (i = 0; i < num; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@stbi__zbui
$LN11@stbi__zbui:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@stbi__zbui:
	mov	eax, DWORD PTR num$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN12@stbi__zbui

; 3544 : 		int s = sizelist[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR sizelist$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR s$1[rsp], eax

; 3545 : 		if (s) {

	cmp	DWORD PTR s$1[rsp], 0
	je	$LN19@stbi__zbui

; 3546 : 			int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

	movsxd	rax, DWORD PTR s$1[rsp]
	movsxd	rcx, DWORD PTR s$1[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx*2+1024]
	mov	eax, DWORD PTR next_code$[rsp+rax*4]
	sub	eax, ecx
	movsxd	rcx, DWORD PTR s$1[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx*2+1124]
	add	eax, ecx
	mov	DWORD PTR c$4[rsp], eax

; 3547 : 			stbi__uint16 fastv = (stbi__uint16)((s << 9) | i);

	mov	eax, DWORD PTR s$1[rsp]
	shl	eax, 9
	or	eax, DWORD PTR i$[rsp]
	mov	WORD PTR fastv$3[rsp], ax

; 3548 : 			z->size[c] = (stbi_uc)s;

	movsxd	rax, DWORD PTR c$4[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	movzx	edx, BYTE PTR s$1[rsp]
	mov	BYTE PTR [rcx+rax+1156], dl

; 3549 : 			z->value[c] = (stbi__uint16)i;

	movsxd	rax, DWORD PTR c$4[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	movzx	edx, WORD PTR i$[rsp]
	mov	WORD PTR [rcx+rax*2+1444], dx

; 3550 : 			if (s <= STBI__ZFAST_BITS) {

	cmp	DWORD PTR s$1[rsp], 9
	jg	SHORT $LN20@stbi__zbui

; 3551 : 				int j = stbi__bit_reverse(next_code[s], s);

	movsxd	rax, DWORD PTR s$1[rsp]
	mov	edx, DWORD PTR s$1[rsp]
	mov	ecx, DWORD PTR next_code$[rsp+rax*4]
	call	?stbi__bit_reverse@@YAHHH@Z		; stbi__bit_reverse
	mov	DWORD PTR j$2[rsp], eax
$LN14@stbi__zbui:

; 3552 : 				while (j < (1 << STBI__ZFAST_BITS)) {

	cmp	DWORD PTR j$2[rsp], 512			; 00000200H
	jge	SHORT $LN15@stbi__zbui

; 3553 : 					z->fast[j] = fastv;

	movsxd	rax, DWORD PTR j$2[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	movzx	edx, WORD PTR fastv$3[rsp]
	mov	WORD PTR [rcx+rax*2], dx

; 3554 : 					j += (1 << s);

	mov	eax, DWORD PTR s$1[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv280[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv280[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR j$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR j$2[rsp], eax

; 3555 : 				}

	jmp	SHORT $LN14@stbi__zbui
$LN15@stbi__zbui:
$LN20@stbi__zbui:

; 3556 : 			}
; 3557 : 			++next_code[s];

	movsxd	rax, DWORD PTR s$1[rsp]
	mov	eax, DWORD PTR next_code$[rsp+rax*4]
	inc	eax
	movsxd	rcx, DWORD PTR s$1[rsp]
	mov	DWORD PTR next_code$[rsp+rcx*4], eax
$LN19@stbi__zbui:

; 3558 : 		}
; 3559 : 	}

	jmp	$LN11@stbi__zbui
$LN12@stbi__zbui:

; 3560 : 	return 1;

	mov	eax, 1
$LN1@stbi__zbui:

; 3561 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	ret	0
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEAEH@Z ENDP ; stbi__zbuild_huffman
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
v$ = 48
bits$ = 56
?stbi__bit_reverse@@YAHHH@Z PROC			; stbi__bit_reverse

; 3509 : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 3510 : 	STBI_ASSERT(bits <= 16);
; 3511 : 	// to bit reverse n bits, reverse 16 and shift
; 3512 : 	// e.g. 11 bits, bit reverse and shift away 5
; 3513 : 	return stbi__bitreverse16(v) >> (16 - bits);

	mov	ecx, DWORD PTR v$[rsp]
	call	?stbi__bitreverse16@@YAHH@Z		; stbi__bitreverse16
	mov	ecx, 16
	sub	ecx, DWORD PTR bits$[rsp]
	sar	eax, cl

; 3514 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__bit_reverse@@YAHHH@Z ENDP			; stbi__bit_reverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
n$ = 8
?stbi__bitreverse16@@YAHH@Z PROC			; stbi__bitreverse16

; 3500 : {

	mov	DWORD PTR [rsp+8], ecx

; 3501 : 	n = ((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1);

	mov	eax, DWORD PTR n$[rsp]
	and	eax, 43690				; 0000aaaaH
	sar	eax, 1
	mov	ecx, DWORD PTR n$[rsp]
	and	ecx, 21845				; 00005555H
	shl	ecx, 1
	or	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 3502 : 	n = ((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2);

	mov	eax, DWORD PTR n$[rsp]
	and	eax, 52428				; 0000ccccH
	sar	eax, 2
	mov	ecx, DWORD PTR n$[rsp]
	and	ecx, 13107				; 00003333H
	shl	ecx, 2
	or	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 3503 : 	n = ((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4);

	mov	eax, DWORD PTR n$[rsp]
	and	eax, 61680				; 0000f0f0H
	sar	eax, 4
	mov	ecx, DWORD PTR n$[rsp]
	and	ecx, 3855				; 00000f0fH
	shl	ecx, 4
	or	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 3504 : 	n = ((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8);

	mov	eax, DWORD PTR n$[rsp]
	and	eax, 65280				; 0000ff00H
	sar	eax, 8
	mov	ecx, DWORD PTR n$[rsp]
	and	ecx, 255				; 000000ffH
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR n$[rsp], eax

; 3505 : 	return n;

	mov	eax, DWORD PTR n$[rsp]

; 3506 : }

	ret	0
?stbi__bitreverse16@@YAHH@Z ENDP			; stbi__bitreverse16
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
j$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z PROC	; stbi__jpeg_info_raw

; 3455 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3456 : 	if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {

	mov	edx, 2
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
	test	eax, eax
	jne	SHORT $LN2@stbi__jpeg

; 3457 : 		stbi__rewind(j->s);

	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 3458 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 3459 : 	}
; 3460 : 	if (x) *x = j->s->img_x;

	cmp	QWORD PTR x$[rsp], 0
	je	SHORT $LN3@stbi__jpeg
	mov	rax, QWORD PTR j$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR x$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax
$LN3@stbi__jpeg:

; 3461 : 	if (y) *y = j->s->img_y;

	cmp	QWORD PTR y$[rsp], 0
	je	SHORT $LN4@stbi__jpeg
	mov	rax, QWORD PTR j$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR y$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rcx], eax
$LN4@stbi__jpeg:

; 3462 : 	if (comp) *comp = j->s->img_n;

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN5@stbi__jpeg
	mov	rax, QWORD PTR j$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rcx], eax
$LN5@stbi__jpeg:

; 3463 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 3464 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z ENDP	; stbi__jpeg_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$1 = 48
i$2 = 52
r$3 = 56
r$4 = 64
out$5 = 72
n$ = 80
j$6 = 84
decode_n$ = 88
tv75 = 92
tv230 = 96
y_bot$7 = 100
tv264 = 104
tv272 = 108
tv259 = 112
tv257 = 116
output$8 = 120
tv243 = 128
tv248 = 136
y$9 = 144
y$10 = 152
tv145 = 160
tv153 = 168
tv261 = 176
tv308 = 184
coutput$11 = 192
res_comp$12 = 224
__$ArrayPad$ = 416
z$ = 448
out_x$ = 456
out_y$ = 464
comp$ = 472
req_comp$ = 480
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z PROC	; load_jpeg_image

; 3337 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 432				; 000001b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3338 : 	int n, decode_n;
; 3339 : 	z->s->img_n = 0; // make stbi__cleanup_jpeg safe

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax+8], 0

; 3340 : 
; 3341 : 	// validate req_comp
; 3342 : 	if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

	cmp	DWORD PTR req_comp$[rsp], 0
	jl	SHORT $LN21@load_jpeg_
	cmp	DWORD PTR req_comp$[rsp], 4
	jle	SHORT $LN20@load_jpeg_
$LN21@load_jpeg_:
	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LN20@load_jpeg_:

; 3343 : 
; 3344 : 	// load a jpeg image from whichever source, but leave in YCbCr format
; 3345 : 	if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ; stbi__decode_jpeg_image
	test	eax, eax
	jne	SHORT $LN22@load_jpeg_
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LN22@load_jpeg_:

; 3346 : 
; 3347 : 	// determine actual number of components to generate
; 3348 : 	n = req_comp ? req_comp : z->s->img_n;

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN45@load_jpeg_
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR tv75[rsp], eax
	jmp	SHORT $LN46@load_jpeg_
$LN45@load_jpeg_:
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR tv75[rsp], eax
$LN46@load_jpeg_:
	mov	eax, DWORD PTR tv75[rsp]
	mov	DWORD PTR n$[rsp], eax

; 3349 : 
; 3350 : 	if (z->s->img_n == 3 && n < 3)

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	DWORD PTR [rax+8], 3
	jne	SHORT $LN23@load_jpeg_
	cmp	DWORD PTR n$[rsp], 3
	jge	SHORT $LN23@load_jpeg_

; 3351 : 		decode_n = 1;

	mov	DWORD PTR decode_n$[rsp], 1
	jmp	SHORT $LN24@load_jpeg_
$LN23@load_jpeg_:

; 3352 : 	else
; 3353 : 		decode_n = z->s->img_n;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR decode_n$[rsp], eax
$LN24@load_jpeg_:

; 3354 : 
; 3355 : 	// resample and color-convert
; 3356 : 	{
; 3357 : 		int k;
; 3358 : 		unsigned int i, j;
; 3359 : 		stbi_uc* output;
; 3360 : 		stbi_uc* coutput[4] = {};

	lea	rax, QWORD PTR coutput$11[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 32					; 00000020H
	rep stosb

; 3361 : 
; 3362 : 		stbi__resample res_comp[4];
; 3363 : 
; 3364 : 		for (k = 0; k < decode_n; ++k) {

	mov	DWORD PTR k$1[rsp], 0
	jmp	SHORT $LN4@load_jpeg_
$LN2@load_jpeg_:
	mov	eax, DWORD PTR k$1[rsp]
	inc	eax
	mov	DWORD PTR k$1[rsp], eax
$LN4@load_jpeg_:
	mov	eax, DWORD PTR decode_n$[rsp]
	cmp	DWORD PTR k$1[rsp], eax
	jge	$LN3@load_jpeg_

; 3365 : 			stbi__resample* r = &res_comp[k];

	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 48				; 00000030H
	lea	rax, QWORD PTR res_comp$12[rsp+rax]
	mov	QWORD PTR r$3[rsp], rax

; 3366 : 
; 3367 : 			// allocate line buffer big enough for upsampling off the edges
; 3368 : 			// with upsample factor of 4
; 3369 : 			z->img_comp[k].linebuf = (stbi_uc*)stbi__malloc(z->s->img_x + 3);

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	add	eax, 3
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	movsxd	rcx, DWORD PTR k$1[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rdx+rcx+17896], rax

; 3370 : 			if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	QWORD PTR [rcx+rax+17896], 0
	jne	SHORT $LN25@load_jpeg_
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LN25@load_jpeg_:

; 3371 : 
; 3372 : 			r->hs = z->img_h_max / z->img_comp[k].h;

	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	QWORD PTR tv145[rsp], rax
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+17800]
	cdq
	mov	rcx, QWORD PTR z$[rsp]
	mov	rdi, QWORD PTR tv145[rsp]
	idiv	DWORD PTR [rcx+rdi+17828]
	mov	rcx, QWORD PTR r$3[rsp]
	mov	DWORD PTR [rcx+24], eax

; 3373 : 			r->vs = z->img_v_max / z->img_comp[k].v;

	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	QWORD PTR tv153[rsp], rax
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+17804]
	cdq
	mov	rcx, QWORD PTR z$[rsp]
	mov	rdi, QWORD PTR tv153[rsp]
	idiv	DWORD PTR [rcx+rdi+17832]
	mov	rcx, QWORD PTR r$3[rsp]
	mov	DWORD PTR [rcx+28], eax

; 3374 : 			r->ystep = r->vs >> 1;

	mov	rax, QWORD PTR r$3[rsp]
	mov	eax, DWORD PTR [rax+28]
	sar	eax, 1
	mov	rcx, QWORD PTR r$3[rsp]
	mov	DWORD PTR [rcx+36], eax

; 3375 : 			r->w_lores = (z->s->img_x + r->hs - 1) / r->hs;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR r$3[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	lea	eax, DWORD PTR [rax+rcx-1]
	xor	edx, edx
	mov	rcx, QWORD PTR r$3[rsp]
	div	DWORD PTR [rcx+24]
	mov	rcx, QWORD PTR r$3[rsp]
	mov	DWORD PTR [rcx+32], eax

; 3376 : 			r->ypos = 0;

	mov	rax, QWORD PTR r$3[rsp]
	mov	DWORD PTR [rax+40], 0

; 3377 : 			r->line0 = r->line1 = z->img_comp[k].data;

	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR r$3[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rdx+rax+17872]
	mov	QWORD PTR [rcx+16], rax
	mov	rax, QWORD PTR r$3[rsp]
	mov	rcx, QWORD PTR r$3[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+8], rcx

; 3378 : 
; 3379 : 			if (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+24], 1
	jne	SHORT $LN26@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+28], 1
	jne	SHORT $LN26@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	lea	rcx, OFFSET FLAT:?resample_row_1@@YAPEAEPEAE00HH@Z ; resample_row_1
	mov	QWORD PTR [rax], rcx
	jmp	$LN27@load_jpeg_
$LN26@load_jpeg_:

; 3380 : 			else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+24], 1
	jne	SHORT $LN28@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+28], 2
	jne	SHORT $LN28@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	lea	rcx, OFFSET FLAT:?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_v_2
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN29@load_jpeg_
$LN28@load_jpeg_:

; 3381 : 			else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+24], 2
	jne	SHORT $LN30@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+28], 1
	jne	SHORT $LN30@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	lea	rcx, OFFSET FLAT:?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_h_2
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN31@load_jpeg_
$LN30@load_jpeg_:

; 3382 : 			else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+24], 2
	jne	SHORT $LN32@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	cmp	DWORD PTR [rax+28], 2
	jne	SHORT $LN32@load_jpeg_
	mov	rax, QWORD PTR r$3[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rcx+18296]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN33@load_jpeg_
$LN32@load_jpeg_:

; 3383 : 			else                               r->resample = stbi__resample_row_generic;

	mov	rax, QWORD PTR r$3[rsp]
	lea	rcx, OFFSET FLAT:?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ; stbi__resample_row_generic
	mov	QWORD PTR [rax], rcx
$LN33@load_jpeg_:
$LN31@load_jpeg_:
$LN29@load_jpeg_:
$LN27@load_jpeg_:

; 3384 : 		}

	jmp	$LN2@load_jpeg_
$LN3@load_jpeg_:

; 3385 : 
; 3386 : 		// can't error after this so, this is safe
; 3387 : 		output = (stbi_uc*)stbi__malloc(n * z->s->img_x * z->s->img_y + 1);

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR n$[rsp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	rcx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rcx]
	imul	eax, DWORD PTR [rcx+4]
	inc	eax
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR output$8[rsp], rax

; 3388 : 		if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	cmp	QWORD PTR output$8[rsp], 0
	jne	SHORT $LN34@load_jpeg_
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
	xor	eax, eax
	jmp	$LN1@load_jpeg_
$LN34@load_jpeg_:

; 3389 : 
; 3390 : 		// now go ahead and resample
; 3391 : 		for (j = 0; j < z->s->img_y; ++j) {

	mov	DWORD PTR j$6[rsp], 0
	jmp	SHORT $LN7@load_jpeg_
$LN5@load_jpeg_:
	mov	eax, DWORD PTR j$6[rsp]
	inc	eax
	mov	DWORD PTR j$6[rsp], eax
$LN7@load_jpeg_:
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR j$6[rsp], eax
	jae	$LN6@load_jpeg_

; 3392 : 			stbi_uc* out = output + n * z->s->img_x * j;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR n$[rsp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	imul	eax, DWORD PTR j$6[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR output$8[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$5[rsp], rax

; 3393 : 			for (k = 0; k < decode_n; ++k) {

	mov	DWORD PTR k$1[rsp], 0
	jmp	SHORT $LN10@load_jpeg_
$LN8@load_jpeg_:
	mov	eax, DWORD PTR k$1[rsp]
	inc	eax
	mov	DWORD PTR k$1[rsp], eax
$LN10@load_jpeg_:
	mov	eax, DWORD PTR decode_n$[rsp]
	cmp	DWORD PTR k$1[rsp], eax
	jge	$LN9@load_jpeg_

; 3394 : 				stbi__resample* r = &res_comp[k];

	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 48				; 00000030H
	lea	rax, QWORD PTR res_comp$12[rsp+rax]
	mov	QWORD PTR r$4[rsp], rax

; 3395 : 				int y_bot = r->ystep >= (r->vs >> 1);

	mov	rax, QWORD PTR r$4[rsp]
	mov	eax, DWORD PTR [rax+28]
	sar	eax, 1
	mov	rcx, QWORD PTR r$4[rsp]
	cmp	DWORD PTR [rcx+36], eax
	jl	SHORT $LN47@load_jpeg_
	mov	DWORD PTR tv230[rsp], 1
	jmp	SHORT $LN48@load_jpeg_
$LN47@load_jpeg_:
	mov	DWORD PTR tv230[rsp], 0
$LN48@load_jpeg_:
	mov	eax, DWORD PTR tv230[rsp]
	mov	DWORD PTR y_bot$7[rsp], eax

; 3396 : 				coutput[k] = r->resample(z->img_comp[k].linebuf,

	mov	rax, QWORD PTR r$4[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv261[rsp], rax
	mov	rax, QWORD PTR r$4[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv259[rsp], eax
	mov	rax, QWORD PTR r$4[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv257[rsp], eax
	cmp	DWORD PTR y_bot$7[rsp], 0
	je	SHORT $LN49@load_jpeg_
	mov	rax, QWORD PTR r$4[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv243[rsp], rax
	jmp	SHORT $LN50@load_jpeg_
$LN49@load_jpeg_:
	mov	rax, QWORD PTR r$4[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv243[rsp], rax
$LN50@load_jpeg_:
	cmp	DWORD PTR y_bot$7[rsp], 0
	je	SHORT $LN51@load_jpeg_
	mov	rax, QWORD PTR r$4[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv248[rsp], rax
	jmp	SHORT $LN52@load_jpeg_
$LN51@load_jpeg_:
	mov	rax, QWORD PTR r$4[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv248[rsp], rax
$LN52@load_jpeg_:
	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	ecx, DWORD PTR tv259[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR tv257[rsp]
	mov	r8, QWORD PTR tv243[rsp]
	mov	rdx, QWORD PTR tv248[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+17896]
	call	QWORD PTR tv261[rsp]
	movsxd	rcx, DWORD PTR k$1[rsp]
	mov	QWORD PTR coutput$11[rsp+rcx*8], rax

; 3397 : 					y_bot ? r->line1 : r->line0,
; 3398 : 					y_bot ? r->line0 : r->line1,
; 3399 : 					r->w_lores, r->hs);
; 3400 : 				if (++r->ystep >= r->vs) {

	mov	rax, QWORD PTR r$4[rsp]
	mov	eax, DWORD PTR [rax+36]
	inc	eax
	mov	DWORD PTR tv264[rsp], eax
	mov	rax, QWORD PTR r$4[rsp]
	mov	ecx, DWORD PTR tv264[rsp]
	mov	DWORD PTR [rax+36], ecx
	mov	rax, QWORD PTR r$4[rsp]
	mov	eax, DWORD PTR [rax+28]
	cmp	DWORD PTR tv264[rsp], eax
	jl	$LN35@load_jpeg_

; 3401 : 					r->ystep = 0;

	mov	rax, QWORD PTR r$4[rsp]
	mov	DWORD PTR [rax+36], 0

; 3402 : 					r->line0 = r->line1;

	mov	rax, QWORD PTR r$4[rsp]
	mov	rcx, QWORD PTR r$4[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+8], rcx

; 3403 : 					if (++r->ypos < z->img_comp[k].y)

	mov	rax, QWORD PTR r$4[rsp]
	mov	eax, DWORD PTR [rax+40]
	inc	eax
	mov	DWORD PTR tv272[rsp], eax
	mov	rax, QWORD PTR r$4[rsp]
	mov	ecx, DWORD PTR tv272[rsp]
	mov	DWORD PTR [rax+40], ecx
	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17856]
	cmp	DWORD PTR tv272[rsp], eax
	jge	SHORT $LN36@load_jpeg_

; 3404 : 						r->line1 += z->img_comp[k].w2;

	movsxd	rax, DWORD PTR k$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+17860]
	mov	rcx, QWORD PTR r$4[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR r$4[rsp]
	mov	QWORD PTR [rcx+16], rax
$LN36@load_jpeg_:
$LN35@load_jpeg_:

; 3405 : 				}
; 3406 : 			}

	jmp	$LN8@load_jpeg_
$LN9@load_jpeg_:

; 3407 : 			if (n >= 3) {

	cmp	DWORD PTR n$[rsp], 3
	jl	$LN37@load_jpeg_

; 3408 : 				stbi_uc* y = coutput[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rax, QWORD PTR coutput$11[rsp+rax]
	mov	QWORD PTR y$9[rsp], rax

; 3409 : 				if (z->s->img_n == 3) {

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	DWORD PTR [rax+8], 3
	jne	SHORT $LN39@load_jpeg_

; 3410 : 					z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax+18288]
	mov	QWORD PTR tv308[rsp], rax
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	edi, DWORD PTR n$[rsp]
	mov	DWORD PTR [rsp+40], edi
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR coutput$11[rsp+rcx]
	mov	r8, QWORD PTR coutput$11[rsp+rdx]
	mov	rdx, QWORD PTR y$9[rsp]
	mov	rcx, QWORD PTR out$5[rsp]
	call	QWORD PTR tv308[rsp]
	npad	1

; 3411 : 				}

	jmp	$LN40@load_jpeg_
$LN39@load_jpeg_:

; 3412 : 				else
; 3413 : 					for (i = 0; i < z->s->img_x; ++i) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN13@load_jpeg_
$LN11@load_jpeg_:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN13@load_jpeg_:
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$2[rsp], eax
	jae	$LN12@load_jpeg_

; 3414 : 						out[0] = out[1] = out[2] = y[i];

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR out$5[rsp]
	mov	rdi, QWORD PTR y$9[rsp]
	movzx	eax, BYTE PTR [rdi+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR out$5[rsp]
	mov	rdi, QWORD PTR out$5[rsp]
	movzx	eax, BYTE PTR [rdi+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR out$5[rsp]
	mov	rdi, QWORD PTR out$5[rsp]
	movzx	eax, BYTE PTR [rdi+rax]
	mov	BYTE PTR [rdx+rcx], al

; 3415 : 						out[3] = 255; // not used if n==3

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR out$5[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH

; 3416 : 						out += n;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR out$5[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$5[rsp], rax

; 3417 : 					}

	jmp	$LN11@load_jpeg_
$LN12@load_jpeg_:
$LN40@load_jpeg_:

; 3418 : 			}

	jmp	$LN38@load_jpeg_
$LN37@load_jpeg_:

; 3419 : 			else {
; 3420 : 				stbi_uc* y = coutput[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rax, QWORD PTR coutput$11[rsp+rax]
	mov	QWORD PTR y$10[rsp], rax

; 3421 : 				if (n == 1)

	cmp	DWORD PTR n$[rsp], 1
	jne	SHORT $LN41@load_jpeg_

; 3422 : 					for (i = 0; i < z->s->img_x; ++i) out[i] = y[i];

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN16@load_jpeg_
$LN14@load_jpeg_:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN16@load_jpeg_:
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN15@load_jpeg_
	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR i$2[rsp]
	mov	rdx, QWORD PTR out$5[rsp]
	mov	rdi, QWORD PTR y$10[rsp]
	movzx	eax, BYTE PTR [rdi+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN14@load_jpeg_
$LN15@load_jpeg_:
	jmp	SHORT $LN42@load_jpeg_
$LN41@load_jpeg_:

; 3423 : 				else
; 3424 : 					for (i = 0; i < z->s->img_x; ++i) *out++ = y[i], * out++ = 255;

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN19@load_jpeg_
$LN17@load_jpeg_:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN19@load_jpeg_:
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN18@load_jpeg_
	mov	eax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR out$5[rsp]
	mov	rdx, QWORD PTR y$10[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR out$5[rsp]
	inc	rax
	mov	QWORD PTR out$5[rsp], rax
	mov	rax, QWORD PTR out$5[rsp]
	mov	BYTE PTR [rax], 255			; 000000ffH
	mov	rax, QWORD PTR out$5[rsp]
	inc	rax
	mov	QWORD PTR out$5[rsp], rax
	jmp	SHORT $LN17@load_jpeg_
$LN18@load_jpeg_:
$LN42@load_jpeg_:
$LN38@load_jpeg_:

; 3425 : 			}
; 3426 : 		}

	jmp	$LN5@load_jpeg_
$LN6@load_jpeg_:

; 3427 : 		stbi__cleanup_jpeg(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg

; 3428 : 		*out_x = z->s->img_x;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR out_x$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 3429 : 		*out_y = z->s->img_y;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR out_y$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rcx], eax

; 3430 : 		if (comp) *comp = z->s->img_n; // report original components, not output

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN43@load_jpeg_
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rcx], eax
$LN43@load_jpeg_:

; 3431 : 		return output;

	mov	rax, QWORD PTR output$8[rsp]
$LN1@load_jpeg_:

; 3432 : 	}
; 3433 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 432				; 000001b0H
	pop	rdi
	ret	0
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ENDP	; load_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
j$ = 64
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__cleanup_jpeg

; 3306 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3307 : 	int i;
; 3308 : 	for (i = 0; i < j->s->img_n; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__clea
$LN2@stbi__clea:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__clea:
	mov	rax, QWORD PTR j$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbi__clea

; 3309 : 		if (j->img_comp[i].raw_data) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	cmp	QWORD PTR [rcx+rax+17880], 0
	je	SHORT $LN5@stbi__clea

; 3310 : 			STBI_FREE(j->img_comp[i].raw_data);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+17880]
	call	free

; 3311 : 			j->img_comp[i].raw_data = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR [rcx+rax+17880], 0

; 3312 : 			j->img_comp[i].data = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR [rcx+rax+17872], 0
$LN5@stbi__clea:

; 3313 : 		}
; 3314 : 		if (j->img_comp[i].raw_coeff) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	cmp	QWORD PTR [rcx+rax+17888], 0
	je	SHORT $LN6@stbi__clea

; 3315 : 			STBI_FREE(j->img_comp[i].raw_coeff);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+17888]
	call	free

; 3316 : 			j->img_comp[i].raw_coeff = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR [rcx+rax+17888], 0

; 3317 : 			j->img_comp[i].coeff = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR [rcx+rax+17904], 0
$LN6@stbi__clea:

; 3318 : 		}
; 3319 : 		if (j->img_comp[i].linebuf) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	cmp	QWORD PTR [rcx+rax+17896], 0
	je	SHORT $LN7@stbi__clea

; 3320 : 			STBI_FREE(j->img_comp[i].linebuf);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+17896]
	call	free

; 3321 : 			j->img_comp[i].linebuf = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR [rcx+rax+17896], 0
$LN7@stbi__clea:

; 3322 : 		}
; 3323 : 	}

	jmp	$LN2@stbi__clea
$LN3@stbi__clea:

; 3324 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__cleanup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
j$ = 8
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__setup_jpeg

; 3280 : {

	mov	QWORD PTR [rsp+8], rcx

; 3281 : 	j->idct_block_kernel = stbi__idct_block;

	mov	rax, QWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__idct_block@@YAXPEAEHQEAF@Z ; stbi__idct_block
	mov	QWORD PTR [rax+18280], rcx

; 3282 : 	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

	mov	rax, QWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ; stbi__YCbCr_to_RGB_row
	mov	QWORD PTR [rax+18288], rcx

; 3283 : 	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

	mov	rax, QWORD PTR j$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_hv_2
	mov	QWORD PTR [rax+18296], rcx

; 3284 : 
; 3285 : #ifdef STBI_SSE2
; 3286 : 	if (stbi__sse2_available()) {
; 3287 : 		j->idct_block_kernel = stbi__idct_simd;
; 3288 : #ifndef STBI_JPEG_OLD
; 3289 : 		j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3290 : #endif
; 3291 : 		j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3292 : 	}
; 3293 : #endif
; 3294 : 
; 3295 : #ifdef STBI_NEON
; 3296 : 	j->idct_block_kernel = stbi__idct_simd;
; 3297 : #ifndef STBI_JPEG_OLD
; 3298 : 	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3299 : #endif
; 3300 : 	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3301 : #endif
; 3302 : }

	ret	0
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__setup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$1 = 0
g$2 = 4
b$3 = 8
i$ = 12
y_fixed$4 = 16
cr$5 = 20
cb$6 = 24
out$ = 48
y$ = 56
pcb$ = 64
pcr$ = 72
count$ = 80
step$ = 88
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z PROC		; stbi__YCbCr_to_RGB_row

; 3118 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3119 : 	int i;
; 3120 : 	for (i = 0; i < count; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__YCbC:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbi__YCbC

; 3121 : 		int y_fixed = (y[i] << 20) + (1 << 19); // rounding

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR y$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 20
	add	eax, 524288				; 00080000H
	mov	DWORD PTR y_fixed$4[rsp], eax

; 3122 : 		int r, g, b;
; 3123 : 		int cr = pcr[i] - 128;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR pcr$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 128				; 00000080H
	mov	DWORD PTR cr$5[rsp], eax

; 3124 : 		int cb = pcb[i] - 128;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR pcb$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 128				; 00000080H
	mov	DWORD PTR cb$6[rsp], eax

; 3125 : 		r = y_fixed + cr * float2fixed(1.40200f);

	imul	eax, DWORD PTR cr$5[rsp], 1470208	; 00166f00H
	mov	ecx, DWORD PTR y_fixed$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR r$1[rsp], eax

; 3126 : 		g = y_fixed + (cr * -float2fixed(0.71414f)) + ((cb * -float2fixed(0.34414f)) & 0xffff0000);

	imul	eax, DWORD PTR cr$5[rsp], -748800	; fffffffffff49300H
	mov	ecx, DWORD PTR y_fixed$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	ecx, DWORD PTR cb$6[rsp], -360960	; fffffffffffa7e00H
	and	ecx, -65536				; ffff0000H
	add	eax, ecx
	mov	DWORD PTR g$2[rsp], eax

; 3127 : 		b = y_fixed + cb * float2fixed(1.77200f);

	imul	eax, DWORD PTR cb$6[rsp], 1858048	; 001c5a00H
	mov	ecx, DWORD PTR y_fixed$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR b$3[rsp], eax

; 3128 : 		r >>= 20;

	mov	eax, DWORD PTR r$1[rsp]
	sar	eax, 20
	mov	DWORD PTR r$1[rsp], eax

; 3129 : 		g >>= 20;

	mov	eax, DWORD PTR g$2[rsp]
	sar	eax, 20
	mov	DWORD PTR g$2[rsp], eax

; 3130 : 		b >>= 20;

	mov	eax, DWORD PTR b$3[rsp]
	sar	eax, 20
	mov	DWORD PTR b$3[rsp], eax

; 3131 : 		if ((unsigned)r > 255) { if (r < 0) r = 0; else r = 255; }

	cmp	DWORD PTR r$1[rsp], 255			; 000000ffH
	jbe	SHORT $LN5@stbi__YCbC
	cmp	DWORD PTR r$1[rsp], 0
	jge	SHORT $LN6@stbi__YCbC
	mov	DWORD PTR r$1[rsp], 0
	jmp	SHORT $LN7@stbi__YCbC
$LN6@stbi__YCbC:
	mov	DWORD PTR r$1[rsp], 255			; 000000ffH
$LN7@stbi__YCbC:
$LN5@stbi__YCbC:

; 3132 : 		if ((unsigned)g > 255) { if (g < 0) g = 0; else g = 255; }

	cmp	DWORD PTR g$2[rsp], 255			; 000000ffH
	jbe	SHORT $LN8@stbi__YCbC
	cmp	DWORD PTR g$2[rsp], 0
	jge	SHORT $LN9@stbi__YCbC
	mov	DWORD PTR g$2[rsp], 0
	jmp	SHORT $LN10@stbi__YCbC
$LN9@stbi__YCbC:
	mov	DWORD PTR g$2[rsp], 255			; 000000ffH
$LN10@stbi__YCbC:
$LN8@stbi__YCbC:

; 3133 : 		if ((unsigned)b > 255) { if (b < 0) b = 0; else b = 255; }

	cmp	DWORD PTR b$3[rsp], 255			; 000000ffH
	jbe	SHORT $LN11@stbi__YCbC
	cmp	DWORD PTR b$3[rsp], 0
	jge	SHORT $LN12@stbi__YCbC
	mov	DWORD PTR b$3[rsp], 0
	jmp	SHORT $LN13@stbi__YCbC
$LN12@stbi__YCbC:
	mov	DWORD PTR b$3[rsp], 255			; 000000ffH
$LN13@stbi__YCbC:
$LN11@stbi__YCbC:

; 3134 : 		out[0] = (stbi_uc)r;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, BYTE PTR r$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 3135 : 		out[1] = (stbi_uc)g;

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, BYTE PTR g$2[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 3136 : 		out[2] = (stbi_uc)b;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, BYTE PTR b$3[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 3137 : 		out[3] = 255;

	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH

; 3138 : 		out += step;

	movsxd	rax, DWORD PTR step$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 3139 : 	}

	jmp	$LN2@stbi__YCbC
$LN3@stbi__YCbC:

; 3140 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ENDP		; stbi__YCbCr_to_RGB_row
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
j$ = 4
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z PROC	; stbi__resample_row_generic

; 3075 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 3076 : 	// resample with nearest-neighbor
; 3077 : 	int i, j;
; 3078 : 	STBI_NOTUSED(in_far);
; 3079 : 	for (i = 0; i < w; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR w$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbi__resa

; 3080 : 		for (j = 0; j < hs; ++j)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN7@stbi__resa
$LN5@stbi__resa:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@stbi__resa:
	mov	eax, DWORD PTR hs$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	SHORT $LN6@stbi__resa

; 3081 : 			out[i * hs + j] = in_near[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	imul	ecx, DWORD PTR hs$[rsp]
	add	ecx, DWORD PTR j$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	r8, QWORD PTR in_near$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN5@stbi__resa
$LN6@stbi__resa:
	jmp	SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3082 : 	return out;

	mov	rax, QWORD PTR out$[rsp]

; 3083 : }

	add	rsp, 24
	ret	0
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ENDP	; stbi__resample_row_generic
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
t1$ = 4
tv78 = 8
t0$ = 12
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_hv_2

; 2934 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2935 : 	// need to generate 2x2 samples for every one in input
; 2936 : 	int i, t0, t1;
; 2937 : 	if (w == 1) {

	cmp	DWORD PTR w$[rsp], 1
	jne	SHORT $LN5@stbi__resa

; 2938 : 		out[0] = out[1] = stbi__div4(3 * in_near[0] + in_far[0] + 2);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR in_near$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 3
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR in_far$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+2]
	sar	eax, 2
	mov	DWORD PTR tv78[rsp], eax
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, BYTE PTR tv78[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, BYTE PTR tv78[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 2939 : 		return out;

	mov	rax, QWORD PTR out$[rsp]
	jmp	$LN1@stbi__resa
$LN5@stbi__resa:

; 2940 : 	}
; 2941 : 
; 2942 : 	t1 = 3 * in_near[0] + in_far[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR in_near$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 3
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR in_far$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	mov	DWORD PTR t1$[rsp], eax

; 2943 : 	out[0] = stbi__div4(t1 + 2);

	mov	eax, DWORD PTR t1$[rsp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2944 : 	for (i = 1; i < w; ++i) {

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR w$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbi__resa

; 2945 : 		t0 = t1;

	mov	eax, DWORD PTR t1$[rsp]
	mov	DWORD PTR t0$[rsp], eax

; 2946 : 		t1 = 3 * in_near[i] + in_far[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR in_near$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 3
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR in_far$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	add	eax, ecx
	mov	DWORD PTR t1$[rsp], eax

; 2947 : 		out[i * 2 - 1] = stbi__div16(3 * t0 + t1 + 8);

	imul	eax, DWORD PTR t0$[rsp], 3
	mov	ecx, DWORD PTR t1$[rsp]
	lea	eax, DWORD PTR [rax+rcx+8]
	sar	eax, 4
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx-1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2948 : 		out[i * 2] = stbi__div16(3 * t1 + t0 + 8);

	imul	eax, DWORD PTR t1$[rsp], 3
	mov	ecx, DWORD PTR t0$[rsp]
	lea	eax, DWORD PTR [rax+rcx+8]
	sar	eax, 4
	mov	ecx, DWORD PTR i$[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2949 : 	}

	jmp	SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 2950 : 	out[w * 2 - 1] = stbi__div4(t1 + 2);

	mov	eax, DWORD PTR t1$[rsp]
	add	eax, 2
	sar	eax, 2
	mov	ecx, DWORD PTR w$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx-1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2951 : 
; 2952 : 	STBI_NOTUSED(hs);
; 2953 : 
; 2954 : 	return out;

	mov	rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 2955 : }

	add	rsp, 24
	ret	0
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_hv_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
n$1 = 4
input$ = 8
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_h_2

; 2904 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2905 : 	// need to generate two samples horizontally for every one in input
; 2906 : 	int i;
; 2907 : 	stbi_uc* input = in_near;

	mov	rax, QWORD PTR in_near$[rsp]
	mov	QWORD PTR input$[rsp], rax

; 2908 : 
; 2909 : 	if (w == 1) {

	cmp	DWORD PTR w$[rsp], 1
	jne	SHORT $LN5@stbi__resa

; 2910 : 		// if only one sample, can't do any interpolation
; 2911 : 		out[0] = out[1] = input[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR out$[rsp]
	mov	r8, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR out$[rsp]
	mov	r8, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 2912 : 		return out;

	mov	rax, QWORD PTR out$[rsp]
	jmp	$LN1@stbi__resa
$LN5@stbi__resa:

; 2913 : 	}
; 2914 : 
; 2915 : 	out[0] = input[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR out$[rsp]
	mov	r8, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 2916 : 	out[1] = stbi__div4(input[0] * 3 + input[1] + 2);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 3
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR input$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+2]
	sar	eax, 2
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2917 : 	for (i = 1; i < w - 1; ++i) {

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR w$[rsp]
	dec	eax
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbi__resa

; 2918 : 		int n = 3 * input[i] + 2;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 3
	add	eax, 2
	mov	DWORD PTR n$1[rsp], eax

; 2919 : 		out[i * 2 + 0] = stbi__div4(n + input[i - 1]);

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	cdqe
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR n$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 2
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2920 : 		out[i * 2 + 1] = stbi__div4(n + input[i + 1]);

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR n$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 2
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2921 : 	}

	jmp	$LN2@stbi__resa
$LN3@stbi__resa:

; 2922 : 	out[i * 2 + 0] = stbi__div4(input[w - 2] * 3 + input[w - 1] + 2);

	mov	eax, DWORD PTR w$[rsp]
	sub	eax, 2
	cdqe
	mov	rcx, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 3
	mov	ecx, DWORD PTR w$[rsp]
	dec	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR input$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+2]
	sar	eax, 2
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2923 : 	out[i * 2 + 1] = input[w - 1];

	mov	eax, DWORD PTR w$[rsp]
	dec	eax
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	r8, QWORD PTR input$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 2924 : 
; 2925 : 	STBI_NOTUSED(in_far);
; 2926 : 	STBI_NOTUSED(hs);
; 2927 : 
; 2928 : 	return out;

	mov	rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 2929 : }

	add	rsp, 24
	ret	0
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_h_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_v_2

; 2894 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2895 : 	// need to generate two samples vertically for every one in input
; 2896 : 	int i;
; 2897 : 	STBI_NOTUSED(hs);
; 2898 : 	for (i = 0; i < w; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__resa
$LN2@stbi__resa:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
	mov	eax, DWORD PTR w$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbi__resa

; 2899 : 		out[i] = stbi__div4(3 * in_near[i] + in_far[i] + 2);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR in_near$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, eax, 3
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR in_far$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	lea	eax, DWORD PTR [rax+rcx+2]
	sar	eax, 2
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 2900 : 	return out;

	mov	rax, QWORD PTR out$[rsp]

; 2901 : }

	add	rsp, 24
	ret	0
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_v_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
out$ = 8
in_near$ = 16
in_far$ = 24
w$ = 32
hs$ = 40
?resample_row_1@@YAPEAEPEAE00HH@Z PROC			; resample_row_1

; 2885 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 2886 : 	STBI_NOTUSED(out);
; 2887 : 	STBI_NOTUSED(in_far);
; 2888 : 	STBI_NOTUSED(w);
; 2889 : 	STBI_NOTUSED(hs);
; 2890 : 	return in_near;

	mov	rax, QWORD PTR in_near$[rsp]

; 2891 : }

	ret	0
?resample_row_1@@YAPEAEPEAE00HH@Z ENDP			; resample_row_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
m$ = 32
x$1 = 36
j$ = 64
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__decode_jpeg_image

; 2839 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2840 : 	int m;
; 2841 : 	for (m = 0; m < 4; m++) {

	mov	DWORD PTR m$[rsp], 0
	jmp	SHORT $LN4@stbi__deco
$LN2@stbi__deco:
	mov	eax, DWORD PTR m$[rsp]
	inc	eax
	mov	DWORD PTR m$[rsp], eax
$LN4@stbi__deco:
	cmp	DWORD PTR m$[rsp], 4
	jge	SHORT $LN3@stbi__deco

; 2842 : 		j->img_comp[m].raw_data = NULL;

	movsxd	rax, DWORD PTR m$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR [rcx+rax+17880], 0

; 2843 : 		j->img_comp[m].raw_coeff = NULL;

	movsxd	rax, DWORD PTR m$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR [rcx+rax+17888], 0

; 2844 : 	}

	jmp	SHORT $LN2@stbi__deco
$LN3@stbi__deco:

; 2845 : 	j->restart_interval = 0;

	mov	rax, QWORD PTR j$[rsp]
	mov	DWORD PTR [rax+18268], 0

; 2846 : 	if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

	xor	edx, edx
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
	test	eax, eax
	jne	SHORT $LN9@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN9@stbi__deco:

; 2847 : 	m = stbi__get_marker(j);

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	eax, al
	mov	DWORD PTR m$[rsp], eax
$LN5@stbi__deco:

; 2848 : 	while (!stbi__EOI(m)) {

	cmp	DWORD PTR m$[rsp], 217			; 000000d9H
	je	$LN6@stbi__deco

; 2849 : 		if (stbi__SOS(m)) {

	cmp	DWORD PTR m$[rsp], 218			; 000000daH
	jne	$LN10@stbi__deco

; 2850 : 			if (!stbi__process_scan_header(j)) return 0;

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ; stbi__process_scan_header
	test	eax, eax
	jne	SHORT $LN12@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN12@stbi__deco:

; 2851 : 			if (!stbi__parse_entropy_coded_data(j)) return 0;

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ; stbi__parse_entropy_coded_data
	test	eax, eax
	jne	SHORT $LN13@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN13@stbi__deco:

; 2852 : 			if (j->marker == STBI__MARKER_none) {

	mov	rax, QWORD PTR j$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN14@stbi__deco
$LN7@stbi__deco:

; 2853 : 				// handle 0s at the end of image data from IP Kamera 9060
; 2854 : 				while (!stbi__at_eof(j->s)) {

	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	jne	SHORT $LN8@stbi__deco

; 2855 : 					int x = stbi__get8(j->s);

	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR x$1[rsp], eax

; 2856 : 					if (x == 255) {

	cmp	DWORD PTR x$1[rsp], 255			; 000000ffH
	jne	SHORT $LN15@stbi__deco

; 2857 : 						j->marker = stbi__get8(j->s);

	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR j$[rsp]
	mov	BYTE PTR [rcx+18216], al

; 2858 : 						break;

	jmp	SHORT $LN8@stbi__deco

; 2859 : 					}

	jmp	SHORT $LN16@stbi__deco
$LN15@stbi__deco:

; 2860 : 					else if (x != 0) {

	cmp	DWORD PTR x$1[rsp], 0
	je	SHORT $LN17@stbi__deco

; 2861 : 						return stbi__err("junk before marker", "Corrupt JPEG");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__deco
$LN17@stbi__deco:
$LN16@stbi__deco:

; 2862 : 					}
; 2863 : 				}

	jmp	SHORT $LN7@stbi__deco
$LN8@stbi__deco:
$LN14@stbi__deco:

; 2864 : 				// if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 2865 : 			}
; 2866 : 		}

	jmp	SHORT $LN11@stbi__deco
$LN10@stbi__deco:

; 2867 : 		else {
; 2868 : 			if (!stbi__process_marker(j, m)) return 0;

	mov	edx, DWORD PTR m$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
	test	eax, eax
	jne	SHORT $LN18@stbi__deco
	xor	eax, eax
	jmp	SHORT $LN1@stbi__deco
$LN18@stbi__deco:
$LN11@stbi__deco:

; 2869 : 		}
; 2870 : 		m = stbi__get_marker(j);

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	eax, al
	mov	DWORD PTR m$[rsp], eax

; 2871 : 	}

	jmp	$LN5@stbi__deco
$LN6@stbi__deco:

; 2872 : 	if (j->progressive)

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18224], 0
	je	SHORT $LN19@stbi__deco

; 2873 : 		stbi__jpeg_finish(j);

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_finish
	npad	1
$LN19@stbi__deco:

; 2874 : 	return 1;

	mov	eax, 1
$LN1@stbi__deco:

; 2875 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__decode_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
m$ = 32
tv93 = 36
z$ = 64
scan$ = 72
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__decode_jpeg_header

; 2816 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2817 : 	int m;
; 2818 : 	z->marker = STBI__MARKER_none; // initialize cached marker to empty

	mov	rax, QWORD PTR z$[rsp]
	mov	BYTE PTR [rax+18216], 255		; 000000ffH

; 2819 : 	m = stbi__get_marker(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	eax, al
	mov	DWORD PTR m$[rsp], eax

; 2820 : 	if (!stbi__SOI(m)) return stbi__err("no SOI", "Corrupt JPEG");

	cmp	DWORD PTR m$[rsp], 216			; 000000d8H
	je	SHORT $LN6@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN6@stbi__deco:

; 2821 : 	if (scan == STBI__SCAN_type) return 1;

	cmp	DWORD PTR scan$[rsp], 1
	jne	SHORT $LN7@stbi__deco
	mov	eax, 1
	jmp	$LN1@stbi__deco
$LN7@stbi__deco:

; 2822 : 	m = stbi__get_marker(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	eax, al
	mov	DWORD PTR m$[rsp], eax
$LN2@stbi__deco:

; 2823 : 	while (!stbi__SOF(m)) {

	cmp	DWORD PTR m$[rsp], 192			; 000000c0H
	je	SHORT $LN3@stbi__deco
	cmp	DWORD PTR m$[rsp], 193			; 000000c1H
	je	SHORT $LN3@stbi__deco
	cmp	DWORD PTR m$[rsp], 194			; 000000c2H
	je	SHORT $LN3@stbi__deco

; 2824 : 		if (!stbi__process_marker(z, m)) return 0;

	mov	edx, DWORD PTR m$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
	test	eax, eax
	jne	SHORT $LN8@stbi__deco
	xor	eax, eax
	jmp	$LN1@stbi__deco
$LN8@stbi__deco:

; 2825 : 		m = stbi__get_marker(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	eax, al
	mov	DWORD PTR m$[rsp], eax
$LN4@stbi__deco:

; 2826 : 		while (m == STBI__MARKER_none) {

	cmp	DWORD PTR m$[rsp], 255			; 000000ffH
	jne	SHORT $LN5@stbi__deco

; 2827 : 			// some files have extra padding after their blocks, so ok, we'll scan
; 2828 : 			if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN9@stbi__deco
	xor	eax, eax
	jmp	SHORT $LN1@stbi__deco
$LN9@stbi__deco:

; 2829 : 			m = stbi__get_marker(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
	movzx	eax, al
	mov	DWORD PTR m$[rsp], eax

; 2830 : 		}

	jmp	SHORT $LN4@stbi__deco
$LN5@stbi__deco:

; 2831 : 	}

	jmp	SHORT $LN2@stbi__deco
$LN3@stbi__deco:

; 2832 : 	z->progressive = stbi__SOF_progressive(m);

	cmp	DWORD PTR m$[rsp], 194			; 000000c2H
	jne	SHORT $LN12@stbi__deco
	mov	DWORD PTR tv93[rsp], 1
	jmp	SHORT $LN13@stbi__deco
$LN12@stbi__deco:
	mov	DWORD PTR tv93[rsp], 0
$LN13@stbi__deco:
	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR tv93[rsp]
	mov	DWORD PTR [rax+18224], ecx

; 2833 : 	if (!stbi__process_frame_header(z, scan)) return 0;

	mov	edx, DWORD PTR scan$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_frame_header
	test	eax, eax
	jne	SHORT $LN10@stbi__deco
	xor	eax, eax
	jmp	SHORT $LN1@stbi__deco
$LN10@stbi__deco:

; 2834 : 	return 1;

	mov	eax, 1
$LN1@stbi__deco:

; 2835 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__decode_jpeg_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
h_max$ = 36
v_max$ = 40
c$ = 44
Lf$ = 48
q$ = 52
p$ = 56
s$ = 64
z$ = 96
scan$ = 104
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z PROC ; stbi__process_frame_header

; 2724 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2725 : 	stbi__context* s = z->s;

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR s$[rsp], rax

; 2726 : 	int Lf, p, i, q, h_max = 1, v_max = 1, c;

	mov	DWORD PTR h_max$[rsp], 1
	mov	DWORD PTR v_max$[rsp], 1

; 2727 : 	Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len", "Corrupt JPEG"); // JPEG

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR Lf$[rsp], eax
	cmp	DWORD PTR Lf$[rsp], 11
	jge	SHORT $LN17@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN17@stbi__proc:

; 2728 : 	p = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit", "JPEG format not supported: 8-bit only"); // JPEG baseline

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR p$[rsp], eax
	cmp	DWORD PTR p$[rsp], 8
	je	SHORT $LN18@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN18@stbi__proc:

; 2729 : 	s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN19@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN19@stbi__proc:

; 2730 : 	s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width", "Corrupt JPEG"); // JPEG requires

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN20@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN20@stbi__proc:

; 2731 : 	c = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR c$[rsp], eax

; 2732 : 	if (c != 3 && c != 1) return stbi__err("bad component count", "Corrupt JPEG");    // JFIF requires

	cmp	DWORD PTR c$[rsp], 3
	je	SHORT $LN21@stbi__proc
	cmp	DWORD PTR c$[rsp], 1
	je	SHORT $LN21@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN21@stbi__proc:

; 2733 : 	s->img_n = c;

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR c$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 2734 : 	for (i = 0; i < c; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__proc
$LN2@stbi__proc:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
	mov	eax, DWORD PTR c$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN3@stbi__proc

; 2735 : 		z->img_comp[i].data = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+rax+17872], 0

; 2736 : 		z->img_comp[i].linebuf = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+rax+17896], 0

; 2737 : 	}

	jmp	SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 2738 : 
; 2739 : 	if (Lf != 8 + 3 * s->img_n) return stbi__err("bad SOF len", "Corrupt JPEG");

	mov	rax, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rax+8], 3
	add	eax, 8
	cmp	DWORD PTR Lf$[rsp], eax
	je	SHORT $LN22@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN22@stbi__proc:

; 2740 : 
; 2741 : 	for (i = 0; i < s->img_n; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbi__proc
$LN5@stbi__proc:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__proc:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN6@stbi__proc

; 2742 : 		z->img_comp[i].id = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17824], eax

; 2743 : 		if (z->img_comp[i].id != i + 1)   // JFIF requires

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	mov	rdx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rdx+rax+17824], ecx
	je	SHORT $LN23@stbi__proc

; 2744 : 			if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	cmp	DWORD PTR [rcx+rax+17824], edx
	je	SHORT $LN24@stbi__proc

; 2745 : 				return stbi__err("bad component ID", "Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN24@stbi__proc:
$LN23@stbi__proc:

; 2746 : 		q = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR q$[rsp], eax

; 2747 : 		z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H", "Corrupt JPEG");

	mov	eax, DWORD PTR q$[rsp]
	sar	eax, 4
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17828], eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rcx+rax+17828], 0
	je	SHORT $LN26@stbi__proc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rcx+rax+17828], 4
	jle	SHORT $LN25@stbi__proc
$LN26@stbi__proc:
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN25@stbi__proc:

; 2748 : 		z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V", "Corrupt JPEG");

	mov	eax, DWORD PTR q$[rsp]
	and	eax, 15
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17832], eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rcx+rax+17832], 0
	je	SHORT $LN28@stbi__proc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rcx+rax+17832], 4
	jle	SHORT $LN27@stbi__proc
$LN28@stbi__proc:
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN27@stbi__proc:

; 2749 : 		z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ", "Corrupt JPEG");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17836], eax
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rcx+rax+17836], 3
	jle	SHORT $LN29@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN29@stbi__proc:

; 2750 : 	}

	jmp	$LN5@stbi__proc
$LN6@stbi__proc:

; 2751 : 
; 2752 : 	if (scan != STBI__SCAN_load) return 1;

	cmp	DWORD PTR scan$[rsp], 0
	je	SHORT $LN30@stbi__proc
	mov	eax, 1
	jmp	$LN1@stbi__proc
$LN30@stbi__proc:

; 2753 : 
; 2754 : 	if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

	xor	edx, edx
	mov	eax, 1073741824				; 40000000H
	mov	rcx, QWORD PTR s$[rsp]
	div	DWORD PTR [rcx]
	xor	edx, edx
	mov	rcx, QWORD PTR s$[rsp]
	div	DWORD PTR [rcx+8]
	mov	rcx, QWORD PTR s$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jae	SHORT $LN31@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN31@stbi__proc:

; 2755 : 
; 2756 : 	for (i = 0; i < s->img_n; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@stbi__proc
$LN8@stbi__proc:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@stbi__proc:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN9@stbi__proc

; 2757 : 		if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR h_max$[rsp]
	cmp	DWORD PTR [rcx+rax+17828], edx
	jle	SHORT $LN32@stbi__proc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17828]
	mov	DWORD PTR h_max$[rsp], eax
$LN32@stbi__proc:

; 2758 : 		if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR v_max$[rsp]
	cmp	DWORD PTR [rcx+rax+17832], edx
	jle	SHORT $LN33@stbi__proc
	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17832]
	mov	DWORD PTR v_max$[rsp], eax
$LN33@stbi__proc:

; 2759 : 	}

	jmp	$LN8@stbi__proc
$LN9@stbi__proc:

; 2760 : 
; 2761 : 	// compute interleaved mcu info
; 2762 : 	z->img_h_max = h_max;

	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR h_max$[rsp]
	mov	DWORD PTR [rax+17800], ecx

; 2763 : 	z->img_v_max = v_max;

	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR v_max$[rsp]
	mov	DWORD PTR [rax+17804], ecx

; 2764 : 	z->img_mcu_w = h_max * 8;

	mov	eax, DWORD PTR h_max$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+17816], eax

; 2765 : 	z->img_mcu_h = v_max * 8;

	mov	eax, DWORD PTR v_max$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+17820], eax

; 2766 : 	z->img_mcu_x = (s->img_x + z->img_mcu_w - 1) / z->img_mcu_w;

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx+17816]
	lea	eax, DWORD PTR [rax+rcx-1]
	xor	edx, edx
	mov	rcx, QWORD PTR z$[rsp]
	div	DWORD PTR [rcx+17816]
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+17808], eax

; 2767 : 	z->img_mcu_y = (s->img_y + z->img_mcu_h - 1) / z->img_mcu_h;

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx+17820]
	lea	eax, DWORD PTR [rax+rcx-1]
	xor	edx, edx
	mov	rcx, QWORD PTR z$[rsp]
	div	DWORD PTR [rcx+17820]
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+17812], eax

; 2768 : 
; 2769 : 	for (i = 0; i < s->img_n; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@stbi__proc
$LN11@stbi__proc:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@stbi__proc:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN12@stbi__proc

; 2770 : 		// number of effective pixels (e.g. for non-interleaved MCU)
; 2771 : 		z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max - 1) / h_max;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR s$[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx]
	imul	ecx, DWORD PTR [rdx+rax+17828]
	mov	eax, ecx
	mov	ecx, DWORD PTR h_max$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	DWORD PTR h_max$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17852], eax

; 2772 : 		z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max - 1) / v_max;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR s$[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	imul	ecx, DWORD PTR [rdx+rax+17832]
	mov	eax, ecx
	mov	ecx, DWORD PTR v_max$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	DWORD PTR v_max$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17856], eax

; 2773 : 		// to simplify generation, we'll allocate enough memory to decode
; 2774 : 		// the bogus oversized data from using interleaved MCUs and their
; 2775 : 		// big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 2776 : 		// discard the extra data until colorspace conversion
; 2777 : 		z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx+17808]
	imul	ecx, DWORD PTR [rdx+rax+17828]
	mov	eax, ecx
	shl	eax, 3
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17860], eax

; 2778 : 		z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx+17812]
	imul	ecx, DWORD PTR [rdx+rax+17832]
	mov	eax, ecx
	shl	eax, 3
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17864], eax

; 2779 : 		z->img_comp[i].raw_data = stbi__malloc(z->img_comp[i].w2 * z->img_comp[i].h2 + 15);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	r8, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rdx+rax+17860]
	imul	eax, DWORD PTR [r8+rcx+17864]
	add	eax, 15
	cdqe
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rdx+rcx+17880], rax

; 2780 : 
; 2781 : 		if (z->img_comp[i].raw_data == NULL) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	QWORD PTR [rcx+rax+17880], 0
	jne	SHORT $LN34@stbi__proc

; 2782 : 			for (--i; i >= 0; --i) {

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN16@stbi__proc
$LN14@stbi__proc:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN16@stbi__proc:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN15@stbi__proc

; 2783 : 				STBI_FREE(z->img_comp[i].raw_data);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rcx+rax+17880]
	call	free

; 2784 : 				z->img_comp[i].raw_data = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+rax+17880], 0

; 2785 : 			}

	jmp	SHORT $LN14@stbi__proc
$LN15@stbi__proc:

; 2786 : 			return stbi__err("outofmem", "Out of memory");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN34@stbi__proc:

; 2787 : 		}
; 2788 : 		// align blocks for idct using mmx/sse
; 2789 : 		z->img_comp[i].data = (stbi_uc*)(((size_t)z->img_comp[i].raw_data + 15) & ~15);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rcx+rax+17880]
	add	rax, 15
	and	rax, -16
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rdx+rcx+17872], rax

; 2790 : 		z->img_comp[i].linebuf = NULL;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+rax+17896], 0

; 2791 : 		if (z->progressive) {

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18224], 0
	je	$LN35@stbi__proc

; 2792 : 			z->img_comp[i].coeff_w = (z->img_comp[i].w2 + 7) >> 3;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17860]
	add	eax, 7
	sar	eax, 3
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17912], eax

; 2793 : 			z->img_comp[i].coeff_h = (z->img_comp[i].h2 + 7) >> 3;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17864]
	add	eax, 7
	sar	eax, 3
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17916], eax

; 2794 : 			z->img_comp[i].raw_coeff = STBI_MALLOC(z->img_comp[i].coeff_w * z->img_comp[i].coeff_h * 64 * sizeof(short) + 15);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	r8, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rdx+rax+17912]
	imul	eax, DWORD PTR [r8+rcx+17916]
	imul	eax, eax, 64				; 00000040H
	cdqe
	lea	rax, QWORD PTR [rax+rax+15]
	mov	rcx, rax
	call	malloc
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rdx+rcx+17888], rax

; 2795 : 			z->img_comp[i].coeff = (short*)(((size_t)z->img_comp[i].raw_coeff + 15) & ~15);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rcx+rax+17888]
	add	rax, 15
	and	rax, -16
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rdx+rcx+17904], rax

; 2796 : 		}

	jmp	SHORT $LN36@stbi__proc
$LN35@stbi__proc:

; 2797 : 		else {
; 2798 : 			z->img_comp[i].coeff = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+rax+17904], 0

; 2799 : 			z->img_comp[i].raw_coeff = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	QWORD PTR [rcx+rax+17888], 0
$LN36@stbi__proc:

; 2800 : 		}
; 2801 : 	}

	jmp	$LN11@stbi__proc
$LN12@stbi__proc:

; 2802 : 
; 2803 : 	return 1;

	mov	eax, 1
$LN1@stbi__proc:

; 2804 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ENDP ; stbi__process_frame_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
which$1 = 32
i$ = 36
q$2 = 40
aa$3 = 44
Ls$ = 48
id$4 = 52
z$ = 80
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__process_scan_header

; 2684 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2685 : 	int i;
; 2686 : 	int Ls = stbi__get16be(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR Ls$[rsp], eax

; 2687 : 	z->scan_n = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+18248], eax

; 2688 : 	if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int)z->s->img_n) return stbi__err("bad SOS component count", "Corrupt JPEG");

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18248], 1
	jl	SHORT $LN9@stbi__proc
	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18248], 4
	jg	SHORT $LN9@stbi__proc
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR [rcx+18248], eax
	jle	SHORT $LN8@stbi__proc
$LN9@stbi__proc:
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN8@stbi__proc:

; 2689 : 	if (Ls != 6 + 2 * z->scan_n) return stbi__err("bad SOS len", "Corrupt JPEG");

	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18248]
	lea	eax, DWORD PTR [rax+rax+6]
	cmp	DWORD PTR Ls$[rsp], eax
	je	SHORT $LN10@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN10@stbi__proc:

; 2690 : 	for (i = 0; i < z->scan_n; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__proc
$LN2@stbi__proc:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18248]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbi__proc

; 2691 : 		int id = stbi__get8(z->s), which;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR id$4[rsp], eax

; 2692 : 		int q = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR q$2[rsp], eax

; 2693 : 		for (which = 0; which < z->s->img_n; ++which)

	mov	DWORD PTR which$1[rsp], 0
	jmp	SHORT $LN7@stbi__proc
$LN5@stbi__proc:
	mov	eax, DWORD PTR which$1[rsp]
	inc	eax
	mov	DWORD PTR which$1[rsp], eax
$LN7@stbi__proc:
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR which$1[rsp], eax
	jge	SHORT $LN6@stbi__proc

; 2694 : 			if (z->img_comp[which].id == id)

	movsxd	rax, DWORD PTR which$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR id$4[rsp]
	cmp	DWORD PTR [rcx+rax+17824], edx
	jne	SHORT $LN11@stbi__proc

; 2695 : 				break;

	jmp	SHORT $LN6@stbi__proc
$LN11@stbi__proc:
	jmp	SHORT $LN5@stbi__proc
$LN6@stbi__proc:

; 2696 : 		if (which == z->s->img_n) return 0; // no match

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR which$1[rsp], eax
	jne	SHORT $LN12@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN12@stbi__proc:

; 2697 : 		z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff", "Corrupt JPEG");

	mov	eax, DWORD PTR q$2[rsp]
	sar	eax, 4
	movsxd	rcx, DWORD PTR which$1[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17840], eax
	movsxd	rax, DWORD PTR which$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rcx+rax+17840], 3
	jle	SHORT $LN13@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN13@stbi__proc:

; 2698 : 		z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff", "Corrupt JPEG");

	mov	eax, DWORD PTR q$2[rsp]
	and	eax, 15
	movsxd	rcx, DWORD PTR which$1[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rdx+rcx+17844], eax
	movsxd	rax, DWORD PTR which$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rcx+rax+17844], 3
	jle	SHORT $LN14@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN14@stbi__proc:

; 2699 : 		z->order[i] = which;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR which$1[rsp]
	mov	DWORD PTR [rcx+rax*4+18252], edx

; 2700 : 	}

	jmp	$LN2@stbi__proc
$LN3@stbi__proc:

; 2701 : 
; 2702 : 	{
; 2703 : 		int aa;
; 2704 : 		z->spec_start = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+18228], eax

; 2705 : 		z->spec_end = stbi__get8(z->s); // should be 63, but might be 0

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+18232], eax

; 2706 : 		aa = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR aa$3[rsp], eax

; 2707 : 		z->succ_high = (aa >> 4);

	mov	eax, DWORD PTR aa$3[rsp]
	sar	eax, 4
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+18236], eax

; 2708 : 		z->succ_low = (aa & 15);

	mov	eax, DWORD PTR aa$3[rsp]
	and	eax, 15
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+18240], eax

; 2709 : 		if (z->progressive) {

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18224], 0
	je	SHORT $LN15@stbi__proc

; 2710 : 			if (z->spec_start > 63 || z->spec_end > 63 || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18228], 63		; 0000003fH
	jg	SHORT $LN18@stbi__proc
	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18232], 63		; 0000003fH
	jg	SHORT $LN18@stbi__proc
	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR [rcx+18232]
	cmp	DWORD PTR [rax+18228], ecx
	jg	SHORT $LN18@stbi__proc
	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18236], 13
	jg	SHORT $LN18@stbi__proc
	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18240], 13
	jle	SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 2711 : 				return stbi__err("bad SOS", "Corrupt JPEG");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__proc
$LN17@stbi__proc:

; 2712 : 		}

	jmp	SHORT $LN16@stbi__proc
$LN15@stbi__proc:

; 2713 : 		else {
; 2714 : 			if (z->spec_start != 0) return stbi__err("bad SOS", "Corrupt JPEG");

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18228], 0
	je	SHORT $LN19@stbi__proc
	xor	eax, eax
	jmp	SHORT $LN1@stbi__proc
$LN19@stbi__proc:

; 2715 : 			if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS", "Corrupt JPEG");

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18236], 0
	jne	SHORT $LN21@stbi__proc
	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18240], 0
	je	SHORT $LN20@stbi__proc
$LN21@stbi__proc:
	xor	eax, eax
	jmp	SHORT $LN1@stbi__proc
$LN20@stbi__proc:

; 2716 : 			z->spec_end = 63;

	mov	rax, QWORD PTR z$[rsp]
	mov	DWORD PTR [rax+18232], 63		; 0000003fH
$LN16@stbi__proc:

; 2717 : 		}
; 2718 : 	}
; 2719 : 
; 2720 : 	return 1;

	mov	eax, 1
$LN1@stbi__proc:

; 2721 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__process_scan_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
L$ = 32
i$1 = 36
tv134 = 40
th$2 = 44
tv64 = 48
i$3 = 52
n$4 = 56
tc$5 = 60
q$6 = 64
t$7 = 68
tv137 = 72
q$8 = 76
tv213 = 80
p$9 = 84
tv231 = 88
v$10 = 96
tv229 = 104
sizes$11 = 112
__$ArrayPad$ = 176
z$ = 208
m$ = 216
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__process_marker

; 2619 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2620 : 	int L;
; 2621 : 	switch (m) {

	mov	eax, DWORD PTR m$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 196		; 000000c4H
	je	$LN23@stbi__proc
	cmp	DWORD PTR tv64[rsp], 219		; 000000dbH
	je	SHORT $LN20@stbi__proc
	cmp	DWORD PTR tv64[rsp], 221		; 000000ddH
	je	SHORT $LN18@stbi__proc
	cmp	DWORD PTR tv64[rsp], 255		; 000000ffH
	je	SHORT $LN17@stbi__proc
	jmp	$LN2@stbi__proc
$LN17@stbi__proc:

; 2622 : 	case STBI__MARKER_none: // no marker found
; 2623 : 		return stbi__err("expected marker", "Corrupt JPEG");

	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN18@stbi__proc:

; 2624 : 
; 2625 : 	case 0xDD: // DRI - specify restart interval
; 2626 : 		if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len", "Corrupt JPEG");

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 4
	je	SHORT $LN19@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN19@stbi__proc:

; 2627 : 		z->restart_interval = stbi__get16be(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, QWORD PTR z$[rsp]
	mov	DWORD PTR [rcx+18268], eax

; 2628 : 		return 1;

	mov	eax, 1
	jmp	$LN1@stbi__proc
$LN20@stbi__proc:

; 2629 : 
; 2630 : 	case 0xDB: // DQT - define quantization table
; 2631 : 		L = stbi__get16be(z->s) - 2;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	sub	eax, 2
	mov	DWORD PTR L$[rsp], eax
$LN4@stbi__proc:

; 2632 : 		while (L > 0) {

	cmp	DWORD PTR L$[rsp], 0
	jle	$LN5@stbi__proc

; 2633 : 			int q = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR q$6[rsp], eax

; 2634 : 			int p = q >> 4;

	mov	eax, DWORD PTR q$6[rsp]
	sar	eax, 4
	mov	DWORD PTR p$9[rsp], eax

; 2635 : 			int t = q & 15, i;

	mov	eax, DWORD PTR q$6[rsp]
	and	eax, 15
	mov	DWORD PTR t$7[rsp], eax

; 2636 : 			if (p != 0) return stbi__err("bad DQT type", "Corrupt JPEG");

	cmp	DWORD PTR p$9[rsp], 0
	je	SHORT $LN21@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN21@stbi__proc:

; 2637 : 			if (t > 3) return stbi__err("bad DQT table", "Corrupt JPEG");

	cmp	DWORD PTR t$7[rsp], 3
	jle	SHORT $LN22@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN22@stbi__proc:

; 2638 : 			for (i = 0; i < 64; ++i)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN8@stbi__proc
$LN6@stbi__proc:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN8@stbi__proc:
	cmp	DWORD PTR i$3[rsp], 64			; 00000040H
	jge	SHORT $LN7@stbi__proc

; 2639 : 				z->dequant[t][stbi__jpeg_dezigzag[i]] = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR tv134[rsp], al
	movsxd	rax, DWORD PTR t$7[rsp]
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+13448]
	movsxd	rcx, DWORD PTR i$3[rsp]
	lea	rdx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3PAEA
	movzx	ecx, BYTE PTR [rdx+rcx]
	movzx	edx, BYTE PTR tv134[rsp]
	mov	BYTE PTR [rax+rcx], dl
	jmp	SHORT $LN6@stbi__proc
$LN7@stbi__proc:

; 2640 : 			L -= 65;

	mov	eax, DWORD PTR L$[rsp]
	sub	eax, 65					; 00000041H
	mov	DWORD PTR L$[rsp], eax

; 2641 : 		}

	jmp	$LN4@stbi__proc
$LN5@stbi__proc:

; 2642 : 		return L == 0;

	cmp	DWORD PTR L$[rsp], 0
	jne	SHORT $LN35@stbi__proc
	mov	DWORD PTR tv137[rsp], 1
	jmp	SHORT $LN36@stbi__proc
$LN35@stbi__proc:
	mov	DWORD PTR tv137[rsp], 0
$LN36@stbi__proc:
	mov	eax, DWORD PTR tv137[rsp]
	jmp	$LN1@stbi__proc
$LN23@stbi__proc:

; 2643 : 
; 2644 : 	case 0xC4: // DHT - define huffman table
; 2645 : 		L = stbi__get16be(z->s) - 2;

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	sub	eax, 2
	mov	DWORD PTR L$[rsp], eax
$LN9@stbi__proc:

; 2646 : 		while (L > 0) {

	cmp	DWORD PTR L$[rsp], 0
	jle	$LN10@stbi__proc

; 2647 : 			stbi_uc* v;
; 2648 : 			int sizes[16], i, n = 0;

	mov	DWORD PTR n$4[rsp], 0

; 2649 : 			int q = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR q$8[rsp], eax

; 2650 : 			int tc = q >> 4;

	mov	eax, DWORD PTR q$8[rsp]
	sar	eax, 4
	mov	DWORD PTR tc$5[rsp], eax

; 2651 : 			int th = q & 15;

	mov	eax, DWORD PTR q$8[rsp]
	and	eax, 15
	mov	DWORD PTR th$2[rsp], eax

; 2652 : 			if (tc > 1 || th > 3) return stbi__err("bad DHT header", "Corrupt JPEG");

	cmp	DWORD PTR tc$5[rsp], 1
	jg	SHORT $LN25@stbi__proc
	cmp	DWORD PTR th$2[rsp], 3
	jle	SHORT $LN24@stbi__proc
$LN25@stbi__proc:
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN24@stbi__proc:

; 2653 : 			for (i = 0; i < 16; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN13@stbi__proc
$LN11@stbi__proc:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN13@stbi__proc:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN12@stbi__proc

; 2654 : 				sizes[i] = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	DWORD PTR sizes$11[rsp+rcx*4], eax

; 2655 : 				n += sizes[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	eax, DWORD PTR sizes$11[rsp+rax*4]
	mov	ecx, DWORD PTR n$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$4[rsp], eax

; 2656 : 			}

	jmp	SHORT $LN11@stbi__proc
$LN12@stbi__proc:

; 2657 : 			L -= 17;

	mov	eax, DWORD PTR L$[rsp]
	sub	eax, 17
	mov	DWORD PTR L$[rsp], eax

; 2658 : 			if (tc == 0) {

	cmp	DWORD PTR tc$5[rsp], 0
	jne	SHORT $LN26@stbi__proc

; 2659 : 				if (!stbi__build_huffman(z->huff_dc + th, sizes)) return 0;

	movsxd	rax, DWORD PTR th$2[rsp]
	imul	rax, rax, 1680				; 00000690H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	lea	rdx, QWORD PTR sizes$11[rsp]
	mov	rcx, rax
	call	?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
	test	eax, eax
	jne	SHORT $LN28@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN28@stbi__proc:

; 2660 : 				v = z->huff_dc[th].values;

	movsxd	rax, DWORD PTR th$2[rsp]
	imul	rax, rax, 1680				; 00000690H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1032]
	mov	QWORD PTR v$10[rsp], rax

; 2661 : 			}

	jmp	SHORT $LN27@stbi__proc
$LN26@stbi__proc:

; 2662 : 			else {
; 2663 : 				if (!stbi__build_huffman(z->huff_ac + th, sizes)) return 0;

	movsxd	rax, DWORD PTR th$2[rsp]
	imul	rax, rax, 1680				; 00000690H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+6728]
	lea	rdx, QWORD PTR sizes$11[rsp]
	mov	rcx, rax
	call	?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
	test	eax, eax
	jne	SHORT $LN29@stbi__proc
	xor	eax, eax
	jmp	$LN1@stbi__proc
$LN29@stbi__proc:

; 2664 : 				v = z->huff_ac[th].values;

	movsxd	rax, DWORD PTR th$2[rsp]
	imul	rax, rax, 1680				; 00000690H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+7752]
	mov	QWORD PTR v$10[rsp], rax
$LN27@stbi__proc:

; 2665 : 			}
; 2666 : 			for (i = 0; i < n; ++i)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN16@stbi__proc
$LN14@stbi__proc:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN16@stbi__proc:
	mov	eax, DWORD PTR n$4[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN15@stbi__proc

; 2667 : 				v[i] = stbi__get8(z->s);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR v$10[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN14@stbi__proc
$LN15@stbi__proc:

; 2668 : 			if (tc != 0)

	cmp	DWORD PTR tc$5[rsp], 0
	je	SHORT $LN30@stbi__proc

; 2669 : 				stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

	movsxd	rax, DWORD PTR th$2[rsp]
	imul	rax, rax, 1680				; 00000690H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+6728]
	movsxd	rcx, DWORD PTR th$2[rsp]
	imul	rcx, rcx, 1024				; 00000400H
	mov	rdx, QWORD PTR z$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+13704]
	mov	rdx, rax
	call	?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z ; stbi__build_fast_ac
	npad	1
$LN30@stbi__proc:

; 2670 : 			L -= n;

	mov	eax, DWORD PTR n$4[rsp]
	mov	ecx, DWORD PTR L$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR L$[rsp], eax

; 2671 : 		}

	jmp	$LN9@stbi__proc
$LN10@stbi__proc:

; 2672 : 		return L == 0;

	cmp	DWORD PTR L$[rsp], 0
	jne	SHORT $LN37@stbi__proc
	mov	DWORD PTR tv213[rsp], 1
	jmp	SHORT $LN38@stbi__proc
$LN37@stbi__proc:
	mov	DWORD PTR tv213[rsp], 0
$LN38@stbi__proc:
	mov	eax, DWORD PTR tv213[rsp]
	jmp	SHORT $LN1@stbi__proc
$LN2@stbi__proc:

; 2673 : 	}
; 2674 : 	// check for comment block or APP blocks
; 2675 : 	if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

	cmp	DWORD PTR m$[rsp], 224			; 000000e0H
	jl	SHORT $LN33@stbi__proc
	cmp	DWORD PTR m$[rsp], 239			; 000000efH
	jle	SHORT $LN32@stbi__proc
$LN33@stbi__proc:
	cmp	DWORD PTR m$[rsp], 254			; 000000feH
	jne	SHORT $LN31@stbi__proc
$LN32@stbi__proc:

; 2676 : 		stbi__skip(z->s, stbi__get16be(z->s) - 2);

	mov	rax, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	sub	eax, 2
	mov	DWORD PTR tv231[rsp], eax
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv229[rsp], rax
	mov	edx, DWORD PTR tv231[rsp]
	mov	rcx, QWORD PTR tv229[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 2677 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__proc
$LN31@stbi__proc:

; 2678 : 	}
; 2679 : 	return 0;

	xor	eax, eax
$LN1@stbi__proc:

; 2680 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	ret	0
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__process_marker
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
n$1 = 32
j$2 = 36
i$3 = 40
h$4 = 44
w$5 = 48
data$6 = 56
tv174 = 64
z$ = 96
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_finish

; 2600 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2601 : 	if (z->progressive) {

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18224], 0
	je	$LN11@stbi__jpeg

; 2602 : 		// dequantize and idct the data
; 2603 : 		int i, j, n;
; 2604 : 		for (n = 0; n < z->s->img_n; ++n) {

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN4@stbi__jpeg:
	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR n$1[rsp], eax
	jge	$LN3@stbi__jpeg

; 2605 : 			int w = (z->img_comp[n].x + 7) >> 3;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17852]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR w$5[rsp], eax

; 2606 : 			int h = (z->img_comp[n].y + 7) >> 3;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17856]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR h$4[rsp], eax

; 2607 : 			for (j = 0; j < h; ++j) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN7@stbi__jpeg:
	mov	eax, DWORD PTR h$4[rsp]
	cmp	DWORD PTR j$2[rsp], eax
	jge	$LN6@stbi__jpeg

; 2608 : 				for (i = 0; i < w; ++i) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN10@stbi__jpeg
$LN8@stbi__jpeg:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN10@stbi__jpeg:
	mov	eax, DWORD PTR w$5[rsp]
	cmp	DWORD PTR i$3[rsp], eax
	jge	$LN9@stbi__jpeg

; 2609 : 					short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR n$1[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	r8d, DWORD PTR j$2[rsp]
	imul	r8d, DWORD PTR [rdx+rcx+17912]
	mov	ecx, r8d
	mov	edx, DWORD PTR i$3[rsp]
	add	edx, ecx
	mov	ecx, edx
	imul	ecx, ecx, 64				; 00000040H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rdx+rax+17904]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR data$6[rsp], rax

; 2610 : 					stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+17836]
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+13448]
	mov	rdx, rax
	mov	rcx, QWORD PTR data$6[rsp]
	call	?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z	; stbi__jpeg_dequantize

; 2611 : 					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax+18280]
	mov	QWORD PTR tv174[rsp], rax
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR n$1[rsp]
	imul	rcx, rcx, 96				; 00000060H
	movsxd	rdx, DWORD PTR n$1[rsp]
	imul	rdx, rdx, 96				; 00000060H
	mov	r8, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR [r8+rdx+17860]
	imul	edx, DWORD PTR j$2[rsp]
	shl	edx, 3
	movsxd	rdx, edx
	mov	r8, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+17872]
	add	rcx, rdx
	mov	edx, DWORD PTR i$3[rsp]
	shl	edx, 3
	movsxd	rdx, edx
	add	rcx, rdx
	mov	r8, QWORD PTR data$6[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR [rdx+rax+17860]
	call	QWORD PTR tv174[rsp]
	npad	1

; 2612 : 				}

	jmp	$LN8@stbi__jpeg
$LN9@stbi__jpeg:

; 2613 : 			}

	jmp	$LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 2614 : 		}

	jmp	$LN2@stbi__jpeg
$LN3@stbi__jpeg:
$LN11@stbi__jpeg:

; 2615 : 	}
; 2616 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_finish
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 0
data$ = 32
dequant$ = 40
?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z PROC		; stbi__jpeg_dequantize

; 2593 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2594 : 	int i;
; 2595 : 	for (i = 0; i < 64; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__jpeg:
	cmp	DWORD PTR i$[rsp], 64			; 00000040H
	jge	SHORT $LN3@stbi__jpeg

; 2596 : 		data[i] *= dequant[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dequant$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	movsx	ecx, WORD PTR [rdx+rcx*2]
	imul	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax
	jmp	SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 2597 : }

	add	rsp, 24
	ret	0
?stbi__jpeg_dequantize@@YAXPEAFPEAE@Z ENDP		; stbi__jpeg_dequantize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
n$1 = 64
n$2 = 68
n$3 = 72
n$4 = 76
j$5 = 80
i$6 = 84
k$7 = 88
i$8 = 92
x$9 = 96
j$10 = 100
y$11 = 104
j$12 = 108
i$13 = 112
k$14 = 116
i$15 = 120
x$16 = 124
j$17 = 128
y$18 = 132
ha$19 = 136
tv192 = 140
ha$20 = 144
tv315 = 148
ha$21 = 152
tv404 = 156
tv522 = 160
h$22 = 164
w$23 = 168
y2$24 = 172
x2$25 = 176
h$26 = 180
w$27 = 184
y2$28 = 188
x2$29 = 192
data$30 = 200
tv189 = 208
tv312 = 216
data$31 = 224
data$32 = 240
data$33 = 368
__$ArrayPad$ = 496
z$ = 528
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z PROC ; stbi__parse_entropy_coded_data

; 2465 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 520				; 00000208H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2466 : 	stbi__jpeg_reset(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
	npad	1

; 2467 : 	if (!z->progressive) {

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18224], 0
	jne	$LN44@stbi__pars

; 2468 : 		if (z->scan_n == 1) {

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18248], 1
	jne	$LN46@stbi__pars

; 2469 : 			int i, j;
; 2470 : 			STBI_SIMD_ALIGN(short, data[64]);
; 2471 : 			int n = z->order[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+18252]
	mov	DWORD PTR n$2[rsp], eax

; 2472 : 			// non-interleaved data, we just need to process one block at a time,
; 2473 : 			// in trivial scanline order
; 2474 : 			// number of blocks to do just depends on how many actual "pixels" this
; 2475 : 			// component has, independent of interleaved MCU blocking and such
; 2476 : 			int w = (z->img_comp[n].x + 7) >> 3;

	movsxd	rax, DWORD PTR n$2[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17852]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR w$23[rsp], eax

; 2477 : 			int h = (z->img_comp[n].y + 7) >> 3;

	movsxd	rax, DWORD PTR n$2[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17856]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR h$22[rsp], eax

; 2478 : 			for (j = 0; j < h; ++j) {

	mov	DWORD PTR j$5[rsp], 0
	jmp	SHORT $LN4@stbi__pars
$LN2@stbi__pars:
	mov	eax, DWORD PTR j$5[rsp]
	inc	eax
	mov	DWORD PTR j$5[rsp], eax
$LN4@stbi__pars:
	mov	eax, DWORD PTR h$22[rsp]
	cmp	DWORD PTR j$5[rsp], eax
	jge	$LN3@stbi__pars

; 2479 : 				for (i = 0; i < w; ++i) {

	mov	DWORD PTR i$6[rsp], 0
	jmp	SHORT $LN7@stbi__pars
$LN5@stbi__pars:
	mov	eax, DWORD PTR i$6[rsp]
	inc	eax
	mov	DWORD PTR i$6[rsp], eax
$LN7@stbi__pars:
	mov	eax, DWORD PTR w$23[rsp]
	cmp	DWORD PTR i$6[rsp], eax
	jge	$LN6@stbi__pars

; 2480 : 					int ha = z->img_comp[n].ha;

	movsxd	rax, DWORD PTR n$2[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17844]
	mov	DWORD PTR ha$19[rsp], eax

; 2481 : 					if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	movsxd	rax, DWORD PTR n$2[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+17836]
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+13448]
	movsxd	rcx, DWORD PTR ha$19[rsp]
	imul	rcx, rcx, 1024				; 00000400H
	mov	rdx, QWORD PTR z$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+13704]
	movsxd	rdx, DWORD PTR ha$19[rsp]
	imul	rdx, rdx, 1680				; 00000690H
	mov	r8, QWORD PTR z$[rsp]
	lea	rdx, QWORD PTR [r8+rdx+6728]
	movsxd	r8, DWORD PTR n$2[rsp]
	imul	r8, r8, 96				; 00000060H
	mov	r9, QWORD PTR z$[rsp]
	movsxd	r8, DWORD PTR [r9+r8+17840]
	imul	r8, r8, 1680				; 00000690H
	mov	r9, QWORD PTR z$[rsp]
	lea	r8, QWORD PTR [r9+r8+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR n$2[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rdx
	lea	rdx, QWORD PTR data$32[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z ; stbi__jpeg_decode_block
	test	eax, eax
	jne	SHORT $LN48@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN48@stbi__pars:

; 2482 : 					z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * j * 8 + i * 8, z->img_comp[n].w2, data);

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax+18280]
	mov	QWORD PTR tv189[rsp], rax
	movsxd	rax, DWORD PTR n$2[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR n$2[rsp]
	imul	rcx, rcx, 96				; 00000060H
	movsxd	rdx, DWORD PTR n$2[rsp]
	imul	rdx, rdx, 96				; 00000060H
	mov	r8, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR [r8+rdx+17860]
	imul	edx, DWORD PTR j$5[rsp]
	shl	edx, 3
	movsxd	rdx, edx
	mov	r8, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+17872]
	add	rcx, rdx
	mov	edx, DWORD PTR i$6[rsp]
	shl	edx, 3
	movsxd	rdx, edx
	add	rcx, rdx
	lea	r8, QWORD PTR data$32[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR [rdx+rax+17860]
	call	QWORD PTR tv189[rsp]
	npad	1

; 2483 : 					// every data block is an MCU, so countdown the restart interval
; 2484 : 					if (--z->todo <= 0) {

	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18272]
	dec	eax
	mov	DWORD PTR tv192[rsp], eax
	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR tv192[rsp]
	mov	DWORD PTR [rax+18272], ecx
	cmp	DWORD PTR tv192[rsp], 0
	jg	SHORT $LN49@stbi__pars

; 2485 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18212], 24
	jge	SHORT $LN50@stbi__pars
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN50@stbi__pars:

; 2486 : 						// if it's NOT a restart, then just bail, so we get corrupt data
; 2487 : 						// rather than no data
; 2488 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 208				; 000000d0H
	jl	SHORT $LN52@stbi__pars
	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 215				; 000000d7H
	jle	SHORT $LN51@stbi__pars
$LN52@stbi__pars:
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN51@stbi__pars:

; 2489 : 						stbi__jpeg_reset(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
	npad	1
$LN49@stbi__pars:

; 2490 : 					}
; 2491 : 				}

	jmp	$LN5@stbi__pars
$LN6@stbi__pars:

; 2492 : 			}

	jmp	$LN2@stbi__pars
$LN3@stbi__pars:

; 2493 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars

; 2494 : 		}

	jmp	$LN47@stbi__pars
$LN46@stbi__pars:

; 2495 : 		else { // interleaved
; 2496 : 			int i, j, k, x, y;
; 2497 : 			STBI_SIMD_ALIGN(short, data[64]);
; 2498 : 			for (j = 0; j < z->img_mcu_y; ++j) {

	mov	DWORD PTR j$10[rsp], 0
	jmp	SHORT $LN10@stbi__pars
$LN8@stbi__pars:
	mov	eax, DWORD PTR j$10[rsp]
	inc	eax
	mov	DWORD PTR j$10[rsp], eax
$LN10@stbi__pars:
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+17812]
	cmp	DWORD PTR j$10[rsp], eax
	jge	$LN9@stbi__pars

; 2499 : 				for (i = 0; i < z->img_mcu_x; ++i) {

	mov	DWORD PTR i$8[rsp], 0
	jmp	SHORT $LN13@stbi__pars
$LN11@stbi__pars:
	mov	eax, DWORD PTR i$8[rsp]
	inc	eax
	mov	DWORD PTR i$8[rsp], eax
$LN13@stbi__pars:
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+17808]
	cmp	DWORD PTR i$8[rsp], eax
	jge	$LN12@stbi__pars

; 2500 : 					// scan an interleaved mcu... process scan_n components in order
; 2501 : 					for (k = 0; k < z->scan_n; ++k) {

	mov	DWORD PTR k$7[rsp], 0
	jmp	SHORT $LN16@stbi__pars
$LN14@stbi__pars:
	mov	eax, DWORD PTR k$7[rsp]
	inc	eax
	mov	DWORD PTR k$7[rsp], eax
$LN16@stbi__pars:
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18248]
	cmp	DWORD PTR k$7[rsp], eax
	jge	$LN15@stbi__pars

; 2502 : 						int n = z->order[k];

	movsxd	rax, DWORD PTR k$7[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+18252]
	mov	DWORD PTR n$1[rsp], eax

; 2503 : 						// scan out an mcu's worth of this component; that's just determined
; 2504 : 						// by the basic H and V specified for the component
; 2505 : 						for (y = 0; y < z->img_comp[n].v; ++y) {

	mov	DWORD PTR y$11[rsp], 0
	jmp	SHORT $LN19@stbi__pars
$LN17@stbi__pars:
	mov	eax, DWORD PTR y$11[rsp]
	inc	eax
	mov	DWORD PTR y$11[rsp], eax
$LN19@stbi__pars:
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17832]
	cmp	DWORD PTR y$11[rsp], eax
	jge	$LN18@stbi__pars

; 2506 : 							for (x = 0; x < z->img_comp[n].h; ++x) {

	mov	DWORD PTR x$9[rsp], 0
	jmp	SHORT $LN22@stbi__pars
$LN20@stbi__pars:
	mov	eax, DWORD PTR x$9[rsp]
	inc	eax
	mov	DWORD PTR x$9[rsp], eax
$LN22@stbi__pars:
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17828]
	cmp	DWORD PTR x$9[rsp], eax
	jge	$LN21@stbi__pars

; 2507 : 								int x2 = (i * z->img_comp[n].h + x) * 8;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR i$8[rsp]
	imul	edx, DWORD PTR [rcx+rax+17828]
	mov	eax, edx
	add	eax, DWORD PTR x$9[rsp]
	shl	eax, 3
	mov	DWORD PTR x2$25[rsp], eax

; 2508 : 								int y2 = (j * z->img_comp[n].v + y) * 8;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR j$10[rsp]
	imul	edx, DWORD PTR [rcx+rax+17832]
	mov	eax, edx
	add	eax, DWORD PTR y$11[rsp]
	shl	eax, 3
	mov	DWORD PTR y2$24[rsp], eax

; 2509 : 								int ha = z->img_comp[n].ha;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17844]
	mov	DWORD PTR ha$20[rsp], eax

; 2510 : 								if (!stbi__jpeg_decode_block(z, data, z->huff_dc + z->img_comp[n].hd, z->huff_ac + ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+17836]
	imul	rax, rax, 64				; 00000040H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+13448]
	movsxd	rcx, DWORD PTR ha$20[rsp]
	imul	rcx, rcx, 1024				; 00000400H
	mov	rdx, QWORD PTR z$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+13704]
	movsxd	rdx, DWORD PTR ha$20[rsp]
	imul	rdx, rdx, 1680				; 00000690H
	mov	r8, QWORD PTR z$[rsp]
	lea	rdx, QWORD PTR [r8+rdx+6728]
	movsxd	r8, DWORD PTR n$1[rsp]
	imul	r8, r8, 96				; 00000060H
	mov	r9, QWORD PTR z$[rsp]
	movsxd	r8, DWORD PTR [r9+r8+17840]
	imul	r8, r8, 1680				; 00000690H
	mov	r9, QWORD PTR z$[rsp]
	lea	r8, QWORD PTR [r9+r8+8]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR n$1[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rdx
	lea	rdx, QWORD PTR data$33[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z ; stbi__jpeg_decode_block
	test	eax, eax
	jne	SHORT $LN53@stbi__pars
	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN53@stbi__pars:

; 2511 : 								z->idct_block_kernel(z->img_comp[n].data + z->img_comp[n].w2 * y2 + x2, z->img_comp[n].w2, data);

	mov	rax, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rax+18280]
	mov	QWORD PTR tv312[rsp], rax
	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR n$1[rsp]
	imul	rcx, rcx, 96				; 00000060H
	movsxd	rdx, DWORD PTR n$1[rsp]
	imul	rdx, rdx, 96				; 00000060H
	mov	r8, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR [r8+rdx+17860]
	imul	edx, DWORD PTR y2$24[rsp]
	movsxd	rdx, edx
	mov	r8, QWORD PTR z$[rsp]
	mov	rcx, QWORD PTR [r8+rcx+17872]
	add	rcx, rdx
	movsxd	rdx, DWORD PTR x2$25[rsp]
	add	rcx, rdx
	lea	r8, QWORD PTR data$33[rsp]
	mov	rdx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR [rdx+rax+17860]
	call	QWORD PTR tv312[rsp]
	npad	1

; 2512 : 							}

	jmp	$LN20@stbi__pars
$LN21@stbi__pars:

; 2513 : 						}

	jmp	$LN17@stbi__pars
$LN18@stbi__pars:

; 2514 : 					}

	jmp	$LN14@stbi__pars
$LN15@stbi__pars:

; 2515 : 					// after all interleaved components, that's an interleaved MCU,
; 2516 : 					// so now count down the restart interval
; 2517 : 					if (--z->todo <= 0) {

	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18272]
	dec	eax
	mov	DWORD PTR tv315[rsp], eax
	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR tv315[rsp]
	mov	DWORD PTR [rax+18272], ecx
	cmp	DWORD PTR tv315[rsp], 0
	jg	SHORT $LN54@stbi__pars

; 2518 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18212], 24
	jge	SHORT $LN55@stbi__pars
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN55@stbi__pars:

; 2519 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 208				; 000000d0H
	jl	SHORT $LN57@stbi__pars
	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 215				; 000000d7H
	jle	SHORT $LN56@stbi__pars
$LN57@stbi__pars:
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN56@stbi__pars:

; 2520 : 						stbi__jpeg_reset(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
	npad	1
$LN54@stbi__pars:

; 2521 : 					}
; 2522 : 				}

	jmp	$LN11@stbi__pars
$LN12@stbi__pars:

; 2523 : 			}

	jmp	$LN8@stbi__pars
$LN9@stbi__pars:

; 2524 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN47@stbi__pars:

; 2525 : 		}
; 2526 : 	}

	jmp	$LN45@stbi__pars
$LN44@stbi__pars:

; 2527 : 	else {
; 2528 : 		if (z->scan_n == 1) {

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18248], 1
	jne	$LN58@stbi__pars

; 2529 : 			int i, j;
; 2530 : 			int n = z->order[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+18252]
	mov	DWORD PTR n$4[rsp], eax

; 2531 : 			// non-interleaved data, we just need to process one block at a time,
; 2532 : 			// in trivial scanline order
; 2533 : 			// number of blocks to do just depends on how many actual "pixels" this
; 2534 : 			// component has, independent of interleaved MCU blocking and such
; 2535 : 			int w = (z->img_comp[n].x + 7) >> 3;

	movsxd	rax, DWORD PTR n$4[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17852]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR w$27[rsp], eax

; 2536 : 			int h = (z->img_comp[n].y + 7) >> 3;

	movsxd	rax, DWORD PTR n$4[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17856]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR h$26[rsp], eax

; 2537 : 			for (j = 0; j < h; ++j) {

	mov	DWORD PTR j$12[rsp], 0
	jmp	SHORT $LN25@stbi__pars
$LN23@stbi__pars:
	mov	eax, DWORD PTR j$12[rsp]
	inc	eax
	mov	DWORD PTR j$12[rsp], eax
$LN25@stbi__pars:
	mov	eax, DWORD PTR h$26[rsp]
	cmp	DWORD PTR j$12[rsp], eax
	jge	$LN24@stbi__pars

; 2538 : 				for (i = 0; i < w; ++i) {

	mov	DWORD PTR i$13[rsp], 0
	jmp	SHORT $LN28@stbi__pars
$LN26@stbi__pars:
	mov	eax, DWORD PTR i$13[rsp]
	inc	eax
	mov	DWORD PTR i$13[rsp], eax
$LN28@stbi__pars:
	mov	eax, DWORD PTR w$27[rsp]
	cmp	DWORD PTR i$13[rsp], eax
	jge	$LN27@stbi__pars

; 2539 : 					short* data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

	movsxd	rax, DWORD PTR n$4[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR n$4[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	r8d, DWORD PTR j$12[rsp]
	imul	r8d, DWORD PTR [rdx+rcx+17912]
	mov	ecx, r8d
	mov	edx, DWORD PTR i$13[rsp]
	add	edx, ecx
	mov	ecx, edx
	imul	ecx, ecx, 64				; 00000040H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rdx+rax+17904]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR data$30[rsp], rax

; 2540 : 					if (z->spec_start == 0) {

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18228], 0
	jne	SHORT $LN60@stbi__pars

; 2541 : 						if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	movsxd	rax, DWORD PTR n$4[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+17840]
	imul	rax, rax, 1680				; 00000690H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	r9d, DWORD PTR n$4[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR data$30[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
	test	eax, eax
	jne	SHORT $LN62@stbi__pars

; 2542 : 							return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN62@stbi__pars:

; 2543 : 					}

	jmp	$LN61@stbi__pars
$LN60@stbi__pars:

; 2544 : 					else {
; 2545 : 						int ha = z->img_comp[n].ha;

	movsxd	rax, DWORD PTR n$4[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17844]
	mov	DWORD PTR ha$21[rsp], eax

; 2546 : 						if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

	movsxd	rax, DWORD PTR ha$21[rsp]
	imul	rax, rax, 1024				; 00000400H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+13704]
	movsxd	rcx, DWORD PTR ha$21[rsp]
	imul	rcx, rcx, 1680				; 00000690H
	mov	rdx, QWORD PTR z$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx+6728]
	mov	r9, rax
	mov	r8, rcx
	mov	rdx, QWORD PTR data$30[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ; stbi__jpeg_decode_block_prog_ac
	test	eax, eax
	jne	SHORT $LN63@stbi__pars

; 2547 : 							return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN63@stbi__pars:
$LN61@stbi__pars:

; 2548 : 					}
; 2549 : 					// every data block is an MCU, so countdown the restart interval
; 2550 : 					if (--z->todo <= 0) {

	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18272]
	dec	eax
	mov	DWORD PTR tv404[rsp], eax
	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR tv404[rsp]
	mov	DWORD PTR [rax+18272], ecx
	cmp	DWORD PTR tv404[rsp], 0
	jg	SHORT $LN64@stbi__pars

; 2551 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18212], 24
	jge	SHORT $LN65@stbi__pars
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN65@stbi__pars:

; 2552 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 208				; 000000d0H
	jl	SHORT $LN67@stbi__pars
	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 215				; 000000d7H
	jle	SHORT $LN66@stbi__pars
$LN67@stbi__pars:
	mov	eax, 1
	jmp	$LN1@stbi__pars
$LN66@stbi__pars:

; 2553 : 						stbi__jpeg_reset(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
	npad	1
$LN64@stbi__pars:

; 2554 : 					}
; 2555 : 				}

	jmp	$LN26@stbi__pars
$LN27@stbi__pars:

; 2556 : 			}

	jmp	$LN23@stbi__pars
$LN24@stbi__pars:

; 2557 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__pars

; 2558 : 		}

	jmp	$LN59@stbi__pars
$LN58@stbi__pars:

; 2559 : 		else { // interleaved
; 2560 : 			int i, j, k, x, y;
; 2561 : 			for (j = 0; j < z->img_mcu_y; ++j) {

	mov	DWORD PTR j$17[rsp], 0
	jmp	SHORT $LN31@stbi__pars
$LN29@stbi__pars:
	mov	eax, DWORD PTR j$17[rsp]
	inc	eax
	mov	DWORD PTR j$17[rsp], eax
$LN31@stbi__pars:
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+17812]
	cmp	DWORD PTR j$17[rsp], eax
	jge	$LN30@stbi__pars

; 2562 : 				for (i = 0; i < z->img_mcu_x; ++i) {

	mov	DWORD PTR i$15[rsp], 0
	jmp	SHORT $LN34@stbi__pars
$LN32@stbi__pars:
	mov	eax, DWORD PTR i$15[rsp]
	inc	eax
	mov	DWORD PTR i$15[rsp], eax
$LN34@stbi__pars:
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+17808]
	cmp	DWORD PTR i$15[rsp], eax
	jge	$LN33@stbi__pars

; 2563 : 					// scan an interleaved mcu... process scan_n components in order
; 2564 : 					for (k = 0; k < z->scan_n; ++k) {

	mov	DWORD PTR k$14[rsp], 0
	jmp	SHORT $LN37@stbi__pars
$LN35@stbi__pars:
	mov	eax, DWORD PTR k$14[rsp]
	inc	eax
	mov	DWORD PTR k$14[rsp], eax
$LN37@stbi__pars:
	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18248]
	cmp	DWORD PTR k$14[rsp], eax
	jge	$LN36@stbi__pars

; 2565 : 						int n = z->order[k];

	movsxd	rax, DWORD PTR k$14[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+18252]
	mov	DWORD PTR n$3[rsp], eax

; 2566 : 						// scan out an mcu's worth of this component; that's just determined
; 2567 : 						// by the basic H and V specified for the component
; 2568 : 						for (y = 0; y < z->img_comp[n].v; ++y) {

	mov	DWORD PTR y$18[rsp], 0
	jmp	SHORT $LN40@stbi__pars
$LN38@stbi__pars:
	mov	eax, DWORD PTR y$18[rsp]
	inc	eax
	mov	DWORD PTR y$18[rsp], eax
$LN40@stbi__pars:
	movsxd	rax, DWORD PTR n$3[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17832]
	cmp	DWORD PTR y$18[rsp], eax
	jge	$LN39@stbi__pars

; 2569 : 							for (x = 0; x < z->img_comp[n].h; ++x) {

	mov	DWORD PTR x$16[rsp], 0
	jmp	SHORT $LN43@stbi__pars
$LN41@stbi__pars:
	mov	eax, DWORD PTR x$16[rsp]
	inc	eax
	mov	DWORD PTR x$16[rsp], eax
$LN43@stbi__pars:
	movsxd	rax, DWORD PTR n$3[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17828]
	cmp	DWORD PTR x$16[rsp], eax
	jge	$LN42@stbi__pars

; 2570 : 								int x2 = (i * z->img_comp[n].h + x);

	movsxd	rax, DWORD PTR n$3[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR i$15[rsp]
	imul	edx, DWORD PTR [rcx+rax+17828]
	mov	eax, edx
	add	eax, DWORD PTR x$16[rsp]
	mov	DWORD PTR x2$29[rsp], eax

; 2571 : 								int y2 = (j * z->img_comp[n].v + y);

	movsxd	rax, DWORD PTR n$3[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	mov	edx, DWORD PTR j$17[rsp]
	imul	edx, DWORD PTR [rcx+rax+17832]
	mov	eax, edx
	add	eax, DWORD PTR y$18[rsp]
	mov	DWORD PTR y2$28[rsp], eax

; 2572 : 								short* data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

	movsxd	rax, DWORD PTR n$3[rsp]
	imul	rax, rax, 96				; 00000060H
	movsxd	rcx, DWORD PTR n$3[rsp]
	imul	rcx, rcx, 96				; 00000060H
	mov	rdx, QWORD PTR z$[rsp]
	mov	r8d, DWORD PTR y2$28[rsp]
	imul	r8d, DWORD PTR [rdx+rcx+17912]
	mov	ecx, r8d
	mov	edx, DWORD PTR x2$29[rsp]
	add	edx, ecx
	mov	ecx, edx
	imul	ecx, ecx, 64				; 00000040H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR z$[rsp]
	mov	rax, QWORD PTR [rdx+rax+17904]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR data$31[rsp], rax

; 2573 : 								if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

	movsxd	rax, DWORD PTR n$3[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR z$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+17840]
	imul	rax, rax, 1680				; 00000690H
	mov	rcx, QWORD PTR z$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	mov	r9d, DWORD PTR n$3[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR data$31[rsp]
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
	test	eax, eax
	jne	SHORT $LN68@stbi__pars

; 2574 : 									return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pars
$LN68@stbi__pars:

; 2575 : 							}

	jmp	$LN41@stbi__pars
$LN42@stbi__pars:

; 2576 : 						}

	jmp	$LN38@stbi__pars
$LN39@stbi__pars:

; 2577 : 					}

	jmp	$LN35@stbi__pars
$LN36@stbi__pars:

; 2578 : 					// after all interleaved components, that's an interleaved MCU,
; 2579 : 					// so now count down the restart interval
; 2580 : 					if (--z->todo <= 0) {

	mov	rax, QWORD PTR z$[rsp]
	mov	eax, DWORD PTR [rax+18272]
	dec	eax
	mov	DWORD PTR tv522[rsp], eax
	mov	rax, QWORD PTR z$[rsp]
	mov	ecx, DWORD PTR tv522[rsp]
	mov	DWORD PTR [rax+18272], ecx
	cmp	DWORD PTR tv522[rsp], 0
	jg	SHORT $LN69@stbi__pars

; 2581 : 						if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

	mov	rax, QWORD PTR z$[rsp]
	cmp	DWORD PTR [rax+18212], 24
	jge	SHORT $LN70@stbi__pars
	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN70@stbi__pars:

; 2582 : 						if (!STBI__RESTART(z->marker)) return 1;

	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 208				; 000000d0H
	jl	SHORT $LN72@stbi__pars
	mov	rax, QWORD PTR z$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 215				; 000000d7H
	jle	SHORT $LN71@stbi__pars
$LN72@stbi__pars:
	mov	eax, 1
	jmp	SHORT $LN1@stbi__pars
$LN71@stbi__pars:

; 2583 : 						stbi__jpeg_reset(z);

	mov	rcx, QWORD PTR z$[rsp]
	call	?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
	npad	1
$LN69@stbi__pars:

; 2584 : 					}
; 2585 : 				}

	jmp	$LN32@stbi__pars
$LN33@stbi__pars:

; 2586 : 			}

	jmp	$LN29@stbi__pars
$LN30@stbi__pars:

; 2587 : 			return 1;

	mov	eax, 1
$LN59@stbi__pars:
$LN45@stbi__pars:
$LN1@stbi__pars:

; 2588 : 		}
; 2589 : 	}
; 2590 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 520				; 00000208H
	ret	0
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ENDP ; stbi__parse_entropy_coded_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv84 = 0
j$ = 32
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_reset

; 2452 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2453 : 	j->code_bits = 0;

	mov	rax, QWORD PTR j$[rsp]
	mov	DWORD PTR [rax+18212], 0

; 2454 : 	j->code_buffer = 0;

	mov	rax, QWORD PTR j$[rsp]
	mov	DWORD PTR [rax+18208], 0

; 2455 : 	j->nomore = 0;

	mov	rax, QWORD PTR j$[rsp]
	mov	DWORD PTR [rax+18220], 0

; 2456 : 	j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;

	mov	eax, 96					; 00000060H
	imul	rax, rax, 2
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+rax+17848], 0
	mov	eax, 96					; 00000060H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+rax+17848], 0
	mov	eax, 96					; 00000060H
	imul	rax, rax, 0
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+rax+17848], 0

; 2457 : 	j->marker = STBI__MARKER_none;

	mov	rax, QWORD PTR j$[rsp]
	mov	BYTE PTR [rax+18216], 255		; 000000ffH

; 2458 : 	j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18268], 0
	je	SHORT $LN3@stbi__jpeg
	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18268]
	mov	DWORD PTR tv84[rsp], eax
	jmp	SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:
	mov	DWORD PTR tv84[rsp], 2147483647		; 7fffffffH
$LN4@stbi__jpeg:
	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR tv84[rsp]
	mov	DWORD PTR [rax+18272], ecx

; 2459 : 	j->eob_run = 0;

	mov	rax, QWORD PTR j$[rsp]
	mov	DWORD PTR [rax+18244], 0

; 2460 : 	// no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2461 : 	// since we don't even allow 1<<30 pixels
; 2462 : }

	add	rsp, 24
	ret	0
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
x$ = 32
j$ = 64
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z PROC		; stbi__get_marker

; 2435 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2436 : 	stbi_uc x;
; 2437 : 	if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

	mov	rax, QWORD PTR j$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN4@stbi__get_
	mov	rax, QWORD PTR j$[rsp]
	movzx	eax, BYTE PTR [rax+18216]
	mov	BYTE PTR x$[rsp], al
	mov	rax, QWORD PTR j$[rsp]
	mov	BYTE PTR [rax+18216], 255		; 000000ffH
	movzx	eax, BYTE PTR x$[rsp]
	jmp	SHORT $LN1@stbi__get_
$LN4@stbi__get_:

; 2438 : 	x = stbi__get8(j->s);

	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR x$[rsp], al

; 2439 : 	if (x != 0xff) return STBI__MARKER_none;

	movzx	eax, BYTE PTR x$[rsp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN5@stbi__get_
	mov	al, 255					; 000000ffH
	jmp	SHORT $LN1@stbi__get_
$LN5@stbi__get_:
$LN2@stbi__get_:

; 2440 : 	while (x == 0xff)

	movzx	eax, BYTE PTR x$[rsp]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN3@stbi__get_

; 2441 : 		x = stbi__get8(j->s);

	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR x$[rsp], al
	jmp	SHORT $LN2@stbi__get_
$LN3@stbi__get_:

; 2442 : 	return x;

	movzx	eax, BYTE PTR x$[rsp]
$LN1@stbi__get_:

; 2443 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ENDP		; stbi__get_marker
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
v$ = 32
p3$1 = 40
t3$2 = 44
t2$3 = 48
t1$4 = 52
t0$5 = 56
p3$6 = 60
t3$7 = 64
t2$8 = 68
t1$9 = 72
t0$10 = 76
p2$11 = 80
p2$12 = 84
d$ = 88
dcterm$13 = 96
p1$14 = 100
i$ = 104
p1$15 = 108
p4$16 = 112
p4$17 = 116
o$ = 120
x0$18 = 128
x1$19 = 132
x2$20 = 136
x3$21 = 140
x0$22 = 144
x1$23 = 148
x2$24 = 152
x3$25 = 156
p5$26 = 160
p5$27 = 164
val$ = 176
__$ArrayPad$ = 432
out$ = 464
out_stride$ = 472
data$ = 480
?stbi__idct_block@@YAXPEAEHQEAF@Z PROC			; stbi__idct_block

; 1982 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 456				; 000001c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1983 : 	int i, val[64], * v = val;

	lea	rax, QWORD PTR val$[rsp]
	mov	QWORD PTR v$[rsp], rax

; 1984 : 	stbi_uc* o;
; 1985 : 	short* d = data;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR d$[rsp], rax

; 1986 : 
; 1987 : 	// columns
; 1988 : 	for (i = 0; i < 8; ++i, ++d, ++v) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__idct
$LN2@stbi__idct:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR d$[rsp]
	add	rax, 2
	mov	QWORD PTR d$[rsp], rax
	mov	rax, QWORD PTR v$[rsp]
	add	rax, 4
	mov	QWORD PTR v$[rsp], rax
$LN4@stbi__idct:
	cmp	DWORD PTR i$[rsp], 8
	jge	$LN3@stbi__idct

; 1989 : 		// if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 1990 : 		if (d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0
; 1991 : 			&& d[40] == 0 && d[48] == 0 && d[56] == 0) {

	mov	eax, 2
	imul	rax, rax, 8
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	rax, rax, 16
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	rax, rax, 24
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	$LN8@stbi__idct
	mov	eax, 2
	imul	rax, rax, 56				; 00000038H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	$LN8@stbi__idct

; 1992 : 			//    no shortcut                 0     seconds
; 1993 : 			//    (1|2|3|4|5|6|7)==0          0     seconds
; 1994 : 			//    all separate               -0.047 seconds
; 1995 : 			//    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 1996 : 			int dcterm = d[0] << 2;

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	shl	eax, 2
	mov	DWORD PTR dcterm$13[rsp], eax

; 1997 : 			v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

	mov	eax, 4
	imul	rax, rax, 56				; 00000038H
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, rax, 24
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, rax, 16
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR v$[rsp]
	mov	edx, DWORD PTR dcterm$13[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 1998 : 		}

	jmp	$LN9@stbi__idct
$LN8@stbi__idct:

; 1999 : 		else {
; 2000 : 			STBI__IDCT_1D(d[0], d[8], d[16], d[24], d[32], d[40], d[48], d[56])

	mov	eax, 2
	imul	rax, rax, 16
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR p2$11[rsp], eax
	mov	eax, 2
	imul	rax, rax, 48				; 00000030H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR p3$1[rsp], eax
	mov	eax, DWORD PTR p3$1[rsp]
	mov	ecx, DWORD PTR p2$11[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 2217				; 000008a9H
	mov	DWORD PTR p1$14[rsp], eax
	imul	eax, DWORD PTR p3$1[rsp], -7567		; ffffffffffffe271H
	mov	ecx, DWORD PTR p1$14[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t2$3[rsp], eax
	imul	eax, DWORD PTR p2$11[rsp], 3135		; 00000c3fH
	mov	ecx, DWORD PTR p1$14[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t3$2[rsp], eax
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR p2$11[rsp], eax
	mov	eax, 2
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR p3$1[rsp], eax
	mov	eax, DWORD PTR p3$1[rsp]
	mov	ecx, DWORD PTR p2$11[rsp]
	add	ecx, eax
	mov	eax, ecx
	shl	eax, 12
	mov	DWORD PTR t0$5[rsp], eax
	mov	eax, DWORD PTR p3$1[rsp]
	mov	ecx, DWORD PTR p2$11[rsp]
	sub	ecx, eax
	mov	eax, ecx
	shl	eax, 12
	mov	DWORD PTR t1$4[rsp], eax
	mov	eax, DWORD PTR t3$2[rsp]
	mov	ecx, DWORD PTR t0$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x0$18[rsp], eax
	mov	eax, DWORD PTR t3$2[rsp]
	mov	ecx, DWORD PTR t0$5[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x3$21[rsp], eax
	mov	eax, DWORD PTR t2$3[rsp]
	mov	ecx, DWORD PTR t1$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x1$19[rsp], eax
	mov	eax, DWORD PTR t2$3[rsp]
	mov	ecx, DWORD PTR t1$4[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x2$20[rsp], eax
	mov	eax, 2
	imul	rax, rax, 56				; 00000038H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR t0$5[rsp], eax
	mov	eax, 2
	imul	rax, rax, 40				; 00000028H
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR t1$4[rsp], eax
	mov	eax, 2
	imul	rax, rax, 24
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR t2$3[rsp], eax
	mov	eax, 2
	imul	rax, rax, 8
	mov	rcx, QWORD PTR d$[rsp]
	movsx	eax, WORD PTR [rcx+rax]
	mov	DWORD PTR t3$2[rsp], eax
	mov	eax, DWORD PTR t2$3[rsp]
	mov	ecx, DWORD PTR t0$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p3$1[rsp], eax
	mov	eax, DWORD PTR t3$2[rsp]
	mov	ecx, DWORD PTR t1$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p4$16[rsp], eax
	mov	eax, DWORD PTR t3$2[rsp]
	mov	ecx, DWORD PTR t0$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p1$14[rsp], eax
	mov	eax, DWORD PTR t2$3[rsp]
	mov	ecx, DWORD PTR t1$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p2$11[rsp], eax
	mov	eax, DWORD PTR p4$16[rsp]
	mov	ecx, DWORD PTR p3$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 4816				; 000012d0H
	mov	DWORD PTR p5$26[rsp], eax
	imul	eax, DWORD PTR t0$5[rsp], 1223		; 000004c7H
	mov	DWORD PTR t0$5[rsp], eax
	imul	eax, DWORD PTR t1$4[rsp], 8410		; 000020daH
	mov	DWORD PTR t1$4[rsp], eax
	imul	eax, DWORD PTR t2$3[rsp], 12586		; 0000312aH
	mov	DWORD PTR t2$3[rsp], eax
	imul	eax, DWORD PTR t3$2[rsp], 6149		; 00001805H
	mov	DWORD PTR t3$2[rsp], eax
	imul	eax, DWORD PTR p1$14[rsp], -3685	; fffffffffffff19bH
	mov	ecx, DWORD PTR p5$26[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p1$14[rsp], eax
	imul	eax, DWORD PTR p2$11[rsp], -10497	; ffffffffffffd6ffH
	mov	ecx, DWORD PTR p5$26[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p2$11[rsp], eax
	imul	eax, DWORD PTR p3$1[rsp], -8034		; ffffffffffffe09eH
	mov	DWORD PTR p3$1[rsp], eax
	imul	eax, DWORD PTR p4$16[rsp], -1597	; fffffffffffff9c3H
	mov	DWORD PTR p4$16[rsp], eax
	mov	eax, DWORD PTR p4$16[rsp]
	mov	ecx, DWORD PTR p1$14[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t3$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t3$2[rsp], eax
	mov	eax, DWORD PTR p3$1[rsp]
	mov	ecx, DWORD PTR p2$11[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t2$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t2$3[rsp], eax
	mov	eax, DWORD PTR p4$16[rsp]
	mov	ecx, DWORD PTR p2$11[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t1$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t1$4[rsp], eax
	mov	eax, DWORD PTR p3$1[rsp]
	mov	ecx, DWORD PTR p1$14[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t0$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t0$5[rsp], eax

; 2001 : 				// constants scaled things up by 1<<12; let's bring them back
; 2002 : 				// down, but keep 2 extra bits of precision
; 2003 : 				x0 += 512; x1 += 512; x2 += 512; x3 += 512;

	mov	eax, DWORD PTR x0$18[rsp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR x0$18[rsp], eax
	mov	eax, DWORD PTR x1$19[rsp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR x1$19[rsp], eax
	mov	eax, DWORD PTR x2$20[rsp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR x2$20[rsp], eax
	mov	eax, DWORD PTR x3$21[rsp]
	add	eax, 512				; 00000200H
	mov	DWORD PTR x3$21[rsp], eax

; 2004 : 			v[0] = (x0 + t3) >> 10;

	mov	eax, DWORD PTR t3$2[rsp]
	mov	ecx, DWORD PTR x0$18[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 2005 : 			v[56] = (x0 - t3) >> 10;

	mov	eax, DWORD PTR t3$2[rsp]
	mov	ecx, DWORD PTR x0$18[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 56				; 00000038H
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 2006 : 			v[8] = (x1 + t2) >> 10;

	mov	eax, DWORD PTR t2$3[rsp]
	mov	ecx, DWORD PTR x1$19[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 2007 : 			v[48] = (x1 - t2) >> 10;

	mov	eax, DWORD PTR t2$3[rsp]
	mov	ecx, DWORD PTR x1$19[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 48				; 00000030H
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 2008 : 			v[16] = (x2 + t1) >> 10;

	mov	eax, DWORD PTR t1$4[rsp]
	mov	ecx, DWORD PTR x2$20[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 2009 : 			v[40] = (x2 - t1) >> 10;

	mov	eax, DWORD PTR t1$4[rsp]
	mov	ecx, DWORD PTR x2$20[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 40				; 00000028H
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 2010 : 			v[24] = (x3 + t0) >> 10;

	mov	eax, DWORD PTR t0$5[rsp]
	mov	ecx, DWORD PTR x3$21[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 2011 : 			v[32] = (x3 - t0) >> 10;

	mov	eax, DWORD PTR t0$5[rsp]
	mov	ecx, DWORD PTR x3$21[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 10
	mov	ecx, 4
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR v$[rsp]
	mov	DWORD PTR [rdx+rcx], eax
$LN9@stbi__idct:

; 2012 : 		}
; 2013 : 	}

	jmp	$LN2@stbi__idct
$LN3@stbi__idct:

; 2014 : 
; 2015 : 	for (i = 0, v = val, o = out; i < 8; ++i, v += 8, o += out_stride) {

	mov	DWORD PTR i$[rsp], 0
	lea	rax, QWORD PTR val$[rsp]
	mov	QWORD PTR v$[rsp], rax
	mov	rax, QWORD PTR out$[rsp]
	mov	QWORD PTR o$[rsp], rax
	jmp	SHORT $LN7@stbi__idct
$LN5@stbi__idct:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR v$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR v$[rsp], rax
	movsxd	rax, DWORD PTR out_stride$[rsp]
	mov	rcx, QWORD PTR o$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR o$[rsp], rax
$LN7@stbi__idct:
	cmp	DWORD PTR i$[rsp], 8
	jge	$LN6@stbi__idct

; 2016 : 		// no fast case since the first 1D IDCT spread components out
; 2017 : 		STBI__IDCT_1D(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR p2$12[rsp], eax
	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR p3$6[rsp], eax
	mov	eax, DWORD PTR p3$6[rsp]
	mov	ecx, DWORD PTR p2$12[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 2217				; 000008a9H
	mov	DWORD PTR p1$15[rsp], eax
	imul	eax, DWORD PTR p3$6[rsp], -7567		; ffffffffffffe271H
	mov	ecx, DWORD PTR p1$15[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t2$8[rsp], eax
	imul	eax, DWORD PTR p2$12[rsp], 3135		; 00000c3fH
	mov	ecx, DWORD PTR p1$15[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t3$7[rsp], eax
	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR p2$12[rsp], eax
	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR p3$6[rsp], eax
	mov	eax, DWORD PTR p3$6[rsp]
	mov	ecx, DWORD PTR p2$12[rsp]
	add	ecx, eax
	mov	eax, ecx
	shl	eax, 12
	mov	DWORD PTR t0$10[rsp], eax
	mov	eax, DWORD PTR p3$6[rsp]
	mov	ecx, DWORD PTR p2$12[rsp]
	sub	ecx, eax
	mov	eax, ecx
	shl	eax, 12
	mov	DWORD PTR t1$9[rsp], eax
	mov	eax, DWORD PTR t3$7[rsp]
	mov	ecx, DWORD PTR t0$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x0$22[rsp], eax
	mov	eax, DWORD PTR t3$7[rsp]
	mov	ecx, DWORD PTR t0$10[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x3$25[rsp], eax
	mov	eax, DWORD PTR t2$8[rsp]
	mov	ecx, DWORD PTR t1$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x1$23[rsp], eax
	mov	eax, DWORD PTR t2$8[rsp]
	mov	ecx, DWORD PTR t1$9[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x2$24[rsp], eax
	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR t0$10[rsp], eax
	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR t1$9[rsp], eax
	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR t2$8[rsp], eax
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR v$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR t3$7[rsp], eax
	mov	eax, DWORD PTR t2$8[rsp]
	mov	ecx, DWORD PTR t0$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p3$6[rsp], eax
	mov	eax, DWORD PTR t3$7[rsp]
	mov	ecx, DWORD PTR t1$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p4$17[rsp], eax
	mov	eax, DWORD PTR t3$7[rsp]
	mov	ecx, DWORD PTR t0$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p1$15[rsp], eax
	mov	eax, DWORD PTR t2$8[rsp]
	mov	ecx, DWORD PTR t1$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p2$12[rsp], eax
	mov	eax, DWORD PTR p4$17[rsp]
	mov	ecx, DWORD PTR p3$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 4816				; 000012d0H
	mov	DWORD PTR p5$27[rsp], eax
	imul	eax, DWORD PTR t0$10[rsp], 1223		; 000004c7H
	mov	DWORD PTR t0$10[rsp], eax
	imul	eax, DWORD PTR t1$9[rsp], 8410		; 000020daH
	mov	DWORD PTR t1$9[rsp], eax
	imul	eax, DWORD PTR t2$8[rsp], 12586		; 0000312aH
	mov	DWORD PTR t2$8[rsp], eax
	imul	eax, DWORD PTR t3$7[rsp], 6149		; 00001805H
	mov	DWORD PTR t3$7[rsp], eax
	imul	eax, DWORD PTR p1$15[rsp], -3685	; fffffffffffff19bH
	mov	ecx, DWORD PTR p5$27[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p1$15[rsp], eax
	imul	eax, DWORD PTR p2$12[rsp], -10497	; ffffffffffffd6ffH
	mov	ecx, DWORD PTR p5$27[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR p2$12[rsp], eax
	imul	eax, DWORD PTR p3$6[rsp], -8034		; ffffffffffffe09eH
	mov	DWORD PTR p3$6[rsp], eax
	imul	eax, DWORD PTR p4$17[rsp], -1597	; fffffffffffff9c3H
	mov	DWORD PTR p4$17[rsp], eax
	mov	eax, DWORD PTR p4$17[rsp]
	mov	ecx, DWORD PTR p1$15[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t3$7[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t3$7[rsp], eax
	mov	eax, DWORD PTR p3$6[rsp]
	mov	ecx, DWORD PTR p2$12[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t2$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t2$8[rsp], eax
	mov	eax, DWORD PTR p4$17[rsp]
	mov	ecx, DWORD PTR p2$12[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t1$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t1$9[rsp], eax
	mov	eax, DWORD PTR p3$6[rsp]
	mov	ecx, DWORD PTR p1$15[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR t0$10[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t0$10[rsp], eax

; 2018 : 			// constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2019 : 			// loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2020 : 			// we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2021 : 			// so we want to round that, which means adding 0.5 * 1<<17,
; 2022 : 			// aka 65536. Also, we'll end up with -128 to 127 that we want
; 2023 : 			// to encode as 0..255 by adding 128, so we'll add that before the shift
; 2024 : 			x0 += 65536 + (128 << 17);

	mov	eax, DWORD PTR x0$22[rsp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR x0$22[rsp], eax

; 2025 : 		x1 += 65536 + (128 << 17);

	mov	eax, DWORD PTR x1$23[rsp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR x1$23[rsp], eax

; 2026 : 		x2 += 65536 + (128 << 17);

	mov	eax, DWORD PTR x2$24[rsp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR x2$24[rsp], eax

; 2027 : 		x3 += 65536 + (128 << 17);

	mov	eax, DWORD PTR x3$25[rsp]
	add	eax, 16842752				; 01010000H
	mov	DWORD PTR x3$25[rsp], eax

; 2028 : 		// tried computing the shifts into temps, or'ing the temps to see
; 2029 : 		// if any were out of range, but that was slower
; 2030 : 		o[0] = stbi__clamp((x0 + t3) >> 17);

	mov	eax, DWORD PTR t3$7[rsp]
	mov	ecx, DWORD PTR x0$22[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2031 : 		o[7] = stbi__clamp((x0 - t3) >> 17);

	mov	eax, DWORD PTR t3$7[rsp]
	mov	ecx, DWORD PTR x0$22[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2032 : 		o[1] = stbi__clamp((x1 + t2) >> 17);

	mov	eax, DWORD PTR t2$8[rsp]
	mov	ecx, DWORD PTR x1$23[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2033 : 		o[6] = stbi__clamp((x1 - t2) >> 17);

	mov	eax, DWORD PTR t2$8[rsp]
	mov	ecx, DWORD PTR x1$23[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2034 : 		o[2] = stbi__clamp((x2 + t1) >> 17);

	mov	eax, DWORD PTR t1$9[rsp]
	mov	ecx, DWORD PTR x2$24[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2035 : 		o[5] = stbi__clamp((x2 - t1) >> 17);

	mov	eax, DWORD PTR t1$9[rsp]
	mov	ecx, DWORD PTR x2$24[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2036 : 		o[3] = stbi__clamp((x3 + t0) >> 17);

	mov	eax, DWORD PTR t0$10[rsp]
	mov	ecx, DWORD PTR x3$25[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2037 : 		o[4] = stbi__clamp((x3 - t0) >> 17);

	mov	eax, DWORD PTR t0$10[rsp]
	mov	ecx, DWORD PTR x3$25[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 17
	mov	ecx, eax
	call	?stbi__clamp@@YAEH@Z			; stbi__clamp
	mov	ecx, 1
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR o$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 2038 : 	}

	jmp	$LN5@stbi__idct
$LN6@stbi__idct:

; 2039 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 456				; 000001c8H
	ret	0
?stbi__idct_block@@YAXPEAEHQEAF@Z ENDP			; stbi__idct_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
x$ = 8
?stbi__clamp@@YAEH@Z PROC				; stbi__clamp

; 1931 : {

	mov	DWORD PTR [rsp+8], ecx

; 1932 : 	// trick to use a single test to catch both cases
; 1933 : 	if ((unsigned int)x > 255) {

	cmp	DWORD PTR x$[rsp], 255			; 000000ffH
	jbe	SHORT $LN2@stbi__clam

; 1934 : 		if (x < 0) return 0;

	cmp	DWORD PTR x$[rsp], 0
	jge	SHORT $LN3@stbi__clam
	xor	al, al
	jmp	SHORT $LN1@stbi__clam
$LN3@stbi__clam:

; 1935 : 		if (x > 255) return 255;

	cmp	DWORD PTR x$[rsp], 255			; 000000ffH
	jle	SHORT $LN4@stbi__clam
	mov	al, 255					; 000000ffH
	jmp	SHORT $LN1@stbi__clam
$LN4@stbi__clam:
$LN2@stbi__clam:

; 1936 : 	}
; 1937 : 	return (stbi_uc)x;

	movzx	eax, BYTE PTR x$[rsp]
$LN1@stbi__clam:

; 1938 : }

	ret	0
?stbi__clamp@@YAEH@Z ENDP				; stbi__clamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
bit$1 = 36
r$2 = 40
r$3 = 44
s$4 = 48
s$5 = 52
p$6 = 56
rs$7 = 64
zig$8 = 68
rs$9 = 72
p$10 = 80
shift$11 = 88
c$12 = 92
tv134 = 96
tv355 = 100
tv160 = 104
tv158 = 108
tv173 = 112
tv378 = 116
tv405 = 120
tv242 = 124
tv240 = 128
tv339 = 136
tv261 = 144
j$ = 176
data$ = 184
hac$ = 192
fac$ = 200
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z PROC ; stbi__jpeg_decode_block_prog_ac

; 1804 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1805 : 	int k;
; 1806 : 	if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18228], 0
	jne	SHORT $LN13@stbi__jpeg
	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 1807 : 
; 1808 : 	if (j->succ_high == 0) {

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18236], 0
	jne	$LN14@stbi__jpeg

; 1809 : 		int shift = j->succ_low;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18240]
	mov	DWORD PTR shift$11[rsp], eax

; 1810 : 
; 1811 : 		if (j->eob_run) {

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18244], 0
	je	SHORT $LN16@stbi__jpeg

; 1812 : 			--j->eob_run;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18244]
	dec	eax
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18244], eax

; 1813 : 			return 1;

	mov	eax, 1
	jmp	$LN1@stbi__jpeg
$LN16@stbi__jpeg:

; 1814 : 		}
; 1815 : 
; 1816 : 		k = j->spec_start;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18228]
	mov	DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 1817 : 		do {
; 1818 : 			unsigned int zig;
; 1819 : 			int c, r, s;
; 1820 : 			if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18212], 16
	jge	SHORT $LN17@stbi__jpeg
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN17@stbi__jpeg:

; 1821 : 			c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shr	eax, 23
	and	eax, 511				; 000001ffH
	mov	DWORD PTR c$12[rsp], eax

; 1822 : 			r = fac[c];

	movsxd	rax, DWORD PTR c$12[rsp]
	mov	rcx, QWORD PTR fac$[rsp]
	movsx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR r$2[rsp], eax

; 1823 : 			if (r) { // fast-AC path

	cmp	DWORD PTR r$2[rsp], 0
	je	$LN18@stbi__jpeg

; 1824 : 				k += (r >> 4) & 15; // run

	mov	eax, DWORD PTR r$2[rsp]
	sar	eax, 4
	and	eax, 15
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 1825 : 				s = r & 15; // combined length

	mov	eax, DWORD PTR r$2[rsp]
	and	eax, 15
	mov	DWORD PTR s$4[rsp], eax

; 1826 : 				j->code_buffer <<= s;

	mov	eax, DWORD PTR s$4[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR tv339[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv339[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shl	eax, cl
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1827 : 				j->code_bits -= s;

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR s$4[rsp]
	mov	eax, DWORD PTR [rax+18212]
	sub	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1828 : 				zig = stbi__jpeg_dezigzag[k++];

	movsxd	rax, DWORD PTR k$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv134[rsp], eax
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	mov	eax, DWORD PTR tv134[rsp]
	mov	DWORD PTR zig$8[rsp], eax

; 1829 : 				data[zig] = (short)((r >> 8) << shift);

	mov	eax, DWORD PTR r$2[rsp]
	sar	eax, 8
	mov	ecx, DWORD PTR shift$11[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR zig$8[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax

; 1830 : 			}

	jmp	$LN19@stbi__jpeg
$LN18@stbi__jpeg:

; 1831 : 			else {
; 1832 : 				int rs = stbi__jpeg_huff_decode(j, hac);

	mov	rdx, QWORD PTR hac$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	mov	DWORD PTR rs$7[rsp], eax

; 1833 : 				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR rs$7[rsp], 0
	jge	SHORT $LN20@stbi__jpeg
	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN20@stbi__jpeg:

; 1834 : 				s = rs & 15;

	mov	eax, DWORD PTR rs$7[rsp]
	and	eax, 15
	mov	DWORD PTR s$4[rsp], eax

; 1835 : 				r = rs >> 4;

	mov	eax, DWORD PTR rs$7[rsp]
	sar	eax, 4
	mov	DWORD PTR r$2[rsp], eax

; 1836 : 				if (s == 0) {

	cmp	DWORD PTR s$4[rsp], 0
	jne	$LN21@stbi__jpeg

; 1837 : 					if (r < 15) {

	cmp	DWORD PTR r$2[rsp], 15
	jge	$LN23@stbi__jpeg

; 1838 : 						j->eob_run = (1 << r);

	mov	eax, DWORD PTR r$2[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv355[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv355[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18244], eax

; 1839 : 						if (r)

	cmp	DWORD PTR r$2[rsp], 0
	je	SHORT $LN24@stbi__jpeg

; 1840 : 							j->eob_run += stbi__jpeg_get_bits(j, r);

	mov	edx, DWORD PTR r$2[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
	mov	DWORD PTR tv160[rsp], eax
	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18244]
	mov	DWORD PTR tv158[rsp], eax
	mov	eax, DWORD PTR tv160[rsp]
	mov	ecx, DWORD PTR tv158[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18244], eax
$LN24@stbi__jpeg:

; 1841 : 						--j->eob_run;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18244]
	dec	eax
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18244], eax

; 1842 : 						break;

	jmp	$LN3@stbi__jpeg
$LN23@stbi__jpeg:

; 1843 : 					}
; 1844 : 					k += 16;

	mov	eax, DWORD PTR k$[rsp]
	add	eax, 16
	mov	DWORD PTR k$[rsp], eax

; 1845 : 				}

	jmp	SHORT $LN22@stbi__jpeg
$LN21@stbi__jpeg:

; 1846 : 				else {
; 1847 : 					k += r;

	mov	eax, DWORD PTR r$2[rsp]
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 1848 : 					zig = stbi__jpeg_dezigzag[k++];

	movsxd	rax, DWORD PTR k$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv173[rsp], eax
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	mov	eax, DWORD PTR tv173[rsp]
	mov	DWORD PTR zig$8[rsp], eax

; 1849 : 					data[zig] = (short)(stbi__extend_receive(j, s) << shift);

	mov	edx, DWORD PTR s$4[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
	mov	ecx, DWORD PTR shift$11[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR zig$8[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax
$LN22@stbi__jpeg:
$LN19@stbi__jpeg:

; 1850 : 				}
; 1851 : 			}
; 1852 : 		} while (k <= j->spec_end);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18232]
	cmp	DWORD PTR k$[rsp], eax
	jle	$LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 1853 : 	}

	jmp	$LN15@stbi__jpeg
$LN14@stbi__jpeg:

; 1854 : 	else {
; 1855 : 		// refinement scan for these AC coefficients
; 1856 : 
; 1857 : 		short bit = (short)(1 << j->succ_low);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18240]
	mov	ecx, 1
	mov	DWORD PTR tv378[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv378[rsp]
	shl	eax, cl
	mov	WORD PTR bit$1[rsp], ax

; 1858 : 
; 1859 : 		if (j->eob_run) {

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18244], 0
	je	$LN25@stbi__jpeg

; 1860 : 			--j->eob_run;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18244]
	dec	eax
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18244], eax

; 1861 : 			for (k = j->spec_start; k <= j->spec_end; ++k) {

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18228]
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN7@stbi__jpeg:
	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18232]
	cmp	DWORD PTR k$[rsp], eax
	jg	$LN6@stbi__jpeg

; 1862 : 				short* p = &data[stbi__jpeg_dezigzag[k]];

	movsxd	rax, DWORD PTR k$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR p$10[rsp], rax

; 1863 : 				if (*p != 0)

	mov	rax, QWORD PTR p$10[rsp]
	movsx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN27@stbi__jpeg

; 1864 : 					if (stbi__jpeg_get_bit(j))

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	test	eax, eax
	je	SHORT $LN28@stbi__jpeg

; 1865 : 						if ((*p & bit) == 0) {

	mov	rax, QWORD PTR p$10[rsp]
	movsx	eax, WORD PTR [rax]
	movsx	ecx, WORD PTR bit$1[rsp]
	and	eax, ecx
	test	eax, eax
	jne	SHORT $LN29@stbi__jpeg

; 1866 : 							if (*p > 0)

	mov	rax, QWORD PTR p$10[rsp]
	movsx	eax, WORD PTR [rax]
	test	eax, eax
	jle	SHORT $LN30@stbi__jpeg

; 1867 : 								*p += bit;

	movsx	eax, WORD PTR bit$1[rsp]
	mov	rcx, QWORD PTR p$10[rsp]
	movsx	ecx, WORD PTR [rcx]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$10[rsp]
	mov	WORD PTR [rcx], ax
	jmp	SHORT $LN31@stbi__jpeg
$LN30@stbi__jpeg:

; 1868 : 							else
; 1869 : 								*p -= bit;

	movsx	eax, WORD PTR bit$1[rsp]
	mov	rcx, QWORD PTR p$10[rsp]
	movsx	ecx, WORD PTR [rcx]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$10[rsp]
	mov	WORD PTR [rcx], ax
$LN31@stbi__jpeg:
$LN29@stbi__jpeg:
$LN28@stbi__jpeg:
$LN27@stbi__jpeg:

; 1870 : 						}
; 1871 : 			}

	jmp	$LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 1872 : 		}

	jmp	$LN26@stbi__jpeg
$LN25@stbi__jpeg:

; 1873 : 		else {
; 1874 : 			k = j->spec_start;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18228]
	mov	DWORD PTR k$[rsp], eax
$LN10@stbi__jpeg:

; 1875 : 			do {
; 1876 : 				int r, s;
; 1877 : 				int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh

	mov	rdx, QWORD PTR hac$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	mov	DWORD PTR rs$9[rsp], eax

; 1878 : 				if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR rs$9[rsp], 0
	jge	SHORT $LN32@stbi__jpeg
	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN32@stbi__jpeg:

; 1879 : 				s = rs & 15;

	mov	eax, DWORD PTR rs$9[rsp]
	and	eax, 15
	mov	DWORD PTR s$5[rsp], eax

; 1880 : 				r = rs >> 4;

	mov	eax, DWORD PTR rs$9[rsp]
	sar	eax, 4
	mov	DWORD PTR r$3[rsp], eax

; 1881 : 				if (s == 0) {

	cmp	DWORD PTR s$5[rsp], 0
	jne	$LN33@stbi__jpeg

; 1882 : 					if (r < 15) {

	cmp	DWORD PTR r$3[rsp], 15
	jge	SHORT $LN35@stbi__jpeg

; 1883 : 						j->eob_run = (1 << r) - 1;

	mov	eax, DWORD PTR r$3[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv405[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv405[rsp]
	shl	eax, cl
	dec	eax
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18244], eax

; 1884 : 						if (r)

	cmp	DWORD PTR r$3[rsp], 0
	je	SHORT $LN37@stbi__jpeg

; 1885 : 							j->eob_run += stbi__jpeg_get_bits(j, r);

	mov	edx, DWORD PTR r$3[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
	mov	DWORD PTR tv242[rsp], eax
	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18244]
	mov	DWORD PTR tv240[rsp], eax
	mov	eax, DWORD PTR tv242[rsp]
	mov	ecx, DWORD PTR tv240[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18244], eax
$LN37@stbi__jpeg:

; 1886 : 						r = 64; // force end of block

	mov	DWORD PTR r$3[rsp], 64			; 00000040H
$LN35@stbi__jpeg:

; 1887 : 					}
; 1888 : 					else {
; 1889 : 						// r=15 s=0 should write 16 0s, so we just do
; 1890 : 						// a run of 15 0s and then write s (which is 0),
; 1891 : 						// so we don't have to do anything special here
; 1892 : 					}
; 1893 : 				}

	jmp	SHORT $LN34@stbi__jpeg
$LN33@stbi__jpeg:

; 1894 : 				else {
; 1895 : 					if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR s$5[rsp], 1
	je	SHORT $LN38@stbi__jpeg
	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN38@stbi__jpeg:

; 1896 : 					// sign bit
; 1897 : 					if (stbi__jpeg_get_bit(j))

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	test	eax, eax
	je	SHORT $LN39@stbi__jpeg

; 1898 : 						s = bit;

	movsx	eax, WORD PTR bit$1[rsp]
	mov	DWORD PTR s$5[rsp], eax
	jmp	SHORT $LN40@stbi__jpeg
$LN39@stbi__jpeg:

; 1899 : 					else
; 1900 : 						s = -bit;

	movsx	eax, WORD PTR bit$1[rsp]
	neg	eax
	mov	DWORD PTR s$5[rsp], eax
$LN40@stbi__jpeg:
$LN34@stbi__jpeg:
$LN11@stbi__jpeg:

; 1901 : 				}
; 1902 : 
; 1903 : 				// advance by r
; 1904 : 				while (k <= j->spec_end) {

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18232]
	cmp	DWORD PTR k$[rsp], eax
	jg	$LN12@stbi__jpeg

; 1905 : 					short* p = &data[stbi__jpeg_dezigzag[k++]];

	movsxd	rax, DWORD PTR k$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR data$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR tv261[rsp], rax
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	mov	rax, QWORD PTR tv261[rsp]
	mov	QWORD PTR p$6[rsp], rax

; 1906 : 					if (*p != 0) {

	mov	rax, QWORD PTR p$6[rsp]
	movsx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN41@stbi__jpeg

; 1907 : 						if (stbi__jpeg_get_bit(j))

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	test	eax, eax
	je	SHORT $LN43@stbi__jpeg

; 1908 : 							if ((*p & bit) == 0) {

	mov	rax, QWORD PTR p$6[rsp]
	movsx	eax, WORD PTR [rax]
	movsx	ecx, WORD PTR bit$1[rsp]
	and	eax, ecx
	test	eax, eax
	jne	SHORT $LN44@stbi__jpeg

; 1909 : 								if (*p > 0)

	mov	rax, QWORD PTR p$6[rsp]
	movsx	eax, WORD PTR [rax]
	test	eax, eax
	jle	SHORT $LN45@stbi__jpeg

; 1910 : 									*p += bit;

	movsx	eax, WORD PTR bit$1[rsp]
	mov	rcx, QWORD PTR p$6[rsp]
	movsx	ecx, WORD PTR [rcx]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$6[rsp]
	mov	WORD PTR [rcx], ax
	jmp	SHORT $LN46@stbi__jpeg
$LN45@stbi__jpeg:

; 1911 : 								else
; 1912 : 									*p -= bit;

	movsx	eax, WORD PTR bit$1[rsp]
	mov	rcx, QWORD PTR p$6[rsp]
	movsx	ecx, WORD PTR [rcx]
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$6[rsp]
	mov	WORD PTR [rcx], ax
$LN46@stbi__jpeg:
$LN44@stbi__jpeg:
$LN43@stbi__jpeg:

; 1913 : 							}
; 1914 : 					}

	jmp	SHORT $LN42@stbi__jpeg
$LN41@stbi__jpeg:

; 1915 : 					else {
; 1916 : 						if (r == 0) {

	cmp	DWORD PTR r$3[rsp], 0
	jne	SHORT $LN47@stbi__jpeg

; 1917 : 							*p = (short)s;

	mov	rax, QWORD PTR p$6[rsp]
	movzx	ecx, WORD PTR s$5[rsp]
	mov	WORD PTR [rax], cx

; 1918 : 							break;

	jmp	SHORT $LN12@stbi__jpeg
$LN47@stbi__jpeg:

; 1919 : 						}
; 1920 : 						--r;

	mov	eax, DWORD PTR r$3[rsp]
	dec	eax
	mov	DWORD PTR r$3[rsp], eax
$LN42@stbi__jpeg:

; 1921 : 					}
; 1922 : 				}

	jmp	$LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 1923 : 			} while (k <= j->spec_end);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18232]
	cmp	DWORD PTR k$[rsp], eax
	jle	$LN10@stbi__jpeg
$LN26@stbi__jpeg:
$LN15@stbi__jpeg:

; 1924 : 		}
; 1925 : 	}
; 1926 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 1927 : }

	add	rsp, 168				; 000000a8H
	ret	0
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ENDP ; stbi__jpeg_decode_block_prog_ac
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
t$ = 32
tv81 = 36
dc$ = 40
diff$ = 44
tv169 = 48
j$ = 80
data$ = 88
hdc$ = 96
b$ = 104
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z PROC ; stbi__jpeg_decode_block_prog_dc

; 1776 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1777 : 	int diff, dc;
; 1778 : 	int t;
; 1779 : 	if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18232], 0
	je	SHORT $LN2@stbi__jpeg
	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 1780 : 
; 1781 : 	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18212], 16
	jge	SHORT $LN3@stbi__jpeg
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN3@stbi__jpeg:

; 1782 : 
; 1783 : 	if (j->succ_high == 0) {

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18236], 0
	jne	$LN4@stbi__jpeg

; 1784 : 		// first scan for DC coefficient, must be first
; 1785 : 		memset(data, 0, 64 * sizeof(data[0])); // 0 all the ac values now

	mov	r8d, 128				; 00000080H
	xor	edx, edx
	mov	rcx, QWORD PTR data$[rsp]
	call	memset

; 1786 : 		t = stbi__jpeg_huff_decode(j, hdc);

	mov	rdx, QWORD PTR hdc$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	mov	DWORD PTR t$[rsp], eax

; 1787 : 		diff = t ? stbi__extend_receive(j, t) : 0;

	cmp	DWORD PTR t$[rsp], 0
	je	SHORT $LN8@stbi__jpeg
	mov	edx, DWORD PTR t$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
	mov	DWORD PTR tv81[rsp], eax
	jmp	SHORT $LN9@stbi__jpeg
$LN8@stbi__jpeg:
	mov	DWORD PTR tv81[rsp], 0
$LN9@stbi__jpeg:
	mov	eax, DWORD PTR tv81[rsp]
	mov	DWORD PTR diff$[rsp], eax

; 1788 : 
; 1789 : 		dc = j->img_comp[b].dc_pred + diff;

	movsxd	rax, DWORD PTR b$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17848]
	add	eax, DWORD PTR diff$[rsp]
	mov	DWORD PTR dc$[rsp], eax

; 1790 : 		j->img_comp[b].dc_pred = dc;

	movsxd	rax, DWORD PTR b$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	edx, DWORD PTR dc$[rsp]
	mov	DWORD PTR [rcx+rax+17848], edx

; 1791 : 		data[0] = (short)(dc << j->succ_low);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18240]
	movzx	ecx, al
	mov	eax, DWORD PTR dc$[rsp]
	shl	eax, cl
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 1792 : 	}

	jmp	SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 1793 : 	else {
; 1794 : 		// refinement scan for DC coefficient
; 1795 : 		if (stbi__jpeg_get_bit(j))

	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
	test	eax, eax
	je	SHORT $LN6@stbi__jpeg

; 1796 : 			data[0] += (short)(1 << j->succ_low);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18240]
	mov	ecx, 1
	mov	DWORD PTR tv169[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv169[rsp]
	shl	eax, cl
	cwde
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR data$[rsp]
	movsx	ecx, WORD PTR [rdx+rcx]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx], ax
$LN6@stbi__jpeg:
$LN5@stbi__jpeg:

; 1797 : 	}
; 1798 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 1799 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ENDP ; stbi__jpeg_decode_block_prog_dc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
r$1 = 36
s$2 = 40
zig$3 = 44
rs$4 = 48
t$ = 52
tv78 = 56
dc$ = 60
diff$ = 64
c$5 = 68
tv156 = 72
tv183 = 76
tv231 = 80
j$ = 112
data$ = 120
hdc$ = 128
hac$ = 136
fac$ = 144
b$ = 152
dequant$ = 160
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z PROC ; stbi__jpeg_decode_block

; 1722 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1723 : 	int diff, dc, k;
; 1724 : 	int t;
; 1725 : 
; 1726 : 	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18212], 16
	jge	SHORT $LN5@stbi__jpeg
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN5@stbi__jpeg:

; 1727 : 	t = stbi__jpeg_huff_decode(j, hdc);

	mov	rdx, QWORD PTR hdc$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	mov	DWORD PTR t$[rsp], eax

; 1728 : 	if (t < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR t$[rsp], 0
	jge	SHORT $LN6@stbi__jpeg
	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 1729 : 
; 1730 : 	// 0 all the ac values now so we can do it 32-bits at a time
; 1731 : 	memset(data, 0, 64 * sizeof(data[0]));

	mov	r8d, 128				; 00000080H
	xor	edx, edx
	mov	rcx, QWORD PTR data$[rsp]
	call	memset

; 1732 : 
; 1733 : 	diff = t ? stbi__extend_receive(j, t) : 0;

	cmp	DWORD PTR t$[rsp], 0
	je	SHORT $LN15@stbi__jpeg
	mov	edx, DWORD PTR t$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN16@stbi__jpeg
$LN15@stbi__jpeg:
	mov	DWORD PTR tv78[rsp], 0
$LN16@stbi__jpeg:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR diff$[rsp], eax

; 1734 : 	dc = j->img_comp[b].dc_pred + diff;

	movsxd	rax, DWORD PTR b$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rcx+rax+17848]
	add	eax, DWORD PTR diff$[rsp]
	mov	DWORD PTR dc$[rsp], eax

; 1735 : 	j->img_comp[b].dc_pred = dc;

	movsxd	rax, DWORD PTR b$[rsp]
	imul	rax, rax, 96				; 00000060H
	mov	rcx, QWORD PTR j$[rsp]
	mov	edx, DWORD PTR dc$[rsp]
	mov	DWORD PTR [rcx+rax+17848], edx

; 1736 : 	data[0] = (short)(dc * dequant[0]);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dequant$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR dc$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 1737 : 
; 1738 : 	// decode AC components, see JPEG spec
; 1739 : 	k = 1;

	mov	DWORD PTR k$[rsp], 1
$LN4@stbi__jpeg:

; 1740 : 	do {
; 1741 : 		unsigned int zig;
; 1742 : 		int c, r, s;
; 1743 : 		if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18212], 16
	jge	SHORT $LN7@stbi__jpeg
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN7@stbi__jpeg:

; 1744 : 		c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shr	eax, 23
	and	eax, 511				; 000001ffH
	mov	DWORD PTR c$5[rsp], eax

; 1745 : 		r = fac[c];

	movsxd	rax, DWORD PTR c$5[rsp]
	mov	rcx, QWORD PTR fac$[rsp]
	movsx	eax, WORD PTR [rcx+rax*2]
	mov	DWORD PTR r$1[rsp], eax

; 1746 : 		if (r) { // fast-AC path

	cmp	DWORD PTR r$1[rsp], 0
	je	$LN8@stbi__jpeg

; 1747 : 			k += (r >> 4) & 15; // run

	mov	eax, DWORD PTR r$1[rsp]
	sar	eax, 4
	and	eax, 15
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 1748 : 			s = r & 15; // combined length

	mov	eax, DWORD PTR r$1[rsp]
	and	eax, 15
	mov	DWORD PTR s$2[rsp], eax

; 1749 : 			j->code_buffer <<= s;

	mov	eax, DWORD PTR s$2[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR tv231[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv231[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shl	eax, cl
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1750 : 			j->code_bits -= s;

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR s$2[rsp]
	mov	eax, DWORD PTR [rax+18212]
	sub	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1751 : 			// decode into unzigzag'd location
; 1752 : 			zig = stbi__jpeg_dezigzag[k++];

	movsxd	rax, DWORD PTR k$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv156[rsp], eax
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	mov	eax, DWORD PTR tv156[rsp]
	mov	DWORD PTR zig$3[rsp], eax

; 1753 : 			data[zig] = (short)((r >> 8) * dequant[zig]);

	mov	eax, DWORD PTR r$1[rsp]
	sar	eax, 8
	mov	ecx, DWORD PTR zig$3[rsp]
	mov	rdx, QWORD PTR dequant$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	eax, ecx
	mov	ecx, DWORD PTR zig$3[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax

; 1754 : 		}

	jmp	$LN9@stbi__jpeg
$LN8@stbi__jpeg:

; 1755 : 		else {
; 1756 : 			int rs = stbi__jpeg_huff_decode(j, hac);

	mov	rdx, QWORD PTR hac$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
	mov	DWORD PTR rs$4[rsp], eax

; 1757 : 			if (rs < 0) return stbi__err("bad huffman code", "Corrupt JPEG");

	cmp	DWORD PTR rs$4[rsp], 0
	jge	SHORT $LN10@stbi__jpeg
	xor	eax, eax
	jmp	$LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 1758 : 			s = rs & 15;

	mov	eax, DWORD PTR rs$4[rsp]
	and	eax, 15
	mov	DWORD PTR s$2[rsp], eax

; 1759 : 			r = rs >> 4;

	mov	eax, DWORD PTR rs$4[rsp]
	sar	eax, 4
	mov	DWORD PTR r$1[rsp], eax

; 1760 : 			if (s == 0) {

	cmp	DWORD PTR s$2[rsp], 0
	jne	SHORT $LN11@stbi__jpeg

; 1761 : 				if (rs != 0xf0) break; // end block

	cmp	DWORD PTR rs$4[rsp], 240		; 000000f0H
	je	SHORT $LN13@stbi__jpeg
	jmp	SHORT $LN3@stbi__jpeg
$LN13@stbi__jpeg:

; 1762 : 				k += 16;

	mov	eax, DWORD PTR k$[rsp]
	add	eax, 16
	mov	DWORD PTR k$[rsp], eax

; 1763 : 			}

	jmp	SHORT $LN12@stbi__jpeg
$LN11@stbi__jpeg:

; 1764 : 			else {
; 1765 : 				k += r;

	mov	eax, DWORD PTR r$1[rsp]
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 1766 : 				// decode into unzigzag'd location
; 1767 : 				zig = stbi__jpeg_dezigzag[k++];

	movsxd	rax, DWORD PTR k$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3PAEA
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv183[rsp], eax
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	mov	eax, DWORD PTR tv183[rsp]
	mov	DWORD PTR zig$3[rsp], eax

; 1768 : 				data[zig] = (short)(stbi__extend_receive(j, s) * dequant[zig]);

	mov	edx, DWORD PTR s$2[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
	mov	ecx, DWORD PTR zig$3[rsp]
	mov	rdx, QWORD PTR dequant$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	eax, ecx
	mov	ecx, DWORD PTR zig$3[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax
$LN12@stbi__jpeg:
$LN9@stbi__jpeg:

; 1769 : 			}
; 1770 : 		}
; 1771 : 	} while (k < 64);

	cmp	DWORD PTR k$[rsp], 64			; 00000040H
	jl	$LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 1772 : 	return 1;

	mov	eax, 1
$LN1@stbi__jpeg:

; 1773 : }

	add	rsp, 104				; 00000068H
	ret	0
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAE@Z ENDP ; stbi__jpeg_decode_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
j$ = 64
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_get_bit

; 1694 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1695 : 	unsigned int k;
; 1696 : 	if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18212], 1
	jge	SHORT $LN2@stbi__jpeg
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN2@stbi__jpeg:

; 1697 : 	k = j->code_buffer;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18208]
	mov	DWORD PTR k$[rsp], eax

; 1698 : 	j->code_buffer <<= 1;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shl	eax, 1
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1699 : 	--j->code_bits;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	dec	eax
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1700 : 	return k & 0x80000000;

	mov	eax, DWORD PTR k$[rsp]
	and	eax, -2147483648			; 80000000H

; 1701 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_get_bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
j$ = 64
n$ = 72
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__jpeg_get_bits

; 1683 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1684 : 	unsigned int k;
; 1685 : 	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	cmp	DWORD PTR [rax+18212], ecx
	jge	SHORT $LN2@stbi__jpeg
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN2@stbi__jpeg:

; 1686 : 	k = stbi_lrot(j->code_buffer, n);

	mov	edx, DWORD PTR n$[rsp]
	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR [rax+18208]
	call	_lrotl
	mov	DWORD PTR k$[rsp], eax

; 1687 : 	j->code_buffer = k & ~stbi__bmask[n];

	movsxd	rax, DWORD PTR n$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__bmask@@3PAIA
	mov	eax, DWORD PTR [rcx+rax*4]
	not	eax
	mov	ecx, DWORD PTR k$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1688 : 	k &= stbi__bmask[n];

	movsxd	rax, DWORD PTR n$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__bmask@@3PAIA
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	ecx, DWORD PTR k$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 1689 : 	j->code_bits -= n;

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	sub	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1690 : 	return k;

	mov	eax, DWORD PTR k$[rsp]

; 1691 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__jpeg_get_bits
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
sgn$ = 36
j$ = 64
n$ = 72
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__extend_receive

; 1667 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1668 : 	unsigned int k;
; 1669 : 	int sgn;
; 1670 : 	if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	cmp	DWORD PTR [rax+18212], ecx
	jge	SHORT $LN2@stbi__exte
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN2@stbi__exte:

; 1671 : 
; 1672 : 	sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18208]
	sar	eax, 31
	mov	DWORD PTR sgn$[rsp], eax

; 1673 : 	k = stbi_lrot(j->code_buffer, n);

	mov	edx, DWORD PTR n$[rsp]
	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR [rax+18208]
	call	_lrotl
	mov	DWORD PTR k$[rsp], eax

; 1674 : 	STBI_ASSERT(n >= 0 && n < (int)(sizeof(stbi__bmask) / sizeof(*stbi__bmask)));
; 1675 : 	j->code_buffer = k & ~stbi__bmask[n];

	movsxd	rax, DWORD PTR n$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__bmask@@3PAIA
	mov	eax, DWORD PTR [rcx+rax*4]
	not	eax
	mov	ecx, DWORD PTR k$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1676 : 	k &= stbi__bmask[n];

	movsxd	rax, DWORD PTR n$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__bmask@@3PAIA
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	ecx, DWORD PTR k$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 1677 : 	j->code_bits -= n;

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	sub	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1678 : 	return k + (stbi__jbias[n] & ~sgn);

	movsxd	rax, DWORD PTR n$[rsp]
	lea	rcx, OFFSET FLAT:?stbi__jbias@@3QBHB
	mov	edx, DWORD PTR sgn$[rsp]
	not	edx
	mov	eax, DWORD PTR [rcx+rax*4]
	and	eax, edx
	mov	ecx, DWORD PTR k$[rsp]
	add	ecx, eax
	mov	eax, ecx

; 1679 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__extend_receive
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
s$1 = 36
c$ = 40
temp$ = 44
tv180 = 48
tv201 = 56
tv211 = 64
j$ = 96
h$ = 104
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z PROC ; stbi__jpeg_huff_decode

; 1613 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1614 : 	unsigned int temp;
; 1615 : 	int c, k;
; 1616 : 
; 1617 : 	if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18212], 16
	jge	SHORT $LN5@stbi__jpeg
	mov	rcx, QWORD PTR j$[rsp]
	call	?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
	npad	1
$LN5@stbi__jpeg:

; 1618 : 
; 1619 : 	// look at the top FAST_BITS and determine what symbol ID it is,
; 1620 : 	// if the code is <= FAST_BITS
; 1621 : 	c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS) - 1);

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shr	eax, 23
	and	eax, 511				; 000001ffH
	mov	DWORD PTR c$[rsp], eax

; 1622 : 	k = h->fast[c];

	movsxd	rax, DWORD PTR c$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR k$[rsp], eax

; 1623 : 	if (k < 255) {

	cmp	DWORD PTR k$[rsp], 255			; 000000ffH
	jge	$LN6@stbi__jpeg

; 1624 : 		int s = h->size[k];

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1280]
	mov	DWORD PTR s$1[rsp], eax

; 1625 : 		if (s > j->code_bits)

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	cmp	DWORD PTR s$1[rsp], eax
	jle	SHORT $LN7@stbi__jpeg

; 1626 : 			return -1;

	mov	eax, -1
	jmp	$LN1@stbi__jpeg
$LN7@stbi__jpeg:

; 1627 : 		j->code_buffer <<= s;

	mov	eax, DWORD PTR s$1[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR tv180[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv180[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shl	eax, cl
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1628 : 		j->code_bits -= s;

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR s$1[rsp]
	mov	eax, DWORD PTR [rax+18212]
	sub	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1629 : 		return h->values[k];

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1024]
	jmp	$LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 1630 : 	}
; 1631 : 
; 1632 : 	// naive test is to shift the code_buffer down so k bits are
; 1633 : 	// valid, then test against maxcode. To speed this up, we've
; 1634 : 	// preshifted maxcode left so that it has (16-k) 0s at the
; 1635 : 	// end; in other words, regardless of the number of bits, it
; 1636 : 	// wants to be compared against something shifted to have 16;
; 1637 : 	// that way we don't need to shift inside the loop.
; 1638 : 	temp = j->code_buffer >> 16;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shr	eax, 16
	mov	DWORD PTR temp$[rsp], eax

; 1639 : 	for (k = FAST_BITS + 1; ; ++k)

	mov	DWORD PTR k$[rsp], 10
	jmp	SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 1640 : 		if (temp < h->maxcode[k])

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4+1540]
	cmp	DWORD PTR temp$[rsp], eax
	jae	SHORT $LN8@stbi__jpeg

; 1641 : 			break;

	jmp	SHORT $LN3@stbi__jpeg
$LN8@stbi__jpeg:
	jmp	SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 1642 : 	if (k == 17) {

	cmp	DWORD PTR k$[rsp], 17
	jne	SHORT $LN9@stbi__jpeg

; 1643 : 		// error! code not found
; 1644 : 		j->code_bits -= 16;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	sub	eax, 16
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1645 : 		return -1;

	mov	eax, -1
	jmp	$LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 1646 : 	}
; 1647 : 
; 1648 : 	if (k > j->code_bits)

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	cmp	DWORD PTR k$[rsp], eax
	jle	SHORT $LN10@stbi__jpeg

; 1649 : 		return -1;

	mov	eax, -1
	jmp	$LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 1650 : 
; 1651 : 	// convert the huffman code to the symbol id
; 1652 : 	c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

	mov	eax, 32					; 00000020H
	sub	eax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR tv201[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv201[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shr	eax, cl
	movsxd	rcx, DWORD PTR k$[rsp]
	lea	rdx, OFFSET FLAT:?stbi__bmask@@3PAIA
	and	eax, DWORD PTR [rdx+rcx*4]
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR h$[rsp]
	add	eax, DWORD PTR [rdx+rcx*4+1612]
	mov	DWORD PTR c$[rsp], eax

; 1653 : 	STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
; 1654 : 
; 1655 : 	// convert the id to a symbol
; 1656 : 	j->code_bits -= k;

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR k$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	sub	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1657 : 	j->code_buffer <<= k;

	mov	eax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR j$[rsp]
	mov	QWORD PTR tv211[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv211[rsp]
	mov	eax, DWORD PTR [rax+18208]
	shl	eax, cl
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1658 : 	return h->values[c];

	movsxd	rax, DWORD PTR c$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1024]
$LN1@stbi__jpeg:

; 1659 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ENDP ; stbi__jpeg_huff_decode
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv70 = 32
c$1 = 36
b$2 = 40
j$ = 64
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z PROC	; stbi__grow_buffer_unsafe

; 1592 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN4@stbi__grow:

; 1593 : 	do {
; 1594 : 		int b = j->nomore ? 0 : stbi__get8(j->s);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18220], 0
	je	SHORT $LN8@stbi__grow
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN9@stbi__grow
$LN8@stbi__grow:
	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tv70[rsp], eax
$LN9@stbi__grow:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR b$2[rsp], eax

; 1595 : 		if (b == 0xff) {

	cmp	DWORD PTR b$2[rsp], 255			; 000000ffH
	jne	SHORT $LN5@stbi__grow

; 1596 : 			int c = stbi__get8(j->s);

	mov	rax, QWORD PTR j$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR c$1[rsp], eax

; 1597 : 			if (c != 0) {

	cmp	DWORD PTR c$1[rsp], 0
	je	SHORT $LN6@stbi__grow

; 1598 : 				j->marker = (unsigned char)c;

	mov	rax, QWORD PTR j$[rsp]
	movzx	ecx, BYTE PTR c$1[rsp]
	mov	BYTE PTR [rax+18216], cl

; 1599 : 				j->nomore = 1;

	mov	rax, QWORD PTR j$[rsp]
	mov	DWORD PTR [rax+18220], 1

; 1600 : 				return;

	jmp	SHORT $LN1@stbi__grow
$LN6@stbi__grow:
$LN5@stbi__grow:

; 1601 : 			}
; 1602 : 		}
; 1603 : 		j->code_buffer |= b << (24 - j->code_bits);

	mov	rax, QWORD PTR j$[rsp]
	mov	ecx, 24
	sub	ecx, DWORD PTR [rax+18212]
	mov	eax, ecx
	movzx	ecx, al
	mov	eax, DWORD PTR b$2[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR j$[rsp]
	mov	ecx, DWORD PTR [rcx+18208]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18208], eax

; 1604 : 		j->code_bits += 8;

	mov	rax, QWORD PTR j$[rsp]
	mov	eax, DWORD PTR [rax+18212]
	add	eax, 8
	mov	rcx, QWORD PTR j$[rsp]
	mov	DWORD PTR [rcx+18212], eax

; 1605 : 	} while (j->code_bits <= 24);

	mov	rax, QWORD PTR j$[rsp]
	cmp	DWORD PTR [rax+18212], 24
	jle	$LN4@stbi__grow
$LN1@stbi__grow:

; 1606 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ENDP	; stbi__grow_buffer_unsafe
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
fast$1 = 0
i$ = 4
k$2 = 8
magbits$3 = 12
len$4 = 16
rs$5 = 20
tv173 = 24
m$6 = 28
tv177 = 32
run$7 = 36
fast_ac$ = 64
h$ = 72
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z PROC	; stbi__build_fast_ac

; 1567 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1568 : 	int i;
; 1569 : 	for (i = 0; i < (1 << FAST_BITS); ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__buil
$LN2@stbi__buil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
	cmp	DWORD PTR i$[rsp], 512			; 00000200H
	jge	$LN3@stbi__buil

; 1570 : 		stbi_uc fast = h->fast[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR fast$1[rsp], al

; 1571 : 		fast_ac[i] = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	xor	ecx, ecx
	mov	rdx, QWORD PTR fast_ac$[rsp]
	mov	WORD PTR [rdx+rax*2], cx

; 1572 : 		if (fast < 255) {

	movzx	eax, BYTE PTR fast$1[rsp]
	cmp	eax, 255				; 000000ffH
	jge	$LN5@stbi__buil

; 1573 : 			int rs = h->values[fast];

	movzx	eax, BYTE PTR fast$1[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1024]
	mov	DWORD PTR rs$5[rsp], eax

; 1574 : 			int run = (rs >> 4) & 15;

	mov	eax, DWORD PTR rs$5[rsp]
	sar	eax, 4
	and	eax, 15
	mov	DWORD PTR run$7[rsp], eax

; 1575 : 			int magbits = rs & 15;

	mov	eax, DWORD PTR rs$5[rsp]
	and	eax, 15
	mov	DWORD PTR magbits$3[rsp], eax

; 1576 : 			int len = h->size[fast];

	movzx	eax, BYTE PTR fast$1[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1280]
	mov	DWORD PTR len$4[rsp], eax

; 1577 : 
; 1578 : 			if (magbits && len + magbits <= FAST_BITS) {

	cmp	DWORD PTR magbits$3[rsp], 0
	je	$LN6@stbi__buil
	mov	eax, DWORD PTR magbits$3[rsp]
	mov	ecx, DWORD PTR len$4[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, 9
	jg	$LN6@stbi__buil

; 1579 : 				// magnitude code followed by receive_extend code
; 1580 : 				int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

	mov	eax, DWORD PTR len$4[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR i$[rsp]
	shl	eax, cl
	and	eax, 511				; 000001ffH
	mov	ecx, 9
	sub	ecx, DWORD PTR magbits$3[rsp]
	sar	eax, cl
	mov	DWORD PTR k$2[rsp], eax

; 1581 : 				int m = 1 << (magbits - 1);

	mov	eax, DWORD PTR magbits$3[rsp]
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv173[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv173[rsp]
	shl	eax, cl
	mov	DWORD PTR m$6[rsp], eax

; 1582 : 				if (k < m) k += (-1 << magbits) + 1;

	mov	eax, DWORD PTR m$6[rsp]
	cmp	DWORD PTR k$2[rsp], eax
	jge	SHORT $LN7@stbi__buil
	mov	eax, DWORD PTR magbits$3[rsp]
	mov	ecx, -1
	mov	DWORD PTR tv177[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv177[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR k$2[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR k$2[rsp], eax
$LN7@stbi__buil:

; 1583 : 				// if the result is small enough, we can fit it in fast_ac table
; 1584 : 				if (k >= -128 && k <= 127)

	cmp	DWORD PTR k$2[rsp], -128		; ffffffffffffff80H
	jl	SHORT $LN8@stbi__buil
	cmp	DWORD PTR k$2[rsp], 127			; 0000007fH
	jg	SHORT $LN8@stbi__buil

; 1585 : 					fast_ac[i] = (stbi__int16)((k << 8) + (run << 4) + (len + magbits));

	mov	eax, DWORD PTR k$2[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR run$7[rsp]
	shl	ecx, 4
	add	eax, ecx
	mov	ecx, DWORD PTR magbits$3[rsp]
	mov	edx, DWORD PTR len$4[rsp]
	add	edx, ecx
	mov	ecx, edx
	add	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR fast_ac$[rsp]
	mov	WORD PTR [rdx+rcx*2], ax
$LN8@stbi__buil:
$LN6@stbi__buil:
$LN5@stbi__buil:

; 1586 : 			}
; 1587 : 		}
; 1588 : 	}

	jmp	$LN2@stbi__buil
$LN3@stbi__buil:

; 1589 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z ENDP	; stbi__build_fast_ac
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
j$ = 32
k$ = 36
i$ = 40
code$ = 44
tv140 = 48
s$1 = 52
tv231 = 56
m$2 = 60
c$3 = 64
h$ = 96
count$ = 104
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z PROC	; stbi__build_huffman

; 1524 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1525 : 	int i, j, k = 0, code;

	mov	DWORD PTR k$[rsp], 0

; 1526 : 	// build size list for each symbol (from JPEG spec)
; 1527 : 	for (i = 0; i < 16; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__buil
$LN2@stbi__buil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
	cmp	DWORD PTR i$[rsp], 16
	jge	SHORT $LN3@stbi__buil

; 1528 : 		for (j = 0; j < count[i]; ++j)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN7@stbi__buil
$LN5@stbi__buil:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN7@stbi__buil:
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR count$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	cmp	DWORD PTR j$[rsp], eax
	jge	SHORT $LN6@stbi__buil

; 1529 : 			h->size[k++] = (stbi_uc)(i + 1);

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	movsxd	rcx, DWORD PTR k$[rsp]
	mov	rdx, QWORD PTR h$[rsp]
	mov	BYTE PTR [rdx+rcx+1280], al
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN5@stbi__buil
$LN6@stbi__buil:
	jmp	SHORT $LN2@stbi__buil
$LN3@stbi__buil:

; 1530 : 	h->size[k] = 0;

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	mov	BYTE PTR [rcx+rax+1280], 0

; 1531 : 
; 1532 : 	// compute actual symbols (from jpeg spec)
; 1533 : 	code = 0;

	mov	DWORD PTR code$[rsp], 0

; 1534 : 	k = 0;

	mov	DWORD PTR k$[rsp], 0

; 1535 : 	for (j = 1; j <= 16; ++j) {

	mov	DWORD PTR j$[rsp], 1
	jmp	SHORT $LN10@stbi__buil
$LN8@stbi__buil:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN10@stbi__buil:
	cmp	DWORD PTR j$[rsp], 16
	jg	$LN9@stbi__buil

; 1536 : 		// compute delta to add to code to compute symbol id
; 1537 : 		h->delta[j] = k - code;

	mov	eax, DWORD PTR code$[rsp]
	mov	ecx, DWORD PTR k$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR h$[rsp]
	mov	DWORD PTR [rdx+rcx*4+1612], eax

; 1538 : 		if (h->size[k] == j) {

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1280]
	cmp	eax, DWORD PTR j$[rsp]
	jne	SHORT $LN19@stbi__buil
$LN11@stbi__buil:

; 1539 : 			while (h->size[k] == j)

	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1280]
	cmp	eax, DWORD PTR j$[rsp]
	jne	SHORT $LN12@stbi__buil

; 1540 : 				h->code[k++] = (stbi__uint16)(code++);

	movzx	eax, WORD PTR code$[rsp]
	mov	WORD PTR tv140[rsp], ax
	mov	eax, DWORD PTR code$[rsp]
	inc	eax
	mov	DWORD PTR code$[rsp], eax
	movsxd	rax, DWORD PTR k$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	edx, WORD PTR tv140[rsp]
	mov	WORD PTR [rcx+rax*2+512], dx
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
	jmp	SHORT $LN11@stbi__buil
$LN12@stbi__buil:

; 1541 : 			if (code - 1 >= (1 << j)) return stbi__err("bad code lengths", "Corrupt JPEG");

	mov	eax, DWORD PTR code$[rsp]
	dec	eax
	mov	ecx, DWORD PTR j$[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	cmp	eax, ecx
	jl	SHORT $LN20@stbi__buil
	xor	eax, eax
	jmp	$LN1@stbi__buil
$LN20@stbi__buil:
$LN19@stbi__buil:

; 1542 : 		}
; 1543 : 		// compute largest code + 1 for this size, preshifted as needed later
; 1544 : 		h->maxcode[j] = code << (16 - j);

	mov	eax, 16
	sub	eax, DWORD PTR j$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR code$[rsp]
	shl	eax, cl
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR h$[rsp]
	mov	DWORD PTR [rdx+rcx*4+1540], eax

; 1545 : 		code <<= 1;

	mov	eax, DWORD PTR code$[rsp]
	shl	eax, 1
	mov	DWORD PTR code$[rsp], eax

; 1546 : 	}

	jmp	$LN8@stbi__buil
$LN9@stbi__buil:

; 1547 : 	h->maxcode[j] = 0xffffffff;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	mov	DWORD PTR [rcx+rax*4+1540], -1		; ffffffffH

; 1548 : 
; 1549 : 	// build non-spec acceleration table; 255 is flag for not-accelerated
; 1550 : 	memset(h->fast, 255, 1 << FAST_BITS);

	mov	rax, QWORD PTR h$[rsp]
	mov	r8d, 512				; 00000200H
	mov	edx, 255				; 000000ffH
	mov	rcx, rax
	call	memset
	npad	1

; 1551 : 	for (i = 0; i < k; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN15@stbi__buil
$LN13@stbi__buil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN15@stbi__buil:
	mov	eax, DWORD PTR k$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN14@stbi__buil

; 1552 : 		int s = h->size[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+1280]
	mov	DWORD PTR s$1[rsp], eax

; 1553 : 		if (s <= FAST_BITS) {

	cmp	DWORD PTR s$1[rsp], 9
	jg	SHORT $LN21@stbi__buil

; 1554 : 			int c = h->code[i] << (FAST_BITS - s);

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR h$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2+512]
	mov	ecx, 9
	sub	ecx, DWORD PTR s$1[rsp]
	shl	eax, cl
	mov	DWORD PTR c$3[rsp], eax

; 1555 : 			int m = 1 << (FAST_BITS - s);

	mov	eax, 9
	sub	eax, DWORD PTR s$1[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv231[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv231[rsp]
	shl	eax, cl
	mov	DWORD PTR m$2[rsp], eax

; 1556 : 			for (j = 0; j < m; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN18@stbi__buil
$LN16@stbi__buil:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN18@stbi__buil:
	mov	eax, DWORD PTR m$2[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	SHORT $LN17@stbi__buil

; 1557 : 				h->fast[c + j] = (stbi_uc)i;

	mov	eax, DWORD PTR j$[rsp]
	mov	ecx, DWORD PTR c$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR h$[rsp]
	movzx	edx, BYTE PTR i$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 1558 : 			}

	jmp	SHORT $LN16@stbi__buil
$LN17@stbi__buil:
$LN21@stbi__buil:

; 1559 : 		}
; 1560 : 	}

	jmp	$LN13@stbi__buil
$LN14@stbi__buil:

; 1561 : 	return 1;

	mov	eax, 1
$LN1@stbi__buil:

; 1562 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ENDP	; stbi__build_huffman
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 32
dest$1 = 40
src$2 = 48
j$ = 56
tv84 = 60
tv248 = 64
tv268 = 68
tv290 = 72
tv310 = 76
good$ = 80
data$ = 112
img_n$ = 120
req_comp$ = 128
x$ = 136
y$ = 144
?stbi__convert_format@@YAPEAEPEAEHHII@Z PROC		; stbi__convert_format

; 1345 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1346 : 	int i, j;
; 1347 : 	unsigned char* good;
; 1348 : 
; 1349 : 	if (req_comp == img_n) return data;

	mov	eax, DWORD PTR img_n$[rsp]
	cmp	DWORD PTR req_comp$[rsp], eax
	jne	SHORT $LN43@stbi__conv
	mov	rax, QWORD PTR data$[rsp]
	jmp	$LN1@stbi__conv
$LN43@stbi__conv:

; 1350 : 	STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
; 1351 : 
; 1352 : 	good = (unsigned char*)stbi__malloc(req_comp * x * y);

	mov	eax, DWORD PTR req_comp$[rsp]
	imul	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR good$[rsp], rax

; 1353 : 	if (good == NULL) {

	cmp	QWORD PTR good$[rsp], 0
	jne	SHORT $LN44@stbi__conv

; 1354 : 		STBI_FREE(data);

	mov	rcx, QWORD PTR data$[rsp]
	call	free

; 1355 : 		return stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax
	jmp	$LN1@stbi__conv
$LN44@stbi__conv:

; 1356 : 	}
; 1357 : 
; 1358 : 	for (j = 0; j < (int)y; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN4@stbi__conv
$LN2@stbi__conv:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN4@stbi__conv:
	mov	eax, DWORD PTR y$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN3@stbi__conv

; 1359 : 		unsigned char* src = data + j * x * img_n;

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR img_n$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR src$2[rsp], rax

; 1360 : 		unsigned char* dest = good + j * x * req_comp;

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR req_comp$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR good$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dest$1[rsp], rax

; 1361 : 
; 1362 : #define COMBO(a,b)  ((a)*8+(b))
; 1363 : #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1364 : 		// convert source image with img_n components to one with req_comp components;
; 1365 : 		// avoid switch per pixel, so use switch per scanline and massive macros
; 1366 : 		switch (COMBO(img_n, req_comp)) {

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	ecx, DWORD PTR img_n$[rsp]
	lea	eax, DWORD PTR [rax+rcx*8]
	mov	DWORD PTR tv84[rsp], eax
	mov	eax, DWORD PTR tv84[rsp]
	sub	eax, 10
	mov	DWORD PTR tv84[rsp], eax
	cmp	DWORD PTR tv84[rsp], 25
	ja	$LN57@stbi__conv
	movsxd	rax, DWORD PTR tv84[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN59@stbi__conv[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN45@stbi__conv:

; 1367 : 			CASE(1, 2) dest[0] = src[0], dest[1] = 255; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN9@stbi__conv
$LN7@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	inc	rax
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 2
	mov	QWORD PTR dest$1[rsp], rax
$LN9@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN8@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	jmp	SHORT $LN7@stbi__conv
$LN8@stbi__conv:
	jmp	$LN5@stbi__conv
$LN46@stbi__conv:

; 1368 : 			CASE(1, 3) dest[0] = dest[1] = dest[2] = src[0]; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN12@stbi__conv
$LN10@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	inc	rax
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 3
	mov	QWORD PTR dest$1[rsp], rax
$LN12@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN11@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN10@stbi__conv
$LN11@stbi__conv:
	jmp	$LN5@stbi__conv
$LN47@stbi__conv:

; 1369 : 			CASE(1, 4) dest[0] = dest[1] = dest[2] = src[0], dest[3] = 255; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN15@stbi__conv
$LN13@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	inc	rax
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 4
	mov	QWORD PTR dest$1[rsp], rax
$LN15@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	$LN14@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	jmp	$LN13@stbi__conv
$LN14@stbi__conv:
	jmp	$LN5@stbi__conv
$LN48@stbi__conv:

; 1370 : 			CASE(2, 1) dest[0] = src[0]; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN18@stbi__conv
$LN16@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 2
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	inc	rax
	mov	QWORD PTR dest$1[rsp], rax
$LN18@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN17@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN16@stbi__conv
$LN17@stbi__conv:
	jmp	$LN5@stbi__conv
$LN49@stbi__conv:

; 1371 : 			CASE(2, 3) dest[0] = dest[1] = dest[2] = src[0]; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN21@stbi__conv
$LN19@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 2
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 3
	mov	QWORD PTR dest$1[rsp], rax
$LN21@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN20@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN19@stbi__conv
$LN20@stbi__conv:
	jmp	$LN5@stbi__conv
$LN50@stbi__conv:

; 1372 : 			CASE(2, 4) dest[0] = dest[1] = dest[2] = src[0], dest[3] = src[1]; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN24@stbi__conv
$LN22@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 2
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 4
	mov	QWORD PTR dest$1[rsp], rax
$LN24@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	$LN23@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR dest$1[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN22@stbi__conv
$LN23@stbi__conv:
	jmp	$LN5@stbi__conv
$LN51@stbi__conv:

; 1373 : 			CASE(3, 4) dest[0] = src[0], dest[1] = src[1], dest[2] = src[2], dest[3] = 255; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN27@stbi__conv
$LN25@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 3
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 4
	mov	QWORD PTR dest$1[rsp], rax
$LN27@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	$LN26@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 3
	mov	rcx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	jmp	$LN25@stbi__conv
$LN26@stbi__conv:
	jmp	$LN5@stbi__conv
$LN52@stbi__conv:

; 1374 : 			CASE(3, 1) dest[0] = stbi__compute_y(src[0], src[1], src[2]); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN30@stbi__conv
$LN28@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 3
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	inc	rax
	mov	QWORD PTR dest$1[rsp], rax
$LN30@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN29@stbi__conv
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR src$2[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR src$2[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	mov	DWORD PTR tv248[rsp], edx
	mov	r8d, eax
	mov	edx, ecx
	mov	eax, DWORD PTR tv248[rsp]
	mov	ecx, eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN28@stbi__conv
$LN29@stbi__conv:
	jmp	$LN5@stbi__conv
$LN53@stbi__conv:

; 1375 : 			CASE(3, 2) dest[0] = stbi__compute_y(src[0], src[1], src[2]), dest[1] = 255; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN33@stbi__conv
$LN31@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 3
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 2
	mov	QWORD PTR dest$1[rsp], rax
$LN33@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN32@stbi__conv
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR src$2[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR src$2[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	mov	DWORD PTR tv268[rsp], edx
	mov	r8d, eax
	mov	edx, ecx
	mov	eax, DWORD PTR tv268[rsp]
	mov	ecx, eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	jmp	$LN31@stbi__conv
$LN32@stbi__conv:
	jmp	$LN5@stbi__conv
$LN54@stbi__conv:

; 1376 : 			CASE(4, 1) dest[0] = stbi__compute_y(src[0], src[1], src[2]); break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN36@stbi__conv
$LN34@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 4
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	inc	rax
	mov	QWORD PTR dest$1[rsp], rax
$LN36@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN35@stbi__conv
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR src$2[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR src$2[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	mov	DWORD PTR tv290[rsp], edx
	mov	r8d, eax
	mov	edx, ecx
	mov	eax, DWORD PTR tv290[rsp]
	mov	ecx, eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN34@stbi__conv
$LN35@stbi__conv:
	jmp	$LN5@stbi__conv
$LN55@stbi__conv:

; 1377 : 			CASE(4, 2) dest[0] = stbi__compute_y(src[0], src[1], src[2]), dest[1] = src[3]; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN39@stbi__conv
$LN37@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 4
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 2
	mov	QWORD PTR dest$1[rsp], rax
$LN39@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	$LN38@stbi__conv
	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR src$2[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR src$2[rsp]
	movzx	edx, BYTE PTR [r8+rdx]
	mov	DWORD PTR tv310[rsp], edx
	mov	r8d, eax
	mov	edx, ecx
	mov	eax, DWORD PTR tv310[rsp]
	mov	ecx, eax
	call	?stbi__compute_y@@YAEHHH@Z		; stbi__compute_y
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 3
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN37@stbi__conv
$LN38@stbi__conv:
	jmp	$LN5@stbi__conv
$LN56@stbi__conv:

; 1378 : 			CASE(4, 3) dest[0] = src[0], dest[1] = src[1], dest[2] = src[2]; break;

	mov	eax, DWORD PTR x$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN42@stbi__conv
$LN40@stbi__conv:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR src$2[rsp]
	add	rax, 4
	mov	QWORD PTR src$2[rsp], rax
	mov	rax, QWORD PTR dest$1[rsp]
	add	rax, 3
	mov	QWORD PTR dest$1[rsp], rax
$LN42@stbi__conv:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN41@stbi__conv
	mov	eax, 1
	imul	rax, rax, 0
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 1
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR dest$1[rsp]
	mov	r8, QWORD PTR src$2[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	$LN40@stbi__conv
$LN41@stbi__conv:
$LN57@stbi__conv:
$LN5@stbi__conv:

; 1379 : 		default: STBI_ASSERT(0);
; 1380 : 		}
; 1381 : #undef CASE
; 1382 : 	}

	jmp	$LN2@stbi__conv
$LN3@stbi__conv:

; 1383 : 
; 1384 : 	STBI_FREE(data);

	mov	rcx, QWORD PTR data$[rsp]
	call	free

; 1385 : 	return good;

	mov	rax, QWORD PTR good$[rsp]
$LN1@stbi__conv:

; 1386 : }

	add	rsp, 104				; 00000068H
	ret	0
	npad	2
$LN59@stbi__conv:
	DD	$LN45@stbi__conv
	DD	$LN46@stbi__conv
	DD	$LN47@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN48@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN49@stbi__conv
	DD	$LN50@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN52@stbi__conv
	DD	$LN53@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN51@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN57@stbi__conv
	DD	$LN54@stbi__conv
	DD	$LN55@stbi__conv
	DD	$LN56@stbi__conv
?stbi__convert_format@@YAPEAEPEAEHHII@Z ENDP		; stbi__convert_format
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
?stbi__compute_y@@YAEHHH@Z PROC				; stbi__compute_y

; 1340 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 1341 : 	return (stbi_uc)(((r * 77) + (g * 150) + (29 * b)) >> 8);

	imul	eax, DWORD PTR r$[rsp], 77		; 0000004dH
	imul	ecx, DWORD PTR g$[rsp], 150		; 00000096H
	add	eax, ecx
	imul	ecx, DWORD PTR b$[rsp], 29
	add	eax, ecx
	sar	eax, 8

; 1342 : }

	ret	0
?stbi__compute_y@@YAEHHH@Z ENDP				; stbi__compute_y
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
z$ = 32
s$ = 64
?stbi__get32le@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32le

; 1319 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1320 : 	stbi__uint32 z = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR z$[rsp], eax

; 1321 : 	return z + (stbi__get16le(s) << 16);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	shl	eax, 16
	mov	ecx, DWORD PTR z$[rsp]
	add	ecx, eax
	mov	eax, ecx

; 1322 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__get32le@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32le
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
z$ = 32
s$ = 64
?stbi__get16le@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16le

; 1311 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1312 : 	int z = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR z$[rsp], eax

; 1313 : 	return z + (stbi__get8(s) << 8);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	shl	eax, 8
	mov	ecx, DWORD PTR z$[rsp]
	add	ecx, eax
	mov	eax, ecx

; 1314 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__get16le@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16le
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
z$ = 32
tv66 = 36
s$ = 64
?stbi__get32be@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32be

; 1302 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1303 : 	stbi__uint32 z = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR z$[rsp], eax

; 1304 : 	return (z << 16) + stbi__get16be(s);

	mov	eax, DWORD PTR z$[rsp]
	shl	eax, 16
	mov	DWORD PTR tv66[rsp], eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	ecx, DWORD PTR tv66[rsp]
	add	ecx, eax
	mov	eax, ecx

; 1305 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__get32be@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32be
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
z$ = 32
tv67 = 36
s$ = 64
?stbi__get16be@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16be

; 1296 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1297 : 	int z = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR z$[rsp], eax

; 1298 : 	return (z << 8) + stbi__get8(s);

	mov	eax, DWORD PTR z$[rsp]
	shl	eax, 8
	mov	DWORD PTR tv67[rsp], eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	ecx, DWORD PTR tv67[rsp]
	add	ecx, eax
	mov	eax, ecx

; 1299 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__get16be@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16be
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
tv91 = 36
count$2 = 40
res$3 = 44
tv88 = 48
s$ = 80
buffer$ = 88
n$ = 96
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z PROC		; stbi__getn

; 1271 : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1272 : 	if (s->io.read) {

	mov	rax, QWORD PTR s$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	$LN2@stbi__getn

; 1273 : 		int blen = (int)(s->img_buffer_end - s->img_buffer);

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	rax, QWORD PTR [rax+192]
	sub	rax, rcx
	mov	DWORD PTR blen$1[rsp], eax

; 1274 : 		if (blen < n) {

	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR blen$1[rsp], eax
	jge	$LN3@stbi__getn

; 1275 : 			int res, count;
; 1276 : 
; 1277 : 			memcpy(buffer, s->img_buffer, blen);

	movsxd	rax, DWORD PTR blen$1[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR s$[rsp]
	mov	rdx, QWORD PTR [rax+184]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1278 : 
; 1279 : 			count = (s->io.read)(s->io_user_data, (char*)buffer + blen, n - blen);

	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv88[rsp], rax
	mov	eax, DWORD PTR blen$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR blen$1[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	QWORD PTR tv88[rsp]
	mov	DWORD PTR count$2[rsp], eax

; 1280 : 			res = (count == (n - blen));

	mov	eax, DWORD PTR blen$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR count$2[rsp], eax
	jne	SHORT $LN7@stbi__getn
	mov	DWORD PTR tv91[rsp], 1
	jmp	SHORT $LN8@stbi__getn
$LN7@stbi__getn:
	mov	DWORD PTR tv91[rsp], 0
$LN8@stbi__getn:
	mov	eax, DWORD PTR tv91[rsp]
	mov	DWORD PTR res$3[rsp], eax

; 1281 : 			s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+192]
	mov	QWORD PTR [rax+184], rcx

; 1282 : 			return res;

	mov	eax, DWORD PTR res$3[rsp]
	jmp	SHORT $LN1@stbi__getn
$LN3@stbi__getn:
$LN2@stbi__getn:

; 1283 : 		}
; 1284 : 	}
; 1285 : 
; 1286 : 	if (s->img_buffer + n <= s->img_buffer_end) {

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	add	rax, QWORD PTR [rcx+184]
	mov	rcx, QWORD PTR s$[rsp]
	cmp	rax, QWORD PTR [rcx+192]
	ja	SHORT $LN4@stbi__getn

; 1287 : 		memcpy(buffer, s->img_buffer, n);

	movsxd	rax, DWORD PTR n$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR s$[rsp]
	mov	rdx, QWORD PTR [rax+184]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1288 : 		s->img_buffer += n;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	add	rax, QWORD PTR [rcx+184]
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+184], rax

; 1289 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@stbi__getn

; 1290 : 	}

	jmp	SHORT $LN5@stbi__getn
$LN4@stbi__getn:

; 1291 : 	else
; 1292 : 		return 0;

	xor	eax, eax
$LN5@stbi__getn:
$LN1@stbi__getn:

; 1293 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ENDP		; stbi__getn
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
tv84 = 40
s$ = 64
n$ = 72
?stbi__skip@@YAXPEAUstbi__context@@H@Z PROC		; stbi__skip

; 1254 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1255 : 	if (n < 0) {

	cmp	DWORD PTR n$[rsp], 0
	jge	SHORT $LN2@stbi__skip

; 1256 : 		s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+192]
	mov	QWORD PTR [rax+184], rcx

; 1257 : 		return;

	jmp	$LN1@stbi__skip
$LN2@stbi__skip:

; 1258 : 	}
; 1259 : 	if (s->io.read) {

	mov	rax, QWORD PTR s$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN3@stbi__skip

; 1260 : 		int blen = (int)(s->img_buffer_end - s->img_buffer);

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	rax, QWORD PTR [rax+192]
	sub	rax, rcx
	mov	DWORD PTR blen$1[rsp], eax

; 1261 : 		if (blen < n) {

	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR blen$1[rsp], eax
	jge	SHORT $LN4@stbi__skip

; 1262 : 			s->img_buffer = s->img_buffer_end;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+192]
	mov	QWORD PTR [rax+184], rcx

; 1263 : 			(s->io.skip)(s->io_user_data, n - blen);

	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv84[rsp], rax
	mov	eax, DWORD PTR blen$1[rsp]
	mov	ecx, DWORD PTR n$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	QWORD PTR tv84[rsp]
	npad	1

; 1264 : 			return;

	jmp	SHORT $LN1@stbi__skip
$LN4@stbi__skip:
$LN3@stbi__skip:

; 1265 : 		}
; 1266 : 	}
; 1267 : 	s->img_buffer += n;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	add	rax, QWORD PTR [rcx+184]
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+184], rax
$LN1@stbi__skip:

; 1268 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__skip@@YAXPEAUstbi__context@@H@Z ENDP		; stbi__skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv80 = 32
tv73 = 40
s$ = 64
?stbi__at_eof@@YAHPEAUstbi__context@@@Z PROC		; stbi__at_eof

; 1242 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1243 : 	if (s->io.read) {

	mov	rax, QWORD PTR s$[rsp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN2@stbi__at_e

; 1244 : 		if (!(s->io.eof)(s->io_user_data)) return 0;

	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	QWORD PTR tv73[rsp]
	test	eax, eax
	jne	SHORT $LN3@stbi__at_e
	xor	eax, eax
	jmp	SHORT $LN1@stbi__at_e
$LN3@stbi__at_e:

; 1245 : 		// if feof() is true, check if buffer = end
; 1246 : 		// special case: we've only got the special 0 character at the end
; 1247 : 		if (s->read_from_callbacks == 0) return 1;

	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+48], 0
	jne	SHORT $LN4@stbi__at_e
	mov	eax, 1
	jmp	SHORT $LN1@stbi__at_e
$LN4@stbi__at_e:
$LN2@stbi__at_e:

; 1248 : 	}
; 1249 : 
; 1250 : 	return s->img_buffer >= s->img_buffer_end;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+192]
	cmp	QWORD PTR [rax+184], rcx
	jb	SHORT $LN6@stbi__at_e
	mov	DWORD PTR tv80[rsp], 1
	jmp	SHORT $LN7@stbi__at_e
$LN6@stbi__at_e:
	mov	DWORD PTR tv80[rsp], 0
$LN7@stbi__at_e:
	mov	eax, DWORD PTR tv80[rsp]
$LN1@stbi__at_e:

; 1251 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__at_eof@@YAHPEAUstbi__context@@@Z ENDP		; stbi__at_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv72 = 32
tv81 = 33
s$ = 64
?stbi__get8@@YAEPEAUstbi__context@@@Z PROC		; stbi__get8

; 1231 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1232 : 	if (s->img_buffer < s->img_buffer_end)

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+192]
	cmp	QWORD PTR [rax+184], rcx
	jae	SHORT $LN2@stbi__get8

; 1233 : 		return *s->img_buffer++;

	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+184]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv72[rsp], al
	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+184]
	inc	rax
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+184], rax
	movzx	eax, BYTE PTR tv72[rsp]
	jmp	SHORT $LN1@stbi__get8
$LN2@stbi__get8:

; 1234 : 	if (s->read_from_callbacks) {

	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+48], 0
	je	SHORT $LN3@stbi__get8

; 1235 : 		stbi__refill_buffer(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1236 : 		return *s->img_buffer++;

	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+184]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv81[rsp], al
	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+184]
	inc	rax
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+184], rax
	movzx	eax, BYTE PTR tv81[rsp]
	jmp	SHORT $LN1@stbi__get8
$LN3@stbi__get8:

; 1237 : 	}
; 1238 : 	return 0;

	xor	al, al
$LN1@stbi__get8:

; 1239 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__get8@@YAEPEAUstbi__context@@@Z ENDP		; stbi__get8
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv88 = 48
hdr_data$1 = 56
data$ = 64
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z PROC ; stbi__loadf_main

; 1083 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1084 : 	unsigned char* data;
; 1085 : #ifndef STBI_NO_HDR
; 1086 : 	if (stbi__hdr_test(s)) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
	test	eax, eax
	je	SHORT $LN2@stbi__load

; 1087 : 		float* hdr_data = stbi__hdr_load(s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__hdr_load
	mov	QWORD PTR hdr_data$1[rsp], rax

; 1088 : 		if (hdr_data)

	cmp	QWORD PTR hdr_data$1[rsp], 0
	je	SHORT $LN3@stbi__load

; 1089 : 			stbi__float_postprocess(hdr_data, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR hdr_data$1[rsp]
	call	?stbi__float_postprocess@@YAXPEAMPEAH11H@Z ; stbi__float_postprocess
	npad	1
$LN3@stbi__load:

; 1090 : 		return hdr_data;

	mov	rax, QWORD PTR hdr_data$1[rsp]
	jmp	SHORT $LN1@stbi__load
$LN2@stbi__load:

; 1091 : 	}
; 1092 : #endif
; 1093 : 	data = stbi__load_flip(s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_flip
	mov	QWORD PTR data$[rsp], rax

; 1094 : 	if (data)

	cmp	QWORD PTR data$[rsp], 0
	je	SHORT $LN4@stbi__load

; 1095 : 		return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR tv88[rsp], eax
	jmp	SHORT $LN7@stbi__load
$LN6@stbi__load:
	mov	rax, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv88[rsp], eax
$LN7@stbi__load:
	mov	r9d, DWORD PTR tv88[rsp]
	mov	rax, QWORD PTR y$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR x$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR data$[rsp]
	call	?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z	; stbi__ldr_to_hdr
	jmp	SHORT $LN1@stbi__load
$LN4@stbi__load:

; 1096 : 	return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");

	xor	eax, eax
$LN1@stbi__load:

; 1097 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__loadf_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
f$ = 32
filename$ = 64
mode$ = 72
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z PROC		; stbi__fopen

; 1031 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1032 : 	FILE* f;
; 1033 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1034 : 	if (0 != fopen_s(&f, filename, mode))

	mov	r8, QWORD PTR mode$[rsp]
	mov	rdx, QWORD PTR filename$[rsp]
	lea	rcx, QWORD PTR f$[rsp]
	call	fopen_s
	test	eax, eax
	je	SHORT $LN2@stbi__fope

; 1035 : 		f = 0;

	mov	QWORD PTR f$[rsp], 0
$LN2@stbi__fope:

; 1036 : #else
; 1037 : 	f = fopen(filename, mode);
; 1038 : #endif
; 1039 : 	return f;

	mov	rax, QWORD PTR f$[rsp]

; 1040 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ENDP		; stbi__fopen
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
row$1 = 0
col$2 = 4
z$3 = 8
w$4 = 12
depth$5 = 16
h$6 = 20
tv67 = 24
temp$7 = 28
result$ = 48
x$ = 56
y$ = 64
comp$ = 72
req_comp$ = 80
?stbi__float_postprocess@@YAXPEAMPEAH11H@Z PROC		; stbi__float_postprocess

; 1007 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1008 : 	if (stbi__vertically_flip_on_load && result != NULL) {

	cmp	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, 0
	je	$LN11@stbi__floa
	cmp	QWORD PTR result$[rsp], 0
	je	$LN11@stbi__floa

; 1009 : 		int w = *x, h = *y;

	mov	rax, QWORD PTR x$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR w$4[rsp], eax
	mov	rax, QWORD PTR y$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR h$6[rsp], eax

; 1010 : 		int depth = req_comp ? req_comp : *comp;

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN13@stbi__floa
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN14@stbi__floa
$LN13@stbi__floa:
	mov	rax, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv67[rsp], eax
$LN14@stbi__floa:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR depth$5[rsp], eax

; 1011 : 		int row, col, z;
; 1012 : 		float temp;
; 1013 : 
; 1014 : 		// @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
; 1015 : 		for (row = 0; row < (h >> 1); row++) {

	mov	DWORD PTR row$1[rsp], 0
	jmp	SHORT $LN4@stbi__floa
$LN2@stbi__floa:
	mov	eax, DWORD PTR row$1[rsp]
	inc	eax
	mov	DWORD PTR row$1[rsp], eax
$LN4@stbi__floa:
	mov	eax, DWORD PTR h$6[rsp]
	sar	eax, 1
	cmp	DWORD PTR row$1[rsp], eax
	jge	$LN3@stbi__floa

; 1016 : 			for (col = 0; col < w; col++) {

	mov	DWORD PTR col$2[rsp], 0
	jmp	SHORT $LN7@stbi__floa
$LN5@stbi__floa:
	mov	eax, DWORD PTR col$2[rsp]
	inc	eax
	mov	DWORD PTR col$2[rsp], eax
$LN7@stbi__floa:
	mov	eax, DWORD PTR w$4[rsp]
	cmp	DWORD PTR col$2[rsp], eax
	jge	$LN6@stbi__floa

; 1017 : 				for (z = 0; z < depth; z++) {

	mov	DWORD PTR z$3[rsp], 0
	jmp	SHORT $LN10@stbi__floa
$LN8@stbi__floa:
	mov	eax, DWORD PTR z$3[rsp]
	inc	eax
	mov	DWORD PTR z$3[rsp], eax
$LN10@stbi__floa:
	mov	eax, DWORD PTR depth$5[rsp]
	cmp	DWORD PTR z$3[rsp], eax
	jge	$LN9@stbi__floa

; 1018 : 					temp = result[(row * w + col) * depth + z];

	mov	eax, DWORD PTR row$1[rsp]
	imul	eax, DWORD PTR w$4[rsp]
	add	eax, DWORD PTR col$2[rsp]
	imul	eax, DWORD PTR depth$5[rsp]
	add	eax, DWORD PTR z$3[rsp]
	cdqe
	mov	rcx, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4]
	movss	DWORD PTR temp$7[rsp], xmm0

; 1019 : 					result[(row * w + col) * depth + z] = result[((h - row - 1) * w + col) * depth + z];

	mov	eax, DWORD PTR row$1[rsp]
	mov	ecx, DWORD PTR h$6[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	imul	eax, DWORD PTR w$4[rsp]
	add	eax, DWORD PTR col$2[rsp]
	imul	eax, DWORD PTR depth$5[rsp]
	add	eax, DWORD PTR z$3[rsp]
	cdqe
	mov	ecx, DWORD PTR row$1[rsp]
	imul	ecx, DWORD PTR w$4[rsp]
	add	ecx, DWORD PTR col$2[rsp]
	imul	ecx, DWORD PTR depth$5[rsp]
	add	ecx, DWORD PTR z$3[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR result$[rsp]
	mov	r8, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR [r8+rax*4]
	movss	DWORD PTR [rdx+rcx*4], xmm0

; 1020 : 					result[((h - row - 1) * w + col) * depth + z] = temp;

	mov	eax, DWORD PTR row$1[rsp]
	mov	ecx, DWORD PTR h$6[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	imul	eax, DWORD PTR w$4[rsp]
	add	eax, DWORD PTR col$2[rsp]
	imul	eax, DWORD PTR depth$5[rsp]
	add	eax, DWORD PTR z$3[rsp]
	cdqe
	mov	rcx, QWORD PTR result$[rsp]
	movss	xmm0, DWORD PTR temp$7[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0

; 1021 : 				}

	jmp	$LN8@stbi__floa
$LN9@stbi__floa:

; 1022 : 			}

	jmp	$LN5@stbi__floa
$LN6@stbi__floa:

; 1023 : 		}

	jmp	$LN2@stbi__floa
$LN3@stbi__floa:
$LN11@stbi__floa:

; 1024 : 	}
; 1025 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__float_postprocess@@YAXPEAMPEAH11H@Z ENDP		; stbi__float_postprocess
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
temp$1 = 48
row$2 = 52
col$3 = 56
z$4 = 60
w$5 = 64
depth$6 = 68
h$7 = 72
result$ = 80
tv73 = 88
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
req_comp$ = 144
?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__load_flip

; 981  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 982  : 	unsigned char* result = stbi__load_main(s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_main
	mov	QWORD PTR result$[rsp], rax

; 983  : 
; 984  : 	if (stbi__vertically_flip_on_load && result != NULL) {

	cmp	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, 0
	je	$LN11@stbi__load
	cmp	QWORD PTR result$[rsp], 0
	je	$LN11@stbi__load

; 985  : 		int w = *x, h = *y;

	mov	rax, QWORD PTR x$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR w$5[rsp], eax
	mov	rax, QWORD PTR y$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR h$7[rsp], eax

; 986  : 		int depth = req_comp ? req_comp : *comp;

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN13@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN14@stbi__load
$LN13@stbi__load:
	mov	rax, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv73[rsp], eax
$LN14@stbi__load:
	mov	eax, DWORD PTR tv73[rsp]
	mov	DWORD PTR depth$6[rsp], eax

; 987  : 		int row, col, z;
; 988  : 		stbi_uc temp;
; 989  : 
; 990  : 		// @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
; 991  : 		for (row = 0; row < (h >> 1); row++) {

	mov	DWORD PTR row$2[rsp], 0
	jmp	SHORT $LN4@stbi__load
$LN2@stbi__load:
	mov	eax, DWORD PTR row$2[rsp]
	inc	eax
	mov	DWORD PTR row$2[rsp], eax
$LN4@stbi__load:
	mov	eax, DWORD PTR h$7[rsp]
	sar	eax, 1
	cmp	DWORD PTR row$2[rsp], eax
	jge	$LN3@stbi__load

; 992  : 			for (col = 0; col < w; col++) {

	mov	DWORD PTR col$3[rsp], 0
	jmp	SHORT $LN7@stbi__load
$LN5@stbi__load:
	mov	eax, DWORD PTR col$3[rsp]
	inc	eax
	mov	DWORD PTR col$3[rsp], eax
$LN7@stbi__load:
	mov	eax, DWORD PTR w$5[rsp]
	cmp	DWORD PTR col$3[rsp], eax
	jge	$LN6@stbi__load

; 993  : 				for (z = 0; z < depth; z++) {

	mov	DWORD PTR z$4[rsp], 0
	jmp	SHORT $LN10@stbi__load
$LN8@stbi__load:
	mov	eax, DWORD PTR z$4[rsp]
	inc	eax
	mov	DWORD PTR z$4[rsp], eax
$LN10@stbi__load:
	mov	eax, DWORD PTR depth$6[rsp]
	cmp	DWORD PTR z$4[rsp], eax
	jge	$LN9@stbi__load

; 994  : 					temp = result[(row * w + col) * depth + z];

	mov	eax, DWORD PTR row$2[rsp]
	imul	eax, DWORD PTR w$5[rsp]
	add	eax, DWORD PTR col$3[rsp]
	imul	eax, DWORD PTR depth$6[rsp]
	add	eax, DWORD PTR z$4[rsp]
	cdqe
	mov	rcx, QWORD PTR result$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR temp$1[rsp], al

; 995  : 					result[(row * w + col) * depth + z] = result[((h - row - 1) * w + col) * depth + z];

	mov	eax, DWORD PTR row$2[rsp]
	mov	ecx, DWORD PTR h$7[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	imul	eax, DWORD PTR w$5[rsp]
	add	eax, DWORD PTR col$3[rsp]
	imul	eax, DWORD PTR depth$6[rsp]
	add	eax, DWORD PTR z$4[rsp]
	cdqe
	mov	ecx, DWORD PTR row$2[rsp]
	imul	ecx, DWORD PTR w$5[rsp]
	add	ecx, DWORD PTR col$3[rsp]
	imul	ecx, DWORD PTR depth$6[rsp]
	add	ecx, DWORD PTR z$4[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR result$[rsp]
	mov	r8, QWORD PTR result$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 996  : 					result[((h - row - 1) * w + col) * depth + z] = temp;

	mov	eax, DWORD PTR row$2[rsp]
	mov	ecx, DWORD PTR h$7[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	imul	eax, DWORD PTR w$5[rsp]
	add	eax, DWORD PTR col$3[rsp]
	imul	eax, DWORD PTR depth$6[rsp]
	add	eax, DWORD PTR z$4[rsp]
	cdqe
	mov	rcx, QWORD PTR result$[rsp]
	movzx	edx, BYTE PTR temp$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 997  : 				}

	jmp	$LN8@stbi__load
$LN9@stbi__load:

; 998  : 			}

	jmp	$LN5@stbi__load
$LN6@stbi__load:

; 999  : 		}

	jmp	$LN2@stbi__load
$LN3@stbi__load:
$LN11@stbi__load:

; 1000 : 	}
; 1001 : 
; 1002 : 	return result;

	mov	rax, QWORD PTR result$[rsp]

; 1003 : }

	add	rsp, 104				; 00000068H
	ret	0
?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__load_flip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv170 = 48
hdr$1 = 56
s$ = 80
x$ = 88
y$ = 96
comp$ = 104
req_comp$ = 112
?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__load_main

; 941  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 942  : #ifndef STBI_NO_JPEG
; 943  : 	if (stbi__jpeg_test(s)) return stbi__jpeg_load(s, x, y, comp, req_comp);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z ; stbi__jpeg_test
	test	eax, eax
	je	SHORT $LN2@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__jpeg_load
	jmp	$LN1@stbi__load
$LN2@stbi__load:

; 944  : #endif
; 945  : #ifndef STBI_NO_PNG
; 946  : 	if (stbi__png_test(s))  return stbi__png_load(s, x, y, comp, req_comp);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__png_test@@YAHPEAUstbi__context@@@Z ; stbi__png_test
	test	eax, eax
	je	SHORT $LN3@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__png_load
	jmp	$LN1@stbi__load
$LN3@stbi__load:

; 947  : #endif
; 948  : #ifndef STBI_NO_BMP
; 949  : 	if (stbi__bmp_test(s))  return stbi__bmp_load(s, x, y, comp, req_comp);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__bmp_test@@YAHPEAUstbi__context@@@Z ; stbi__bmp_test
	test	eax, eax
	je	SHORT $LN4@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__bmp_load
	jmp	$LN1@stbi__load
$LN4@stbi__load:

; 950  : #endif
; 951  : #ifndef STBI_NO_GIF
; 952  : 	if (stbi__gif_test(s))  return stbi__gif_load(s, x, y, comp, req_comp);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_test@@YAHPEAUstbi__context@@@Z ; stbi__gif_test
	test	eax, eax
	je	SHORT $LN5@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__gif_load
	jmp	$LN1@stbi__load
$LN5@stbi__load:

; 953  : #endif
; 954  : #ifndef STBI_NO_PSD
; 955  : 	if (stbi__psd_test(s))  return stbi__psd_load(s, x, y, comp, req_comp);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__psd_test@@YAHPEAUstbi__context@@@Z ; stbi__psd_test
	test	eax, eax
	je	SHORT $LN6@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__psd_load
	jmp	$LN1@stbi__load
$LN6@stbi__load:

; 956  : #endif
; 957  : #ifndef STBI_NO_PIC
; 958  : 	if (stbi__pic_test(s))  return stbi__pic_load(s, x, y, comp, req_comp);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_test@@YAHPEAUstbi__context@@@Z ; stbi__pic_test
	test	eax, eax
	je	SHORT $LN7@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__pic_load
	jmp	$LN1@stbi__load
$LN7@stbi__load:

; 959  : #endif
; 960  : #ifndef STBI_NO_PNM
; 961  : 	if (stbi__pnm_test(s))  return stbi__pnm_load(s, x, y, comp, req_comp);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_test@@YAHPEAUstbi__context@@@Z ; stbi__pnm_test
	test	eax, eax
	je	SHORT $LN8@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__pnm_load
	jmp	$LN1@stbi__load
$LN8@stbi__load:

; 962  : #endif
; 963  : 
; 964  : #ifndef STBI_NO_HDR
; 965  : 	if (stbi__hdr_test(s)) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
	test	eax, eax
	je	SHORT $LN9@stbi__load

; 966  : 		float* hdr = stbi__hdr_load(s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__hdr_load
	mov	QWORD PTR hdr$1[rsp], rax

; 967  : 		return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN12@stbi__load
	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR tv170[rsp], eax
	jmp	SHORT $LN13@stbi__load
$LN12@stbi__load:
	mov	rax, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv170[rsp], eax
$LN13@stbi__load:
	mov	r9d, DWORD PTR tv170[rsp]
	mov	rax, QWORD PTR y$[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR x$[rsp]
	mov	edx, DWORD PTR [rax]
	mov	rcx, QWORD PTR hdr$1[rsp]
	call	?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z	; stbi__hdr_to_ldr
	jmp	SHORT $LN1@stbi__load
$LN9@stbi__load:

; 968  : 	}
; 969  : #endif
; 970  : 
; 971  : #ifndef STBI_NO_TGA
; 972  : 	// test tga last because it's a crappy test!
; 973  : 	if (stbi__tga_test(s))

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__tga_test@@YAHPEAUstbi__context@@@Z ; stbi__tga_test
	test	eax, eax
	je	SHORT $LN10@stbi__load

; 974  : 		return stbi__tga_load(s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__tga_load
	jmp	SHORT $LN1@stbi__load
$LN10@stbi__load:

; 975  : #endif
; 976  : 
; 977  : 	return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

	xor	eax, eax
$LN1@stbi__load:

; 978  : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__load_main@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__load_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
i$ = 36
z$1 = 40
z$2 = 44
n$ = 48
output$ = 56
data$ = 80
x$ = 88
y$ = 96
comp$ = 104
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z PROC			; stbi__hdr_to_ldr

; 1410 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1411 : 	int i, k, n;
; 1412 : 	stbi_uc* output = (stbi_uc*)stbi__malloc(x * y * comp);

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	cdqe
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR output$[rsp], rax

; 1413 : 	if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

	cmp	QWORD PTR output$[rsp], 0
	jne	SHORT $LN8@stbi__hdr_
	mov	rcx, QWORD PTR data$[rsp]
	call	free
	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN8@stbi__hdr_:

; 1414 : 	// compute number of non-alpha components
; 1415 : 	if (comp & 1) n = comp; else n = comp - 1;

	mov	eax, DWORD PTR comp$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@stbi__hdr_
	mov	eax, DWORD PTR comp$[rsp]
	mov	DWORD PTR n$[rsp], eax
	jmp	SHORT $LN10@stbi__hdr_
$LN9@stbi__hdr_:
	mov	eax, DWORD PTR comp$[rsp]
	dec	eax
	mov	DWORD PTR n$[rsp], eax
$LN10@stbi__hdr_:

; 1416 : 	for (i = 0; i < x * y; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbi__hdr_

; 1417 : 		for (k = 0; k < n; ++k) {

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN7@stbi__hdr_
$LN5@stbi__hdr_:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN7@stbi__hdr_:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	$LN6@stbi__hdr_

; 1418 : 			float z = (float)pow(data[i * comp + k] * stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;

	mov	eax, DWORD PTR i$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	add	eax, DWORD PTR k$[rsp]
	cdqe
	mov	rcx, QWORD PTR data$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4]
	mulss	xmm0, DWORD PTR ?stbi__h2l_scale_i@@3MA
	movss	xmm1, DWORD PTR ?stbi__h2l_gamma_i@@3MA
	call	?pow@@YAMMM@Z				; pow
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR z$1[rsp], xmm0

; 1419 : 			if (z < 0) z = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR z$1[rsp]
	jbe	SHORT $LN11@stbi__hdr_
	xorps	xmm0, xmm0
	movss	DWORD PTR z$1[rsp], xmm0
$LN11@stbi__hdr_:

; 1420 : 			if (z > 255) z = 255;

	movss	xmm0, DWORD PTR z$1[rsp]
	comiss	xmm0, DWORD PTR __real@437f0000
	jbe	SHORT $LN12@stbi__hdr_
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR z$1[rsp], xmm0
$LN12@stbi__hdr_:

; 1421 : 			output[i * comp + k] = (stbi_uc)stbi__float2int(z);

	cvttss2si eax, DWORD PTR z$1[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	imul	ecx, DWORD PTR comp$[rsp]
	add	ecx, DWORD PTR k$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR output$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 1422 : 		}

	jmp	$LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 1423 : 		if (k < comp) {

	mov	eax, DWORD PTR comp$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN13@stbi__hdr_

; 1424 : 			float z = data[i * comp + k] * 255 + 0.5f;

	mov	eax, DWORD PTR i$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	add	eax, DWORD PTR k$[rsp]
	cdqe
	mov	rcx, QWORD PTR data$[rsp]
	movss	xmm0, DWORD PTR [rcx+rax*4]
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR z$2[rsp], xmm0

; 1425 : 			if (z < 0) z = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR z$2[rsp]
	jbe	SHORT $LN14@stbi__hdr_
	xorps	xmm0, xmm0
	movss	DWORD PTR z$2[rsp], xmm0
$LN14@stbi__hdr_:

; 1426 : 			if (z > 255) z = 255;

	movss	xmm0, DWORD PTR z$2[rsp]
	comiss	xmm0, DWORD PTR __real@437f0000
	jbe	SHORT $LN15@stbi__hdr_
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR z$2[rsp], xmm0
$LN15@stbi__hdr_:

; 1427 : 			output[i * comp + k] = (stbi_uc)stbi__float2int(z);

	cvttss2si eax, DWORD PTR z$2[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	imul	ecx, DWORD PTR comp$[rsp]
	add	ecx, DWORD PTR k$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR output$[rsp]
	mov	BYTE PTR [rdx+rcx], al
$LN13@stbi__hdr_:

; 1428 : 		}
; 1429 : 	}

	jmp	$LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 1430 : 	STBI_FREE(data);

	mov	rcx, QWORD PTR data$[rsp]
	call	free

; 1431 : 	return output;

	mov	rax, QWORD PTR output$[rsp]
$LN1@stbi__hdr_:

; 1432 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z ENDP			; stbi__hdr_to_ldr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
k$ = 32
i$ = 36
n$ = 40
output$ = 48
data$ = 80
x$ = 88
y$ = 96
comp$ = 104
?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z PROC			; stbi__ldr_to_hdr

; 1390 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1391 : 	int i, k, n;
; 1392 : 	float* output = (float*)stbi__malloc(x * y * comp * sizeof(float));

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	cdqe
	shl	rax, 2
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR output$[rsp], rax

; 1393 : 	if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }

	cmp	QWORD PTR output$[rsp], 0
	jne	SHORT $LN8@stbi__ldr_
	mov	rcx, QWORD PTR data$[rsp]
	call	free
	xor	eax, eax
	jmp	$LN1@stbi__ldr_
$LN8@stbi__ldr_:

; 1394 : 	// compute number of non-alpha components
; 1395 : 	if (comp & 1) n = comp; else n = comp - 1;

	mov	eax, DWORD PTR comp$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@stbi__ldr_
	mov	eax, DWORD PTR comp$[rsp]
	mov	DWORD PTR n$[rsp], eax
	jmp	SHORT $LN10@stbi__ldr_
$LN9@stbi__ldr_:
	mov	eax, DWORD PTR comp$[rsp]
	dec	eax
	mov	DWORD PTR n$[rsp], eax
$LN10@stbi__ldr_:

; 1396 : 	for (i = 0; i < x * y; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__ldr_
$LN2@stbi__ldr_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__ldr_:
	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbi__ldr_

; 1397 : 		for (k = 0; k < n; ++k) {

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN7@stbi__ldr_
$LN5@stbi__ldr_:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN7@stbi__ldr_:
	mov	eax, DWORD PTR n$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN6@stbi__ldr_

; 1398 : 			output[i * comp + k] = (float)(pow(data[i * comp + k] / 255.0f, stbi__l2h_gamma) * stbi__l2h_scale);

	mov	eax, DWORD PTR i$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	add	eax, DWORD PTR k$[rsp]
	cdqe
	mov	rcx, QWORD PTR data$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR ?stbi__l2h_gamma@@3MA
	call	?pow@@YAMMM@Z				; pow
	mulss	xmm0, DWORD PTR ?stbi__l2h_scale@@3MA
	mov	eax, DWORD PTR i$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	add	eax, DWORD PTR k$[rsp]
	cdqe
	mov	rcx, QWORD PTR output$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0

; 1399 : 		}

	jmp	SHORT $LN5@stbi__ldr_
$LN6@stbi__ldr_:

; 1400 : 		if (k < comp) output[i * comp + k] = data[i * comp + k] / 255.0f;

	mov	eax, DWORD PTR comp$[rsp]
	cmp	DWORD PTR k$[rsp], eax
	jge	SHORT $LN11@stbi__ldr_
	mov	eax, DWORD PTR i$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	add	eax, DWORD PTR k$[rsp]
	cdqe
	mov	rcx, QWORD PTR data$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, DWORD PTR i$[rsp]
	imul	eax, DWORD PTR comp$[rsp]
	add	eax, DWORD PTR k$[rsp]
	cdqe
	mov	rcx, QWORD PTR output$[rsp]
	movss	DWORD PTR [rcx+rax*4], xmm0
$LN11@stbi__ldr_:

; 1401 : 	}

	jmp	$LN2@stbi__ldr_
$LN3@stbi__ldr_:

; 1402 : 	STBI_FREE(data);

	mov	rcx, QWORD PTR data$[rsp]
	call	free

; 1403 : 	return output;

	mov	rax, QWORD PTR output$[rsp]
$LN1@stbi__ldr_:

; 1404 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z ENDP			; stbi__ldr_to_hdr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
size$ = 48
?stbi__malloc@@YAPEAX_K@Z PROC				; stbi__malloc

; 901  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 902  : 	return STBI_MALLOC(size);

	mov	rcx, QWORD PTR size$[rsp]
	call	malloc

; 903  : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__malloc@@YAPEAX_K@Z ENDP				; stbi__malloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
c$ = 32
t$ = 33
p$ = 34
tv78 = 36
maxv$ = 40
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__pnm_info

; 6327 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6328 : 	int maxv;
; 6329 : 	char c, p, t;
; 6330 : 
; 6331 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6332 : 
; 6333 : 	// Get identifier
; 6334 : 	p = (char)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR p$[rsp], al

; 6335 : 	t = (char)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR t$[rsp], al

; 6336 : 	if (p != 'P' || (t != '5' && t != '6')) {

	movsx	eax, BYTE PTR p$[rsp]
	cmp	eax, 80					; 00000050H
	jne	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR t$[rsp]
	cmp	eax, 53					; 00000035H
	je	SHORT $LN2@stbi__pnm_
	movsx	eax, BYTE PTR t$[rsp]
	cmp	eax, 54					; 00000036H
	je	SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 6337 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6338 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 6339 : 	}
; 6340 : 
; 6341 : 	*comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

	movsx	eax, BYTE PTR t$[rsp]
	cmp	eax, 54					; 00000036H
	jne	SHORT $LN7@stbi__pnm_
	mov	DWORD PTR tv78[rsp], 3
	jmp	SHORT $LN8@stbi__pnm_
$LN7@stbi__pnm_:
	mov	DWORD PTR tv78[rsp], 1
$LN8@stbi__pnm_:
	mov	rax, QWORD PTR comp$[rsp]
	mov	ecx, DWORD PTR tv78[rsp]
	mov	DWORD PTR [rax], ecx

; 6342 : 
; 6343 : 	c = (char)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR c$[rsp], al

; 6344 : 	stbi__pnm_skip_whitespace(s, &c);

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 6345 : 
; 6346 : 	*x = stbi__pnm_getinteger(s, &c); // read width

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
	mov	rcx, QWORD PTR x$[rsp]
	mov	DWORD PTR [rcx], eax

; 6347 : 	stbi__pnm_skip_whitespace(s, &c);

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 6348 : 
; 6349 : 	*y = stbi__pnm_getinteger(s, &c); // read height

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
	mov	rcx, QWORD PTR y$[rsp]
	mov	DWORD PTR [rcx], eax

; 6350 : 	stbi__pnm_skip_whitespace(s, &c);

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 6351 : 
; 6352 : 	maxv = stbi__pnm_getinteger(s, &c);  // read max value

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
	mov	DWORD PTR maxv$[rsp], eax

; 6353 : 
; 6354 : 	if (maxv > 255)

	cmp	DWORD PTR maxv$[rsp], 255		; 000000ffH
	jle	SHORT $LN4@stbi__pnm_

; 6355 : 		return stbi__err("max value > 255", "PPM image not 8-bit");

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pnm_
	jmp	SHORT $LN5@stbi__pnm_
$LN4@stbi__pnm_:

; 6356 : 	else
; 6357 : 		return 1;

	mov	eax, 1
$LN5@stbi__pnm_:
$LN1@stbi__pnm_:

; 6358 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__pnm_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
out$ = 48
s$ = 80
x$ = 88
y$ = 96
comp$ = 104
req_comp$ = 112
?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__pnm_load

; 6279 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 6280 : 	stbi_uc* out;
; 6281 : 	if (!stbi__pnm_info(s, (int*)&s->img_x, (int*)&s->img_y, (int*)&s->img_n))

	mov	rax, QWORD PTR s$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR s$[rsp]
	add	rcx, 4
	mov	rdx, QWORD PTR s$[rsp]
	mov	r9, rax
	mov	r8, rcx
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
	test	eax, eax
	jne	SHORT $LN2@stbi__pnm_

; 6282 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 6283 : 	*x = s->img_x;

	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx

; 6284 : 	*y = s->img_y;

	mov	rax, QWORD PTR y$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax], ecx

; 6285 : 	*comp = s->img_n;

	mov	rax, QWORD PTR comp$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx

; 6286 : 
; 6287 : 	out = (stbi_uc*)stbi__malloc(s->img_n * s->img_x * s->img_y);

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	imul	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR out$[rsp], rax

; 6288 : 	if (!out) return stbi__errpuc("outofmem", "Out of memory");

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN3@stbi__pnm_
	xor	eax, eax
	jmp	$LN1@stbi__pnm_
$LN3@stbi__pnm_:

; 6289 : 	stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	imul	eax, DWORD PTR [rcx]
	mov	rcx, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	mov	r8d, eax
	mov	rdx, QWORD PTR out$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	npad	1

; 6290 : 
; 6291 : 	if (req_comp && req_comp != s->img_n) {

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN4@stbi__pnm_
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR req_comp$[rsp], eax
	je	SHORT $LN4@stbi__pnm_

; 6292 : 		out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR s$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	rax, QWORD PTR s$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR out$[rsp]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	mov	QWORD PTR out$[rsp], rax

; 6293 : 		if (out == NULL) return out; // stbi__convert_format frees input on failure

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN5@stbi__pnm_
	mov	rax, QWORD PTR out$[rsp]
	jmp	SHORT $LN1@stbi__pnm_
$LN5@stbi__pnm_:
$LN4@stbi__pnm_:

; 6294 : 	}
; 6295 : 	return out;

	mov	rax, QWORD PTR out$[rsp]
$LN1@stbi__pnm_:

; 6296 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__pnm_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__pnm_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
t$ = 32
p$ = 33
s$ = 64
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pnm_test

; 6267 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6268 : 	char p, t;
; 6269 : 	p = (char)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR p$[rsp], al

; 6270 : 	t = (char)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR t$[rsp], al

; 6271 : 	if (p != 'P' || (t != '5' && t != '6')) {

	movsx	eax, BYTE PTR p$[rsp]
	cmp	eax, 80					; 00000050H
	jne	SHORT $LN3@stbi__pnm_
	movsx	eax, BYTE PTR t$[rsp]
	cmp	eax, 53					; 00000035H
	je	SHORT $LN2@stbi__pnm_
	movsx	eax, BYTE PTR t$[rsp]
	cmp	eax, 54					; 00000036H
	je	SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 6272 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6273 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 6274 : 	}
; 6275 : 	return 1;

	mov	eax, 1
$LN1@stbi__pnm_:

; 6276 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pnm_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__gif_info

; 5903 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5904 : 	return stbi__gif_info_raw(s, x, y, comp);

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__gif_info_raw

; 5905 : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__gif_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
u$ = 48
g$ = 64
__$ArrayPad$ = 18592
s$ = 18624
x$ = 18632
y$ = 18640
comp$ = 18648
req_comp$ = 18656
?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__gif_load

; 5883 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 18616				; 000048b8H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5884 : 	stbi_uc* u = 0;

	mov	QWORD PTR u$[rsp], 0

; 5885 : 	stbi__gif g;
; 5886 : 	memset(&g, 0, sizeof(g));

	mov	r8d, 18528				; 00004860H
	xor	edx, edx
	lea	rcx, QWORD PTR g$[rsp]
	call	memset

; 5887 : 
; 5888 : 	u = stbi__gif_load_next(s, &g, comp, req_comp);

	mov	r9d, DWORD PTR req_comp$[rsp]
	mov	r8, QWORD PTR comp$[rsp]
	lea	rdx, QWORD PTR g$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_load_next
	mov	QWORD PTR u$[rsp], rax

; 5889 : 	if (u == (stbi_uc*)s) u = 0;  // end of animated gif marker

	mov	rax, QWORD PTR s$[rsp]
	cmp	QWORD PTR u$[rsp], rax
	jne	SHORT $LN2@stbi__gif_
	mov	QWORD PTR u$[rsp], 0
$LN2@stbi__gif_:

; 5890 : 	if (u) {

	cmp	QWORD PTR u$[rsp], 0
	je	SHORT $LN3@stbi__gif_

; 5891 : 		*x = g.w;

	mov	rax, QWORD PTR x$[rsp]
	mov	ecx, DWORD PTR g$[rsp]
	mov	DWORD PTR [rax], ecx

; 5892 : 		*y = g.h;

	mov	rax, QWORD PTR y$[rsp]
	mov	ecx, DWORD PTR g$[rsp+4]
	mov	DWORD PTR [rax], ecx

; 5893 : 		if (req_comp && req_comp != 4)

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN5@stbi__gif_
	cmp	DWORD PTR req_comp$[rsp], 4
	je	SHORT $LN5@stbi__gif_

; 5894 : 			u = stbi__convert_format(u, 4, req_comp, g.w, g.h);

	mov	eax, DWORD PTR g$[rsp+4]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR g$[rsp]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR u$[rsp]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	mov	QWORD PTR u$[rsp], rax
$LN5@stbi__gif_:

; 5895 : 	}

	jmp	SHORT $LN4@stbi__gif_
$LN3@stbi__gif_:

; 5896 : 	else if (g.out)

	cmp	QWORD PTR g$[rsp+8], 0
	je	SHORT $LN6@stbi__gif_

; 5897 : 		STBI_FREE(g.out);

	mov	rcx, QWORD PTR g$[rsp+8]
	call	free
	npad	1
$LN6@stbi__gif_:
$LN4@stbi__gif_:

; 5898 : 
; 5899 : 	return u;

	mov	rax, QWORD PTR u$[rsp]

; 5900 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 18616				; 000048b8H
	ret	0
?stbi__gif_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__gif_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__gif_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__gif_test

; 5570 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5571 : 	int r = stbi__gif_test_raw(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__gif_test_raw
	mov	DWORD PTR r$[rsp], eax

; 5572 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 5573 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 5574 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__gif_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__gif_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
num_packets$ = 32
act_comp$ = 36
tv151 = 40
packet$1 = 48
chained$ = 56
tv92 = 64
packets$ = 72
__$ArrayPad$ = 104
s$ = 128
x$ = 136
y$ = 144
comp$ = 152
?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__pic_info

; 6199 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6200 : 	int act_comp = 0, num_packets = 0, chained;

	mov	DWORD PTR act_comp$[rsp], 0
	mov	DWORD PTR num_packets$[rsp], 0

; 6201 : 	stbi__pic_packet packets[10];
; 6202 : 
; 6203 : 	if (!stbi__pic_is4(s, "\x53\x80\xF6\x34")) {

	lea	rdx, OFFSET FLAT:??_C@_04KBFEPHFH@S?$IA?v4@
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
	test	eax, eax
	jne	SHORT $LN5@stbi__pic_

; 6204 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6205 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN5@stbi__pic_:

; 6206 : 	}
; 6207 : 
; 6208 : 	stbi__skip(s, 88);

	mov	edx, 88					; 00000058H
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 6209 : 
; 6210 : 	*x = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, QWORD PTR x$[rsp]
	mov	DWORD PTR [rcx], eax

; 6211 : 	*y = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	rcx, QWORD PTR y$[rsp]
	mov	DWORD PTR [rcx], eax

; 6212 : 	if (stbi__at_eof(s)) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN6@stbi__pic_

; 6213 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6214 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN6@stbi__pic_:

; 6215 : 	}
; 6216 : 	if ((*x) != 0 && (1 << 28) / (*x) < (*y)) {

	mov	rax, QWORD PTR x$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN7@stbi__pic_
	mov	eax, 268435456				; 10000000H
	cdq
	mov	rcx, QWORD PTR x$[rsp]
	idiv	DWORD PTR [rcx]
	mov	rcx, QWORD PTR y$[rsp]
	cmp	eax, DWORD PTR [rcx]
	jge	SHORT $LN7@stbi__pic_

; 6217 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6218 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN7@stbi__pic_:

; 6219 : 	}
; 6220 : 
; 6221 : 	stbi__skip(s, 8);

	mov	edx, 8
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1
$LN4@stbi__pic_:

; 6222 : 
; 6223 : 	do {
; 6224 : 		stbi__pic_packet* packet;
; 6225 : 
; 6226 : 		if (num_packets == sizeof(packets) / sizeof(packets[0]))

	movsxd	rax, DWORD PTR num_packets$[rsp]
	cmp	rax, 10
	jne	SHORT $LN8@stbi__pic_

; 6227 : 			return 0;

	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN8@stbi__pic_:

; 6228 : 
; 6229 : 		packet = &packets[num_packets++];

	movsxd	rax, DWORD PTR num_packets$[rsp]
	imul	rax, rax, 3
	lea	rax, QWORD PTR packets$[rsp+rax]
	mov	QWORD PTR tv92[rsp], rax
	mov	eax, DWORD PTR num_packets$[rsp]
	inc	eax
	mov	DWORD PTR num_packets$[rsp], eax
	mov	rax, QWORD PTR tv92[rsp]
	mov	QWORD PTR packet$1[rsp], rax

; 6230 : 		chained = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR chained$[rsp], eax

; 6231 : 		packet->size = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR packet$1[rsp]
	mov	BYTE PTR [rcx], al

; 6232 : 		packet->type = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR packet$1[rsp]
	mov	BYTE PTR [rcx+1], al

; 6233 : 		packet->channel = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR packet$1[rsp]
	mov	BYTE PTR [rcx+2], al

; 6234 : 		act_comp |= packet->channel;

	mov	rax, QWORD PTR packet$1[rsp]
	movzx	eax, BYTE PTR [rax+2]
	mov	ecx, DWORD PTR act_comp$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR act_comp$[rsp], eax

; 6235 : 
; 6236 : 		if (stbi__at_eof(s)) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN9@stbi__pic_

; 6237 : 			stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6238 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN9@stbi__pic_:

; 6239 : 		}
; 6240 : 		if (packet->size != 8) {

	mov	rax, QWORD PTR packet$1[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 8
	je	SHORT $LN10@stbi__pic_

; 6241 : 			stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6242 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__pic_
$LN10@stbi__pic_:

; 6243 : 		}
; 6244 : 	} while (chained);

	cmp	DWORD PTR chained$[rsp], 0
	jne	$LN4@stbi__pic_

; 6245 : 
; 6246 : 	*comp = (act_comp & 0x10 ? 4 : 3);

	mov	eax, DWORD PTR act_comp$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN12@stbi__pic_
	mov	DWORD PTR tv151[rsp], 4
	jmp	SHORT $LN13@stbi__pic_
$LN12@stbi__pic_:
	mov	DWORD PTR tv151[rsp], 3
$LN13@stbi__pic_:
	mov	rax, QWORD PTR comp$[rsp]
	mov	ecx, DWORD PTR tv151[rsp]
	mov	DWORD PTR [rax], ecx

; 6247 : 
; 6248 : 	return 1;

	mov	eax, 1
$LN1@stbi__pic_:

; 6249 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__pic_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
y$ = 48
x$ = 52
i$ = 56
result$ = 64
s$ = 96
px$ = 104
py$ = 112
comp$ = 120
req_comp$ = 128
?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__pic_load

; 5491 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 5492 : 	stbi_uc* result;
; 5493 : 	int i, x, y;
; 5494 : 
; 5495 : 	for (i = 0; i < 92; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
	cmp	DWORD PTR i$[rsp], 92			; 0000005cH
	jge	SHORT $LN3@stbi__pic_

; 5496 : 		stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	npad	1
	jmp	SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 5497 : 
; 5498 : 	x = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR x$[rsp], eax

; 5499 : 	y = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR y$[rsp], eax

; 5500 : 	if (stbi__at_eof(s))  return stbi__errpuc("bad file", "file too short (pic header)");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__at_eof@@YAHPEAUstbi__context@@@Z	; stbi__at_eof
	test	eax, eax
	je	SHORT $LN5@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN5@stbi__pic_:

; 5501 : 	if ((1 << 28) / x < y) return stbi__errpuc("too large", "Image too large to decode");

	mov	eax, 268435456				; 10000000H
	cdq
	idiv	DWORD PTR x$[rsp]
	cmp	eax, DWORD PTR y$[rsp]
	jge	SHORT $LN6@stbi__pic_
	xor	eax, eax
	jmp	$LN1@stbi__pic_
$LN6@stbi__pic_:

; 5502 : 
; 5503 : 	stbi__get32be(s); //skip `ratio'

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 5504 : 	stbi__get16be(s); //skip `fields'

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 5505 : 	stbi__get16be(s); //skip `pad'

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 5506 : 
; 5507 : 	// intermediate buffer is RGBA
; 5508 : 	result = (stbi_uc*)stbi__malloc(x * y * 4);

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	shl	eax, 2
	cdqe
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR result$[rsp], rax

; 5509 : 	memset(result, 0xff, x * y * 4);

	mov	eax, DWORD PTR x$[rsp]
	imul	eax, DWORD PTR y$[rsp]
	shl	eax, 2
	cdqe
	mov	r8, rax
	mov	edx, 255				; 000000ffH
	mov	rcx, QWORD PTR result$[rsp]
	call	memset
	npad	1

; 5510 : 
; 5511 : 	if (!stbi__pic_load_core(s, x, y, comp, result)) {

	mov	rax, QWORD PTR result$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8d, DWORD PTR y$[rsp]
	mov	edx, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ; stbi__pic_load_core
	test	rax, rax
	jne	SHORT $LN7@stbi__pic_

; 5512 : 		STBI_FREE(result);

	mov	rcx, QWORD PTR result$[rsp]
	call	free

; 5513 : 		result = 0;

	mov	QWORD PTR result$[rsp], 0
$LN7@stbi__pic_:

; 5514 : 	}
; 5515 : 	*px = x;

	mov	rax, QWORD PTR px$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rax], ecx

; 5516 : 	*py = y;

	mov	rax, QWORD PTR py$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rax], ecx

; 5517 : 	if (req_comp == 0) req_comp = *comp;

	cmp	DWORD PTR req_comp$[rsp], 0
	jne	SHORT $LN8@stbi__pic_
	mov	rax, QWORD PTR comp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR req_comp$[rsp], eax
$LN8@stbi__pic_:

; 5518 : 	result = stbi__convert_format(result, 4, req_comp, x, y);

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR x$[rsp]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR result$[rsp]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	mov	QWORD PTR result$[rsp], rax

; 5519 : 
; 5520 : 	return result;

	mov	rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 5521 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__pic_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__pic_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__pic_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pic_test

; 5524 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5525 : 	int r = stbi__pic_test_core(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z ; stbi__pic_test_core
	mov	DWORD PTR r$[rsp], eax

; 5526 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 5527 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 5528 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__pic_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pic_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
token$ = 32
valid$ = 40
buffer$ = 48
__$ArrayPad$ = 1072
s$ = 1104
x$ = 1112
y$ = 1120
comp$ = 1128
?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__hdr_info

; 6094 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1096				; 00000448H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6095 : 	char buffer[STBI__HDR_BUFLEN];
; 6096 : 	char* token;
; 6097 : 	int valid = 0;

	mov	DWORD PTR valid$[rsp], 0

; 6098 : 
; 6099 : 	if (strcmp(stbi__hdr_gettoken(s, buffer), "#?RADIANCE") != 0) {

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	lea	rdx, OFFSET FLAT:??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	je	SHORT $LN7@stbi__hdr_

; 6100 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6101 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN7@stbi__hdr_:
$LN2@stbi__hdr_:

; 6102 : 	}
; 6103 : 
; 6104 : 	for (;;) {
; 6105 : 		token = stbi__hdr_gettoken(s, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	mov	QWORD PTR token$[rsp], rax

; 6106 : 		if (token[0] == 0) break;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR token$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN8@stbi__hdr_
	jmp	SHORT $LN3@stbi__hdr_
$LN8@stbi__hdr_:

; 6107 : 		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

	lea	rdx, OFFSET FLAT:??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
	mov	rcx, QWORD PTR token$[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN9@stbi__hdr_
	mov	DWORD PTR valid$[rsp], 1
$LN9@stbi__hdr_:

; 6108 : 	}

	jmp	SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6109 : 
; 6110 : 	if (!valid) {

	cmp	DWORD PTR valid$[rsp], 0
	jne	SHORT $LN10@stbi__hdr_

; 6111 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6112 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN10@stbi__hdr_:

; 6113 : 	}
; 6114 : 	token = stbi__hdr_gettoken(s, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	mov	QWORD PTR token$[rsp], rax

; 6115 : 	if (strncmp(token, "-Y ", 3)) {

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03HKAKGGJN@?9Y?5@
	mov	rcx, QWORD PTR token$[rsp]
	call	strncmp
	test	eax, eax
	je	SHORT $LN11@stbi__hdr_

; 6116 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6117 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN11@stbi__hdr_:

; 6118 : 	}
; 6119 : 	token += 3;

	mov	rax, QWORD PTR token$[rsp]
	add	rax, 3
	mov	QWORD PTR token$[rsp], rax

; 6120 : 	*y = (int)strtol(token, &token, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR token$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	strtol
	mov	rcx, QWORD PTR y$[rsp]
	mov	DWORD PTR [rcx], eax
$LN5@stbi__hdr_:

; 6121 : 	while (*token == ' ') ++token;

	mov	rax, QWORD PTR token$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@stbi__hdr_
	mov	rax, QWORD PTR token$[rsp]
	inc	rax
	mov	QWORD PTR token$[rsp], rax
	jmp	SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 6122 : 	if (strncmp(token, "+X ", 3)) {

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03FOKDFDHG@?$CLX?5@
	mov	rcx, QWORD PTR token$[rsp]
	call	strncmp
	test	eax, eax
	je	SHORT $LN12@stbi__hdr_

; 6123 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6124 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__hdr_
$LN12@stbi__hdr_:

; 6125 : 	}
; 6126 : 	token += 3;

	mov	rax, QWORD PTR token$[rsp]
	add	rax, 3
	mov	QWORD PTR token$[rsp], rax

; 6127 : 	*x = (int)strtol(token, NULL, 10);

	mov	r8d, 10
	xor	edx, edx
	mov	rcx, QWORD PTR token$[rsp]
	call	strtol
	mov	rcx, QWORD PTR x$[rsp]
	mov	DWORD PTR [rcx], eax

; 6128 : 	*comp = 3;

	mov	rax, QWORD PTR comp$[rsp]
	mov	DWORD PTR [rax], 3

; 6129 : 	return 1;

	mov	eax, 1
$LN1@stbi__hdr_:

; 6130 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1096				; 00000448H
	ret	0
?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__hdr_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
count$ = 32
i$ = 36
width$ = 40
j$ = 44
value$ = 48
len$ = 52
z$ = 56
token$ = 64
k$ = 72
height$ = 76
rgbe$1 = 80
scanline$ = 88
valid$ = 96
c1$ = 100
c2$ = 104
hdr_data$ = 112
rgbe$2 = 120
buffer$ = 128
__$ArrayPad$ = 1152
s$ = 1184
x$ = 1192
y$ = 1200
comp$ = 1208
req_comp$ = 1216
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z PROC ; stbi__hdr_load

; 5981 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1176				; 00000498H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5982 : 	char buffer[STBI__HDR_BUFLEN];
; 5983 : 	char* token;
; 5984 : 	int valid = 0;

	mov	DWORD PTR valid$[rsp], 0

; 5985 : 	int width, height;
; 5986 : 	stbi_uc* scanline;
; 5987 : 	float* hdr_data;
; 5988 : 	int len;
; 5989 : 	unsigned char count, value;
; 5990 : 	int i, j, k, c1, c2, z;
; 5991 : 
; 5992 : 
; 5993 : 	// Check identifier
; 5994 : 	if (strcmp(stbi__hdr_gettoken(s, buffer), "#?RADIANCE") != 0)

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	lea	rdx, OFFSET FLAT:??_C@_0L@NCPEAJBD@?$CD?$DPRADIANCE@
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	je	SHORT $LN30@stbi__hdr_

; 5995 : 		return stbi__errpf("not HDR", "Corrupt HDR image");

	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN30@stbi__hdr_:
$LN2@stbi__hdr_:

; 5996 : 
; 5997 : 	// Parse header
; 5998 : 	for (;;) {
; 5999 : 		token = stbi__hdr_gettoken(s, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	mov	QWORD PTR token$[rsp], rax

; 6000 : 		if (token[0] == 0) break;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR token$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN31@stbi__hdr_
	jmp	SHORT $LN3@stbi__hdr_
$LN31@stbi__hdr_:

; 6001 : 		if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

	lea	rdx, OFFSET FLAT:??_C@_0BH@JFGBLLKC@FORMAT?$DN32?9bit_rle_rgbe@
	mov	rcx, QWORD PTR token$[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN32@stbi__hdr_
	mov	DWORD PTR valid$[rsp], 1
$LN32@stbi__hdr_:

; 6002 : 	}

	jmp	SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 6003 : 
; 6004 : 	if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

	cmp	DWORD PTR valid$[rsp], 0
	jne	SHORT $LN33@stbi__hdr_
	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN33@stbi__hdr_:

; 6005 : 
; 6006 : 	// Parse width and height
; 6007 : 	// can't use sscanf() if we're not using stdio!
; 6008 : 	token = stbi__hdr_gettoken(s, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
	mov	QWORD PTR token$[rsp], rax

; 6009 : 	if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03HKAKGGJN@?9Y?5@
	mov	rcx, QWORD PTR token$[rsp]
	call	strncmp
	test	eax, eax
	je	SHORT $LN34@stbi__hdr_
	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN34@stbi__hdr_:

; 6010 : 	token += 3;

	mov	rax, QWORD PTR token$[rsp]
	add	rax, 3
	mov	QWORD PTR token$[rsp], rax

; 6011 : 	height = (int)strtol(token, &token, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR token$[rsp]
	mov	rcx, QWORD PTR token$[rsp]
	call	strtol
	mov	DWORD PTR height$[rsp], eax
$LN5@stbi__hdr_:

; 6012 : 	while (*token == ' ') ++token;

	mov	rax, QWORD PTR token$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@stbi__hdr_
	mov	rax, QWORD PTR token$[rsp]
	inc	rax
	mov	QWORD PTR token$[rsp], rax
	jmp	SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 6013 : 	if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03FOKDFDHG@?$CLX?5@
	mov	rcx, QWORD PTR token$[rsp]
	call	strncmp
	test	eax, eax
	je	SHORT $LN35@stbi__hdr_
	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN35@stbi__hdr_:

; 6014 : 	token += 3;

	mov	rax, QWORD PTR token$[rsp]
	add	rax, 3
	mov	QWORD PTR token$[rsp], rax

; 6015 : 	width = (int)strtol(token, NULL, 10);

	mov	r8d, 10
	xor	edx, edx
	mov	rcx, QWORD PTR token$[rsp]
	call	strtol
	mov	DWORD PTR width$[rsp], eax

; 6016 : 
; 6017 : 	*x = width;

	mov	rax, QWORD PTR x$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax], ecx

; 6018 : 	*y = height;

	mov	rax, QWORD PTR y$[rsp]
	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax], ecx

; 6019 : 
; 6020 : 	if (comp) *comp = 3;

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN36@stbi__hdr_
	mov	rax, QWORD PTR comp$[rsp]
	mov	DWORD PTR [rax], 3
$LN36@stbi__hdr_:

; 6021 : 	if (req_comp == 0) req_comp = 3;

	cmp	DWORD PTR req_comp$[rsp], 0
	jne	SHORT $LN37@stbi__hdr_
	mov	DWORD PTR req_comp$[rsp], 3
$LN37@stbi__hdr_:

; 6022 : 
; 6023 : 	// Read data
; 6024 : 	hdr_data = (float*)stbi__malloc(height * width * req_comp * sizeof(float));

	mov	eax, DWORD PTR height$[rsp]
	imul	eax, DWORD PTR width$[rsp]
	imul	eax, DWORD PTR req_comp$[rsp]
	cdqe
	shl	rax, 2
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR hdr_data$[rsp], rax

; 6025 : 
; 6026 : 	// Load image data
; 6027 : 	// image data is stored as some number of sca
; 6028 : 	if (width < 8 || width >= 32768) {

	cmp	DWORD PTR width$[rsp], 8
	jl	SHORT $LN40@stbi__hdr_
	cmp	DWORD PTR width$[rsp], 32768		; 00008000H
	jl	$LN38@stbi__hdr_
$LN40@stbi__hdr_:

; 6029 : 		// Read flat data
; 6030 : 		for (j = 0; j < height; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN9@stbi__hdr_
$LN7@stbi__hdr_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN9@stbi__hdr_:
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN8@stbi__hdr_

; 6031 : 			for (i = 0; i < width; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN12@stbi__hdr_
$LN10@stbi__hdr_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN12@stbi__hdr_:
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN11@stbi__hdr_
$main_decode_loop$48:

; 6032 : 				stbi_uc rgbe[4];
; 6033 : 			main_decode_loop:
; 6034 : 				stbi__getn(s, rgbe, 4);

	mov	r8d, 4
	lea	rdx, QWORD PTR rgbe$2[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn

; 6035 : 				stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR width$[rsp]
	imul	eax, DWORD PTR req_comp$[rsp]
	cdqe
	mov	rcx, QWORD PTR hdr_data$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	ecx, DWORD PTR i$[rsp]
	imul	ecx, DWORD PTR req_comp$[rsp]
	movsxd	rcx, ecx
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	r8d, DWORD PTR req_comp$[rsp]
	lea	rdx, QWORD PTR rgbe$2[rsp]
	mov	rcx, rax
	call	?stbi__hdr_convert@@YAXPEAMPEAEH@Z	; stbi__hdr_convert
	npad	1

; 6036 : 			}

	jmp	SHORT $LN10@stbi__hdr_
$LN11@stbi__hdr_:

; 6037 : 		}

	jmp	$LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 6038 : 	}

	jmp	$LN39@stbi__hdr_
$LN38@stbi__hdr_:

; 6039 : 	else {
; 6040 : 		// Read RLE-encoded data
; 6041 : 		scanline = NULL;

	mov	QWORD PTR scanline$[rsp], 0

; 6042 : 
; 6043 : 		for (j = 0; j < height; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN15@stbi__hdr_
$LN13@stbi__hdr_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN15@stbi__hdr_:
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN14@stbi__hdr_

; 6044 : 			c1 = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR c1$[rsp], eax

; 6045 : 			c2 = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR c2$[rsp], eax

; 6046 : 			len = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR len$[rsp], eax

; 6047 : 			if (c1 != 2 || c2 != 2 || (len & 0x80)) {

	cmp	DWORD PTR c1$[rsp], 2
	jne	SHORT $LN42@stbi__hdr_
	cmp	DWORD PTR c2$[rsp], 2
	jne	SHORT $LN42@stbi__hdr_
	mov	eax, DWORD PTR len$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN41@stbi__hdr_
$LN42@stbi__hdr_:

; 6048 : 				// not run-length encoded, so we have to actually use THIS data as a decoded
; 6049 : 				// pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 6050 : 				stbi_uc rgbe[4];
; 6051 : 				rgbe[0] = (stbi_uc)c1;

	mov	eax, 1
	imul	rax, rax, 0
	movzx	ecx, BYTE PTR c1$[rsp]
	mov	BYTE PTR rgbe$1[rsp+rax], cl

; 6052 : 				rgbe[1] = (stbi_uc)c2;

	mov	eax, 1
	imul	rax, rax, 1
	movzx	ecx, BYTE PTR c2$[rsp]
	mov	BYTE PTR rgbe$1[rsp+rax], cl

; 6053 : 				rgbe[2] = (stbi_uc)len;

	mov	eax, 1
	imul	rax, rax, 2
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR rgbe$1[rsp+rax], cl

; 6054 : 				rgbe[3] = (stbi_uc)stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	BYTE PTR rgbe$1[rsp+rcx], al

; 6055 : 				stbi__hdr_convert(hdr_data, rgbe, req_comp);

	mov	r8d, DWORD PTR req_comp$[rsp]
	lea	rdx, QWORD PTR rgbe$1[rsp]
	mov	rcx, QWORD PTR hdr_data$[rsp]
	call	?stbi__hdr_convert@@YAXPEAMPEAEH@Z	; stbi__hdr_convert

; 6056 : 				i = 1;

	mov	DWORD PTR i$[rsp], 1

; 6057 : 				j = 0;

	mov	DWORD PTR j$[rsp], 0

; 6058 : 				STBI_FREE(scanline);

	mov	rcx, QWORD PTR scanline$[rsp]
	call	free
	npad	1

; 6059 : 				goto main_decode_loop; // yes, this makes no sense

	jmp	$main_decode_loop$48
$LN41@stbi__hdr_:

; 6060 : 			}
; 6061 : 			len <<= 8;

	mov	eax, DWORD PTR len$[rsp]
	shl	eax, 8
	mov	DWORD PTR len$[rsp], eax

; 6062 : 			len |= stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	ecx, DWORD PTR len$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rsp], eax

; 6063 : 			if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR len$[rsp], eax
	je	SHORT $LN43@stbi__hdr_
	mov	rcx, QWORD PTR hdr_data$[rsp]
	call	free
	mov	rcx, QWORD PTR scanline$[rsp]
	call	free
	xor	eax, eax
	jmp	$LN1@stbi__hdr_
$LN43@stbi__hdr_:

; 6064 : 			if (scanline == NULL) scanline = (stbi_uc*)stbi__malloc(width * 4);

	cmp	QWORD PTR scanline$[rsp], 0
	jne	SHORT $LN44@stbi__hdr_
	mov	eax, DWORD PTR width$[rsp]
	shl	eax, 2
	cdqe
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR scanline$[rsp], rax
$LN44@stbi__hdr_:

; 6065 : 
; 6066 : 			for (k = 0; k < 4; ++k) {

	mov	DWORD PTR k$[rsp], 0
	jmp	SHORT $LN18@stbi__hdr_
$LN16@stbi__hdr_:
	mov	eax, DWORD PTR k$[rsp]
	inc	eax
	mov	DWORD PTR k$[rsp], eax
$LN18@stbi__hdr_:
	cmp	DWORD PTR k$[rsp], 4
	jge	$LN17@stbi__hdr_

; 6067 : 				i = 0;

	mov	DWORD PTR i$[rsp], 0
$LN19@stbi__hdr_:

; 6068 : 				while (i < width) {

	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN20@stbi__hdr_

; 6069 : 					count = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR count$[rsp], al

; 6070 : 					if (count > 128) {

	movzx	eax, BYTE PTR count$[rsp]
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN45@stbi__hdr_

; 6071 : 						// Run
; 6072 : 						value = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR value$[rsp], al

; 6073 : 						count -= 128;

	movzx	eax, BYTE PTR count$[rsp]
	sub	eax, 128				; 00000080H
	mov	BYTE PTR count$[rsp], al

; 6074 : 						for (z = 0; z < count; ++z)

	mov	DWORD PTR z$[rsp], 0
	jmp	SHORT $LN23@stbi__hdr_
$LN21@stbi__hdr_:
	mov	eax, DWORD PTR z$[rsp]
	inc	eax
	mov	DWORD PTR z$[rsp], eax
$LN23@stbi__hdr_:
	movzx	eax, BYTE PTR count$[rsp]
	cmp	DWORD PTR z$[rsp], eax
	jge	SHORT $LN22@stbi__hdr_

; 6075 : 							scanline[i++ * 4 + k] = value;

	mov	eax, DWORD PTR k$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	lea	eax, DWORD PTR [rax+rcx*4]
	cdqe
	mov	rcx, QWORD PTR scanline$[rsp]
	movzx	edx, BYTE PTR value$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN21@stbi__hdr_
$LN22@stbi__hdr_:

; 6076 : 					}

	jmp	SHORT $LN46@stbi__hdr_
$LN45@stbi__hdr_:

; 6077 : 					else {
; 6078 : 						// Dump
; 6079 : 						for (z = 0; z < count; ++z)

	mov	DWORD PTR z$[rsp], 0
	jmp	SHORT $LN26@stbi__hdr_
$LN24@stbi__hdr_:
	mov	eax, DWORD PTR z$[rsp]
	inc	eax
	mov	DWORD PTR z$[rsp], eax
$LN26@stbi__hdr_:
	movzx	eax, BYTE PTR count$[rsp]
	cmp	DWORD PTR z$[rsp], eax
	jge	SHORT $LN25@stbi__hdr_

; 6080 : 							scanline[i++ * 4 + k] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR k$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	lea	ecx, DWORD PTR [rcx+rdx*4]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR scanline$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN24@stbi__hdr_
$LN25@stbi__hdr_:
$LN46@stbi__hdr_:

; 6081 : 					}
; 6082 : 				}

	jmp	$LN19@stbi__hdr_
$LN20@stbi__hdr_:

; 6083 : 			}

	jmp	$LN16@stbi__hdr_
$LN17@stbi__hdr_:

; 6084 : 			for (i = 0; i < width; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN29@stbi__hdr_
$LN27@stbi__hdr_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN29@stbi__hdr_:
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN28@stbi__hdr_

; 6085 : 				stbi__hdr_convert(hdr_data + (j * width + i) * req_comp, scanline + i * 4, req_comp);

	mov	eax, DWORD PTR i$[rsp]
	shl	eax, 2
	cdqe
	mov	rcx, QWORD PTR scanline$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR j$[rsp]
	imul	ecx, DWORD PTR width$[rsp]
	add	ecx, DWORD PTR i$[rsp]
	imul	ecx, DWORD PTR req_comp$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR hdr_data$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*4]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	rdx, rax
	call	?stbi__hdr_convert@@YAXPEAMPEAEH@Z	; stbi__hdr_convert
	npad	1
	jmp	SHORT $LN27@stbi__hdr_
$LN28@stbi__hdr_:

; 6086 : 		}

	jmp	$LN13@stbi__hdr_
$LN14@stbi__hdr_:

; 6087 : 		STBI_FREE(scanline);

	mov	rcx, QWORD PTR scanline$[rsp]
	call	free
	npad	1
$LN39@stbi__hdr_:

; 6088 : 	}
; 6089 : 
; 6090 : 	return hdr_data;

	mov	rax, QWORD PTR hdr_data$[rsp]
$LN1@stbi__hdr_:

; 6091 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1176				; 00000498H
	ret	0
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__hdr_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__hdr_test

; 5923 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5924 : 	int r = stbi__hdr_test_core(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_test_core@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test_core
	mov	DWORD PTR r$[rsp], eax

; 5925 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 5926 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 5927 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__hdr_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
channelCount$ = 32
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__psd_info

; 6166 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6167 : 	int channelCount;
; 6168 : 	if (stbi__get32be(s) != 0x38425053) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	cmp	eax, 943870035				; 38425053H
	je	SHORT $LN2@stbi__psd_

; 6169 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6170 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN2@stbi__psd_:

; 6171 : 	}
; 6172 : 	if (stbi__get16be(s) != 1) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 1
	je	SHORT $LN3@stbi__psd_

; 6173 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6174 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN3@stbi__psd_:

; 6175 : 	}
; 6176 : 	stbi__skip(s, 6);

	mov	edx, 6
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 6177 : 	channelCount = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR channelCount$[rsp], eax

; 6178 : 	if (channelCount < 0 || channelCount > 16) {

	cmp	DWORD PTR channelCount$[rsp], 0
	jl	SHORT $LN5@stbi__psd_
	cmp	DWORD PTR channelCount$[rsp], 16
	jle	SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 6179 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6180 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN4@stbi__psd_:

; 6181 : 	}
; 6182 : 	*y = stbi__get32be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	rcx, QWORD PTR y$[rsp]
	mov	DWORD PTR [rcx], eax

; 6183 : 	*x = stbi__get32be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	rcx, QWORD PTR x$[rsp]
	mov	DWORD PTR [rcx], eax

; 6184 : 	if (stbi__get16be(s) != 8) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 8
	je	SHORT $LN6@stbi__psd_

; 6185 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6186 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN6@stbi__psd_:

; 6187 : 	}
; 6188 : 	if (stbi__get16be(s) != 3) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 3
	je	SHORT $LN7@stbi__psd_

; 6189 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6190 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__psd_
$LN7@stbi__psd_:

; 6191 : 	}
; 6192 : 	*comp = 4;

	mov	rax, QWORD PTR comp$[rsp]
	mov	DWORD PTR [rax], 4

; 6193 : 	return 1;

	mov	eax, 1
$LN1@stbi__psd_:

; 6194 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__psd_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
len$ = 48
i$ = 52
channel$ = 56
val$1 = 60
val$2 = 61
count$ = 64
channelCount$ = 68
pixelCount$ = 72
h$ = 76
w$ = 80
p$3 = 88
p$4 = 96
out$ = 104
bitdepth$ = 112
compression$ = 116
tv155 = 120
tv185 = 124
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
req_comp$ = 176
?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__psd_load

; 5143 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 5144 : 	int   pixelCount;
; 5145 : 	int channelCount, compression;
; 5146 : 	int channel, i, count, len;
; 5147 : 	int bitdepth;
; 5148 : 	int w, h;
; 5149 : 	stbi_uc* out;
; 5150 : 
; 5151 : 	// Check identifier
; 5152 : 	if (stbi__get32be(s) != 0x38425053)   // "8BPS"

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	cmp	eax, 943870035				; 38425053H
	je	SHORT $LN26@stbi__psd_

; 5153 : 		return stbi__errpuc("not PSD", "Corrupt PSD image");

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN26@stbi__psd_:

; 5154 : 
; 5155 : 	// Check file type version.
; 5156 : 	if (stbi__get16be(s) != 1)

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 1
	je	SHORT $LN27@stbi__psd_

; 5157 : 		return stbi__errpuc("wrong version", "Unsupported version of PSD image");

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN27@stbi__psd_:

; 5158 : 
; 5159 : 	// Skip 6 reserved bytes.
; 5160 : 	stbi__skip(s, 6);

	mov	edx, 6
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5161 : 
; 5162 : 	// Read the number of channels (R, G, B, A, etc).
; 5163 : 	channelCount = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR channelCount$[rsp], eax

; 5164 : 	if (channelCount < 0 || channelCount > 16)

	cmp	DWORD PTR channelCount$[rsp], 0
	jl	SHORT $LN29@stbi__psd_
	cmp	DWORD PTR channelCount$[rsp], 16
	jle	SHORT $LN28@stbi__psd_
$LN29@stbi__psd_:

; 5165 : 		return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN28@stbi__psd_:

; 5166 : 
; 5167 : 	// Read the rows and columns of the image.
; 5168 : 	h = stbi__get32be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	DWORD PTR h$[rsp], eax

; 5169 : 	w = stbi__get32be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	DWORD PTR w$[rsp], eax

; 5170 : 
; 5171 : 	// Make sure the depth is 8 bits.
; 5172 : 	bitdepth = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR bitdepth$[rsp], eax

; 5173 : 	if (bitdepth != 8 && bitdepth != 16)

	cmp	DWORD PTR bitdepth$[rsp], 8
	je	SHORT $LN30@stbi__psd_
	cmp	DWORD PTR bitdepth$[rsp], 16
	je	SHORT $LN30@stbi__psd_

; 5174 : 		return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN30@stbi__psd_:

; 5175 : 
; 5176 : 	// Make sure the color mode is RGB.
; 5177 : 	// Valid options are:
; 5178 : 	//   0: Bitmap
; 5179 : 	//   1: Grayscale
; 5180 : 	//   2: Indexed color
; 5181 : 	//   3: RGB color
; 5182 : 	//   4: CMYK color
; 5183 : 	//   7: Multichannel
; 5184 : 	//   8: Duotone
; 5185 : 	//   9: Lab color
; 5186 : 	if (stbi__get16be(s) != 3)

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 3
	je	SHORT $LN31@stbi__psd_

; 5187 : 		return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN31@stbi__psd_:

; 5188 : 
; 5189 : 	// Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 5190 : 	stbi__skip(s, stbi__get32be(s));

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5191 : 
; 5192 : 	// Skip the image resources.  (resolution, pen tool paths, etc)
; 5193 : 	stbi__skip(s, stbi__get32be(s));

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5194 : 
; 5195 : 	// Skip the reserved data.
; 5196 : 	stbi__skip(s, stbi__get32be(s));

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5197 : 
; 5198 : 	// Find out if the data is compressed.
; 5199 : 	// Known values:
; 5200 : 	//   0: no compression
; 5201 : 	//   1: RLE compressed
; 5202 : 	compression = stbi__get16be(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	mov	DWORD PTR compression$[rsp], eax

; 5203 : 	if (compression > 1)

	cmp	DWORD PTR compression$[rsp], 1
	jle	SHORT $LN32@stbi__psd_

; 5204 : 		return stbi__errpuc("bad compression", "PSD has an unknown compression format");

	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN32@stbi__psd_:

; 5205 : 
; 5206 : 	// Create the destination image.
; 5207 : 	out = (stbi_uc*)stbi__malloc(4 * w * h);

	mov	eax, DWORD PTR w$[rsp]
	shl	eax, 2
	imul	eax, DWORD PTR h$[rsp]
	cdqe
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR out$[rsp], rax

; 5208 : 	if (!out) return stbi__errpuc("outofmem", "Out of memory");

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN33@stbi__psd_
	xor	eax, eax
	jmp	$LN1@stbi__psd_
$LN33@stbi__psd_:

; 5209 : 	pixelCount = w * h;

	mov	eax, DWORD PTR w$[rsp]
	imul	eax, DWORD PTR h$[rsp]
	mov	DWORD PTR pixelCount$[rsp], eax

; 5210 : 
; 5211 : 	// Initialize the data to zero.
; 5212 : 	//memset( out, 0, pixelCount * 4 );
; 5213 : 
; 5214 : 	// Finally, the image data.
; 5215 : 	if (compression) {

	cmp	DWORD PTR compression$[rsp], 0
	je	$LN34@stbi__psd_

; 5216 : 		// RLE as used by .PSD and .TIFF
; 5217 : 		// Loop until you get the number of unpacked bytes you are expecting:
; 5218 : 		//     Read the next source byte into n.
; 5219 : 		//     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 5220 : 		//     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 5221 : 		//     Else if n is 128, noop.
; 5222 : 		// Endloop
; 5223 : 
; 5224 : 		// The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
; 5225 : 		// which we're going to just skip.
; 5226 : 		stbi__skip(s, h * channelCount * 2);

	mov	eax, DWORD PTR h$[rsp]
	imul	eax, DWORD PTR channelCount$[rsp]
	shl	eax, 1
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 5227 : 
; 5228 : 		// Read the RLE data by channel.
; 5229 : 		for (channel = 0; channel < 4; channel++) {

	mov	DWORD PTR channel$[rsp], 0
	jmp	SHORT $LN4@stbi__psd_
$LN2@stbi__psd_:
	mov	eax, DWORD PTR channel$[rsp]
	inc	eax
	mov	DWORD PTR channel$[rsp], eax
$LN4@stbi__psd_:
	cmp	DWORD PTR channel$[rsp], 4
	jge	$LN3@stbi__psd_

; 5230 : 			stbi_uc* p;
; 5231 : 
; 5232 : 			p = out + channel;

	movsxd	rax, DWORD PTR channel$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$3[rsp], rax

; 5233 : 			if (channel >= channelCount) {

	mov	eax, DWORD PTR channelCount$[rsp]
	cmp	DWORD PTR channel$[rsp], eax
	jl	SHORT $LN36@stbi__psd_

; 5234 : 				// Fill this channel with default data.
; 5235 : 				for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbi__psd_
$LN5@stbi__psd_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR p$3[rsp]
	add	rax, 4
	mov	QWORD PTR p$3[rsp], rax
$LN7@stbi__psd_:
	mov	eax, DWORD PTR pixelCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN6@stbi__psd_

; 5236 : 					*p = (channel == 3 ? 255 : 0);

	cmp	DWORD PTR channel$[rsp], 3
	jne	SHORT $LN51@stbi__psd_
	mov	DWORD PTR tv155[rsp], 255		; 000000ffH
	jmp	SHORT $LN52@stbi__psd_
$LN51@stbi__psd_:
	mov	DWORD PTR tv155[rsp], 0
$LN52@stbi__psd_:
	mov	rax, QWORD PTR p$3[rsp]
	movzx	ecx, BYTE PTR tv155[rsp]
	mov	BYTE PTR [rax], cl
	jmp	SHORT $LN5@stbi__psd_
$LN6@stbi__psd_:

; 5237 : 			}

	jmp	$LN37@stbi__psd_
$LN36@stbi__psd_:

; 5238 : 			else {
; 5239 : 				// Read the RLE data.
; 5240 : 				count = 0;

	mov	DWORD PTR count$[rsp], 0
$LN8@stbi__psd_:

; 5241 : 				while (count < pixelCount) {

	mov	eax, DWORD PTR pixelCount$[rsp]
	cmp	DWORD PTR count$[rsp], eax
	jge	$LN9@stbi__psd_

; 5242 : 					len = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR len$[rsp], eax

; 5243 : 					if (len == 128) {

	cmp	DWORD PTR len$[rsp], 128		; 00000080H
	jne	SHORT $LN38@stbi__psd_

; 5244 : 						// No-op.
; 5245 : 					}

	jmp	$LN39@stbi__psd_
$LN38@stbi__psd_:

; 5246 : 					else if (len < 128) {

	cmp	DWORD PTR len$[rsp], 128		; 00000080H
	jge	SHORT $LN40@stbi__psd_

; 5247 : 						// Copy next len+1 bytes literally.
; 5248 : 						len++;

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	mov	DWORD PTR len$[rsp], eax

; 5249 : 						count += len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR count$[rsp], eax
$LN10@stbi__psd_:

; 5250 : 						while (len) {

	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN11@stbi__psd_

; 5251 : 							*p = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR p$3[rsp]
	mov	BYTE PTR [rcx], al

; 5252 : 							p += 4;

	mov	rax, QWORD PTR p$3[rsp]
	add	rax, 4
	mov	QWORD PTR p$3[rsp], rax

; 5253 : 							len--;

	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax

; 5254 : 						}

	jmp	SHORT $LN10@stbi__psd_
$LN11@stbi__psd_:

; 5255 : 					}

	jmp	SHORT $LN41@stbi__psd_
$LN40@stbi__psd_:

; 5256 : 					else if (len > 128) {

	cmp	DWORD PTR len$[rsp], 128		; 00000080H
	jle	SHORT $LN42@stbi__psd_

; 5257 : 						stbi_uc   val;
; 5258 : 						// Next -len+1 bytes in the dest are replicated from next source byte.
; 5259 : 						// (Interpret len as a negative 8-bit int.)
; 5260 : 						len ^= 0x0FF;

	mov	eax, DWORD PTR len$[rsp]
	xor	eax, 255				; 000000ffH
	mov	DWORD PTR len$[rsp], eax

; 5261 : 						len += 2;

	mov	eax, DWORD PTR len$[rsp]
	add	eax, 2
	mov	DWORD PTR len$[rsp], eax

; 5262 : 						val = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	BYTE PTR val$1[rsp], al

; 5263 : 						count += len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR count$[rsp], eax
$LN12@stbi__psd_:

; 5264 : 						while (len) {

	cmp	DWORD PTR len$[rsp], 0
	je	SHORT $LN13@stbi__psd_

; 5265 : 							*p = val;

	mov	rax, QWORD PTR p$3[rsp]
	movzx	ecx, BYTE PTR val$1[rsp]
	mov	BYTE PTR [rax], cl

; 5266 : 							p += 4;

	mov	rax, QWORD PTR p$3[rsp]
	add	rax, 4
	mov	QWORD PTR p$3[rsp], rax

; 5267 : 							len--;

	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax

; 5268 : 						}

	jmp	SHORT $LN12@stbi__psd_
$LN13@stbi__psd_:
$LN42@stbi__psd_:
$LN41@stbi__psd_:
$LN39@stbi__psd_:

; 5269 : 					}
; 5270 : 				}

	jmp	$LN8@stbi__psd_
$LN9@stbi__psd_:
$LN37@stbi__psd_:

; 5271 : 			}
; 5272 : 		}

	jmp	$LN2@stbi__psd_
$LN3@stbi__psd_:

; 5273 : 
; 5274 : 	}

	jmp	$LN35@stbi__psd_
$LN34@stbi__psd_:

; 5275 : 	else {
; 5276 : 		// We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 5277 : 		// where each channel consists of an 8-bit value for each pixel in the image.
; 5278 : 
; 5279 : 		// Read the data by channel.
; 5280 : 		for (channel = 0; channel < 4; channel++) {

	mov	DWORD PTR channel$[rsp], 0
	jmp	SHORT $LN16@stbi__psd_
$LN14@stbi__psd_:
	mov	eax, DWORD PTR channel$[rsp]
	inc	eax
	mov	DWORD PTR channel$[rsp], eax
$LN16@stbi__psd_:
	cmp	DWORD PTR channel$[rsp], 4
	jge	$LN15@stbi__psd_

; 5281 : 			stbi_uc* p;
; 5282 : 
; 5283 : 			p = out + channel;

	movsxd	rax, DWORD PTR channel$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$4[rsp], rax

; 5284 : 			if (channel >= channelCount) {

	mov	eax, DWORD PTR channelCount$[rsp]
	cmp	DWORD PTR channel$[rsp], eax
	jl	SHORT $LN43@stbi__psd_

; 5285 : 				// Fill this channel with default data.
; 5286 : 				stbi_uc val = channel == 3 ? 255 : 0;

	cmp	DWORD PTR channel$[rsp], 3
	jne	SHORT $LN53@stbi__psd_
	mov	DWORD PTR tv185[rsp], 255		; 000000ffH
	jmp	SHORT $LN54@stbi__psd_
$LN53@stbi__psd_:
	mov	DWORD PTR tv185[rsp], 0
$LN54@stbi__psd_:
	movzx	eax, BYTE PTR tv185[rsp]
	mov	BYTE PTR val$2[rsp], al

; 5287 : 				for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN19@stbi__psd_
$LN17@stbi__psd_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR p$4[rsp]
	add	rax, 4
	mov	QWORD PTR p$4[rsp], rax
$LN19@stbi__psd_:
	mov	eax, DWORD PTR pixelCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN18@stbi__psd_

; 5288 : 					*p = val;

	mov	rax, QWORD PTR p$4[rsp]
	movzx	ecx, BYTE PTR val$2[rsp]
	mov	BYTE PTR [rax], cl
	jmp	SHORT $LN17@stbi__psd_
$LN18@stbi__psd_:

; 5289 : 			}

	jmp	$LN44@stbi__psd_
$LN43@stbi__psd_:

; 5290 : 			else {
; 5291 : 				// Read the data.
; 5292 : 				if (bitdepth == 16) {

	cmp	DWORD PTR bitdepth$[rsp], 16
	jne	SHORT $LN45@stbi__psd_

; 5293 : 					for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN22@stbi__psd_
$LN20@stbi__psd_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR p$4[rsp]
	add	rax, 4
	mov	QWORD PTR p$4[rsp], rax
$LN22@stbi__psd_:
	mov	eax, DWORD PTR pixelCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN21@stbi__psd_

; 5294 : 						*p = (stbi_uc)(stbi__get16be(s) >> 8);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	sar	eax, 8
	mov	rcx, QWORD PTR p$4[rsp]
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 5295 : 				}

	jmp	SHORT $LN46@stbi__psd_
$LN45@stbi__psd_:

; 5296 : 				else {
; 5297 : 					for (i = 0; i < pixelCount; i++, p += 4)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN25@stbi__psd_
$LN23@stbi__psd_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR p$4[rsp]
	add	rax, 4
	mov	QWORD PTR p$4[rsp], rax
$LN25@stbi__psd_:
	mov	eax, DWORD PTR pixelCount$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN24@stbi__psd_

; 5298 : 						*p = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	rcx, QWORD PTR p$4[rsp]
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN23@stbi__psd_
$LN24@stbi__psd_:
$LN46@stbi__psd_:
$LN44@stbi__psd_:

; 5299 : 				}
; 5300 : 			}
; 5301 : 		}

	jmp	$LN14@stbi__psd_
$LN15@stbi__psd_:
$LN35@stbi__psd_:

; 5302 : 	}
; 5303 : 
; 5304 : 	if (req_comp && req_comp != 4) {

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN47@stbi__psd_
	cmp	DWORD PTR req_comp$[rsp], 4
	je	SHORT $LN47@stbi__psd_

; 5305 : 		out = stbi__convert_format(out, 4, req_comp, w, h);

	mov	eax, DWORD PTR h$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR w$[rsp]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	edx, 4
	mov	rcx, QWORD PTR out$[rsp]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	mov	QWORD PTR out$[rsp], rax

; 5306 : 		if (out == NULL) return out; // stbi__convert_format frees input on failure

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN48@stbi__psd_
	mov	rax, QWORD PTR out$[rsp]
	jmp	SHORT $LN1@stbi__psd_
$LN48@stbi__psd_:
$LN47@stbi__psd_:

; 5307 : 	}
; 5308 : 
; 5309 : 	if (comp) *comp = 4;

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN49@stbi__psd_
	mov	rax, QWORD PTR comp$[rsp]
	mov	DWORD PTR [rax], 4
$LN49@stbi__psd_:

; 5310 : 	*y = h;

	mov	rax, QWORD PTR y$[rsp]
	mov	ecx, DWORD PTR h$[rsp]
	mov	DWORD PTR [rax], ecx

; 5311 : 	*x = w;

	mov	rax, QWORD PTR x$[rsp]
	mov	ecx, DWORD PTR w$[rsp]
	mov	DWORD PTR [rax], ecx

; 5312 : 
; 5313 : 	return out;

	mov	rax, QWORD PTR out$[rsp]
$LN1@stbi__psd_:

; 5314 : }

	add	rsp, 136				; 00000088H
	ret	0
?stbi__psd_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__psd_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv67 = 32
r$ = 36
s$ = 64
?stbi__psd_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__psd_test

; 5136 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5137 : 	int r = (stbi__get32be(s) == 0x38425053);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
	cmp	eax, 943870035				; 38425053H
	jne	SHORT $LN3@stbi__psd_
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@stbi__psd_
$LN3@stbi__psd_:
	mov	DWORD PTR tv67[rsp], 0
$LN4@stbi__psd_:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR r$[rsp], eax

; 5138 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 5139 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 5140 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__psd_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__psd_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
sz$ = 32
tga_w$ = 36
tga_h$ = 40
tga_comp$ = 44
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__tga_info

; 4871 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4872 : 	int tga_w, tga_h, tga_comp;
; 4873 : 	int sz;
; 4874 : 	stbi__get8(s);                   // discard Offset

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8

; 4875 : 	sz = stbi__get8(s);              // color type

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR sz$[rsp], eax

; 4876 : 	if (sz > 1) {

	cmp	DWORD PTR sz$[rsp], 1
	jle	SHORT $LN2@stbi__tga_

; 4877 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4878 : 		return 0;      // only RGB or indexed allowed

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN2@stbi__tga_:

; 4879 : 	}
; 4880 : 	sz = stbi__get8(s);              // image type

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR sz$[rsp], eax

; 4881 : 	// only RGB or grey allowed, +/- RLE
; 4882 : 	if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;

	cmp	DWORD PTR sz$[rsp], 1
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 2
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 3
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 9
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 10
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 11
	je	SHORT $LN3@stbi__tga_
	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN3@stbi__tga_:

; 4883 : 	stbi__skip(s, 9);

	mov	edx, 9
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 4884 : 	tga_w = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_w$[rsp], eax

; 4885 : 	if (tga_w < 1) {

	cmp	DWORD PTR tga_w$[rsp], 1
	jge	SHORT $LN4@stbi__tga_

; 4886 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4887 : 		return 0;   // test width

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN4@stbi__tga_:

; 4888 : 	}
; 4889 : 	tga_h = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_h$[rsp], eax

; 4890 : 	if (tga_h < 1) {

	cmp	DWORD PTR tga_h$[rsp], 1
	jge	SHORT $LN5@stbi__tga_

; 4891 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4892 : 		return 0;   // test height

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN5@stbi__tga_:

; 4893 : 	}
; 4894 : 	sz = stbi__get8(s);               // bits per pixel

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR sz$[rsp], eax

; 4895 : 	// only RGB or RGBA or grey allowed
; 4896 : 	if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {

	cmp	DWORD PTR sz$[rsp], 8
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 16
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 24
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 32			; 00000020H
	je	SHORT $LN6@stbi__tga_

; 4897 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4898 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__tga_
$LN6@stbi__tga_:

; 4899 : 	}
; 4900 : 	tga_comp = sz;

	mov	eax, DWORD PTR sz$[rsp]
	mov	DWORD PTR tga_comp$[rsp], eax

; 4901 : 	if (x) *x = tga_w;

	cmp	QWORD PTR x$[rsp], 0
	je	SHORT $LN7@stbi__tga_
	mov	rax, QWORD PTR x$[rsp]
	mov	ecx, DWORD PTR tga_w$[rsp]
	mov	DWORD PTR [rax], ecx
$LN7@stbi__tga_:

; 4902 : 	if (y) *y = tga_h;

	cmp	QWORD PTR y$[rsp], 0
	je	SHORT $LN8@stbi__tga_
	mov	rax, QWORD PTR y$[rsp]
	mov	ecx, DWORD PTR tga_h$[rsp]
	mov	DWORD PTR [rax], ecx
$LN8@stbi__tga_:

; 4903 : 	if (comp) *comp = tga_comp / 8;

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN9@stbi__tga_
	mov	eax, DWORD PTR tga_comp$[rsp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	rcx, QWORD PTR comp$[rsp]
	mov	DWORD PTR [rcx], eax
$LN9@stbi__tga_:

; 4904 : 	return 1;                   // seems to have passed everything

	mov	eax, 1
$LN1@stbi__tga_:

; 4905 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__tga_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
j$ = 48
i$ = 52
tga_comp$ = 56
tga_width$ = 60
tga_height$ = 64
tga_bits_per_pixel$ = 68
temp$1 = 72
temp$2 = 73
tga_data$ = 80
tga_image_type$ = 88
pal_idx$3 = 92
read_next_pixel$ = 96
tga_palette_bits$ = 100
tga_palette_len$ = 104
tga_indexed$ = 108
RLE_count$ = 112
tga_inverted$ = 116
index1$4 = 120
index2$5 = 124
tga_is_RLE$ = 128
tga_palette$ = 136
tga_pixel$6 = 144
tv160 = 152
RLE_cmd$7 = 156
RLE_repeating$ = 160
raw_data$ = 164
tga_y_origin$ = 168
tga_x_origin$ = 172
tga_palette_start$ = 176
tga_offset$ = 180
row$8 = 184
tga_row$9 = 192
s$ = 224
x$ = 232
y$ = 240
comp$ = 248
req_comp$ = 256
?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__tga_load

; 4933 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 4934 : 	//   read in the TGA header stuff
; 4935 : 	int tga_offset = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tga_offset$[rsp], eax

; 4936 : 	int tga_indexed = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tga_indexed$[rsp], eax

; 4937 : 	int tga_image_type = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tga_image_type$[rsp], eax

; 4938 : 	int tga_is_RLE = 0;

	mov	DWORD PTR tga_is_RLE$[rsp], 0

; 4939 : 	int tga_palette_start = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_palette_start$[rsp], eax

; 4940 : 	int tga_palette_len = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_palette_len$[rsp], eax

; 4941 : 	int tga_palette_bits = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tga_palette_bits$[rsp], eax

; 4942 : 	int tga_x_origin = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_x_origin$[rsp], eax

; 4943 : 	int tga_y_origin = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_y_origin$[rsp], eax

; 4944 : 	int tga_width = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_width$[rsp], eax

; 4945 : 	int tga_height = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tga_height$[rsp], eax

; 4946 : 	int tga_bits_per_pixel = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tga_bits_per_pixel$[rsp], eax

; 4947 : 	int tga_comp = tga_bits_per_pixel / 8;

	mov	eax, DWORD PTR tga_bits_per_pixel$[rsp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR tga_comp$[rsp], eax

; 4948 : 	int tga_inverted = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tga_inverted$[rsp], eax

; 4949 : 	//   image data
; 4950 : 	unsigned char* tga_data;
; 4951 : 	unsigned char* tga_palette = NULL;

	mov	QWORD PTR tga_palette$[rsp], 0

; 4952 : 	int i, j;
; 4953 : 	unsigned char raw_data[4];
; 4954 : 	int RLE_count = 0;

	mov	DWORD PTR RLE_count$[rsp], 0

; 4955 : 	int RLE_repeating = 0;

	mov	DWORD PTR RLE_repeating$[rsp], 0

; 4956 : 	int read_next_pixel = 1;

	mov	DWORD PTR read_next_pixel$[rsp], 1

; 4957 : 
; 4958 : 	//   do a tiny bit of precessing
; 4959 : 	if (tga_image_type >= 8)

	cmp	DWORD PTR tga_image_type$[rsp], 8
	jl	SHORT $LN26@stbi__tga_

; 4960 : 	{
; 4961 : 		tga_image_type -= 8;

	mov	eax, DWORD PTR tga_image_type$[rsp]
	sub	eax, 8
	mov	DWORD PTR tga_image_type$[rsp], eax

; 4962 : 		tga_is_RLE = 1;

	mov	DWORD PTR tga_is_RLE$[rsp], 1
$LN26@stbi__tga_:

; 4963 : 	}
; 4964 : 	/* int tga_alpha_bits = tga_inverted & 15; */
; 4965 : 	tga_inverted = 1 - ((tga_inverted >> 5) & 1);

	mov	eax, DWORD PTR tga_inverted$[rsp]
	sar	eax, 5
	and	eax, 1
	mov	ecx, 1
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tga_inverted$[rsp], eax

; 4966 : 
; 4967 : 	//   error check
; 4968 : 	if ( //(tga_indexed) ||
; 4969 : 		(tga_width < 1) || (tga_height < 1) ||
; 4970 : 		(tga_image_type < 1) || (tga_image_type > 3) ||

	cmp	DWORD PTR tga_width$[rsp], 1
	jl	SHORT $LN28@stbi__tga_
	cmp	DWORD PTR tga_height$[rsp], 1
	jl	SHORT $LN28@stbi__tga_
	cmp	DWORD PTR tga_image_type$[rsp], 1
	jl	SHORT $LN28@stbi__tga_
	cmp	DWORD PTR tga_image_type$[rsp], 3
	jg	SHORT $LN28@stbi__tga_
	cmp	DWORD PTR tga_bits_per_pixel$[rsp], 8
	je	SHORT $LN27@stbi__tga_
	cmp	DWORD PTR tga_bits_per_pixel$[rsp], 16
	je	SHORT $LN27@stbi__tga_
	cmp	DWORD PTR tga_bits_per_pixel$[rsp], 24
	je	SHORT $LN27@stbi__tga_
	cmp	DWORD PTR tga_bits_per_pixel$[rsp], 32	; 00000020H
	je	SHORT $LN27@stbi__tga_
$LN28@stbi__tga_:

; 4971 : 		((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&
; 4972 : 			(tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))
; 4973 : 		)
; 4974 : 	{
; 4975 : 		return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN27@stbi__tga_:

; 4976 : 	}
; 4977 : 
; 4978 : 	//   If I'm paletted, then I'll use the number of bits from the palette
; 4979 : 	if (tga_indexed)

	cmp	DWORD PTR tga_indexed$[rsp], 0
	je	SHORT $LN29@stbi__tga_

; 4980 : 	{
; 4981 : 		tga_comp = tga_palette_bits / 8;

	mov	eax, DWORD PTR tga_palette_bits$[rsp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR tga_comp$[rsp], eax
$LN29@stbi__tga_:

; 4982 : 	}
; 4983 : 
; 4984 : 	//   tga info
; 4985 : 	*x = tga_width;

	mov	rax, QWORD PTR x$[rsp]
	mov	ecx, DWORD PTR tga_width$[rsp]
	mov	DWORD PTR [rax], ecx

; 4986 : 	*y = tga_height;

	mov	rax, QWORD PTR y$[rsp]
	mov	ecx, DWORD PTR tga_height$[rsp]
	mov	DWORD PTR [rax], ecx

; 4987 : 	if (comp) *comp = tga_comp;

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN30@stbi__tga_
	mov	rax, QWORD PTR comp$[rsp]
	mov	ecx, DWORD PTR tga_comp$[rsp]
	mov	DWORD PTR [rax], ecx
$LN30@stbi__tga_:

; 4988 : 
; 4989 : 	tga_data = (unsigned char*)stbi__malloc((size_t)tga_width * tga_height * tga_comp);

	movsxd	rax, DWORD PTR tga_width$[rsp]
	movsxd	rcx, DWORD PTR tga_height$[rsp]
	imul	rax, rcx
	movsxd	rcx, DWORD PTR tga_comp$[rsp]
	imul	rax, rcx
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR tga_data$[rsp], rax

; 4990 : 	if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

	cmp	QWORD PTR tga_data$[rsp], 0
	jne	SHORT $LN31@stbi__tga_
	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN31@stbi__tga_:

; 4991 : 
; 4992 : 	// skip to the data's starting position (offset usually = 0)
; 4993 : 	stbi__skip(s, tga_offset);

	mov	edx, DWORD PTR tga_offset$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 4994 : 
; 4995 : 	if (!tga_indexed && !tga_is_RLE) {

	cmp	DWORD PTR tga_indexed$[rsp], 0
	jne	$LN32@stbi__tga_
	cmp	DWORD PTR tga_is_RLE$[rsp], 0
	jne	$LN32@stbi__tga_

; 4996 : 		for (i = 0; i < tga_height; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__tga_
$LN2@stbi__tga_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__tga_:
	mov	eax, DWORD PTR tga_height$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@stbi__tga_

; 4997 : 			int row = tga_inverted ? tga_height - i - 1 : i;

	cmp	DWORD PTR tga_inverted$[rsp], 0
	je	SHORT $LN51@stbi__tga_
	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR tga_height$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	mov	DWORD PTR tv160[rsp], eax
	jmp	SHORT $LN52@stbi__tga_
$LN51@stbi__tga_:
	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR tv160[rsp], eax
$LN52@stbi__tga_:
	mov	eax, DWORD PTR tv160[rsp]
	mov	DWORD PTR row$8[rsp], eax

; 4998 : 			stbi_uc* tga_row = tga_data + row * tga_width * tga_comp;

	mov	eax, DWORD PTR row$8[rsp]
	imul	eax, DWORD PTR tga_width$[rsp]
	imul	eax, DWORD PTR tga_comp$[rsp]
	cdqe
	mov	rcx, QWORD PTR tga_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tga_row$9[rsp], rax

; 4999 : 			stbi__getn(s, tga_row, tga_width * tga_comp);

	mov	eax, DWORD PTR tga_width$[rsp]
	imul	eax, DWORD PTR tga_comp$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR tga_row$9[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	npad	1

; 5000 : 		}

	jmp	$LN2@stbi__tga_
$LN3@stbi__tga_:

; 5001 : 	}

	jmp	$LN33@stbi__tga_
$LN32@stbi__tga_:

; 5002 : 	else {
; 5003 : 		//   do I need to load a palette?
; 5004 : 		if (tga_indexed)

	cmp	DWORD PTR tga_indexed$[rsp], 0
	je	$LN34@stbi__tga_

; 5005 : 		{
; 5006 : 			//   any data to skip? (offset usually = 0)
; 5007 : 			stbi__skip(s, tga_palette_start);

	mov	edx, DWORD PTR tga_palette_start$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 5008 : 			//   load the palette
; 5009 : 			tga_palette = (unsigned char*)stbi__malloc(tga_palette_len * tga_palette_bits / 8);

	mov	eax, DWORD PTR tga_palette_len$[rsp]
	imul	eax, DWORD PTR tga_palette_bits$[rsp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	cdqe
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR tga_palette$[rsp], rax

; 5010 : 			if (!tga_palette) {

	cmp	QWORD PTR tga_palette$[rsp], 0
	jne	SHORT $LN35@stbi__tga_

; 5011 : 				STBI_FREE(tga_data);

	mov	rcx, QWORD PTR tga_data$[rsp]
	call	free

; 5012 : 				return stbi__errpuc("outofmem", "Out of memory");

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN35@stbi__tga_:

; 5013 : 			}
; 5014 : 			if (!stbi__getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8)) {

	mov	eax, DWORD PTR tga_palette_len$[rsp]
	imul	eax, DWORD PTR tga_palette_bits$[rsp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	r8d, eax
	mov	rdx, QWORD PTR tga_palette$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
	test	eax, eax
	jne	SHORT $LN36@stbi__tga_

; 5015 : 				STBI_FREE(tga_data);

	mov	rcx, QWORD PTR tga_data$[rsp]
	call	free

; 5016 : 				STBI_FREE(tga_palette);

	mov	rcx, QWORD PTR tga_palette$[rsp]
	call	free

; 5017 : 				return stbi__errpuc("bad palette", "Corrupt TGA");

	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN36@stbi__tga_:
$LN34@stbi__tga_:

; 5018 : 			}
; 5019 : 		}
; 5020 : 		//   load the data
; 5021 : 		for (i = 0; i < tga_width * tga_height; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbi__tga_
$LN5@stbi__tga_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__tga_:
	mov	eax, DWORD PTR tga_width$[rsp]
	imul	eax, DWORD PTR tga_height$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN6@stbi__tga_

; 5022 : 		{
; 5023 : 			//   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5024 : 			if (tga_is_RLE)

	cmp	DWORD PTR tga_is_RLE$[rsp], 0
	je	SHORT $LN37@stbi__tga_

; 5025 : 			{
; 5026 : 				if (RLE_count == 0)

	cmp	DWORD PTR RLE_count$[rsp], 0
	jne	SHORT $LN39@stbi__tga_

; 5027 : 				{
; 5028 : 					//   yep, get the next byte as a RLE command
; 5029 : 					int RLE_cmd = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR RLE_cmd$7[rsp], eax

; 5030 : 					RLE_count = 1 + (RLE_cmd & 127);

	mov	eax, DWORD PTR RLE_cmd$7[rsp]
	and	eax, 127				; 0000007fH
	inc	eax
	mov	DWORD PTR RLE_count$[rsp], eax

; 5031 : 					RLE_repeating = RLE_cmd >> 7;

	mov	eax, DWORD PTR RLE_cmd$7[rsp]
	sar	eax, 7
	mov	DWORD PTR RLE_repeating$[rsp], eax

; 5032 : 					read_next_pixel = 1;

	mov	DWORD PTR read_next_pixel$[rsp], 1

; 5033 : 				}

	jmp	SHORT $LN40@stbi__tga_
$LN39@stbi__tga_:

; 5034 : 				else if (!RLE_repeating)

	cmp	DWORD PTR RLE_repeating$[rsp], 0
	jne	SHORT $LN41@stbi__tga_

; 5035 : 				{
; 5036 : 					read_next_pixel = 1;

	mov	DWORD PTR read_next_pixel$[rsp], 1
$LN41@stbi__tga_:
$LN40@stbi__tga_:

; 5037 : 				}
; 5038 : 			}

	jmp	SHORT $LN38@stbi__tga_
$LN37@stbi__tga_:

; 5039 : 			else
; 5040 : 			{
; 5041 : 				read_next_pixel = 1;

	mov	DWORD PTR read_next_pixel$[rsp], 1
$LN38@stbi__tga_:

; 5042 : 			}
; 5043 : 			//   OK, if I need to read a pixel, do it now
; 5044 : 			if (read_next_pixel)

	cmp	DWORD PTR read_next_pixel$[rsp], 0
	je	$LN42@stbi__tga_

; 5045 : 			{
; 5046 : 				//   load however much data we did have
; 5047 : 				if (tga_indexed)

	cmp	DWORD PTR tga_indexed$[rsp], 0
	je	$LN43@stbi__tga_

; 5048 : 				{
; 5049 : 					//   read in 1 byte, then perform the lookup
; 5050 : 					int pal_idx = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR pal_idx$3[rsp], eax

; 5051 : 					if (pal_idx >= tga_palette_len)

	mov	eax, DWORD PTR tga_palette_len$[rsp]
	cmp	DWORD PTR pal_idx$3[rsp], eax
	jl	SHORT $LN45@stbi__tga_

; 5052 : 					{
; 5053 : 						//   invalid index
; 5054 : 						pal_idx = 0;

	mov	DWORD PTR pal_idx$3[rsp], 0
$LN45@stbi__tga_:

; 5055 : 					}
; 5056 : 					pal_idx *= tga_bits_per_pixel / 8;

	mov	eax, DWORD PTR tga_bits_per_pixel$[rsp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	ecx, DWORD PTR pal_idx$3[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR pal_idx$3[rsp], eax

; 5057 : 					for (j = 0; j * 8 < tga_bits_per_pixel; ++j)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN10@stbi__tga_
$LN8@stbi__tga_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN10@stbi__tga_:
	mov	eax, DWORD PTR j$[rsp]
	shl	eax, 3
	cmp	eax, DWORD PTR tga_bits_per_pixel$[rsp]
	jge	SHORT $LN9@stbi__tga_

; 5058 : 					{
; 5059 : 						raw_data[j] = tga_palette[pal_idx + j];

	mov	eax, DWORD PTR j$[rsp]
	mov	ecx, DWORD PTR pal_idx$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR tga_palette$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR raw_data$[rsp+rcx], al

; 5060 : 					}

	jmp	SHORT $LN8@stbi__tga_
$LN9@stbi__tga_:

; 5061 : 				}

	jmp	SHORT $LN44@stbi__tga_
$LN43@stbi__tga_:

; 5062 : 				else
; 5063 : 				{
; 5064 : 					//   read in the data raw
; 5065 : 					for (j = 0; j * 8 < tga_bits_per_pixel; ++j)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN13@stbi__tga_
$LN11@stbi__tga_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN13@stbi__tga_:
	mov	eax, DWORD PTR j$[rsp]
	shl	eax, 3
	cmp	eax, DWORD PTR tga_bits_per_pixel$[rsp]
	jge	SHORT $LN12@stbi__tga_

; 5066 : 					{
; 5067 : 						raw_data[j] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	BYTE PTR raw_data$[rsp+rcx], al

; 5068 : 					}

	jmp	SHORT $LN11@stbi__tga_
$LN12@stbi__tga_:
$LN44@stbi__tga_:

; 5069 : 				}
; 5070 : 				//   clear the reading flag for the next pixel
; 5071 : 				read_next_pixel = 0;

	mov	DWORD PTR read_next_pixel$[rsp], 0
$LN42@stbi__tga_:

; 5072 : 			} // end of reading a pixel
; 5073 : 
; 5074 : 			  // copy data
; 5075 : 			for (j = 0; j < tga_comp; ++j)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN16@stbi__tga_
$LN14@stbi__tga_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN16@stbi__tga_:
	mov	eax, DWORD PTR tga_comp$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jge	SHORT $LN15@stbi__tga_

; 5076 : 				tga_data[i * tga_comp + j] = raw_data[j];

	movsxd	rax, DWORD PTR j$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	imul	ecx, DWORD PTR tga_comp$[rsp]
	add	ecx, DWORD PTR j$[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR tga_data$[rsp]
	movzx	eax, BYTE PTR raw_data$[rsp+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN14@stbi__tga_
$LN15@stbi__tga_:

; 5077 : 
; 5078 : 			//   in case we're in RLE mode, keep counting down
; 5079 : 			--RLE_count;

	mov	eax, DWORD PTR RLE_count$[rsp]
	dec	eax
	mov	DWORD PTR RLE_count$[rsp], eax

; 5080 : 		}

	jmp	$LN5@stbi__tga_
$LN6@stbi__tga_:

; 5081 : 		//   do I need to invert the image?
; 5082 : 		if (tga_inverted)

	cmp	DWORD PTR tga_inverted$[rsp], 0
	je	$LN46@stbi__tga_

; 5083 : 		{
; 5084 : 			for (j = 0; j * 2 < tga_height; ++j)

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN19@stbi__tga_
$LN17@stbi__tga_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN19@stbi__tga_:
	mov	eax, DWORD PTR j$[rsp]
	shl	eax, 1
	cmp	eax, DWORD PTR tga_height$[rsp]
	jge	$LN18@stbi__tga_

; 5085 : 			{
; 5086 : 				int index1 = j * tga_width * tga_comp;

	mov	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR tga_width$[rsp]
	imul	eax, DWORD PTR tga_comp$[rsp]
	mov	DWORD PTR index1$4[rsp], eax

; 5087 : 				int index2 = (tga_height - 1 - j) * tga_width * tga_comp;

	mov	eax, DWORD PTR tga_height$[rsp]
	dec	eax
	sub	eax, DWORD PTR j$[rsp]
	imul	eax, DWORD PTR tga_width$[rsp]
	imul	eax, DWORD PTR tga_comp$[rsp]
	mov	DWORD PTR index2$5[rsp], eax

; 5088 : 				for (i = tga_width * tga_comp; i > 0; --i)

	mov	eax, DWORD PTR tga_width$[rsp]
	imul	eax, DWORD PTR tga_comp$[rsp]
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN22@stbi__tga_
$LN20@stbi__tga_:
	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
$LN22@stbi__tga_:
	cmp	DWORD PTR i$[rsp], 0
	jle	SHORT $LN21@stbi__tga_

; 5089 : 				{
; 5090 : 					unsigned char temp = tga_data[index1];

	movsxd	rax, DWORD PTR index1$4[rsp]
	mov	rcx, QWORD PTR tga_data$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR temp$1[rsp], al

; 5091 : 					tga_data[index1] = tga_data[index2];

	movsxd	rax, DWORD PTR index2$5[rsp]
	movsxd	rcx, DWORD PTR index1$4[rsp]
	mov	rdx, QWORD PTR tga_data$[rsp]
	mov	r8, QWORD PTR tga_data$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5092 : 					tga_data[index2] = temp;

	movsxd	rax, DWORD PTR index2$5[rsp]
	mov	rcx, QWORD PTR tga_data$[rsp]
	movzx	edx, BYTE PTR temp$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 5093 : 					++index1;

	mov	eax, DWORD PTR index1$4[rsp]
	inc	eax
	mov	DWORD PTR index1$4[rsp], eax

; 5094 : 					++index2;

	mov	eax, DWORD PTR index2$5[rsp]
	inc	eax
	mov	DWORD PTR index2$5[rsp], eax

; 5095 : 				}

	jmp	SHORT $LN20@stbi__tga_
$LN21@stbi__tga_:

; 5096 : 			}

	jmp	$LN17@stbi__tga_
$LN18@stbi__tga_:
$LN46@stbi__tga_:

; 5097 : 		}
; 5098 : 		//   clear my palette, if I had one
; 5099 : 		if (tga_palette != NULL)

	cmp	QWORD PTR tga_palette$[rsp], 0
	je	SHORT $LN47@stbi__tga_

; 5100 : 		{
; 5101 : 			STBI_FREE(tga_palette);

	mov	rcx, QWORD PTR tga_palette$[rsp]
	call	free
	npad	1
$LN47@stbi__tga_:
$LN33@stbi__tga_:

; 5102 : 		}
; 5103 : 	}
; 5104 : 
; 5105 : 	// swap RGB
; 5106 : 	if (tga_comp >= 3)

	cmp	DWORD PTR tga_comp$[rsp], 3
	jl	$LN48@stbi__tga_

; 5107 : 	{
; 5108 : 		unsigned char* tga_pixel = tga_data;

	mov	rax, QWORD PTR tga_data$[rsp]
	mov	QWORD PTR tga_pixel$6[rsp], rax

; 5109 : 		for (i = 0; i < tga_width * tga_height; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN25@stbi__tga_
$LN23@stbi__tga_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN25@stbi__tga_:
	mov	eax, DWORD PTR tga_width$[rsp]
	imul	eax, DWORD PTR tga_height$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN24@stbi__tga_

; 5110 : 		{
; 5111 : 			unsigned char temp = tga_pixel[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tga_pixel$6[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR temp$2[rsp], al

; 5112 : 			tga_pixel[0] = tga_pixel[2];

	mov	eax, 1
	imul	rax, rax, 2
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tga_pixel$6[rsp]
	mov	r8, QWORD PTR tga_pixel$6[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 5113 : 			tga_pixel[2] = temp;

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR tga_pixel$6[rsp]
	movzx	edx, BYTE PTR temp$2[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 5114 : 			tga_pixel += tga_comp;

	movsxd	rax, DWORD PTR tga_comp$[rsp]
	mov	rcx, QWORD PTR tga_pixel$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tga_pixel$6[rsp], rax

; 5115 : 		}

	jmp	$LN23@stbi__tga_
$LN24@stbi__tga_:
$LN48@stbi__tga_:

; 5116 : 	}
; 5117 : 
; 5118 : 	// convert to target component count
; 5119 : 	if (req_comp && req_comp != tga_comp)

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN49@stbi__tga_
	mov	eax, DWORD PTR tga_comp$[rsp]
	cmp	DWORD PTR req_comp$[rsp], eax
	je	SHORT $LN49@stbi__tga_

; 5120 : 		tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

	mov	eax, DWORD PTR tga_height$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR tga_width$[rsp]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	edx, DWORD PTR tga_comp$[rsp]
	mov	rcx, QWORD PTR tga_data$[rsp]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	mov	QWORD PTR tga_data$[rsp], rax
$LN49@stbi__tga_:

; 5121 : 
; 5122 : 	//   the things I do to get rid of an error message, and yet keep
; 5123 : 	//   Microsoft's C compilers happy... [8^(
; 5124 : 	tga_palette_start = tga_palette_len = tga_palette_bits =

	mov	DWORD PTR tga_y_origin$[rsp], 0
	mov	eax, DWORD PTR tga_y_origin$[rsp]
	mov	DWORD PTR tga_x_origin$[rsp], eax
	mov	eax, DWORD PTR tga_x_origin$[rsp]
	mov	DWORD PTR tga_palette_bits$[rsp], eax
	mov	eax, DWORD PTR tga_palette_bits$[rsp]
	mov	DWORD PTR tga_palette_len$[rsp], eax
	mov	eax, DWORD PTR tga_palette_len$[rsp]
	mov	DWORD PTR tga_palette_start$[rsp], eax

; 5125 : 		tga_x_origin = tga_y_origin = 0;
; 5126 : 	//   OK, done
; 5127 : 	return tga_data;

	mov	rax, QWORD PTR tga_data$[rsp]
$LN1@stbi__tga_:

; 5128 : }

	add	rsp, 216				; 000000d8H
	ret	0
?stbi__tga_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__tga_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
sz$ = 32
res$ = 36
s$ = 64
?stbi__tga_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__tga_test

; 4908 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4909 : 	int res;
; 4910 : 	int sz;
; 4911 : 	stbi__get8(s);      //   discard Offset

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8

; 4912 : 	sz = stbi__get8(s);   //   color type

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR sz$[rsp], eax

; 4913 : 	if (sz > 1) return 0;   //   only RGB or indexed allowed

	cmp	DWORD PTR sz$[rsp], 1
	jle	SHORT $LN2@stbi__tga_
	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN2@stbi__tga_:

; 4914 : 	sz = stbi__get8(s);   //   image type

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR sz$[rsp], eax

; 4915 : 	if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;   //   only RGB or grey allowed, +/- RLE

	cmp	DWORD PTR sz$[rsp], 1
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 2
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 3
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 9
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 10
	je	SHORT $LN3@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 11
	je	SHORT $LN3@stbi__tga_
	xor	eax, eax
	jmp	$LN1@stbi__tga_
$LN3@stbi__tga_:

; 4916 : 	stbi__get16be(s);      //   discard palette start

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 4917 : 	stbi__get16be(s);      //   discard palette length

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 4918 : 	stbi__get8(s);         //   discard bits per palette color entry

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8

; 4919 : 	stbi__get16be(s);      //   discard x origin

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 4920 : 	stbi__get16be(s);      //   discard y origin

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	npad	1

; 4921 : 	if (stbi__get16be(s) < 1) return 0;      //   test width

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 1
	jge	SHORT $LN4@stbi__tga_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__tga_
$LN4@stbi__tga_:

; 4922 : 	if (stbi__get16be(s) < 1) return 0;      //   test height

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
	cmp	eax, 1
	jge	SHORT $LN5@stbi__tga_
	xor	eax, eax
	jmp	SHORT $LN1@stbi__tga_
$LN5@stbi__tga_:

; 4923 : 	sz = stbi__get8(s);   //   bits per pixel

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR sz$[rsp], eax

; 4924 : 	if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32))

	cmp	DWORD PTR sz$[rsp], 8
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 16
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 24
	je	SHORT $LN6@stbi__tga_
	cmp	DWORD PTR sz$[rsp], 32			; 00000020H
	je	SHORT $LN6@stbi__tga_

; 4925 : 		res = 0;

	mov	DWORD PTR res$[rsp], 0
	jmp	SHORT $LN7@stbi__tga_
$LN6@stbi__tga_:

; 4926 : 	else
; 4927 : 		res = 1;

	mov	DWORD PTR res$[rsp], 1
$LN7@stbi__tga_:

; 4928 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4929 : 	return res;

	mov	eax, DWORD PTR res$[rsp]
$LN1@stbi__tga_:

; 4930 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__tga_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__tga_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
hsz$ = 32
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__bmp_info

; 6135 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6136 : 	int hsz;
; 6137 : 	if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN3@stbi__bmp_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 77					; 0000004dH
	je	SHORT $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 6138 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6139 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 6140 : 	}
; 6141 : 	stbi__skip(s, 12);

	mov	edx, 12
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip

; 6142 : 	hsz = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR hsz$[rsp], eax

; 6143 : 	if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) {

	cmp	DWORD PTR hsz$[rsp], 12
	je	SHORT $LN4@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 40			; 00000028H
	je	SHORT $LN4@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 56			; 00000038H
	je	SHORT $LN4@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 108		; 0000006cH
	je	SHORT $LN4@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 124		; 0000007cH
	je	SHORT $LN4@stbi__bmp_

; 6144 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6145 : 		return 0;

	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN4@stbi__bmp_:

; 6146 : 	}
; 6147 : 	if (hsz == 12) {

	cmp	DWORD PTR hsz$[rsp], 12
	jne	SHORT $LN5@stbi__bmp_

; 6148 : 		*x = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	rcx, QWORD PTR x$[rsp]
	mov	DWORD PTR [rcx], eax

; 6149 : 		*y = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	rcx, QWORD PTR y$[rsp]
	mov	DWORD PTR [rcx], eax

; 6150 : 	}

	jmp	SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:

; 6151 : 	else {
; 6152 : 		*x = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	rcx, QWORD PTR x$[rsp]
	mov	DWORD PTR [rcx], eax

; 6153 : 		*y = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	rcx, QWORD PTR y$[rsp]
	mov	DWORD PTR [rcx], eax
$LN6@stbi__bmp_:

; 6154 : 	}
; 6155 : 	if (stbi__get16le(s) != 1) {

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	cmp	eax, 1
	je	SHORT $LN7@stbi__bmp_

; 6156 : 		stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 6157 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@stbi__bmp_
$LN7@stbi__bmp_:

; 6158 : 	}
; 6159 : 	*comp = stbi__get16le(s) / 8;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	rcx, QWORD PTR comp$[rsp]
	mov	DWORD PTR [rcx], eax

; 6160 : 	return 1;

	mov	eax, 1
$LN1@stbi__bmp_:

; 6161 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__bmp_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
i$ = 48
z$1 = 52
z$2 = 56
hsz$ = 60
bpp$ = 64
out$ = 72
mg$ = 80
j$ = 84
target$ = 88
mb$ = 92
a$3 = 96
mr$ = 100
v$4 = 104
ma$ = 108
t$5 = 112
psize$ = 116
width$ = 120
all_a$ = 124
compress$ = 128
easy$6 = 132
offset$ = 136
v$7 = 140
pad$ = 144
tv199 = 148
tv248 = 152
v2$8 = 156
tv313 = 160
tv453 = 164
tv470 = 168
rcount$9 = 172
rshift$10 = 176
gcount$11 = 180
gshift$12 = 184
bcount$13 = 188
bshift$14 = 192
acount$15 = 196
ashift$16 = 200
tv510 = 204
a$17 = 208
tv137 = 212
flip_vertically$ = 216
p1$18 = 224
p2$19 = 232
pal$ = 240
__$ArrayPad$ = 1264
s$ = 1296
x$ = 1304
y$ = 1312
comp$ = 1320
req_comp$ = 1328
?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__bmp_load

; 4649 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1288				; 00000508H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4650 : 	stbi_uc* out;
; 4651 : 	unsigned int mr = 0, mg = 0, mb = 0, ma = 0, all_a = 255;

	mov	DWORD PTR mr$[rsp], 0
	mov	DWORD PTR mg$[rsp], 0
	mov	DWORD PTR mb$[rsp], 0
	mov	DWORD PTR ma$[rsp], 0
	mov	DWORD PTR all_a$[rsp], 255		; 000000ffH

; 4652 : 	stbi_uc pal[256][4];
; 4653 : 	int psize = 0, i, j, compress = 0, width;

	mov	DWORD PTR psize$[rsp], 0
	mov	DWORD PTR compress$[rsp], 0

; 4654 : 	int bpp, flip_vertically, pad, target, offset, hsz;
; 4655 : 	if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN33@stbi__bmp_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	cmp	eax, 77					; 0000004dH
	je	SHORT $LN32@stbi__bmp_
$LN33@stbi__bmp_:
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN32@stbi__bmp_:

; 4656 : 	stbi__get32le(s); // discard filesize

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4657 : 	stbi__get16le(s); // discard reserved

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 4658 : 	stbi__get16le(s); // discard reserved

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 4659 : 	offset = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR offset$[rsp], eax

; 4660 : 	hsz = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR hsz$[rsp], eax

; 4661 : 	if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

	cmp	DWORD PTR hsz$[rsp], 12
	je	SHORT $LN34@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 40			; 00000028H
	je	SHORT $LN34@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 56			; 00000038H
	je	SHORT $LN34@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 108		; 0000006cH
	je	SHORT $LN34@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 124		; 0000007cH
	je	SHORT $LN34@stbi__bmp_
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN34@stbi__bmp_:

; 4662 : 	if (hsz == 12) {

	cmp	DWORD PTR hsz$[rsp], 12
	jne	SHORT $LN35@stbi__bmp_

; 4663 : 		s->img_x = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx], eax

; 4664 : 		s->img_y = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 4665 : 	}

	jmp	SHORT $LN36@stbi__bmp_
$LN35@stbi__bmp_:

; 4666 : 	else {
; 4667 : 		s->img_x = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx], eax

; 4668 : 		s->img_y = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+4], eax
$LN36@stbi__bmp_:

; 4669 : 	}
; 4670 : 	if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	cmp	eax, 1
	je	SHORT $LN37@stbi__bmp_
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN37@stbi__bmp_:

; 4671 : 	bpp = stbi__get16le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR bpp$[rsp], eax

; 4672 : 	if (bpp == 1) return stbi__errpuc("monochrome", "BMP type not supported: 1-bit");

	cmp	DWORD PTR bpp$[rsp], 1
	jne	SHORT $LN38@stbi__bmp_
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN38@stbi__bmp_:

; 4673 : 	flip_vertically = ((int)s->img_y) > 0;

	mov	rax, QWORD PTR s$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jle	SHORT $LN96@stbi__bmp_
	mov	DWORD PTR tv137[rsp], 1
	jmp	SHORT $LN97@stbi__bmp_
$LN96@stbi__bmp_:
	mov	DWORD PTR tv137[rsp], 0
$LN97@stbi__bmp_:
	mov	eax, DWORD PTR tv137[rsp]
	mov	DWORD PTR flip_vertically$[rsp], eax

; 4674 : 	s->img_y = abs((int)s->img_y);

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rax+4]
	call	abs
	mov	rcx, QWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 4675 : 	if (hsz == 12) {

	cmp	DWORD PTR hsz$[rsp], 12
	jne	SHORT $LN39@stbi__bmp_

; 4676 : 		if (bpp < 24)

	cmp	DWORD PTR bpp$[rsp], 24
	jge	SHORT $LN41@stbi__bmp_

; 4677 : 			psize = (offset - 14 - 24) / 3;

	mov	eax, DWORD PTR offset$[rsp]
	sub	eax, 38					; 00000026H
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR psize$[rsp], eax
$LN41@stbi__bmp_:

; 4678 : 	}

	jmp	$LN40@stbi__bmp_
$LN39@stbi__bmp_:

; 4679 : 	else {
; 4680 : 		compress = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR compress$[rsp], eax

; 4681 : 		if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

	cmp	DWORD PTR compress$[rsp], 1
	je	SHORT $LN43@stbi__bmp_
	cmp	DWORD PTR compress$[rsp], 2
	jne	SHORT $LN42@stbi__bmp_
$LN43@stbi__bmp_:
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN42@stbi__bmp_:

; 4682 : 		stbi__get32le(s); // discard sizeof

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4683 : 		stbi__get32le(s); // discard hres

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4684 : 		stbi__get32le(s); // discard vres

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4685 : 		stbi__get32le(s); // discard colorsused

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4686 : 		stbi__get32le(s); // discard max important

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	npad	1

; 4687 : 		if (hsz == 40 || hsz == 56) {

	cmp	DWORD PTR hsz$[rsp], 40			; 00000028H
	je	SHORT $LN46@stbi__bmp_
	cmp	DWORD PTR hsz$[rsp], 56			; 00000038H
	jne	$LN44@stbi__bmp_
$LN46@stbi__bmp_:

; 4688 : 			if (hsz == 56) {

	cmp	DWORD PTR hsz$[rsp], 56			; 00000038H
	jne	SHORT $LN47@stbi__bmp_

; 4689 : 				stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4690 : 				stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4691 : 				stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4692 : 				stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	npad	1
$LN47@stbi__bmp_:

; 4693 : 			}
; 4694 : 			if (bpp == 16 || bpp == 32) {

	cmp	DWORD PTR bpp$[rsp], 16
	je	SHORT $LN49@stbi__bmp_
	cmp	DWORD PTR bpp$[rsp], 32			; 00000020H
	jne	$LN48@stbi__bmp_
$LN49@stbi__bmp_:

; 4695 : 				mr = mg = mb = 0;

	mov	DWORD PTR mb$[rsp], 0
	mov	eax, DWORD PTR mb$[rsp]
	mov	DWORD PTR mg$[rsp], eax
	mov	eax, DWORD PTR mg$[rsp]
	mov	DWORD PTR mr$[rsp], eax

; 4696 : 				if (compress == 0) {

	cmp	DWORD PTR compress$[rsp], 0
	jne	SHORT $LN50@stbi__bmp_

; 4697 : 					if (bpp == 32) {

	cmp	DWORD PTR bpp$[rsp], 32			; 00000020H
	jne	SHORT $LN52@stbi__bmp_

; 4698 : 						mr = 0xffu << 16;

	mov	DWORD PTR mr$[rsp], 16711680		; 00ff0000H

; 4699 : 						mg = 0xffu << 8;

	mov	DWORD PTR mg$[rsp], 65280		; 0000ff00H

; 4700 : 						mb = 0xffu << 0;

	mov	DWORD PTR mb$[rsp], 255			; 000000ffH

; 4701 : 						ma = 0xffu << 24;

	mov	DWORD PTR ma$[rsp], -16777216		; ff000000H

; 4702 : 						all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

	mov	DWORD PTR all_a$[rsp], 0

; 4703 : 					}

	jmp	SHORT $LN53@stbi__bmp_
$LN52@stbi__bmp_:

; 4704 : 					else {
; 4705 : 						mr = 31u << 10;

	mov	DWORD PTR mr$[rsp], 31744		; 00007c00H

; 4706 : 						mg = 31u << 5;

	mov	DWORD PTR mg$[rsp], 992			; 000003e0H

; 4707 : 						mb = 31u << 0;

	mov	DWORD PTR mb$[rsp], 31
$LN53@stbi__bmp_:

; 4708 : 					}
; 4709 : 				}

	jmp	SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:

; 4710 : 				else if (compress == 3) {

	cmp	DWORD PTR compress$[rsp], 3
	jne	SHORT $LN54@stbi__bmp_

; 4711 : 					mr = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR mr$[rsp], eax

; 4712 : 					mg = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR mg$[rsp], eax

; 4713 : 					mb = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR mb$[rsp], eax

; 4714 : 					// not documented, but generated by photoshop and handled by mspaint
; 4715 : 					if (mr == mg && mg == mb) {

	mov	eax, DWORD PTR mg$[rsp]
	cmp	DWORD PTR mr$[rsp], eax
	jne	SHORT $LN56@stbi__bmp_
	mov	eax, DWORD PTR mb$[rsp]
	cmp	DWORD PTR mg$[rsp], eax
	jne	SHORT $LN56@stbi__bmp_

; 4716 : 						// ?!?!?
; 4717 : 						return stbi__errpuc("bad BMP", "bad BMP");

	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN56@stbi__bmp_:

; 4718 : 					}
; 4719 : 				}

	jmp	SHORT $LN55@stbi__bmp_
$LN54@stbi__bmp_:

; 4720 : 				else
; 4721 : 					return stbi__errpuc("bad BMP", "bad BMP");

	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN55@stbi__bmp_:
$LN51@stbi__bmp_:
$LN48@stbi__bmp_:

; 4722 : 			}
; 4723 : 		}

	jmp	$LN45@stbi__bmp_
$LN44@stbi__bmp_:

; 4724 : 		else {
; 4725 : 			STBI_ASSERT(hsz == 108 || hsz == 124);
; 4726 : 			mr = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR mr$[rsp], eax

; 4727 : 			mg = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR mg$[rsp], eax

; 4728 : 			mb = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR mb$[rsp], eax

; 4729 : 			ma = stbi__get32le(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR ma$[rsp], eax

; 4730 : 			stbi__get32le(s); // discard color space

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	npad	1

; 4731 : 			for (i = 0; i < 12; ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@stbi__bmp_:
	cmp	DWORD PTR i$[rsp], 12
	jge	SHORT $LN3@stbi__bmp_

; 4732 : 				stbi__get32le(s); // discard color space parameters

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	npad	1
	jmp	SHORT $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 4733 : 			if (hsz == 124) {

	cmp	DWORD PTR hsz$[rsp], 124		; 0000007cH
	jne	SHORT $LN57@stbi__bmp_

; 4734 : 				stbi__get32le(s); // discard rendering intent

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4735 : 				stbi__get32le(s); // discard offset of profile data

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4736 : 				stbi__get32le(s); // discard size of profile data

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 4737 : 				stbi__get32le(s); // discard reserved

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	npad	1
$LN57@stbi__bmp_:
$LN45@stbi__bmp_:

; 4738 : 			}
; 4739 : 		}
; 4740 : 		if (bpp < 16)

	cmp	DWORD PTR bpp$[rsp], 16
	jge	SHORT $LN58@stbi__bmp_

; 4741 : 			psize = (offset - 14 - hsz) >> 2;

	mov	eax, DWORD PTR offset$[rsp]
	sub	eax, 14
	sub	eax, DWORD PTR hsz$[rsp]
	sar	eax, 2
	mov	DWORD PTR psize$[rsp], eax
$LN58@stbi__bmp_:
$LN40@stbi__bmp_:

; 4742 : 	}
; 4743 : 	s->img_n = ma ? 4 : 3;

	cmp	DWORD PTR ma$[rsp], 0
	je	SHORT $LN98@stbi__bmp_
	mov	DWORD PTR tv199[rsp], 4
	jmp	SHORT $LN99@stbi__bmp_
$LN98@stbi__bmp_:
	mov	DWORD PTR tv199[rsp], 3
$LN99@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR tv199[rsp]
	mov	DWORD PTR [rax+8], ecx

; 4744 : 	if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN59@stbi__bmp_
	cmp	DWORD PTR req_comp$[rsp], 3
	jl	SHORT $LN59@stbi__bmp_

; 4745 : 		target = req_comp;

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR target$[rsp], eax
	jmp	SHORT $LN60@stbi__bmp_
$LN59@stbi__bmp_:

; 4746 : 	else
; 4747 : 		target = s->img_n; // if they want monochrome, we'll post-convert

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR target$[rsp], eax
$LN60@stbi__bmp_:

; 4748 : 	out = (stbi_uc*)stbi__malloc(target * s->img_x * s->img_y);

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR target$[rsp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	rcx, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	mov	eax, eax
	mov	ecx, eax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR out$[rsp], rax

; 4749 : 	if (!out) return stbi__errpuc("outofmem", "Out of memory");

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN61@stbi__bmp_
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN61@stbi__bmp_:

; 4750 : 	if (bpp < 16) {

	cmp	DWORD PTR bpp$[rsp], 16
	jge	$LN62@stbi__bmp_

; 4751 : 		int z = 0;

	mov	DWORD PTR z$1[rsp], 0

; 4752 : 		if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

	cmp	DWORD PTR psize$[rsp], 0
	je	SHORT $LN65@stbi__bmp_
	cmp	DWORD PTR psize$[rsp], 256		; 00000100H
	jle	SHORT $LN64@stbi__bmp_
$LN65@stbi__bmp_:
	mov	rcx, QWORD PTR out$[rsp]
	call	free
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN64@stbi__bmp_:

; 4753 : 		for (i = 0; i < psize; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@stbi__bmp_
$LN5@stbi__bmp_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@stbi__bmp_:
	mov	eax, DWORD PTR psize$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN6@stbi__bmp_

; 4754 : 			pal[i][2] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR pal$[rsp+rcx*4]
	mov	edx, 1
	imul	rdx, rdx, 2
	mov	BYTE PTR [rcx+rdx], al

; 4755 : 			pal[i][1] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR pal$[rsp+rcx*4]
	mov	edx, 1
	imul	rdx, rdx, 1
	mov	BYTE PTR [rcx+rdx], al

; 4756 : 			pal[i][0] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR pal$[rsp+rcx*4]
	mov	edx, 1
	imul	rdx, rdx, 0
	mov	BYTE PTR [rcx+rdx], al

; 4757 : 			if (hsz != 12) stbi__get8(s);

	cmp	DWORD PTR hsz$[rsp], 12
	je	SHORT $LN66@stbi__bmp_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	npad	1
$LN66@stbi__bmp_:

; 4758 : 			pal[i][3] = 255;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rax, QWORD PTR pal$[rsp+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 3
	mov	BYTE PTR [rax+rcx], 255			; 000000ffH

; 4759 : 		}

	jmp	$LN5@stbi__bmp_
$LN6@stbi__bmp_:

; 4760 : 		stbi__skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));

	cmp	DWORD PTR hsz$[rsp], 12
	jne	SHORT $LN100@stbi__bmp_
	mov	DWORD PTR tv248[rsp], 3
	jmp	SHORT $LN101@stbi__bmp_
$LN100@stbi__bmp_:
	mov	DWORD PTR tv248[rsp], 4
$LN101@stbi__bmp_:
	mov	eax, DWORD PTR offset$[rsp]
	sub	eax, 14
	sub	eax, DWORD PTR hsz$[rsp]
	mov	ecx, DWORD PTR psize$[rsp]
	imul	ecx, DWORD PTR tv248[rsp]
	sub	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 4761 : 		if (bpp == 4) width = (s->img_x + 1) >> 1;

	cmp	DWORD PTR bpp$[rsp], 4
	jne	SHORT $LN67@stbi__bmp_
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	shr	eax, 1
	mov	DWORD PTR width$[rsp], eax
	jmp	SHORT $LN68@stbi__bmp_
$LN67@stbi__bmp_:

; 4762 : 		else if (bpp == 8) width = s->img_x;

	cmp	DWORD PTR bpp$[rsp], 8
	jne	SHORT $LN69@stbi__bmp_
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR width$[rsp], eax
	jmp	SHORT $LN70@stbi__bmp_
$LN69@stbi__bmp_:

; 4763 : 		else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

	mov	rcx, QWORD PTR out$[rsp]
	call	free
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN70@stbi__bmp_:
$LN68@stbi__bmp_:

; 4764 : 		pad = (-width) & 3;

	mov	eax, DWORD PTR width$[rsp]
	neg	eax
	and	eax, 3
	mov	DWORD PTR pad$[rsp], eax

; 4765 : 		for (j = 0; j < (int)s->img_y; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN10@stbi__bmp_
$LN8@stbi__bmp_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN10@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN9@stbi__bmp_

; 4766 : 			for (i = 0; i < (int)s->img_x; i += 2) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@stbi__bmp_
$LN11@stbi__bmp_:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 2
	mov	DWORD PTR i$[rsp], eax
$LN13@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN12@stbi__bmp_

; 4767 : 				int v = stbi__get8(s), v2 = 0;

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR v$4[rsp], eax
	mov	DWORD PTR v2$8[rsp], 0

; 4768 : 				if (bpp == 4) {

	cmp	DWORD PTR bpp$[rsp], 4
	jne	SHORT $LN71@stbi__bmp_

; 4769 : 					v2 = v & 15;

	mov	eax, DWORD PTR v$4[rsp]
	and	eax, 15
	mov	DWORD PTR v2$8[rsp], eax

; 4770 : 					v >>= 4;

	mov	eax, DWORD PTR v$4[rsp]
	sar	eax, 4
	mov	DWORD PTR v$4[rsp], eax
$LN71@stbi__bmp_:

; 4771 : 				}
; 4772 : 				out[z++] = pal[v][0];

	movsxd	rax, DWORD PTR v$4[rsp]
	lea	rax, QWORD PTR pal$[rsp+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 0
	movsxd	rdx, DWORD PTR z$1[rsp]
	mov	r8, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR [r8+rdx], al
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax

; 4773 : 				out[z++] = pal[v][1];

	movsxd	rax, DWORD PTR v$4[rsp]
	lea	rax, QWORD PTR pal$[rsp+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 1
	movsxd	rdx, DWORD PTR z$1[rsp]
	mov	r8, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR [r8+rdx], al
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax

; 4774 : 				out[z++] = pal[v][2];

	movsxd	rax, DWORD PTR v$4[rsp]
	lea	rax, QWORD PTR pal$[rsp+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 2
	movsxd	rdx, DWORD PTR z$1[rsp]
	mov	r8, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR [r8+rdx], al
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax

; 4775 : 				if (target == 4) out[z++] = 255;

	cmp	DWORD PTR target$[rsp], 4
	jne	SHORT $LN72@stbi__bmp_
	movsxd	rax, DWORD PTR z$1[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax
$LN72@stbi__bmp_:

; 4776 : 				if (i + 1 == (int)s->img_x) break;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	rcx, QWORD PTR s$[rsp]
	cmp	eax, DWORD PTR [rcx]
	jne	SHORT $LN73@stbi__bmp_
	jmp	$LN12@stbi__bmp_
$LN73@stbi__bmp_:

; 4777 : 				v = (bpp == 8) ? stbi__get8(s) : v2;

	cmp	DWORD PTR bpp$[rsp], 8
	jne	SHORT $LN102@stbi__bmp_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tv313[rsp], eax
	jmp	SHORT $LN103@stbi__bmp_
$LN102@stbi__bmp_:
	mov	eax, DWORD PTR v2$8[rsp]
	mov	DWORD PTR tv313[rsp], eax
$LN103@stbi__bmp_:
	mov	eax, DWORD PTR tv313[rsp]
	mov	DWORD PTR v$4[rsp], eax

; 4778 : 				out[z++] = pal[v][0];

	movsxd	rax, DWORD PTR v$4[rsp]
	lea	rax, QWORD PTR pal$[rsp+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 0
	movsxd	rdx, DWORD PTR z$1[rsp]
	mov	r8, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR [r8+rdx], al
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax

; 4779 : 				out[z++] = pal[v][1];

	movsxd	rax, DWORD PTR v$4[rsp]
	lea	rax, QWORD PTR pal$[rsp+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 1
	movsxd	rdx, DWORD PTR z$1[rsp]
	mov	r8, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR [r8+rdx], al
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax

; 4780 : 				out[z++] = pal[v][2];

	movsxd	rax, DWORD PTR v$4[rsp]
	lea	rax, QWORD PTR pal$[rsp+rax*4]
	mov	ecx, 1
	imul	rcx, rcx, 2
	movsxd	rdx, DWORD PTR z$1[rsp]
	mov	r8, QWORD PTR out$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR [r8+rdx], al
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax

; 4781 : 				if (target == 4) out[z++] = 255;

	cmp	DWORD PTR target$[rsp], 4
	jne	SHORT $LN74@stbi__bmp_
	movsxd	rax, DWORD PTR z$1[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	mov	eax, DWORD PTR z$1[rsp]
	inc	eax
	mov	DWORD PTR z$1[rsp], eax
$LN74@stbi__bmp_:

; 4782 : 			}

	jmp	$LN11@stbi__bmp_
$LN12@stbi__bmp_:

; 4783 : 			stbi__skip(s, pad);

	mov	edx, DWORD PTR pad$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 4784 : 		}

	jmp	$LN8@stbi__bmp_
$LN9@stbi__bmp_:

; 4785 : 	}

	jmp	$LN63@stbi__bmp_
$LN62@stbi__bmp_:

; 4786 : 	else {
; 4787 : 		int rshift = 0, gshift = 0, bshift = 0, ashift = 0, rcount = 0, gcount = 0, bcount = 0, acount = 0;

	mov	DWORD PTR rshift$10[rsp], 0
	mov	DWORD PTR gshift$12[rsp], 0
	mov	DWORD PTR bshift$14[rsp], 0
	mov	DWORD PTR ashift$16[rsp], 0
	mov	DWORD PTR rcount$9[rsp], 0
	mov	DWORD PTR gcount$11[rsp], 0
	mov	DWORD PTR bcount$13[rsp], 0
	mov	DWORD PTR acount$15[rsp], 0

; 4788 : 		int z = 0;

	mov	DWORD PTR z$2[rsp], 0

; 4789 : 		int easy = 0;

	mov	DWORD PTR easy$6[rsp], 0

; 4790 : 		stbi__skip(s, offset - 14 - hsz);

	mov	eax, DWORD PTR offset$[rsp]
	sub	eax, 14
	sub	eax, DWORD PTR hsz$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 4791 : 		if (bpp == 24) width = 3 * s->img_x;

	cmp	DWORD PTR bpp$[rsp], 24
	jne	SHORT $LN75@stbi__bmp_
	mov	rax, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rax], 3
	mov	DWORD PTR width$[rsp], eax
	jmp	SHORT $LN76@stbi__bmp_
$LN75@stbi__bmp_:

; 4792 : 		else if (bpp == 16) width = 2 * s->img_x;

	cmp	DWORD PTR bpp$[rsp], 16
	jne	SHORT $LN77@stbi__bmp_
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	shl	eax, 1
	mov	DWORD PTR width$[rsp], eax
	jmp	SHORT $LN78@stbi__bmp_
$LN77@stbi__bmp_:

; 4793 : 		else /* bpp = 32 and pad = 0 */ width = 0;

	mov	DWORD PTR width$[rsp], 0
$LN78@stbi__bmp_:
$LN76@stbi__bmp_:

; 4794 : 		pad = (-width) & 3;

	mov	eax, DWORD PTR width$[rsp]
	neg	eax
	and	eax, 3
	mov	DWORD PTR pad$[rsp], eax

; 4795 : 		if (bpp == 24) {

	cmp	DWORD PTR bpp$[rsp], 24
	jne	SHORT $LN79@stbi__bmp_

; 4796 : 			easy = 1;

	mov	DWORD PTR easy$6[rsp], 1

; 4797 : 		}

	jmp	SHORT $LN80@stbi__bmp_
$LN79@stbi__bmp_:

; 4798 : 		else if (bpp == 32) {

	cmp	DWORD PTR bpp$[rsp], 32			; 00000020H
	jne	SHORT $LN81@stbi__bmp_

; 4799 : 			if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

	cmp	DWORD PTR mb$[rsp], 255			; 000000ffH
	jne	SHORT $LN82@stbi__bmp_
	cmp	DWORD PTR mg$[rsp], 65280		; 0000ff00H
	jne	SHORT $LN82@stbi__bmp_
	cmp	DWORD PTR mr$[rsp], 16711680		; 00ff0000H
	jne	SHORT $LN82@stbi__bmp_
	cmp	DWORD PTR ma$[rsp], -16777216		; ff000000H
	jne	SHORT $LN82@stbi__bmp_

; 4800 : 				easy = 2;

	mov	DWORD PTR easy$6[rsp], 2
$LN82@stbi__bmp_:
$LN81@stbi__bmp_:
$LN80@stbi__bmp_:

; 4801 : 		}
; 4802 : 		if (!easy) {

	cmp	DWORD PTR easy$6[rsp], 0
	jne	$LN83@stbi__bmp_

; 4803 : 			if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

	cmp	DWORD PTR mr$[rsp], 0
	je	SHORT $LN85@stbi__bmp_
	cmp	DWORD PTR mg$[rsp], 0
	je	SHORT $LN85@stbi__bmp_
	cmp	DWORD PTR mb$[rsp], 0
	jne	SHORT $LN84@stbi__bmp_
$LN85@stbi__bmp_:
	mov	rcx, QWORD PTR out$[rsp]
	call	free
	xor	eax, eax
	jmp	$LN1@stbi__bmp_
$LN84@stbi__bmp_:

; 4804 : 			// right shift amt to put high bit in position #7
; 4805 : 			rshift = stbi__high_bit(mr) - 7; rcount = stbi__bitcount(mr);

	mov	ecx, DWORD PTR mr$[rsp]
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	sub	eax, 7
	mov	DWORD PTR rshift$10[rsp], eax
	mov	ecx, DWORD PTR mr$[rsp]
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	mov	DWORD PTR rcount$9[rsp], eax

; 4806 : 			gshift = stbi__high_bit(mg) - 7; gcount = stbi__bitcount(mg);

	mov	ecx, DWORD PTR mg$[rsp]
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	sub	eax, 7
	mov	DWORD PTR gshift$12[rsp], eax
	mov	ecx, DWORD PTR mg$[rsp]
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	mov	DWORD PTR gcount$11[rsp], eax

; 4807 : 			bshift = stbi__high_bit(mb) - 7; bcount = stbi__bitcount(mb);

	mov	ecx, DWORD PTR mb$[rsp]
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	sub	eax, 7
	mov	DWORD PTR bshift$14[rsp], eax
	mov	ecx, DWORD PTR mb$[rsp]
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	mov	DWORD PTR bcount$13[rsp], eax

; 4808 : 			ashift = stbi__high_bit(ma) - 7; acount = stbi__bitcount(ma);

	mov	ecx, DWORD PTR ma$[rsp]
	call	?stbi__high_bit@@YAHI@Z			; stbi__high_bit
	sub	eax, 7
	mov	DWORD PTR ashift$16[rsp], eax
	mov	ecx, DWORD PTR ma$[rsp]
	call	?stbi__bitcount@@YAHI@Z			; stbi__bitcount
	mov	DWORD PTR acount$15[rsp], eax
$LN83@stbi__bmp_:

; 4809 : 		}
; 4810 : 		for (j = 0; j < (int)s->img_y; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN16@stbi__bmp_
$LN14@stbi__bmp_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN16@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN15@stbi__bmp_

; 4811 : 			if (easy) {

	cmp	DWORD PTR easy$6[rsp], 0
	je	$LN86@stbi__bmp_

; 4812 : 				for (i = 0; i < (int)s->img_x; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN19@stbi__bmp_
$LN17@stbi__bmp_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN19@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN18@stbi__bmp_

; 4813 : 					unsigned char a;
; 4814 : 					out[z + 2] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR z$2[rsp]
	add	ecx, 2
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 4815 : 					out[z + 1] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR z$2[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 4816 : 					out[z + 0] = stbi__get8(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	mov	ecx, DWORD PTR z$2[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 4817 : 					z += 3;

	mov	eax, DWORD PTR z$2[rsp]
	add	eax, 3
	mov	DWORD PTR z$2[rsp], eax

; 4818 : 					a = (easy == 2 ? stbi__get8(s) : 255);

	cmp	DWORD PTR easy$6[rsp], 2
	jne	SHORT $LN104@stbi__bmp_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get8@@YAEPEAUstbi__context@@@Z	; stbi__get8
	movzx	eax, al
	mov	DWORD PTR tv453[rsp], eax
	jmp	SHORT $LN105@stbi__bmp_
$LN104@stbi__bmp_:
	mov	DWORD PTR tv453[rsp], 255		; 000000ffH
$LN105@stbi__bmp_:
	movzx	eax, BYTE PTR tv453[rsp]
	mov	BYTE PTR a$3[rsp], al

; 4819 : 					all_a |= a;

	movzx	eax, BYTE PTR a$3[rsp]
	mov	ecx, DWORD PTR all_a$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR all_a$[rsp], eax

; 4820 : 					if (target == 4) out[z++] = a;

	cmp	DWORD PTR target$[rsp], 4
	jne	SHORT $LN88@stbi__bmp_
	movsxd	rax, DWORD PTR z$2[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	movzx	edx, BYTE PTR a$3[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR z$2[rsp]
	inc	eax
	mov	DWORD PTR z$2[rsp], eax
$LN88@stbi__bmp_:

; 4821 : 				}

	jmp	$LN17@stbi__bmp_
$LN18@stbi__bmp_:

; 4822 : 			}

	jmp	$LN87@stbi__bmp_
$LN86@stbi__bmp_:

; 4823 : 			else {
; 4824 : 				for (i = 0; i < (int)s->img_x; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN22@stbi__bmp_
$LN20@stbi__bmp_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN22@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN21@stbi__bmp_

; 4825 : 					stbi__uint32 v = (bpp == 16 ? (stbi__uint32)stbi__get16le(s) : stbi__get32le(s));

	cmp	DWORD PTR bpp$[rsp], 16
	jne	SHORT $LN106@stbi__bmp_
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
	mov	DWORD PTR tv470[rsp], eax
	jmp	SHORT $LN107@stbi__bmp_
$LN106@stbi__bmp_:
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
	mov	DWORD PTR tv470[rsp], eax
$LN107@stbi__bmp_:
	mov	eax, DWORD PTR tv470[rsp]
	mov	DWORD PTR v$7[rsp], eax

; 4826 : 					int a;
; 4827 : 					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

	mov	eax, DWORD PTR mr$[rsp]
	mov	ecx, DWORD PTR v$7[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	r8d, DWORD PTR rcount$9[rsp]
	mov	edx, DWORD PTR rshift$10[rsp]
	mov	ecx, eax
	call	?stbi__shiftsigned@@YAHHHH@Z		; stbi__shiftsigned
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR z$2[rsp]
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR z$2[rsp]
	inc	eax
	mov	DWORD PTR z$2[rsp], eax

; 4828 : 					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

	mov	eax, DWORD PTR mg$[rsp]
	mov	ecx, DWORD PTR v$7[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	r8d, DWORD PTR gcount$11[rsp]
	mov	edx, DWORD PTR gshift$12[rsp]
	mov	ecx, eax
	call	?stbi__shiftsigned@@YAHHHH@Z		; stbi__shiftsigned
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR z$2[rsp]
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR z$2[rsp]
	inc	eax
	mov	DWORD PTR z$2[rsp], eax

; 4829 : 					out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

	mov	eax, DWORD PTR mb$[rsp]
	mov	ecx, DWORD PTR v$7[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	r8d, DWORD PTR bcount$13[rsp]
	mov	edx, DWORD PTR bshift$14[rsp]
	mov	ecx, eax
	call	?stbi__shiftsigned@@YAHHHH@Z		; stbi__shiftsigned
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR z$2[rsp]
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR z$2[rsp]
	inc	eax
	mov	DWORD PTR z$2[rsp], eax

; 4830 : 					a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

	cmp	DWORD PTR ma$[rsp], 0
	je	SHORT $LN108@stbi__bmp_
	mov	eax, DWORD PTR ma$[rsp]
	mov	ecx, DWORD PTR v$7[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	r8d, DWORD PTR acount$15[rsp]
	mov	edx, DWORD PTR ashift$16[rsp]
	mov	ecx, eax
	call	?stbi__shiftsigned@@YAHHHH@Z		; stbi__shiftsigned
	mov	DWORD PTR tv510[rsp], eax
	jmp	SHORT $LN109@stbi__bmp_
$LN108@stbi__bmp_:
	mov	DWORD PTR tv510[rsp], 255		; 000000ffH
$LN109@stbi__bmp_:
	mov	eax, DWORD PTR tv510[rsp]
	mov	DWORD PTR a$17[rsp], eax

; 4831 : 					all_a |= a;

	mov	eax, DWORD PTR a$17[rsp]
	mov	ecx, DWORD PTR all_a$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR all_a$[rsp], eax

; 4832 : 					if (target == 4) out[z++] = STBI__BYTECAST(a);

	cmp	DWORD PTR target$[rsp], 4
	jne	SHORT $LN89@stbi__bmp_
	mov	eax, DWORD PTR a$17[rsp]
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR z$2[rsp]
	mov	rdx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR z$2[rsp]
	inc	eax
	mov	DWORD PTR z$2[rsp], eax
$LN89@stbi__bmp_:

; 4833 : 				}

	jmp	$LN20@stbi__bmp_
$LN21@stbi__bmp_:
$LN87@stbi__bmp_:

; 4834 : 			}
; 4835 : 			stbi__skip(s, pad);

	mov	edx, DWORD PTR pad$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__skip@@YAXPEAUstbi__context@@H@Z	; stbi__skip
	npad	1

; 4836 : 		}

	jmp	$LN14@stbi__bmp_
$LN15@stbi__bmp_:
$LN63@stbi__bmp_:

; 4837 : 	}
; 4838 : 
; 4839 : 	// if alpha channel is all 0s, replace with all 255s
; 4840 : 	if (target == 4 && all_a == 0)

	cmp	DWORD PTR target$[rsp], 4
	jne	SHORT $LN90@stbi__bmp_
	cmp	DWORD PTR all_a$[rsp], 0
	jne	SHORT $LN90@stbi__bmp_

; 4841 : 		for (i = 4 * s->img_x * s->img_y - 1; i >= 0; i -= 4)

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	shl	eax, 2
	mov	rcx, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN25@stbi__bmp_
$LN23@stbi__bmp_:
	mov	eax, DWORD PTR i$[rsp]
	sub	eax, 4
	mov	DWORD PTR i$[rsp], eax
$LN25@stbi__bmp_:
	cmp	DWORD PTR i$[rsp], 0
	jl	SHORT $LN24@stbi__bmp_

; 4842 : 			out[i] = 255;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	jmp	SHORT $LN23@stbi__bmp_
$LN24@stbi__bmp_:
$LN90@stbi__bmp_:

; 4843 : 
; 4844 : 	if (flip_vertically) {

	cmp	DWORD PTR flip_vertically$[rsp], 0
	je	$LN91@stbi__bmp_

; 4845 : 		stbi_uc t;
; 4846 : 		for (j = 0; j < (int)s->img_y >> 1; ++j) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN28@stbi__bmp_
$LN26@stbi__bmp_:
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN28@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+4]
	sar	eax, 1
	cmp	DWORD PTR j$[rsp], eax
	jge	$LN27@stbi__bmp_

; 4847 : 			stbi_uc* p1 = out + j * s->img_x * target;

	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR j$[rsp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	imul	eax, DWORD PTR target$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p1$18[rsp], rax

; 4848 : 			stbi_uc* p2 = out + (s->img_y - 1 - j) * s->img_x * target;

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+4]
	dec	eax
	sub	eax, DWORD PTR j$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	imul	eax, DWORD PTR [rcx]
	imul	eax, DWORD PTR target$[rsp]
	mov	eax, eax
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p2$19[rsp], rax

; 4849 : 			for (i = 0; i < (int)s->img_x * target; ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN31@stbi__bmp_
$LN29@stbi__bmp_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN31@stbi__bmp_:
	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax]
	imul	eax, DWORD PTR target$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN30@stbi__bmp_

; 4850 : 				t = p1[i], p1[i] = p2[i], p2[i] = t;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p1$18[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR t$5[rsp], al
	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR p1$18[rsp]
	mov	r8, QWORD PTR p2$19[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p2$19[rsp]
	movzx	edx, BYTE PTR t$5[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 4851 : 			}

	jmp	SHORT $LN29@stbi__bmp_
$LN30@stbi__bmp_:

; 4852 : 		}

	jmp	$LN26@stbi__bmp_
$LN27@stbi__bmp_:
$LN91@stbi__bmp_:

; 4853 : 	}
; 4854 : 
; 4855 : 	if (req_comp && req_comp != target) {

	cmp	DWORD PTR req_comp$[rsp], 0
	je	SHORT $LN92@stbi__bmp_
	mov	eax, DWORD PTR target$[rsp]
	cmp	DWORD PTR req_comp$[rsp], eax
	je	SHORT $LN92@stbi__bmp_

; 4856 : 		out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);

	mov	rax, QWORD PTR s$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR s$[rsp]
	mov	r9d, DWORD PTR [rax]
	mov	r8d, DWORD PTR req_comp$[rsp]
	mov	edx, DWORD PTR target$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	call	?stbi__convert_format@@YAPEAEPEAEHHII@Z	; stbi__convert_format
	mov	QWORD PTR out$[rsp], rax

; 4857 : 		if (out == NULL) return out; // stbi__convert_format frees input on failure

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN93@stbi__bmp_
	mov	rax, QWORD PTR out$[rsp]
	jmp	SHORT $LN1@stbi__bmp_
$LN93@stbi__bmp_:
$LN92@stbi__bmp_:

; 4858 : 	}
; 4859 : 
; 4860 : 	*x = s->img_x;

	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx

; 4861 : 	*y = s->img_y;

	mov	rax, QWORD PTR y$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	DWORD PTR [rax], ecx

; 4862 : 	if (comp) *comp = s->img_n;

	cmp	QWORD PTR comp$[rsp], 0
	je	SHORT $LN94@stbi__bmp_
	mov	rax, QWORD PTR comp$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax], ecx
$LN94@stbi__bmp_:

; 4863 : 	return out;

	mov	rax, QWORD PTR out$[rsp]
$LN1@stbi__bmp_:

; 4864 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1288				; 00000508H
	ret	0
?stbi__bmp_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__bmp_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__bmp_test

; 4601 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4602 : 	int r = stbi__bmp_test_raw(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__bmp_test_raw
	mov	DWORD PTR r$[rsp], eax

; 4603 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4604 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 4605 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__bmp_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 32
s$ = 80
x$ = 88
y$ = 96
comp$ = 104
?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__png_info

; 4575 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4576 : 	stbi__png p;
; 4577 : 	p.s = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 4578 : 	return stbi__png_info_raw(&p, x, y, comp);

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR p$[rsp]
	call	?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ; stbi__png_info_raw

; 4579 : }

	add	rsp, 72					; 00000048H
	ret	0
?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__png_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 48
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__png_load

; 4548 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4549 : 	stbi__png p;
; 4550 : 	p.s = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 4551 : 	return stbi__do_png(&p, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR p$[rsp]
	call	?stbi__do_png@@YAPEAEPEAUstbi__png@@PEAH11H@Z ; stbi__do_png

; 4552 : }

	add	rsp, 88					; 00000058H
	ret	0
?stbi__png_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__png_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__png_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__png_test

; 4555 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4556 : 	int r;
; 4557 : 	r = stbi__check_png_header(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header
	mov	DWORD PTR r$[rsp], eax

; 4558 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 4559 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 4560 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__png_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__png_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
j$ = 32
__$ArrayPad$ = 18336
s$ = 18368
x$ = 18376
y$ = 18384
comp$ = 18392
?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__jpeg_info

; 3467 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 18360				; 000047b8H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3468 : 	stbi__jpeg j;
; 3469 : 	j.s = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR j$[rsp], rax

; 3470 : 	return stbi__jpeg_info_raw(&j, x, y, comp);

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR j$[rsp]
	call	?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z ; stbi__jpeg_info_raw

; 3471 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 18360				; 000047b8H
	ret	0
?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__jpeg_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
j$ = 48
__$ArrayPad$ = 18352
s$ = 18384
x$ = 18392
y$ = 18400
comp$ = 18408
req_comp$ = 18416
?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__jpeg_load

; 3436 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 18376				; 000047c8H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3437 : 	stbi__jpeg j;
; 3438 : 	j.s = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR j$[rsp], rax

; 3439 : 	stbi__setup_jpeg(&j);

	lea	rcx, QWORD PTR j$[rsp]
	call	?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 3440 : 	return load_jpeg_image(&j, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR j$[rsp]
	call	?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ; load_jpeg_image

; 3441 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 18376				; 000047c8H
	ret	0
?stbi__jpeg_load@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__jpeg_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
r$ = 32
j$ = 48
__$ArrayPad$ = 18352
s$ = 18384
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__jpeg_test

; 3444 : {

	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 18376				; 000047c8H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3445 : 	int r;
; 3446 : 	stbi__jpeg j;
; 3447 : 	j.s = s;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR j$[rsp], rax

; 3448 : 	stbi__setup_jpeg(&j);

	lea	rcx, QWORD PTR j$[rsp]
	call	?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 3449 : 	r = stbi__decode_jpeg_header(&j, STBI__SCAN_type);

	mov	edx, 1
	lea	rcx, QWORD PTR j$[rsp]
	call	?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
	mov	DWORD PTR r$[rsp], eax

; 3450 : 	stbi__rewind(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__rewind@@YAXPEAUstbi__context@@@Z	; stbi__rewind

; 3451 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 3452 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 18376				; 000047c8H
	ret	0
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__jpeg_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 8
?stbi__rewind@@YAXPEAUstbi__context@@@Z PROC		; stbi__rewind

; 824  : {

	mov	QWORD PTR [rsp+8], rcx

; 825  : 	// conceptually rewind SHOULD rewind to the beginning of the stream,
; 826  : 	// but we just rewind to the beginning of the initial buffer, because
; 827  : 	// we only use it after doing 'test', which only ever looks at at most 92 bytes
; 828  : 	s->img_buffer = s->img_buffer_original;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+200]
	mov	QWORD PTR [rax+184], rcx

; 829  : 	s->img_buffer_end = s->img_buffer_original_end;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+208]
	mov	QWORD PTR [rax+192], rcx

; 830  : }

	ret	0
?stbi__rewind@@YAXPEAUstbi__context@@@Z ENDP		; stbi__rewind
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
f$ = 56
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z PROC ; stbi__start_file

; 815  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 816  : 	stbi__start_callbacks(s, &stbi__stdio_callbacks, (void*)f);

	mov	r8, QWORD PTR f$[rsp]
	lea	rdx, OFFSET FLAT:?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A
	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks
	npad	1

; 817  : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ENDP ; stbi__start_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
user$ = 48
?stbi__stdio_eof@@YAHPEAX@Z PROC			; stbi__stdio_eof

; 803  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 804  : 	return feof((FILE*)user);

	mov	rcx, QWORD PTR user$[rsp]
	call	feof

; 805  : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__stdio_eof@@YAHPEAX@Z ENDP			; stbi__stdio_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
user$ = 48
n$ = 56
?stbi__stdio_skip@@YAXPEAXH@Z PROC			; stbi__stdio_skip

; 798  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 799  : 	fseek((FILE*)user, n, SEEK_CUR);

	mov	r8d, 1
	mov	edx, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR user$[rsp]
	call	fseek
	npad	1

; 800  : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__stdio_skip@@YAXPEAXH@Z ENDP			; stbi__stdio_skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
user$ = 48
data$ = 56
size$ = 64
?stbi__stdio_read@@YAHPEAXPEADH@Z PROC			; stbi__stdio_read

; 793  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 794  : 	return (int)fread(data, 1, size, (FILE*)user);

	movsxd	rax, DWORD PTR size$[rsp]
	mov	r9, QWORD PTR user$[rsp]
	mov	r8, rax
	mov	edx, 1
	mov	rcx, QWORD PTR data$[rsp]
	call	fread

; 795  : }

	add	rsp, 40					; 00000028H
	ret	0
?stbi__stdio_read@@YAHPEAXPEADH@Z ENDP			; stbi__stdio_read
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 64
c$ = 72
user$ = 80
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z PROC ; stbi__start_callbacks

; 780  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 781  : 	s->io = *c;

	mov	rax, QWORD PTR s$[rsp]
	lea	rdi, QWORD PTR [rax+16]
	mov	rsi, QWORD PTR c$[rsp]
	mov	ecx, 24
	rep movsb

; 782  : 	s->io_user_data = user;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR user$[rsp]
	mov	QWORD PTR [rax+40], rcx

; 783  : 	s->buflen = sizeof(s->buffer_start);

	mov	rax, QWORD PTR s$[rsp]
	mov	DWORD PTR [rax+52], 128			; 00000080H

; 784  : 	s->read_from_callbacks = 1;

	mov	rax, QWORD PTR s$[rsp]
	mov	DWORD PTR [rax+48], 1

; 785  : 	s->img_buffer_original = s->buffer_start;

	mov	rax, QWORD PTR s$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+200], rax

; 786  : 	stbi__refill_buffer(s);

	mov	rcx, QWORD PTR s$[rsp]
	call	?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 787  : 	s->img_buffer_original_end = s->img_buffer_end;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rcx+192]
	mov	QWORD PTR [rax+208], rcx

; 788  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ENDP ; stbi__start_callbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
tv72 = 0
s$ = 32
buffer$ = 40
len$ = 48
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z PROC	; stbi__start_mem

; 771  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  : 	s->io.read = NULL;

	mov	rax, QWORD PTR s$[rsp]
	mov	QWORD PTR [rax+16], 0

; 773  : 	s->read_from_callbacks = 0;

	mov	rax, QWORD PTR s$[rsp]
	mov	DWORD PTR [rax+48], 0

; 774  : 	s->img_buffer = s->img_buffer_original = (stbi_uc*)buffer;

	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax+200], rcx
	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax+184], rcx

; 775  : 	s->img_buffer_end = s->img_buffer_original_end = (stbi_uc*)buffer + len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	QWORD PTR tv72[rsp], rcx
	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	mov	QWORD PTR [rax+208], rcx
	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	mov	QWORD PTR [rax+192], rcx

; 776  : }

	add	rsp, 24
	ret	0
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ENDP	; stbi__start_mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
n$ = 32
tv74 = 40
s$ = 64
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z PROC	; stbi__refill_buffer

; 1214 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1215 : 	int n = (s->io.read)(s->io_user_data, (char*)s->buffer_start, s->buflen);

	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR s$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, QWORD PTR s$[rsp]
	mov	r8d, DWORD PTR [rcx+52]
	mov	rdx, rax
	mov	rax, QWORD PTR s$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	QWORD PTR tv74[rsp]
	mov	DWORD PTR n$[rsp], eax

; 1216 : 	if (n == 0) {

	cmp	DWORD PTR n$[rsp], 0
	jne	SHORT $LN2@stbi__refi

; 1217 : 		// at end of file, treat same as if from memory, but need to handle case
; 1218 : 		// where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1219 : 		s->read_from_callbacks = 0;

	mov	rax, QWORD PTR s$[rsp]
	mov	DWORD PTR [rax+48], 0

; 1220 : 		s->img_buffer = s->buffer_start;

	mov	rax, QWORD PTR s$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+184], rax

; 1221 : 		s->img_buffer_end = s->buffer_start + 1;

	mov	rax, QWORD PTR s$[rsp]
	add	rax, 57					; 00000039H
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+192], rax

; 1222 : 		*s->img_buffer = 0;

	mov	rax, QWORD PTR s$[rsp]
	mov	rax, QWORD PTR [rax+184]
	mov	BYTE PTR [rax], 0

; 1223 : 	}

	jmp	SHORT $LN3@stbi__refi
$LN2@stbi__refi:

; 1224 : 	else {
; 1225 : 		s->img_buffer = s->buffer_start;

	mov	rax, QWORD PTR s$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+184], rax

; 1226 : 		s->img_buffer_end = s->buffer_start + n;

	movsxd	rax, DWORD PTR n$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	lea	rax, QWORD PTR [rcx+rax+56]
	mov	rcx, QWORD PTR s$[rsp]
	mov	QWORD PTR [rcx+192], rax
$LN3@stbi__refi:

; 1227 : 	}
; 1228 : }

	add	rsp, 56					; 00000038H
	ret	0
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ENDP	; stbi__refill_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
a$ = 48
__$ArrayPad$ = 4144
obuffer$ = 4176
olen$ = 4184
ibuffer$ = 4192
ilen$ = 4200
stbi_zlib_decode_noheader_buffer PROC

; 3929 : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4168				; 00001048H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3930 : 	stbi__zbuf a;
; 3931 : 	a.zbuffer = (stbi_uc*)ibuffer;

	mov	rax, QWORD PTR ibuffer$[rsp]
	mov	QWORD PTR a$[rsp], rax

; 3932 : 	a.zbuffer_end = (stbi_uc*)ibuffer + ilen;

	movsxd	rax, DWORD PTR ilen$[rsp]
	mov	rcx, QWORD PTR ibuffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR a$[rsp+8], rax

; 3933 : 	if (stbi__do_zlib(&a, obuffer, olen, 0, 0))

	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, DWORD PTR olen$[rsp]
	mov	rdx, QWORD PTR obuffer$[rsp]
	lea	rcx, QWORD PTR a$[rsp]
	call	?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
	test	eax, eax
	je	SHORT $LN2@stbi_zlib_

; 3934 : 		return (int)(a.zout - a.zout_start);

	mov	rax, QWORD PTR a$[rsp+32]
	mov	rcx, QWORD PTR a$[rsp+24]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@stbi_zlib_
	jmp	SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 3935 : 	else
; 3936 : 		return -1;

	mov	eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 3937 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4168				; 00001048H
	ret	0
stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4160
buffer$ = 4192
len$ = 4200
outlen$ = 4208
stbi_zlib_decode_noheader_malloc PROC

; 3912 : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4184				; 00001058H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3913 : 	stbi__zbuf a;
; 3914 : 	char* p = (char*)stbi__malloc(16384);

	mov	ecx, 16384				; 00004000H
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR p$[rsp], rax

; 3915 : 	if (p == NULL) return NULL;

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN2@stbi_zlib_
	xor	eax, eax
	jmp	$LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 3916 : 	a.zbuffer = (stbi_uc*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR a$[rsp], rax

; 3917 : 	a.zbuffer_end = (stbi_uc*)buffer + len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR a$[rsp+8], rax

; 3918 : 	if (stbi__do_zlib(&a, p, 16384, 1, 0)) {

	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	r8d, 16384				; 00004000H
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR a$[rsp]
	call	?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 3919 : 		if (outlen) *outlen = (int)(a.zout - a.zout_start);

	cmp	QWORD PTR outlen$[rsp], 0
	je	SHORT $LN5@stbi_zlib_
	mov	rax, QWORD PTR a$[rsp+32]
	mov	rcx, QWORD PTR a$[rsp+24]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR outlen$[rsp]
	mov	DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 3920 : 		return a.zout_start;

	mov	rax, QWORD PTR a$[rsp+32]
	jmp	SHORT $LN1@stbi_zlib_

; 3921 : 	}

	jmp	SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 3922 : 	else {
; 3923 : 		STBI_FREE(a.zout_start);

	mov	rcx, QWORD PTR a$[rsp+32]
	call	free

; 3924 : 		return NULL;

	xor	eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 3925 : 	}
; 3926 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4184				; 00001058H
	ret	0
stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
a$ = 48
__$ArrayPad$ = 4144
obuffer$ = 4176
olen$ = 4184
ibuffer$ = 4192
ilen$ = 4200
stbi_zlib_decode_buffer PROC

; 3901 : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4168				; 00001048H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3902 : 	stbi__zbuf a;
; 3903 : 	a.zbuffer = (stbi_uc*)ibuffer;

	mov	rax, QWORD PTR ibuffer$[rsp]
	mov	QWORD PTR a$[rsp], rax

; 3904 : 	a.zbuffer_end = (stbi_uc*)ibuffer + ilen;

	movsxd	rax, DWORD PTR ilen$[rsp]
	mov	rcx, QWORD PTR ibuffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR a$[rsp+8], rax

; 3905 : 	if (stbi__do_zlib(&a, obuffer, olen, 0, 1))

	mov	DWORD PTR [rsp+32], 1
	xor	r9d, r9d
	mov	r8d, DWORD PTR olen$[rsp]
	mov	rdx, QWORD PTR obuffer$[rsp]
	lea	rcx, QWORD PTR a$[rsp]
	call	?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
	test	eax, eax
	je	SHORT $LN2@stbi_zlib_

; 3906 : 		return (int)(a.zout - a.zout_start);

	mov	rax, QWORD PTR a$[rsp+32]
	mov	rcx, QWORD PTR a$[rsp+24]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@stbi_zlib_
	jmp	SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 3907 : 	else
; 3908 : 		return -1;

	mov	eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 3909 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4168				; 00001048H
	ret	0
stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
buffer$ = 48
len$ = 56
outlen$ = 64
stbi_zlib_decode_malloc PROC

; 3879 : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3880 : 	return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

	mov	r9, QWORD PTR outlen$[rsp]
	mov	r8d, 16384				; 00004000H
	mov	edx, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	stbi_zlib_decode_malloc_guesssize

; 3881 : }

	add	rsp, 40					; 00000028H
	ret	0
stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4160
buffer$ = 4192
len$ = 4200
initial_size$ = 4208
outlen$ = 4216
parse_header$ = 4224
stbi_zlib_decode_malloc_guesssize_headerflag PROC

; 3884 : {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4184				; 00001058H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3885 : 	stbi__zbuf a;
; 3886 : 	char* p = (char*)stbi__malloc(initial_size);

	movsxd	rax, DWORD PTR initial_size$[rsp]
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR p$[rsp], rax

; 3887 : 	if (p == NULL) return NULL;

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN2@stbi_zlib_
	xor	eax, eax
	jmp	$LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 3888 : 	a.zbuffer = (stbi_uc*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR a$[rsp], rax

; 3889 : 	a.zbuffer_end = (stbi_uc*)buffer + len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR a$[rsp+8], rax

; 3890 : 	if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

	mov	eax, DWORD PTR parse_header$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, 1
	mov	r8d, DWORD PTR initial_size$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR a$[rsp]
	call	?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 3891 : 		if (outlen) *outlen = (int)(a.zout - a.zout_start);

	cmp	QWORD PTR outlen$[rsp], 0
	je	SHORT $LN5@stbi_zlib_
	mov	rax, QWORD PTR a$[rsp+32]
	mov	rcx, QWORD PTR a$[rsp+24]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR outlen$[rsp]
	mov	DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 3892 : 		return a.zout_start;

	mov	rax, QWORD PTR a$[rsp+32]
	jmp	SHORT $LN1@stbi_zlib_

; 3893 : 	}

	jmp	SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 3894 : 	else {
; 3895 : 		STBI_FREE(a.zout_start);

	mov	rcx, QWORD PTR a$[rsp+32]
	call	free

; 3896 : 		return NULL;

	xor	eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 3897 : 	}
; 3898 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4184				; 00001058H
	ret	0
stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4160
buffer$ = 4192
len$ = 4200
initial_size$ = 4208
outlen$ = 4216
stbi_zlib_decode_malloc_guesssize PROC

; 3862 : {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4184				; 00001058H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3863 : 	stbi__zbuf a;
; 3864 : 	char* p = (char*)stbi__malloc(initial_size);

	movsxd	rax, DWORD PTR initial_size$[rsp]
	mov	rcx, rax
	call	?stbi__malloc@@YAPEAX_K@Z		; stbi__malloc
	mov	QWORD PTR p$[rsp], rax

; 3865 : 	if (p == NULL) return NULL;

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN2@stbi_zlib_
	xor	eax, eax
	jmp	$LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 3866 : 	a.zbuffer = (stbi_uc*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR a$[rsp], rax

; 3867 : 	a.zbuffer_end = (stbi_uc*)buffer + len;

	movsxd	rax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR a$[rsp+8], rax

; 3868 : 	if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {

	mov	DWORD PTR [rsp+32], 1
	mov	r9d, 1
	mov	r8d, DWORD PTR initial_size$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR a$[rsp]
	call	?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
	test	eax, eax
	je	SHORT $LN3@stbi_zlib_

; 3869 : 		if (outlen) *outlen = (int)(a.zout - a.zout_start);

	cmp	QWORD PTR outlen$[rsp], 0
	je	SHORT $LN5@stbi_zlib_
	mov	rax, QWORD PTR a$[rsp+32]
	mov	rcx, QWORD PTR a$[rsp+24]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR outlen$[rsp]
	mov	DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 3870 : 		return a.zout_start;

	mov	rax, QWORD PTR a$[rsp+32]
	jmp	SHORT $LN1@stbi_zlib_

; 3871 : 	}

	jmp	SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 3872 : 	else {
; 3873 : 		STBI_FREE(a.zout_start);

	mov	rcx, QWORD PTR a$[rsp+32]
	call	free

; 3874 : 		return NULL;

	xor	eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 3875 : 	}
; 3876 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4184				; 00001058H
	ret	0
stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_flip$ = 8
stbi_set_flip_vertically_on_load PROC

; 936  : {

	mov	DWORD PTR [rsp+8], ecx

; 937  : 	stbi__vertically_flip_on_load = flag_true_if_should_flip;

	mov	eax, DWORD PTR flag_true_if_should_flip$[rsp]
	mov	DWORD PTR ?stbi__vertically_flip_on_load@@3HA, eax

; 938  : }

	ret	0
stbi_set_flip_vertically_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_convert$ = 8
stbi_convert_iphone_png_to_rgb PROC

; 4314 : {

	mov	DWORD PTR [rsp+8], ecx

; 4315 : 	stbi__de_iphone_flag = flag_true_if_should_convert;

	mov	eax, DWORD PTR flag_true_if_should_convert$[rsp]
	mov	DWORD PTR ?stbi__de_iphone_flag@@3HA, eax

; 4316 : }

	ret	0
stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 8
stbi_set_unpremultiply_on_load PROC

; 4309 : {

	mov	DWORD PTR [rsp+8], ecx

; 4310 : 	stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;

	mov	eax, DWORD PTR flag_true_if_should_unpremultiply$[rsp]
	mov	DWORD PTR ?stbi__unpremultiply_on_load@@3HA, eax

; 4311 : }

	ret	0
stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
pos$ = 32
r$ = 36
s$ = 48
__$ArrayPad$ = 272
f$ = 304
x$ = 312
y$ = 320
comp$ = 328
stbi_info_from_file PROC

; 6415 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6416 : 	int r;
; 6417 : 	stbi__context s;
; 6418 : 	long pos = ftell(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	ftell
	mov	DWORD PTR pos$[rsp], eax

; 6419 : 	stbi__start_file(&s, f);

	mov	rdx, QWORD PTR f$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 6420 : 	r = stbi__info_main(&s, x, y, comp);

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main
	mov	DWORD PTR r$[rsp], eax

; 6421 : 	fseek(f, pos, SEEK_SET);

	xor	r8d, r8d
	mov	edx, DWORD PTR pos$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	fseek

; 6422 : 	return r;

	mov	eax, DWORD PTR r$[rsp]

; 6423 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
x$ = 72
y$ = 80
comp$ = 88
stbi_info PROC

; 6405 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 6406 : 	FILE* f = stbi__fopen(filename, "rb");

	lea	rdx, OFFSET FLAT:??_C@_02JDPG@rb@
	mov	rcx, QWORD PTR filename$[rsp]
	call	?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z	; stbi__fopen
	mov	QWORD PTR f$[rsp], rax

; 6407 : 	int result;
; 6408 : 	if (!f) return stbi__err("can't fopen", "Unable to open file");

	cmp	QWORD PTR f$[rsp], 0
	jne	SHORT $LN2@stbi_info
	xor	eax, eax
	jmp	SHORT $LN1@stbi_info
$LN2@stbi_info:

; 6409 : 	result = stbi_info_from_file(f, x, y, comp);

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	stbi_info_from_file
	mov	DWORD PTR result$[rsp], eax

; 6410 : 	fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose

; 6411 : 	return result;

	mov	eax, DWORD PTR result$[rsp]
$LN1@stbi_info:

; 6412 : }

	add	rsp, 56					; 00000038H
	ret	0
stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
c$ = 288
user$ = 296
x$ = 304
y$ = 312
comp$ = 320
stbi_info_from_callbacks PROC

; 6434 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6435 : 	stbi__context s;
; 6436 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)c, user);

	mov	r8, QWORD PTR user$[rsp]
	mov	rdx, QWORD PTR c$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 6437 : 	return stbi__info_main(&s, x, y, comp);

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main

; 6438 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
stbi_info_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
x$ = 304
y$ = 312
comp$ = 320
stbi_info_from_memory PROC

; 6427 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6428 : 	stbi__context s;
; 6429 : 	stbi__start_mem(&s, buffer, len);

	mov	r8d, DWORD PTR len$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 6430 : 	return stbi__info_main(&s, x, y, comp);

	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main

; 6431 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
retval_from_stbi_load$ = 48
stbi_image_free PROC

; 921  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 922  : 	STBI_FREE(retval_from_stbi_load);

	mov	rcx, QWORD PTR retval_from_stbi_load$[rsp]
	call	free
	npad	1

; 923  : }

	add	rsp, 40					; 00000028H
	ret	0
stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
stbi_failure_reason PROC

; 891  : 	return stbi__g_failure_reason;

	mov	rax, QWORD PTR ?stbi__g_failure_reason@@3PEBDEB

; 892  : }

	ret	0
stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
f$ = 288
stbi_is_hdr_from_file PROC

; 1164 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1165 : #ifndef STBI_NO_HDR
; 1166 : 	stbi__context s;
; 1167 : 	stbi__start_file(&s, f);

	mov	rdx, QWORD PTR f$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1168 : 	return stbi__hdr_test(&s);

	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test

; 1169 : #else
; 1170 : 	STBI_NOTUSED(f);
; 1171 : 	return 0;
; 1172 : #endif
; 1173 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
stbi_is_hdr PROC

; 1153 : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1154 : 	FILE* f = stbi__fopen(filename, "rb");

	lea	rdx, OFFSET FLAT:??_C@_02JDPG@rb@
	mov	rcx, QWORD PTR filename$[rsp]
	call	?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z	; stbi__fopen
	mov	QWORD PTR f$[rsp], rax

; 1155 : 	int result = 0;

	mov	DWORD PTR result$[rsp], 0

; 1156 : 	if (f) {

	cmp	QWORD PTR f$[rsp], 0
	je	SHORT $LN2@stbi_is_hd

; 1157 : 		result = stbi_is_hdr_from_file(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	stbi_is_hdr_from_file
	mov	DWORD PTR result$[rsp], eax

; 1158 : 		fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose
	npad	1
$LN2@stbi_is_hd:

; 1159 : 	}
; 1160 : 	return result;

	mov	eax, DWORD PTR result$[rsp]

; 1161 : }

	add	rsp, 56					; 00000038H
	ret	0
stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
stbi_is_hdr_from_memory PROC

; 1139 : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1140 : #ifndef STBI_NO_HDR
; 1141 : 	stbi__context s;
; 1142 : 	stbi__start_mem(&s, buffer, len);

	mov	r8d, DWORD PTR len$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1143 : 	return stbi__hdr_test(&s);

	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test

; 1144 : #else
; 1145 : 	STBI_NOTUSED(buffer);
; 1146 : 	STBI_NOTUSED(len);
; 1147 : 	return 0;
; 1148 : #endif
; 1149 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
clbk$ = 288
user$ = 296
stbi_is_hdr_from_callbacks PROC

; 1177 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1178 : #ifndef STBI_NO_HDR
; 1179 : 	stbi__context s;
; 1180 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

	mov	r8, QWORD PTR user$[rsp]
	mov	rdx, QWORD PTR clbk$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1181 : 	return stbi__hdr_test(&s);

	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test

; 1182 : #else
; 1183 : 	STBI_NOTUSED(clbk);
; 1184 : 	STBI_NOTUSED(user);
; 1185 : 	return 0;
; 1186 : #endif
; 1187 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
scale$ = 8
stbi_ldr_to_hdr_scale PROC

; 1194 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }

	movss	DWORD PTR [rsp+8], xmm0
	movss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR ?stbi__l2h_scale@@3MA, xmm0
	ret	0
stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
gamma$ = 8
stbi_ldr_to_hdr_gamma PROC

; 1193 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }

	movss	DWORD PTR [rsp+8], xmm0
	movss	xmm0, DWORD PTR gamma$[rsp]
	movss	DWORD PTR ?stbi__l2h_gamma@@3MA, xmm0
	ret	0
stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
scale$ = 8
stbi_hdr_to_ldr_scale PROC

; 1198 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1 / scale; }

	movss	DWORD PTR [rsp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR scale$[rsp]
	movss	DWORD PTR ?stbi__h2l_scale_i@@3MA, xmm0
	ret	0
stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
gamma$ = 8
stbi_hdr_to_ldr_gamma PROC

; 1197 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1 / gamma; }

	movss	DWORD PTR [rsp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR gamma$[rsp]
	movss	DWORD PTR ?stbi__h2l_gamma_i@@3MA, xmm0
	ret	0
stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
f$ = 304
x$ = 312
y$ = 320
comp$ = 328
req_comp$ = 336
stbi_loadf_from_file PROC

; 1125 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1126 : 	stbi__context s;
; 1127 : 	stbi__start_file(&s, f);

	mov	rdx, QWORD PTR f$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1128 : 	return stbi__loadf_main(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1129 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_loadf_from_callbacks PROC

; 1107 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1108 : 	stbi__context s;
; 1109 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

	mov	r8, QWORD PTR user$[rsp]
	mov	rdx, QWORD PTR clbk$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1110 : 	return stbi__loadf_main(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1111 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_loadf_from_memory PROC

; 1100 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1101 : 	stbi__context s;
; 1102 : 	stbi__start_mem(&s, buffer, len);

	mov	r8d, DWORD PTR len$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1103 : 	return stbi__loadf_main(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1104 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
f$ = 48
result$ = 56
filename$ = 80
x$ = 88
y$ = 96
comp$ = 104
req_comp$ = 112
stbi_loadf PROC

; 1115 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1116 : 	float* result;
; 1117 : 	FILE* f = stbi__fopen(filename, "rb");

	lea	rdx, OFFSET FLAT:??_C@_02JDPG@rb@
	mov	rcx, QWORD PTR filename$[rsp]
	call	?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z	; stbi__fopen
	mov	QWORD PTR f$[rsp], rax

; 1118 : 	if (!f) return stbi__errpf("can't fopen", "Unable to open file");

	cmp	QWORD PTR f$[rsp], 0
	jne	SHORT $LN2@stbi_loadf
	xor	eax, eax
	jmp	SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 1119 : 	result = stbi_loadf_from_file(f, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	stbi_loadf_from_file
	mov	QWORD PTR result$[rsp], rax

; 1120 : 	fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose

; 1121 : 	return result;

	mov	rax, QWORD PTR result$[rsp]
$LN1@stbi_loadf:

; 1122 : }

	add	rsp, 72					; 00000048H
	ret	0
stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
result$ = 48
s$ = 64
__$ArrayPad$ = 288
f$ = 320
x$ = 328
y$ = 336
comp$ = 344
req_comp$ = 352
stbi_load_from_file PROC

; 1054 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 312				; 00000138H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1055 : 	unsigned char* result;
; 1056 : 	stbi__context s;
; 1057 : 	stbi__start_file(&s, f);

	mov	rdx, QWORD PTR f$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1058 : 	result = stbi__load_flip(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_flip
	mov	QWORD PTR result$[rsp], rax

; 1059 : 	if (result) {

	cmp	QWORD PTR result$[rsp], 0
	je	SHORT $LN2@stbi_load_

; 1060 : 		// need to 'unget' all the characters in the IO buffer
; 1061 : 		fseek(f, -(int)(s.img_buffer_end - s.img_buffer), SEEK_CUR);

	mov	rax, QWORD PTR s$[rsp+184]
	mov	rcx, QWORD PTR s$[rsp+192]
	sub	rcx, rax
	mov	rax, rcx
	neg	eax
	mov	r8d, 1
	mov	edx, eax
	mov	rcx, QWORD PTR f$[rsp]
	call	fseek
	npad	1
$LN2@stbi_load_:

; 1062 : 	}
; 1063 : 	return result;

	mov	rax, QWORD PTR result$[rsp]

; 1064 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 312				; 00000138H
	ret	0
stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_load_from_callbacks PROC

; 1075 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1076 : 	stbi__context s;
; 1077 : 	stbi__start_callbacks(&s, (stbi_io_callbacks*)clbk, user);

	mov	r8, QWORD PTR user$[rsp]
	mov	rdx, QWORD PTR clbk$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1078 : 	return stbi__load_flip(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_flip

; 1079 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_load_from_memory PROC

; 1068 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 296				; 00000128H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1069 : 	stbi__context s;
; 1070 : 	stbi__start_mem(&s, buffer, len);

	mov	r8d, DWORD PTR len$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1071 : 	return stbi__load_flip(&s, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR s$[rsp]
	call	?stbi__load_flip@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_flip

; 1072 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 296				; 00000128H
	ret	0
stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\ThirdParty\stb_image.h
_TEXT	SEGMENT
f$ = 48
result$ = 56
filename$ = 80
x$ = 88
y$ = 96
comp$ = 104
req_comp$ = 112
stbi_load PROC

; 1044 : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1045 : 	FILE* f = stbi__fopen(filename, "rb");

	lea	rdx, OFFSET FLAT:??_C@_02JDPG@rb@
	mov	rcx, QWORD PTR filename$[rsp]
	call	?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z	; stbi__fopen
	mov	QWORD PTR f$[rsp], rax

; 1046 : 	unsigned char* result;
; 1047 : 	if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

	cmp	QWORD PTR f$[rsp], 0
	jne	SHORT $LN2@stbi_load
	xor	eax, eax
	jmp	SHORT $LN1@stbi_load
$LN2@stbi_load:

; 1048 : 	result = stbi_load_from_file(f, x, y, comp, req_comp);

	mov	eax, DWORD PTR req_comp$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR comp$[rsp]
	mov	r8, QWORD PTR y$[rsp]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	stbi_load_from_file
	mov	QWORD PTR result$[rsp], rax

; 1049 : 	fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose

; 1050 : 	return result;

	mov	rax, QWORD PTR result$[rsp]
$LN1@stbi_load:

; 1051 : }

	add	rsp, 72					; 00000048H
	ret	0
stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAH@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAH@std@@YA$$QEAHAEAH@Z PROC			; std::move<int &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAH@std@@YA$$QEAHAEAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ??__ENAME_None@SDK@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__ENAME_None@SDK@Core@IronMan@@YAXXZ PROC		; IronMan::Core::SDK::`dynamic initializer for 'NAME_None'', COMDAT

; 257  : 	static FName NAME_None = 0;

	sub	rsp, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?NAME_None@SDK@Core@IronMan@@3UFName@123@A
	call	??0FName@SDK@Core@IronMan@@QEAA@H@Z	; IronMan::Core::SDK::FName::FName
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__ENAME_None@SDK@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::SDK::`dynamic initializer for 'NAME_None''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$less@H@std@@QEBA_NAEBH0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$less@H@std@@QEBA_NAEBH0@Z PROC			; std::less<int>::operator(), COMDAT

; 2411 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2412 :         return _Left < _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jge	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 2413 :     }

	add	rsp, 24
	ret	0
??R?$less@H@std@@QEBA_NAEBH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ??0FName@SDK@Core@IronMan@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??0FName@SDK@Core@IronMan@@QEAA@H@Z PROC		; IronMan::Core::SDK::FName::FName, COMDAT

; 161  : 		{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 159  : 			: ComparisonIndex(i),

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 160  : 			Number(0)

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0

; 162  : 		};

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FName@SDK@Core@IronMan@@QEAA@H@Z ENDP		; IronMan::Core::SDK::FName::FName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ
_TEXT	SEGMENT
?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ PROC		; IronMan::GetDMA, COMDAT

; 312  : 	inline DMAHandler& GetDMA() { return DMAHandler::Instance(); };

$LN3:
	sub	rsp, 40					; 00000028H
	call	?Instance@DMAHandler@IronMan@@SAAEAV12@XZ ; IronMan::DMAHandler::Instance
	add	rsp, 40					; 00000028H
	ret	0
?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ ENDP		; IronMan::GetDMA
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
text$yd	SEGMENT
??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A ; IronMan::DMAHandler::processInfo
	call	??1BaseProcessInfo@IronMan@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
text$di	SEGMENT
??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::processInfo'', COMDAT

; 116  : 		static inline BaseProcessInfo processInfo{};

	push	rdi
	sub	rsp, 32					; 00000020H

; 92   : 		DWORD pid = 0;

	mov	DWORD PTR ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A, 0

; 116  : 		static inline BaseProcessInfo processInfo{};

	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+40
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 93   : 		std::string name;
; 94   : 		const wchar_t* wname;
; 95   : 		ptr_t base = 0;

	mov	QWORD PTR ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+48, 0

; 116  : 		static inline BaseProcessInfo processInfo{};

	lea	rcx, OFFSET FLAT:??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo''
	call	atexit
	npad	1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::processInfo''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'IronMan::DMAHandler::processInfo'''::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'IronMan::DMAHandler::processInfo'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterReadArray
	call	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::ScatterReadArray'', COMDAT

; 114  : 		static inline std::shared_ptr<std::unordered_map<void*, std::vector<ScatterStruct>>>ScatterReadArray;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::ScatterReadArray''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterWriteArray
	call	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::ScatterWriteArray'', COMDAT

; 113  : 		static inline std::shared_ptr < std::unordered_map<void*, std::vector<ScatterStruct>>>ScatterWriteArray;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::ScatterWriteArray''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >, COMDAT

; 1681 :     ~shared_ptr() noexcept { // release resource

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1682 :         this->_Decref();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
	npad	1

; 1683 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ PROC ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref, COMDAT

; 1375 :     void _Decref() noexcept { // decrement reference count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1376 :         if (_Rep) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Decref

; 1377 :             _Rep->_Decref();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?_Decref@_Ref_count_base@std@@QEAAXXZ	; std::_Ref_count_base::_Decref
	npad	1
$LN2@Decref:

; 1378 :         }
; 1379 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ENDP ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
text$di	SEGMENT
??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::UpdateStartTime'', COMDAT

; 107  : 		static inline std::chrono::time_point<std::chrono::system_clock> UpdateStartTime = std::chrono::system_clock::now();

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A ; IronMan::DMAHandler::UpdateStartTime
	call	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::UpdateStartTime''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1BaseProcessInfo@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1BaseProcessInfo@IronMan@@QEAA@XZ PROC		; IronMan::BaseProcessInfo::~BaseProcessInfo, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1BaseProcessInfo@IronMan@@QEAA@XZ ENDP		; IronMan::BaseProcessInfo::~BaseProcessInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::BaseProcessInfo::~BaseProcessInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::BaseProcessInfo::~BaseProcessInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>, COMDAT

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_chrono.hpp
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT

; 212  :         constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 213  :             : _MyDur(_Other) {}

	mov	rax, QWORD PTR _Other$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 88   :         _NODISCARD static time_point now() noexcept { // get current time

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 89   :             return time_point(duration(_Xtime_get_ticks()));

	call	_Xtime_get_ticks
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 90   :         }

	add	rsp, 56					; 00000038H
	ret	0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
tv64 = 32
state$ = 36
$T1 = 40
<begin>$L0$2 = 48
key$ = 56
<range>$L0$3 = 64
hotkey_callback$4 = 72
<end>$L0$5 = 80
uMsg$ = 112
wParam$ = 120
lParam$ = 128
?ProcessKeybdMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z PROC ; IronMan::Core::OverlayEngine::ProcessKeybdMessage

; 375  : 	{

$LN16:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 376  : 
; 377  : 		auto key = wParam;

	mov	rax, QWORD PTR wParam$[rsp]
	mov	QWORD PTR key$[rsp], rax

; 378  : 		auto state = KeyState::None;

	mov	DWORD PTR state$[rsp], 1

; 379  : 
; 380  : 		switch (uMsg) {

	mov	eax, DWORD PTR uMsg$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 256		; 00000100H
	je	SHORT $LN7@ProcessKey
	cmp	DWORD PTR tv64[rsp], 257		; 00000101H
	je	SHORT $LN9@ProcessKey
	cmp	DWORD PTR tv64[rsp], 260		; 00000104H
	je	SHORT $LN8@ProcessKey
	cmp	DWORD PTR tv64[rsp], 261		; 00000105H
	je	SHORT $LN10@ProcessKey
	jmp	SHORT $LN11@ProcessKey
$LN7@ProcessKey:
$LN8@ProcessKey:

; 381  : 		case WM_KEYDOWN:
; 382  : 		case WM_SYSKEYDOWN:
; 383  : 			state = KeyState::Down;

	mov	DWORD PTR state$[rsp], 2

; 384  : 			break;

	jmp	SHORT $LN2@ProcessKey
$LN9@ProcessKey:
$LN10@ProcessKey:

; 385  : 		case WM_KEYUP:
; 386  : 		case WM_SYSKEYUP:
; 387  : 			state = KeyState::Up;

	mov	DWORD PTR state$[rsp], 3

; 388  : 			break;

	jmp	SHORT $LN2@ProcessKey
$LN11@ProcessKey:

; 389  : 		default:
; 390  : 			return false;

	xor	al, al
	jmp	$LN1@ProcessKey
$LN2@ProcessKey:

; 391  : 		}
; 392  : 
; 393  : 		if (state == KeyState::Up && mKeyMap[int(key)] == KeyState::Down) {

	cmp	DWORD PTR state$[rsp], 3
	jne	$LN12@ProcessKey
	movsxd	rax, DWORD PTR key$[rsp]
	lea	rcx, OFFSET FLAT:?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mKeyMap
	cmp	DWORD PTR [rcx+rax*4], 2
	jne	$LN12@ProcessKey

; 394  : 			mKeyMap[int(key)] = KeyState::Pressed;

	movsxd	rax, DWORD PTR key$[rsp]
	lea	rcx, OFFSET FLAT:?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mKeyMap
	mov	DWORD PTR [rcx+rax*4], 4

; 395  : 
; 396  : 			for (const auto& hotkey_callback : mHotkeys[key])

	mov	eax, DWORD PTR key$[rsp]
	mov	DWORD PTR $T1[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
	call	??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::operator[]
	mov	QWORD PTR <range>$L0$3[rsp], rax
	mov	rcx, QWORD PTR <range>$L0$3[rsp]
	call	?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin
	mov	QWORD PTR <begin>$L0$2[rsp], rax
	mov	rcx, QWORD PTR <range>$L0$3[rsp]
	call	?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_end
	mov	QWORD PTR <end>$L0$5[rsp], rax
	jmp	SHORT $LN6@ProcessKey
$LN4@ProcessKey:
	mov	rax, QWORD PTR <begin>$L0$2[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR <begin>$L0$2[rsp], rax
$LN6@ProcessKey:
	mov	rax, QWORD PTR <end>$L0$5[rsp]
	cmp	QWORD PTR <begin>$L0$2[rsp], rax
	je	SHORT $LN5@ProcessKey
	mov	rax, QWORD PTR <begin>$L0$2[rsp]
	mov	QWORD PTR hotkey_callback$4[rsp], rax

; 397  : 			{
; 398  : 				if (hotkey_callback)

	mov	rcx, QWORD PTR hotkey_callback$4[rsp]
	call	??B?$function@$$A6AXXZ@std@@QEBA_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@ProcessKey

; 399  : 					hotkey_callback();

	mov	rcx, QWORD PTR hotkey_callback$4[rsp]
	call	??R?$_Func_class@X$$V@std@@QEBAXXZ	; std::_Func_class<void>::operator()
	npad	1
$LN14@ProcessKey:

; 400  : 
; 401  : 			}

	jmp	SHORT $LN4@ProcessKey
$LN5@ProcessKey:

; 402  : 		}

	jmp	SHORT $LN13@ProcessKey
$LN12@ProcessKey:

; 403  : 		else {
; 404  : 			mKeyMap[int(key)] = state;

	movsxd	rax, DWORD PTR key$[rsp]
	lea	rcx, OFFSET FLAT:?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mKeyMap
	mov	edx, DWORD PTR state$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx
$LN13@ProcessKey:

; 405  : 		}
; 406  : 
; 407  : 		return true;

	mov	al, 1
$LN1@ProcessKey:

; 408  : 	}

	add	rsp, 104				; 00000068H
	ret	0
?ProcessKeybdMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ENDP ; IronMan::Core::OverlayEngine::ProcessKeybdMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
key$ = 0
state$ = 4
tv64 = 8
tv66 = 12
tv68 = 16
tv70 = 20
tv72 = 24
tv78 = 28
uMsg$ = 48
wParam$ = 56
lParam$ = 64
?ProcessMouseMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z PROC ; IronMan::Core::OverlayEngine::ProcessMouseMessage

; 331  : 	{

$LN30:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 332  : 
; 333  : 		auto key = VK_LBUTTON;

	mov	DWORD PTR key$[rsp], 1

; 334  : 		auto state = KeyState::None;

	mov	DWORD PTR state$[rsp], 1

; 335  : 		switch (uMsg) {

	mov	eax, DWORD PTR uMsg$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	mov	eax, DWORD PTR tv64[rsp]
	sub	eax, 513				; 00000201H
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 12
	ja	$LN15@ProcessMou
	mov	eax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN29@ProcessMou[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@ProcessMou:
$LN5@ProcessMou:

; 336  : 		case WM_MBUTTONDOWN:
; 337  : 		case WM_MBUTTONUP:
; 338  : 			state = uMsg == WM_MBUTTONUP ? KeyState::Up : KeyState::Down;

	cmp	DWORD PTR uMsg$[rsp], 520		; 00000208H
	jne	SHORT $LN19@ProcessMou
	mov	DWORD PTR tv66[rsp], 3
	jmp	SHORT $LN20@ProcessMou
$LN19@ProcessMou:
	mov	DWORD PTR tv66[rsp], 2
$LN20@ProcessMou:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR state$[rsp], eax

; 339  : 			key = VK_MBUTTON;

	mov	DWORD PTR key$[rsp], 4

; 340  : 			break;

	jmp	$LN2@ProcessMou
$LN6@ProcessMou:
$LN7@ProcessMou:
$LN8@ProcessMou:

; 341  : 
; 342  : 		case WM_RBUTTONDBLCLK:
; 343  : 		case WM_RBUTTONDOWN:
; 344  : 		case WM_RBUTTONUP:
; 345  : 			state = uMsg == WM_RBUTTONUP ? KeyState::Up : KeyState::Down;

	cmp	DWORD PTR uMsg$[rsp], 517		; 00000205H
	jne	SHORT $LN21@ProcessMou
	mov	DWORD PTR tv68[rsp], 3
	jmp	SHORT $LN22@ProcessMou
$LN21@ProcessMou:
	mov	DWORD PTR tv68[rsp], 2
$LN22@ProcessMou:
	mov	eax, DWORD PTR tv68[rsp]
	mov	DWORD PTR state$[rsp], eax

; 346  : 			key = VK_RBUTTON;

	mov	DWORD PTR key$[rsp], 2

; 347  : 			break;

	jmp	$LN2@ProcessMou
$LN9@ProcessMou:
$LN10@ProcessMou:
$LN11@ProcessMou:

; 348  : 
; 349  : 		case WM_LBUTTONDBLCLK:
; 350  : 		case WM_LBUTTONDOWN:
; 351  : 		case WM_LBUTTONUP:
; 352  : 			state = uMsg == WM_LBUTTONUP ? KeyState::Up : KeyState::Down;

	cmp	DWORD PTR uMsg$[rsp], 514		; 00000202H
	jne	SHORT $LN23@ProcessMou
	mov	DWORD PTR tv70[rsp], 3
	jmp	SHORT $LN24@ProcessMou
$LN23@ProcessMou:
	mov	DWORD PTR tv70[rsp], 2
$LN24@ProcessMou:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR state$[rsp], eax

; 353  : 			key = VK_LBUTTON;

	mov	DWORD PTR key$[rsp], 1

; 354  : 			break;

	jmp	SHORT $LN2@ProcessMou
$LN12@ProcessMou:
$LN13@ProcessMou:
$LN14@ProcessMou:

; 355  : 		case WM_XBUTTONDOWN:
; 356  : 		case WM_XBUTTONUP:
; 357  : 		case WM_XBUTTONDBLCLK:
; 358  : 			state = uMsg == WM_XBUTTONUP ? KeyState::Up : KeyState::Down;

	cmp	DWORD PTR uMsg$[rsp], 524		; 0000020cH
	jne	SHORT $LN25@ProcessMou
	mov	DWORD PTR tv72[rsp], 3
	jmp	SHORT $LN26@ProcessMou
$LN25@ProcessMou:
	mov	DWORD PTR tv72[rsp], 2
$LN26@ProcessMou:
	mov	eax, DWORD PTR tv72[rsp]
	mov	DWORD PTR state$[rsp], eax

; 359  : 			//key = (*(WORD*)((ptr_t)&wParam + 2) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2);
; 360  : 			key = (HIWORD(wParam) == XBUTTON1) ? VK_XBUTTON1 : VK_XBUTTON2;

	mov	rax, QWORD PTR wParam$[rsp]
	shr	rax, 16
	and	rax, 65535				; 0000ffffH
	movzx	eax, ax
	cmp	eax, 1
	jne	SHORT $LN27@ProcessMou
	mov	DWORD PTR tv78[rsp], 5
	jmp	SHORT $LN28@ProcessMou
$LN27@ProcessMou:
	mov	DWORD PTR tv78[rsp], 6
$LN28@ProcessMou:
	mov	eax, DWORD PTR tv78[rsp]
	mov	DWORD PTR key$[rsp], eax

; 361  : 			break;

	jmp	SHORT $LN2@ProcessMou
$LN15@ProcessMou:

; 362  : 		default:
; 363  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@ProcessMou
$LN2@ProcessMou:

; 364  : 		}
; 365  : 
; 366  : 		if (state == KeyState::Up && mKeyMap[key] == KeyState::Down)

	cmp	DWORD PTR state$[rsp], 3
	jne	SHORT $LN16@ProcessMou
	movsxd	rax, DWORD PTR key$[rsp]
	lea	rcx, OFFSET FLAT:?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mKeyMap
	cmp	DWORD PTR [rcx+rax*4], 2
	jne	SHORT $LN16@ProcessMou

; 367  : 			mKeyMap[key] = KeyState::Pressed;

	movsxd	rax, DWORD PTR key$[rsp]
	lea	rcx, OFFSET FLAT:?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mKeyMap
	mov	DWORD PTR [rcx+rax*4], 4
	jmp	SHORT $LN17@ProcessMou
$LN16@ProcessMou:

; 368  : 		else
; 369  : 			mKeyMap[key] = state;

	movsxd	rax, DWORD PTR key$[rsp]
	lea	rcx, OFFSET FLAT:?mKeyMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mKeyMap
	mov	edx, DWORD PTR state$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx
$LN17@ProcessMou:

; 370  : 
; 371  : 		return true;

	mov	al, 1
$LN1@ProcessMou:

; 372  : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN29@ProcessMou:
	DD	$LN10@ProcessMou
	DD	$LN11@ProcessMou
	DD	$LN9@ProcessMou
	DD	$LN7@ProcessMou
	DD	$LN8@ProcessMou
	DD	$LN6@ProcessMou
	DD	$LN4@ProcessMou
	DD	$LN5@ProcessMou
	DD	$LN15@ProcessMou
	DD	$LN15@ProcessMou
	DD	$LN12@ProcessMou
	DD	$LN13@ProcessMou
	DD	$LN14@ProcessMou
?ProcessMouseMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ENDP ; IronMan::Core::OverlayEngine::ProcessMouseMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
tv64 = 32
uMsg$ = 64
wParam$ = 72
lParam$ = 80
?ProcessMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z PROC ; IronMan::Core::OverlayEngine::ProcessMessage

; 303  : 	{

$LN24:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 304  : 
; 305  : 		switch (uMsg) {

	mov	eax, DWORD PTR uMsg$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 513		; 00000201H
	ja	SHORT $LN22@ProcessMes
	cmp	DWORD PTR tv64[rsp], 513		; 00000201H
	je	SHORT $LN10@ProcessMes
	cmp	DWORD PTR tv64[rsp], 256		; 00000100H
	je	SHORT $LN16@ProcessMes
	cmp	DWORD PTR tv64[rsp], 257		; 00000101H
	je	SHORT $LN17@ProcessMes
	cmp	DWORD PTR tv64[rsp], 260		; 00000104H
	je	SHORT $LN18@ProcessMes
	cmp	DWORD PTR tv64[rsp], 261		; 00000105H
	je	SHORT $LN19@ProcessMes
	jmp	SHORT $LN20@ProcessMes
$LN22@ProcessMes:
	mov	eax, DWORD PTR tv64[rsp]
	sub	eax, 514				; 00000202H
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 11
	ja	SHORT $LN20@ProcessMes
	mov	eax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN23@ProcessMes[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@ProcessMes:
$LN5@ProcessMes:
$LN6@ProcessMes:
$LN7@ProcessMes:
$LN8@ProcessMes:
$LN9@ProcessMes:
$LN10@ProcessMes:
$LN11@ProcessMes:
$LN12@ProcessMes:
$LN13@ProcessMes:
$LN14@ProcessMes:
$LN15@ProcessMes:

; 306  : 		case WM_MBUTTONDBLCLK:
; 307  : 		case WM_RBUTTONDBLCLK:
; 308  : 		case WM_LBUTTONDBLCLK:
; 309  : 		case WM_XBUTTONDBLCLK:
; 310  : 		case WM_MBUTTONDOWN:
; 311  : 		case WM_RBUTTONDOWN:
; 312  : 		case WM_LBUTTONDOWN:
; 313  : 		case WM_XBUTTONDOWN:
; 314  : 		case WM_MBUTTONUP:
; 315  : 		case WM_RBUTTONUP:
; 316  : 		case WM_LBUTTONUP:
; 317  : 		case WM_XBUTTONUP:
; 318  : 			return ProcessMouseMessage(uMsg, wParam, lParam);

	mov	r8, QWORD PTR lParam$[rsp]
	mov	rdx, QWORD PTR wParam$[rsp]
	mov	ecx, DWORD PTR uMsg$[rsp]
	call	?ProcessMouseMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ; IronMan::Core::OverlayEngine::ProcessMouseMessage
	jmp	SHORT $LN1@ProcessMes
$LN16@ProcessMes:
$LN17@ProcessMes:
$LN18@ProcessMes:
$LN19@ProcessMes:

; 319  : 		case WM_KEYDOWN:
; 320  : 		case WM_KEYUP:
; 321  : 		case WM_SYSKEYDOWN:
; 322  : 		case WM_SYSKEYUP:
; 323  : 			return ProcessKeybdMessage(uMsg, wParam, lParam);

	mov	r8, QWORD PTR lParam$[rsp]
	mov	rdx, QWORD PTR wParam$[rsp]
	mov	ecx, DWORD PTR uMsg$[rsp]
	call	?ProcessKeybdMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ; IronMan::Core::OverlayEngine::ProcessKeybdMessage
	jmp	SHORT $LN1@ProcessMes
$LN20@ProcessMes:

; 324  : 		default:
; 325  : 			return false;

	xor	al, al
$LN1@ProcessMes:

; 326  : 		}
; 327  : 
; 328  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN23@ProcessMes:
	DD	$LN14@ProcessMes
	DD	$LN6@ProcessMes
	DD	$LN9@ProcessMes
	DD	$LN13@ProcessMes
	DD	$LN5@ProcessMes
	DD	$LN8@ProcessMes
	DD	$LN12@ProcessMes
	DD	$LN4@ProcessMes
	DD	$LN20@ProcessMes
	DD	$LN11@ProcessMes
	DD	$LN15@ProcessMes
	DD	$LN7@ProcessMes
?ProcessMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ENDP ; IronMan::Core::OverlayEngine::ProcessMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
process$ = 48
tv134 = 52
<begin>$L0$1 = 56
<range>$L0$2 = 64
tv171 = 72
<end>$L0$3 = 80
func$4 = 88
tv156 = 96
args$ = 104
hWnd$ = 160
message$ = 168
wParam$ = 176
lParam$ = 184
?WindowProc@OverlayEngine@Core@IronMan@@CA_JPEAUHWND__@@I_K_J@Z PROC ; IronMan::Core::OverlayEngine::WindowProc

; 250  : 	{

$LN22:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 251  : 		if (message == WM_COMMNOTIFY)

	cmp	DWORD PTR message$[rsp], 68		; 00000044H
	jne	SHORT $LN7@WindowProc

; 252  : 			return 0;

	xor	eax, eax
	jmp	$LN1@WindowProc
$LN7@WindowProc:

; 253  : 
; 254  : 		bool process = true;

	mov	BYTE PTR process$[rsp], 1

; 255  : 		ProcessMessage(message, wParam, lParam);

	mov	r8, QWORD PTR lParam$[rsp]
	mov	rdx, QWORD PTR wParam$[rsp]
	mov	ecx, DWORD PTR message$[rsp]
	call	?ProcessMessage@OverlayEngine@Core@IronMan@@CA_NI_K_J@Z ; IronMan::Core::OverlayEngine::ProcessMessage

; 256  : 		WndEventArgs args{ true,wParam, lParam,message ,hWnd };

	mov	BYTE PTR args$[rsp], 1
	mov	rax, QWORD PTR wParam$[rsp]
	mov	QWORD PTR args$[rsp+8], rax
	mov	rax, QWORD PTR lParam$[rsp]
	mov	QWORD PTR args$[rsp+16], rax
	mov	eax, DWORD PTR message$[rsp]
	mov	DWORD PTR args$[rsp+24], eax
	mov	rax, QWORD PTR hWnd$[rsp]
	mov	QWORD PTR args$[rsp+32], rax

; 257  : 		for (const auto& func : OnWndProc.func_list)

	lea	rax, OFFSET FLAT:?OnWndProc@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@@A ; IronMan::Core::OverlayEngine::OnWndProc
	mov	QWORD PTR <range>$L0$2[rsp], rax
	lea	rdx, QWORD PTR <begin>$L0$1[rsp]
	mov	rcx, QWORD PTR <range>$L0$2[rsp]
	call	?_Unchecked_begin@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_begin
	lea	rdx, QWORD PTR <end>$L0$3[rsp]
	mov	rcx, QWORD PTR <range>$L0$2[rsp]
	call	?_Unchecked_end@?$list@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@V?$allocator@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@2@XZ ; std::list<std::function<void __cdecl(IronMan::Core::WndEventArgs &)>,std::allocator<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >::_Unchecked_end
	npad	1
	jmp	SHORT $LN4@WindowProc
$LN2@WindowProc:
	lea	rcx, QWORD PTR <begin>$L0$1[rsp]
	call	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator++
	npad	1
$LN4@WindowProc:
	lea	rdx, QWORD PTR <end>$L0$3[rsp]
	lea	rcx, QWORD PTR <begin>$L0$1[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@WindowProc
	lea	rcx, QWORD PTR <begin>$L0$1[rsp]
	call	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@std@@@std@@@std@@@std@@QEBAAEAV?$function@$$A6AXAEAUWndEventArgs@Core@IronMan@@@Z@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::function<void __cdecl(IronMan::Core::WndEventArgs &)> > > >::operator*
	mov	QWORD PTR func$4[rsp], rax

; 258  : 		{
; 259  : 			func(args);

	lea	rdx, QWORD PTR args$[rsp]
	mov	rcx, QWORD PTR func$4[rsp]
	call	??R?$_Func_class@XAEAUWndEventArgs@Core@IronMan@@@std@@QEBAXAEAUWndEventArgs@Core@IronMan@@@Z ; std::_Func_class<void,IronMan::Core::WndEventArgs &>::operator()
	npad	1

; 260  : 			if (!args.Process)

	movzx	eax, BYTE PTR args$[rsp]
	test	eax, eax
	jne	SHORT $LN8@WindowProc

; 261  : 			{
; 262  : 				process = false;

	mov	BYTE PTR process$[rsp], 0
$LN8@WindowProc:

; 263  : 			}
; 264  : 		}

	jmp	SHORT $LN2@WindowProc
$LN3@WindowProc:

; 265  : 
; 266  : 		extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
; 267  : 		if (ImGui_ImplWin32_WndProcHandler(hWnd, message, wParam, lParam))

	mov	r9, QWORD PTR lParam$[rsp]
	mov	r8, QWORD PTR wParam$[rsp]
	mov	edx, DWORD PTR message$[rsp]
	mov	rcx, QWORD PTR hWnd$[rsp]
	call	?ImGui_ImplWin32_WndProcHandler@@YA_JPEAUHWND__@@I_K_J@Z ; ImGui_ImplWin32_WndProcHandler
	test	rax, rax
	je	SHORT $LN9@WindowProc

; 268  : 			return true;

	mov	eax, 1
	jmp	$LN1@WindowProc
$LN9@WindowProc:

; 269  : 
; 270  : 		switch (message)

	mov	eax, DWORD PTR message$[rsp]
	mov	DWORD PTR tv134[rsp], eax
	cmp	DWORD PTR tv134[rsp], 2
	je	$LN18@WindowProc
	cmp	DWORD PTR tv134[rsp], 5
	je	SHORT $LN14@WindowProc
	cmp	DWORD PTR tv134[rsp], 24
	je	SHORT $LN12@WindowProc
	cmp	DWORD PTR tv134[rsp], 260		; 00000104H
	je	SHORT $LN10@WindowProc
	cmp	DWORD PTR tv134[rsp], 274		; 00000112H
	je	$LN16@WindowProc
	jmp	$LN5@WindowProc
$LN10@WindowProc:

; 271  : 		{
; 272  : 			/*case WM_NCHITTEST:
; 273  : 				return HTTRANSPARENT;*/
; 274  : 		case WM_SYSKEYDOWN:
; 275  : 			if (wParam == VK_F4)

	cmp	QWORD PTR wParam$[rsp], 115		; 00000073H
	jne	SHORT $LN11@WindowProc

; 276  : 				return 0;

	xor	eax, eax
	jmp	$LN1@WindowProc
$LN11@WindowProc:

; 277  : 			break;

	jmp	$LN5@WindowProc
$LN12@WindowProc:

; 278  : 		case WM_SHOWWINDOW:
; 279  : 			if (!wParam)

	cmp	QWORD PTR wParam$[rsp], 0
	jne	SHORT $LN13@WindowProc

; 280  : 				return 0;

	xor	eax, eax
	jmp	$LN1@WindowProc
$LN13@WindowProc:

; 281  : 			break;

	jmp	$LN5@WindowProc
$LN14@WindowProc:

; 282  : 		case WM_SIZE:
; 283  : 			if (mDevice != NULL && wParam != SIZE_MINIMIZED)

	cmp	QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA, 0 ; IronMan::Core::OverlayEngine::mDevice
	je	SHORT $LN15@WindowProc
	cmp	QWORD PTR wParam$[rsp], 1
	je	SHORT $LN15@WindowProc

; 284  : 			{
; 285  : 				CleanupRenderTarget();

	call	?CleanupRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ ; IronMan::Core::OverlayEngine::CleanupRenderTarget

; 286  : 				mSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);

	mov	rax, QWORD PTR ?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR tv156[rsp], rax
	mov	rax, QWORD PTR lParam$[rsp]
	shr	rax, 16
	and	rax, 65535				; 0000ffffH
	movzx	eax, ax
	mov	rcx, QWORD PTR lParam$[rsp]
	and	rcx, 65535				; 0000ffffH
	movzx	ecx, cx
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, eax
	mov	r8d, ecx
	xor	edx, edx
	mov	rcx, QWORD PTR ?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
	call	QWORD PTR tv156[rsp]

; 287  : 				CreateRenderTarget();

	call	?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ ; IronMan::Core::OverlayEngine::CreateRenderTarget
	npad	1
$LN15@WindowProc:

; 288  : 			}
; 289  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@WindowProc
$LN16@WindowProc:

; 290  : 		case WM_SYSCOMMAND:
; 291  : 			if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu

	mov	rax, QWORD PTR wParam$[rsp]
	and	rax, 65520				; 0000fff0H
	cmp	rax, 61696				; 0000f100H
	jne	SHORT $LN17@WindowProc

; 292  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN1@WindowProc
$LN17@WindowProc:

; 293  : 			break;

	jmp	SHORT $LN5@WindowProc
$LN18@WindowProc:

; 294  : 		case WM_DESTROY:
; 295  : 			PostQuitMessage(0);

	xor	ecx, ecx
	call	QWORD PTR __imp_PostQuitMessage

; 296  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@WindowProc
$LN5@WindowProc:

; 297  : 
; 298  : 		}
; 299  : 		return process ? DefWindowProc(hWnd, message, wParam, lParam) : 0;

	movzx	eax, BYTE PTR process$[rsp]
	test	eax, eax
	je	SHORT $LN20@WindowProc
	mov	r9, QWORD PTR lParam$[rsp]
	mov	r8, QWORD PTR wParam$[rsp]
	mov	edx, DWORD PTR message$[rsp]
	mov	rcx, QWORD PTR hWnd$[rsp]
	call	QWORD PTR __imp_DefWindowProcW
	mov	QWORD PTR tv171[rsp], rax
	jmp	SHORT $LN21@WindowProc
$LN20@WindowProc:
	mov	QWORD PTR tv171[rsp], 0
$LN21@WindowProc:
	mov	rax, QWORD PTR tv171[rsp]
$LN1@WindowProc:

; 300  : 	}

	add	rsp, 152				; 00000098H
	ret	0
?WindowProc@OverlayEngine@Core@IronMan@@CA_JPEAUHWND__@@I_K_J@Z ENDP ; IronMan::Core::OverlayEngine::WindowProc
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?CleanupRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ PROC ; IronMan::Core::OverlayEngine::CleanupRenderTarget

; 245  : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 246  : 		if (mMainRenderTargetView) { mMainRenderTargetView->Release(); mMainRenderTargetView = NULL; }

	cmp	QWORD PTR ?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA, 0 ; IronMan::Core::OverlayEngine::mMainRenderTargetView
	je	SHORT $LN2@CleanupRen
	mov	rax, QWORD PTR ?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA ; IronMan::Core::OverlayEngine::mMainRenderTargetView
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA ; IronMan::Core::OverlayEngine::mMainRenderTargetView
	call	QWORD PTR [rax+16]
	mov	QWORD PTR ?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA, 0 ; IronMan::Core::OverlayEngine::mMainRenderTargetView
$LN2@CleanupRen:

; 247  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?CleanupRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ ENDP ; IronMan::Core::OverlayEngine::CleanupRenderTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
pBackBuffer$ = 32
tv72 = 40
tv85 = 48
?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ PROC ; IronMan::Core::OverlayEngine::CreateRenderTarget

; 229  : 	{

$LN5:
	sub	rsp, 72					; 00000048H

; 230  : 		ID3D11Texture2D* pBackBuffer;
; 231  : 		mSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);

	mov	rax, QWORD PTR ?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR tv72[rsp], rax
	lea	r9, QWORD PTR pBackBuffer$[rsp]
	lea	r8, OFFSET FLAT:_GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
	xor	edx, edx
	mov	rcx, QWORD PTR ?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
	call	QWORD PTR tv72[rsp]
	npad	1

; 232  : 		if (pBackBuffer)

	cmp	QWORD PTR pBackBuffer$[rsp], 0
	je	SHORT $LN2@CreateRend

; 233  : 		{
; 234  : 			mDevice->CreateRenderTargetView(pBackBuffer, NULL, &mMainRenderTargetView);

	mov	rax, QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR tv85[rsp], rax
	lea	r9, OFFSET FLAT:?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA ; IronMan::Core::OverlayEngine::mMainRenderTargetView
	xor	r8d, r8d
	mov	rdx, QWORD PTR pBackBuffer$[rsp]
	mov	rcx, QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	call	QWORD PTR tv85[rsp]

; 235  : 			pBackBuffer->Release();

	mov	rax, QWORD PTR pBackBuffer$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR pBackBuffer$[rsp]
	call	QWORD PTR [rax+16]
	npad	1

; 236  : 		}

	jmp	SHORT $LN3@CreateRend
$LN2@CreateRend:

; 237  : 		else
; 238  : 		{
; 239  : 			MessageBoxA(0, "RenderTarget Failed!", 0, 0);

	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0BF@JMJNPNKE@RenderTarget?5Failed?$CB@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	npad	1
$LN3@CreateRend:

; 240  : 		}
; 241  : 
; 242  : 	}

	add	rsp, 72					; 00000048H
	ret	0
?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ ENDP ; IronMan::Core::OverlayEngine::CreateRenderTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
tv130 = 32
tv79 = 40
tv74 = 48
$T1 = 56
tv87 = 64
tv85 = 72
tv89 = 80
tv133 = 88
?Render@OverlayEngine@Core@IronMan@@CAXXZ PROC		; IronMan::Core::OverlayEngine::Render

; 215  : 	{

$LN7:
	sub	rsp, 104				; 00000068H

; 216  : 		OnPrePresent();

	lea	rcx, OFFSET FLAT:?OnPrePresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPrePresent
	call	??R?$delegate@$$A6AXXZ@@QEAAXXZ		; delegate<void __cdecl(void)>::operator()

; 217  : 		OnPresent();

	lea	rcx, OFFSET FLAT:?OnPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPresent
	call	??R?$delegate@$$A6AXXZ@@QEAAXXZ		; delegate<void __cdecl(void)>::operator()

; 218  : 		OnPostPresent();

	lea	rcx, OFFSET FLAT:?OnPostPresent@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnPostPresent
	call	??R?$delegate@$$A6AXXZ@@QEAAXXZ		; delegate<void __cdecl(void)>::operator()

; 219  : 		ImGui::Render();

	call	?Render@ImGui@@YAXXZ			; ImGui::Render

; 220  : 		mContext->OMSetRenderTargets(1, &mMainRenderTargetView, NULL);

	mov	rax, QWORD PTR ?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA ; IronMan::Core::OverlayEngine::mContext
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+264]
	mov	QWORD PTR tv74[rsp], rax
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA ; IronMan::Core::OverlayEngine::mMainRenderTargetView
	mov	edx, 1
	mov	rcx, QWORD PTR ?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA ; IronMan::Core::OverlayEngine::mContext
	call	QWORD PTR tv74[rsp]
	npad	1

; 221  : 		mContext->ClearRenderTargetView(mMainRenderTargetView, Vars.Misc.DisplayMode == 0 ? DirectX::Colors::Transparent : DirectX::Colors::Black);

	mov	rax, QWORD PTR ?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA ; IronMan::Core::OverlayEngine::mContext
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+400]
	mov	QWORD PTR tv89[rsp], rax
	cmp	DWORD PTR ?Vars@Core@IronMan@@3UVariables@12@A+2384, 0
	jne	SHORT $LN3@Render
	lea	rax, OFFSET FLAT:?Transparent@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::Transparent
	mov	QWORD PTR tv79[rsp], rax
	jmp	SHORT $LN4@Render
$LN3@Render:
	lea	rax, OFFSET FLAT:?Black@Colors@DirectX@@3UXMVECTORF32@2@B ; DirectX::Colors::Black
	mov	QWORD PTR tv79[rsp], rax
$LN4@Render:
	mov	rax, QWORD PTR tv79[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??BXMVECTORF32@DirectX@@QEBAPEBMXZ	; DirectX::XMVECTORF32::operator float const *
	mov	QWORD PTR tv87[rsp], rax
	mov	rax, QWORD PTR ?mMainRenderTargetView@OverlayEngine@Core@IronMan@@2PEAUID3D11RenderTargetView@@EA ; IronMan::Core::OverlayEngine::mMainRenderTargetView
	mov	QWORD PTR tv85[rsp], rax
	mov	r8, QWORD PTR tv87[rsp]
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR ?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA ; IronMan::Core::OverlayEngine::mContext
	call	QWORD PTR tv89[rsp]
	npad	1

; 222  : 		ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

	call	?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ ; ImGui::GetDrawData
	mov	rcx, rax
	call	?ImGui_ImplDX11_RenderDrawData@@YAXPEAUImDrawData@@@Z ; ImGui_ImplDX11_RenderDrawData

; 223  : 
; 224  : 		mSwapChain->Present(!Vars.Menu.LockFlame ? 1 : 0, 0);//vsync

	mov	rax, QWORD PTR ?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR tv133[rsp], rax
	cmp	DWORD PTR ?Vars@Core@IronMan@@3UVariables@12@A+2408, 0
	jne	SHORT $LN5@Render
	mov	DWORD PTR tv130[rsp], 1
	jmp	SHORT $LN6@Render
$LN5@Render:
	mov	DWORD PTR tv130[rsp], 0
$LN6@Render:
	xor	r8d, r8d
	mov	edx, DWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR ?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
	call	QWORD PTR tv133[rsp]
	npad	1

; 225  : 		//mSwapChain->Present(0, 0);//vsync
; 226  : 	}

	add	rsp, 104				; 00000068H
	ret	0
?Render@OverlayEngine@Core@IronMan@@CAXXZ ENDP		; IronMan::Core::OverlayEngine::Render
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?Tick@OverlayEngine@Core@IronMan@@CAXXZ PROC		; IronMan::Core::OverlayEngine::Tick

; 212  : 	}

	ret	0
?Tick@OverlayEngine@Core@IronMan@@CAXXZ ENDP		; IronMan::Core::OverlayEngine::Tick
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
io$ = 32
?Update@OverlayEngine@Core@IronMan@@CAXXZ PROC		; IronMan::Core::OverlayEngine::Update

; 199  : 	{

$LN3:
	sub	rsp, 56					; 00000038H

; 200  : 		ImGui_ImplDX11_NewFrame();

	call	?ImGui_ImplDX11_NewFrame@@YAXXZ		; ImGui_ImplDX11_NewFrame

; 201  : 		ImGui_ImplWin32_NewFrame();

	call	?ImGui_ImplWin32_NewFrame@@YAXXZ	; ImGui_ImplWin32_NewFrame

; 202  : 		ImGuiIO& io = ImGui::GetIO();

	call	?GetIO@ImGui@@YAAEAUImGuiIO@@XZ		; ImGui::GetIO
	mov	QWORD PTR io$[rsp], rax

; 203  : 		io.KeyCtrl = OverlayEngine::IsKeyDown(VK_CONTROL);

	mov	ecx, 17
	call	?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z ; IronMan::Core::OverlayEngine::IsKeyDown
	mov	rcx, QWORD PTR io$[rsp]
	mov	BYTE PTR [rcx+309], al

; 204  : 		io.KeyShift = OverlayEngine::IsKeyDown(VK_SHIFT);

	mov	ecx, 16
	call	?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z ; IronMan::Core::OverlayEngine::IsKeyDown
	mov	rcx, QWORD PTR io$[rsp]
	mov	BYTE PTR [rcx+288], al

; 205  : 		io.KeyAlt = OverlayEngine::IsKeyDown(VK_MENU);

	mov	ecx, 18
	call	?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z ; IronMan::Core::OverlayEngine::IsKeyDown
	mov	rcx, QWORD PTR io$[rsp]
	mov	BYTE PTR [rcx+308], al

; 206  : 		ImGui::NewFrame();

	call	?NewFrame@ImGui@@YAXXZ			; ImGui::NewFrame

; 207  : 		OnUpdate();

	lea	rcx, OFFSET FLAT:?OnUpdate@OverlayEngine@Core@IronMan@@2V?$delegate@$$A6AXXZ@@A ; IronMan::Core::OverlayEngine::OnUpdate
	call	??R?$delegate@$$A6AXXZ@@QEAAXXZ		; delegate<void __cdecl(void)>::operator()
	npad	1

; 208  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?Update@OverlayEngine@Core@IronMan@@CAXXZ ENDP		; IronMan::Core::OverlayEngine::Update
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
style$1 = 48
loadKorea$2 = 56
lid$3 = 60
io$4 = 64
tv137 = 72
msyh_data$5 = 80
glyphRanges$6 = 88
mainColor$7 = 96
msyh_data_size$8 = 112
bodyColor$9 = 120
tv231 = 136
tv239 = 140
tv470 = 144
mainColorHovered$10 = 152
frameBgColor$11 = 168
mainColorActive$12 = 184
tv91 = 200
tv93 = 208
tv160 = 216
tv170 = 224
tv180 = 232
tv190 = 240
tv343 = 248
tv358 = 256
tv376 = 264
tv401 = 272
tv416 = 280
tv431 = 288
tv531 = 296
tv552 = 304
tv567 = 312
tv582 = 320
tv610 = 328
tv625 = 336
tv640 = 344
tv303 = 352
tv200 = 360
tv318 = 368
$T13 = 376
$T14 = 384
$T15 = 392
$T16 = 400
$T17 = 408
$T18 = 416
$T19 = 424
$T20 = 432
$T21 = 440
$T22 = 448
tooltipBgColor$23 = 456
menubarColor$24 = 472
fontColor$25 = 488
$T26 = 504
$T27 = 520
$T28 = 536
$T29 = 552
$T30 = 568
$T31 = 584
$T32 = 600
$T33 = 616
$T34 = 632
$T35 = 648
$T36 = 664
$T37 = 680
$T38 = 696
$T39 = 712
$T40 = 728
$T41 = 744
$T42 = 760
$T43 = 776
$T44 = 792
$T45 = 808
$T46 = 824
$T47 = 840
$T48 = 856
$T49 = 872
$T50 = 888
$T51 = 904
$T52 = 920
$T53 = 936
$T54 = 952
$T55 = 968
$T56 = 984
$T57 = 1000
$T58 = 1016
$T59 = 1032
$T60 = 1048
$T61 = 1064
$T62 = 1080
$T63 = 1096
$T64 = 1112
$T65 = 1128
$T66 = 1144
$T67 = 1160
icons_config$68 = 1184
szPath$69 = 1312
__$ArrayPad$ = 1584
?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ PROC ; IronMan::Core::OverlayEngine::InitializeImgui

; 542  : 	{

$LN13:
	push	rsi
	push	rdi
	sub	rsp, 1608				; 00000648H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 543  : 		ImGui::CreateContext();

	xor	ecx, ecx
	call	?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z ; ImGui::CreateContext

; 544  : 
; 545  : 		ImGui_ImplWin32_Init(mOverlayWindow, OverlayEngine::mTargetScreenWidth, OverlayEngine::mTargetScreenHeight);

	mov	r8d, DWORD PTR ?mTargetScreenHeight@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenHeight
	mov	edx, DWORD PTR ?mTargetScreenWidth@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenWidth
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	?ImGui_ImplWin32_Init@@YA_NPEAXHH@Z	; ImGui_ImplWin32_Init

; 546  : 		ImGui_ImplDX11_Init(mDevice, mContext);

	mov	rdx, QWORD PTR ?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA ; IronMan::Core::OverlayEngine::mContext
	mov	rcx, QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	call	?ImGui_ImplDX11_Init@@YA_NPEAUID3D11Device@@PEAUID3D11DeviceContext@@@Z ; ImGui_ImplDX11_Init
	npad	1

; 547  : 		{
; 548  : 			ImFontConfig icons_config; icons_config.MergeMode = true; icons_config.PixelSnapH = true;

	lea	rcx, QWORD PTR icons_config$68[rsp]
	call	??0ImFontConfig@@QEAA@XZ		; ImFontConfig::ImFontConfig
	mov	BYTE PTR icons_config$68[rsp+72], 1
	mov	BYTE PTR icons_config$68[rsp+12], 1

; 549  : 
; 550  : 			char szPath[MAX_PATH] = { 0 };

	lea	rax, QWORD PTR szPath$69[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 260				; 00000104H
	rep stosb

; 551  : 			SHGetSpecialFolderPathA(NULL, szPath, CSIDL_FONTS, FALSE);

	xor	r9d, r9d
	mov	r8d, 20
	lea	rdx, QWORD PTR szPath$69[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_SHGetSpecialFolderPathA

; 552  : 
; 553  : 			LANGID lid = GetSystemDefaultLangID();

	call	QWORD PTR __imp_GetSystemDefaultLangID
	mov	WORD PTR lid$3[rsp], ax

; 554  : 			bool loadKorea = false;

	mov	BYTE PTR loadKorea$2[rsp], 0

; 555  : 			if (lid == 0x0412 || lid == 0x0812)

	movzx	eax, WORD PTR lid$3[rsp]
	cmp	eax, 1042				; 00000412H
	je	SHORT $LN5@Initialize
	movzx	eax, WORD PTR lid$3[rsp]
	cmp	eax, 2066				; 00000812H
	jne	SHORT $LN4@Initialize
$LN5@Initialize:

; 556  : 				loadKorea = true;

	mov	BYTE PTR loadKorea$2[rsp], 1
$LN4@Initialize:

; 557  : 
; 558  : 			void* msyh_data = nullptr;

	mov	QWORD PTR msyh_data$5[rsp], 0

; 559  : 
; 560  : 			size_t msyh_data_size = Package::GetPackage()->FindFile(HASH("SourceHanSans-Medium.ttc"), (void**)&msyh_data);

	call	?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ ; IronMan::Core::Package::GetPackage
	mov	QWORD PTR tv93[rsp], rax
	call	??$constHash@$0?BGNOOJIGFPHBLFGF@@@YA_KXZ ; constHash<-1648011277000357221>
	mov	QWORD PTR tv91[rsp], rax
	lea	r8, QWORD PTR msyh_data$5[rsp]
	mov	rdx, QWORD PTR tv91[rsp]
	mov	rcx, QWORD PTR tv93[rsp]
	call	?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z ; IronMan::Core::Package::FindFile
	mov	QWORD PTR msyh_data_size$8[rsp], rax

; 561  : 			if (!msyh_data)

	cmp	QWORD PTR msyh_data$5[rsp], 0
	jne	SHORT $LN6@Initialize

; 562  : 			{
; 563  : 				MessageBoxA(NULL, "Cannot find TTC font file \"msyh.ttc\" in configured font directories.\r\nClick OK to terminate.", "ERROR", MB_OK | MB_ICONHAND);

	mov	r9d, 16
	lea	r8, OFFSET FLAT:??_C@_05MBDEGLCK@ERROR@
	lea	rdx, OFFSET FLAT:??_C@_0FN@EFNFJFIJ@Cannot?5find?5TTC?5font?5file?5?$CCmsyh@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA

; 564  : 				TerminateProcess(GetCurrentProcess(), 0);

	call	QWORD PTR __imp_GetCurrentProcess
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_TerminateProcess
	npad	1
$LN6@Initialize:

; 565  : 			}
; 566  : 
; 567  : 			ImGuiIO& io = ImGui::GetIO();

	call	?GetIO@ImGui@@YAAEAUImGuiIO@@XZ		; ImGui::GetIO
	mov	QWORD PTR io$4[rsp], rax

; 568  : 			io.ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;

	mov	rax, QWORD PTR io$4[rsp]
	mov	DWORD PTR [rax+12], 32			; 00000020H

; 569  : 			const ImWchar* glyphRanges = nullptr;

	mov	QWORD PTR glyphRanges$6[rsp], 0

; 570  : 
; 571  : 			switch (lid)

	movzx	eax, WORD PTR lid$3[rsp]
	mov	DWORD PTR tv137[rsp], eax
	cmp	DWORD PTR tv137[rsp], 1026		; 00000402H
	je	SHORT $LN9@Initialize
	cmp	DWORD PTR tv137[rsp], 1042		; 00000412H
	je	SHORT $LN7@Initialize
	cmp	DWORD PTR tv137[rsp], 1049		; 00000419H
	je	SHORT $LN10@Initialize
	cmp	DWORD PTR tv137[rsp], 2066		; 00000812H
	je	SHORT $LN8@Initialize
	jmp	SHORT $LN11@Initialize
$LN7@Initialize:
$LN8@Initialize:

; 572  : 			{
; 573  : 			case 0x0412:
; 574  : 			case 0x0812:
; 575  : 				glyphRanges = io.Fonts->GetGlyphRangesKorean();//

	mov	rax, QWORD PTR io$4[rsp]
	mov	rcx, QWORD PTR [rax+160]
	call	?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ ; ImFontAtlas::GetGlyphRangesKorean
	mov	QWORD PTR glyphRanges$6[rsp], rax

; 576  : 				break;

	jmp	SHORT $LN2@Initialize
$LN9@Initialize:
$LN10@Initialize:

; 577  : 			case 0x0402://
; 578  : 			case 0x0419:
; 579  : 				glyphRanges = io.Fonts->GetGlyphRangesCyrillic();

	mov	rax, QWORD PTR io$4[rsp]
	mov	rcx, QWORD PTR [rax+160]
	call	?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ ; ImFontAtlas::GetGlyphRangesCyrillic
	mov	QWORD PTR glyphRanges$6[rsp], rax

; 580  : 				break;

	jmp	SHORT $LN2@Initialize
$LN11@Initialize:

; 581  : 			default:
; 582  : 				glyphRanges = io.Fonts->GetGlyphRangesChineseFull();

	mov	rax, QWORD PTR io$4[rsp]
	mov	rcx, QWORD PTR [rax+160]
	call	?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ ; ImFontAtlas::GetGlyphRangesChineseFull
	mov	QWORD PTR glyphRanges$6[rsp], rax
$LN2@Initialize:

; 583  : 				break;
; 584  : 			}
; 585  : 
; 586  : 			Font14px = io.Fonts->AddFontFromMemoryTTF(msyh_data, (int)msyh_data_size, 14.0f, NULL, glyphRanges);

	mov	rax, QWORD PTR io$4[rsp]
	mov	rax, QWORD PTR [rax+160]
	mov	QWORD PTR tv160[rsp], rax
	mov	rax, QWORD PTR glyphRanges$6[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	movss	xmm3, DWORD PTR __real@41600000
	mov	r8d, DWORD PTR msyh_data_size$8[rsp]
	mov	rdx, QWORD PTR msyh_data$5[rsp]
	mov	rcx, QWORD PTR tv160[rsp]
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
	mov	QWORD PTR ?Font14px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA, rax ; IronMan::Core::OverlayEngine::Font14px

; 587  : 
; 588  : 			Font16px = io.Fonts->AddFontFromMemoryTTF(msyh_data, (int)msyh_data_size, 16.0f, NULL, glyphRanges);

	mov	rax, QWORD PTR io$4[rsp]
	mov	rax, QWORD PTR [rax+160]
	mov	QWORD PTR tv170[rsp], rax
	mov	rax, QWORD PTR glyphRanges$6[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	movss	xmm3, DWORD PTR __real@41800000
	mov	r8d, DWORD PTR msyh_data_size$8[rsp]
	mov	rdx, QWORD PTR msyh_data$5[rsp]
	mov	rcx, QWORD PTR tv170[rsp]
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
	mov	QWORD PTR ?Font16px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA, rax ; IronMan::Core::OverlayEngine::Font16px

; 589  : 
; 590  : 			Font18px = io.Fonts->AddFontFromMemoryTTF(msyh_data, (int)msyh_data_size, 18.0f, NULL, glyphRanges);

	mov	rax, QWORD PTR io$4[rsp]
	mov	rax, QWORD PTR [rax+160]
	mov	QWORD PTR tv180[rsp], rax
	mov	rax, QWORD PTR glyphRanges$6[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	movss	xmm3, DWORD PTR __real@41900000
	mov	r8d, DWORD PTR msyh_data_size$8[rsp]
	mov	rdx, QWORD PTR msyh_data$5[rsp]
	mov	rcx, QWORD PTR tv180[rsp]
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
	mov	QWORD PTR ?Font18px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA, rax ; IronMan::Core::OverlayEngine::Font18px

; 591  : 
; 592  : 			Font20px = io.Fonts->AddFontFromMemoryTTF(msyh_data, (int)msyh_data_size, 20.0f, NULL, glyphRanges);

	mov	rax, QWORD PTR io$4[rsp]
	mov	rax, QWORD PTR [rax+160]
	mov	QWORD PTR tv190[rsp], rax
	mov	rax, QWORD PTR glyphRanges$6[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	movss	xmm3, DWORD PTR __real@41a00000
	mov	r8d, DWORD PTR msyh_data_size$8[rsp]
	mov	rdx, QWORD PTR msyh_data$5[rsp]
	mov	rcx, QWORD PTR tv190[rsp]
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
	mov	QWORD PTR ?Font20px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA, rax ; IronMan::Core::OverlayEngine::Font20px

; 593  : 
; 594  : 			Font30px = io.Fonts->AddFontFromMemoryTTF(msyh_data, (int)msyh_data_size, 30.0f, NULL, glyphRanges);

	mov	rax, QWORD PTR io$4[rsp]
	mov	rax, QWORD PTR [rax+160]
	mov	QWORD PTR tv200[rsp], rax
	mov	rax, QWORD PTR glyphRanges$6[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	movss	xmm3, DWORD PTR __real@41f00000
	mov	r8d, DWORD PTR msyh_data_size$8[rsp]
	mov	rdx, QWORD PTR msyh_data$5[rsp]
	mov	rcx, QWORD PTR tv200[rsp]
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
	mov	QWORD PTR ?Font30px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA, rax ; IronMan::Core::OverlayEngine::Font30px

; 595  : 
; 596  : 			io.FontDefault = Font14px;

	mov	rax, QWORD PTR io$4[rsp]
	mov	rcx, QWORD PTR ?Font14px@OverlayEngine@Core@IronMan@@2PEAUImFont@@EA ; IronMan::Core::OverlayEngine::Font14px
	mov	QWORD PTR [rax+184], rcx

; 597  : 			io.Fonts->Build();

	mov	rax, QWORD PTR io$4[rsp]
	mov	rcx, QWORD PTR [rax+160]
	call	?Build@ImFontAtlas@@QEAA_NXZ		; ImFontAtlas::Build

; 598  : 
; 599  : 
; 600  : 			memset((void*)msyh_data, 0, msyh_data_size);

	mov	r8, QWORD PTR msyh_data_size$8[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR msyh_data$5[rsp]
	call	memset

; 601  : 			free((void*)msyh_data);

	mov	rcx, QWORD PTR msyh_data$5[rsp]
	call	free
	npad	1

; 602  : 		}
; 603  : 
; 604  : 		/// Style
; 605  : 		{
; 606  : 			ImColor mainColor = ImColor(int(9), int(10), int(31), 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 31
	mov	r8d, 10
	mov	edx, 9
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor

; 607  : 			ImColor bodyColor = ImColor(int(9), int(10), int(31), 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 31
	mov	r8d, 10
	mov	edx, 9
	lea	rcx, QWORD PTR bodyColor$9[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor

; 608  : 			ImColor fontColor = ImColor(int(255), int(255), int(255), 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 255				; 000000ffH
	mov	r8d, 255				; 000000ffH
	mov	edx, 255				; 000000ffH
	lea	rcx, QWORD PTR fontColor$25[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor

; 609  : 
; 610  : 			auto& style = ImGui::GetStyle();

	call	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	QWORD PTR style$1[rsp], rax

; 611  : 
; 612  : 			ImVec4 mainColorHovered = ImVec4(mainColor.Value.x + 0.1f, mainColor.Value.y + 0.1f, mainColor.Value.z + 0.1f, mainColor.Value.w);

	movss	xmm0, DWORD PTR mainColor$7[rsp+8]
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	xmm1, DWORD PTR mainColor$7[rsp+4]
	addss	xmm1, DWORD PTR __real@3dcccccd
	movss	xmm2, DWORD PTR mainColor$7[rsp]
	addss	xmm2, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv231[rsp], xmm2
	movss	xmm3, DWORD PTR mainColor$7[rsp+12]
	movss	DWORD PTR [rsp+32], xmm3
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv231[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR mainColorHovered$10[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4

; 613  : 			ImVec4 mainColorActive = ImVec4(mainColor.Value.x + 0.2f, mainColor.Value.y + 0.2f, mainColor.Value.z + 0.2f, mainColor.Value.w);

	movss	xmm0, DWORD PTR mainColor$7[rsp+8]
	addss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR mainColor$7[rsp+4]
	addss	xmm1, DWORD PTR __real@3e4ccccd
	movss	xmm2, DWORD PTR mainColor$7[rsp]
	addss	xmm2, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR tv239[rsp], xmm2
	movss	xmm3, DWORD PTR mainColor$7[rsp+12]
	movss	DWORD PTR [rsp+32], xmm3
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv239[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR mainColorActive$12[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4

; 614  : 			ImVec4 menubarColor = ImVec4(bodyColor.Value.x, bodyColor.Value.y, bodyColor.Value.z, bodyColor.Value.w - 0.8f);

	movss	xmm0, DWORD PTR bodyColor$9[rsp+12]
	subss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR bodyColor$9[rsp+8]
	movss	xmm2, DWORD PTR bodyColor$9[rsp+4]
	movss	xmm1, DWORD PTR bodyColor$9[rsp]
	lea	rcx, QWORD PTR menubarColor$24[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4

; 615  : 			ImVec4 frameBgColor = ImVec4(bodyColor.Value.x, bodyColor.Value.y, bodyColor.Value.z, bodyColor.Value.w + .1f);

	movss	xmm0, DWORD PTR bodyColor$9[rsp+12]
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR bodyColor$9[rsp+8]
	movss	xmm2, DWORD PTR bodyColor$9[rsp+4]
	movss	xmm1, DWORD PTR bodyColor$9[rsp]
	lea	rcx, QWORD PTR frameBgColor$11[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4

; 616  : 			ImVec4 tooltipBgColor = ImVec4(bodyColor.Value.x, bodyColor.Value.y, bodyColor.Value.z, bodyColor.Value.w + .05f);

	movss	xmm0, DWORD PTR bodyColor$9[rsp+12]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR bodyColor$9[rsp+8]
	movss	xmm2, DWORD PTR bodyColor$9[rsp+4]
	movss	xmm1, DWORD PTR bodyColor$9[rsp]
	lea	rcx, QWORD PTR tooltipBgColor$23[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	npad	1

; 617  : 
; 618  : 			style.Colors[ImGuiCol_HeaderActive] = ImColor(254, 254, 254, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 254				; 000000feH
	mov	r8d, 254				; 000000feH
	mov	edx, 254				; 000000feH
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv303[rsp], rax
	lea	rdx, QWORD PTR $T27[rsp]
	mov	rcx, QWORD PTR tv303[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 619  : 			style.Colors[ImGuiCol_Text] = ImColor(254, 254, 254, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 254				; 000000feH
	mov	r8d, 254				; 000000feH
	mov	edx, 254				; 000000feH
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv318[rsp], rax
	lea	rdx, QWORD PTR $T29[rsp]
	mov	rcx, QWORD PTR tv318[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 620  : 			style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3e947ae1
	movss	xmm2, DWORD PTR __real@3e6b851f
	movss	xmm1, DWORD PTR __real@3e75c28f
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 621  : 			style.Colors[ImGuiCol_WindowBg] = ImColor(9, 10, 31, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 31
	mov	r8d, 10
	mov	edx, 9
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv343[rsp], rax
	lea	rdx, QWORD PTR $T32[rsp]
	mov	rcx, QWORD PTR tv343[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 622  : 			style.Colors[ImGuiCol_ChildBg] = ImColor(9, 10, 31, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 31
	mov	r8d, 10
	mov	edx, 9
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv358[rsp], rax
	lea	rdx, QWORD PTR $T34[rsp]
	mov	rcx, QWORD PTR tv358[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 623  : 			//style.Colors[ImGuiCol_ChildBg] = ImColor(255, 255, 255, 255);
; 624  : 			style.Colors[ImGuiCol_PopupBg] = tooltipBgColor;

	mov	eax, 16
	imul	rax, rax, 4
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR tooltipBgColor$23[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 625  : 			style.Colors[ImGuiCol_Border] = ImColor(250, 125, 0, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	xor	r9d, r9d
	mov	r8d, 125				; 0000007dH
	mov	edx, 250				; 000000faH
	lea	rcx, QWORD PTR $T35[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv376[rsp], rax
	lea	rdx, QWORD PTR $T36[rsp]
	mov	rcx, QWORD PTR tv376[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 626  : 			style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.92f, 0.91f, 0.88f, 0.00f);

	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f6147ae
	movss	xmm2, DWORD PTR __real@3f68f5c3
	movss	xmm1, DWORD PTR __real@3f6b851f
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 627  : 			style.Colors[ImGuiCol_FrameBg] = ImColor(14, 14, 14, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 14
	mov	r8d, 14
	mov	edx, 14
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv401[rsp], rax
	lea	rdx, QWORD PTR $T39[rsp]
	mov	rcx, QWORD PTR tv401[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 628  : 			style.Colors[ImGuiCol_FrameBgHovered] = ImColor(15, 15, 15, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 15
	mov	r8d, 15
	mov	edx, 15
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv416[rsp], rax
	lea	rdx, QWORD PTR $T41[rsp]
	mov	rcx, QWORD PTR tv416[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 629  : 			style.Colors[ImGuiCol_FrameBgActive] = ImColor(15, 15, 15, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 15
	mov	r8d, 15
	mov	edx, 15
	lea	rcx, QWORD PTR $T42[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv431[rsp], rax
	lea	rdx, QWORD PTR $T43[rsp]
	mov	rcx, QWORD PTR tv431[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 630  : 			style.Colors[ImGuiCol_TitleBg] = mainColor;

	lea	rdx, QWORD PTR $T44[rsp]
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 631  : 			style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 0.98f, 0.95f, 0.75f);

	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f733333
	movss	xmm2, DWORD PTR __real@3f7ae148
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T45[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 632  : 			style.Colors[ImGuiCol_TitleBgActive] = mainColor;

	lea	rdx, QWORD PTR $T46[rsp]
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 633  : 			style.Colors[ImGuiCol_MenuBarBg] = menubarColor;

	mov	eax, 16
	imul	rax, rax, 13
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR menubarColor$24[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 634  : 			style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(frameBgColor.x + .05f, frameBgColor.y + .05f, frameBgColor.z + .05f, frameBgColor.w);

	movss	xmm0, DWORD PTR frameBgColor$11[rsp+8]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR frameBgColor$11[rsp+4]
	addss	xmm1, DWORD PTR __real@3d4ccccd
	movss	xmm2, DWORD PTR frameBgColor$11[rsp]
	addss	xmm2, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR tv470[rsp], xmm2
	movss	xmm3, DWORD PTR frameBgColor$11[rsp+12]
	movss	DWORD PTR [rsp+32], xmm3
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv470[rsp]
	movaps	xmm1, xmm0
	lea	rcx, QWORD PTR $T47[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 635  : 			style.Colors[ImGuiCol_ScrollbarGrab] = mainColor;

	lea	rdx, QWORD PTR $T48[rsp]
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 636  : 			style.Colors[ImGuiCol_ScrollbarGrabHovered] = mainColorHovered;

	mov	eax, 16
	imul	rax, rax, 16
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorHovered$10[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 637  : 			style.Colors[ImGuiCol_ScrollbarGrabActive] = mainColorActive;

	mov	eax, 16
	imul	rax, rax, 17
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorActive$12[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 638  : 			style.Colors[ImGuiCol_CheckMark] = ImColor(240, 240, 240, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 240				; 000000f0H
	mov	r8d, 240				; 000000f0H
	mov	edx, 240				; 000000f0H
	lea	rcx, QWORD PTR $T49[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv531[rsp], rax
	lea	rdx, QWORD PTR $T50[rsp]
	mov	rcx, QWORD PTR tv531[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 639  : 			style.Colors[ImGuiCol_SliderGrab] = mainColorHovered;

	mov	eax, 16
	imul	rax, rax, 19
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorHovered$10[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 640  : 			style.Colors[ImGuiCol_SliderGrabActive] = mainColorActive;

	mov	eax, 16
	imul	rax, rax, 20
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorActive$12[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 641  : 			style.Colors[ImGuiCol_Button] = ImColor(14, 14, 14, 255);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 14
	mov	r8d, 14
	mov	edx, 14
	lea	rcx, QWORD PTR $T51[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv552[rsp], rax
	lea	rdx, QWORD PTR $T52[rsp]
	mov	rcx, QWORD PTR tv552[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 642  : 			style.Colors[ImGuiCol_ButtonHovered] = ImColor(28, 28, 28);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 28
	mov	r8d, 28
	mov	edx, 28
	lea	rcx, QWORD PTR $T53[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv567[rsp], rax
	lea	rdx, QWORD PTR $T54[rsp]
	mov	rcx, QWORD PTR tv567[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 643  : 			style.Colors[ImGuiCol_ButtonActive] = ImColor(56, 56, 56);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 56					; 00000038H
	mov	r8d, 56					; 00000038H
	mov	edx, 56					; 00000038H
	lea	rcx, QWORD PTR $T55[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv582[rsp], rax
	lea	rdx, QWORD PTR $T56[rsp]
	mov	rcx, QWORD PTR tv582[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 644  : 			style.Colors[ImGuiCol_Header] = mainColor;

	lea	rdx, QWORD PTR $T57[rsp]
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 645  : 			style.Colors[ImGuiCol_HeaderHovered] = mainColorHovered;

	mov	eax, 16
	imul	rax, rax, 25
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorHovered$10[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 646  : 			style.Colors[ImGuiCol_HeaderActive] = mainColorActive;

	mov	eax, 16
	imul	rax, rax, 26
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorActive$12[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 647  : 
; 648  : 			style.Colors[ImGuiCol_Separator] = ImColor(3, 60, 50);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 50					; 00000032H
	mov	r8d, 60					; 0000003cH
	mov	edx, 3
	lea	rcx, QWORD PTR $T58[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv610[rsp], rax
	lea	rdx, QWORD PTR $T59[rsp]
	mov	rcx, QWORD PTR tv610[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 649  : 			style.Colors[ImGuiCol_SeparatorHovered] = ImColor(6, 254, 227);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 227				; 000000e3H
	mov	r8d, 254				; 000000feH
	mov	edx, 6
	lea	rcx, QWORD PTR $T60[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv625[rsp], rax
	lea	rdx, QWORD PTR $T61[rsp]
	mov	rcx, QWORD PTR tv625[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 650  : 			style.Colors[ImGuiCol_SeparatorActive] = ImColor(6, 254, 227);

	mov	DWORD PTR [rsp+32], 255			; 000000ffH
	mov	r9d, 227				; 000000e3H
	mov	r8d, 254				; 000000feH
	mov	edx, 6
	lea	rcx, QWORD PTR $T62[rsp]
	call	??0ImColor@@QEAA@HHHH@Z			; ImColor::ImColor
	mov	QWORD PTR tv640[rsp], rax
	lea	rdx, QWORD PTR $T63[rsp]
	mov	rcx, QWORD PTR tv640[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 651  : 
; 652  : 			style.Colors[ImGuiCol_ResizeGrip] = mainColor;

	lea	rdx, QWORD PTR $T64[rsp]
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 653  : 			style.Colors[ImGuiCol_ResizeGripHovered] = mainColorHovered;

	mov	eax, 16
	imul	rax, rax, 31
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorHovered$10[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 654  : 			style.Colors[ImGuiCol_ResizeGripActive] = mainColorActive;

	mov	eax, 16
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorActive$12[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 655  : 			style.Colors[ImGuiCol_PlotLines] = mainColor;

	lea	rdx, QWORD PTR $T65[rsp]
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 38				; 00000026H
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 656  : 			style.Colors[ImGuiCol_PlotLinesHovered] = mainColorHovered;

	mov	eax, 16
	imul	rax, rax, 39				; 00000027H
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorHovered$10[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 657  : 			style.Colors[ImGuiCol_PlotHistogram] = mainColor;

	lea	rdx, QWORD PTR $T66[rsp]
	lea	rcx, QWORD PTR mainColor$7[rsp]
	call	??BImColor@@QEBA?AUImVec4@@XZ		; ImColor::operator ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 40				; 00000028H
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 658  : 			style.Colors[ImGuiCol_PlotHistogramHovered] = mainColorHovered;

	mov	eax, 16
	imul	rax, rax, 41				; 00000029H
	mov	rcx, QWORD PTR style$1[rsp]
	lea	rdx, QWORD PTR mainColorHovered$10[rsp]
	lea	rdi, QWORD PTR [rcx+rax+168]
	mov	rsi, rdx
	mov	ecx, 16
	rep movsb

; 659  : 			style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.25f, 1.00f, 0.00f, 0.43f);

	movss	xmm0, DWORD PTR __real@3edc28f6
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3e800000
	lea	rcx, QWORD PTR $T67[rsp]
	call	??0ImVec4@@QEAA@MMMM@Z			; ImVec4::ImVec4
	mov	ecx, 16
	imul	rcx, rcx, 42				; 0000002aH
	mov	rdx, QWORD PTR style$1[rsp]
	lea	rdi, QWORD PTR [rdx+rcx+168]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 660  : 			//style.Colors[ImGuiCol_ModalWindowDarkening] = ImVec4(1.00f, 0.98f, 0.95f, 0.73f);
; 661  : 			style.Alpha = 1.0f;

	mov	rax, QWORD PTR style$1[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 662  : 			style.WindowPadding = ImVec2(0, 0);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+4], rax

; 663  : 			style.WindowMinSize = ImVec2(32, 32);

	movss	xmm2, DWORD PTR __real@42000000
	movss	xmm1, DWORD PTR __real@42000000
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+20], rax

; 664  : 			style.WindowRounding = 0.f;

	mov	rax, QWORD PTR style$1[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0

; 665  : 			style.WindowBorderSize = 0.f;

	mov	rax, QWORD PTR style$1[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+16], xmm0

; 666  : 			style.PopupBorderSize = 0.f;

	mov	rax, QWORD PTR style$1[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+48], xmm0

; 667  : 			style.WindowTitleAlign = ImVec2(0.5f, 0.5f);

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+28], rax

; 668  : 			style.ChildRounding = 0.0f;

	mov	rax, QWORD PTR style$1[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+36], xmm0

; 669  : 			style.ChildBorderSize = 1.f;

	mov	rax, QWORD PTR style$1[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+40], xmm0

; 670  : 			style.FramePadding = ImVec2(4, 3);

	movss	xmm2, DWORD PTR __real@40400000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+52], rax

; 671  : 			style.FrameRounding = 0.0f;

	mov	rax, QWORD PTR style$1[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+60], xmm0

; 672  : 			style.ItemSpacing = ImVec2(4, 3);

	movss	xmm2, DWORD PTR __real@40400000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+68], rax

; 673  : 			style.ItemInnerSpacing = ImVec2(4, 4);

	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+76], rax

; 674  : 			style.TouchExtraPadding = ImVec2(0, 0);

	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+84], rax

; 675  : 			style.IndentSpacing = 21.0f;

	mov	rax, QWORD PTR style$1[rsp]
	movss	xmm0, DWORD PTR __real@41a80000
	movss	DWORD PTR [rax+92], xmm0

; 676  : 			style.ColumnsMinSpacing = 3.0f;

	mov	rax, QWORD PTR style$1[rsp]
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [rax+96], xmm0

; 677  : 			style.ScrollbarSize = 8.f;

	mov	rax, QWORD PTR style$1[rsp]
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [rax+100], xmm0

; 678  : 			style.ScrollbarRounding = 0.0f;

	mov	rax, QWORD PTR style$1[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+104], xmm0

; 679  : 			style.GrabMinSize = 1.0f;

	mov	rax, QWORD PTR style$1[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+108], xmm0

; 680  : 			style.GrabRounding = 0.0f;

	mov	rax, QWORD PTR style$1[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+112], xmm0

; 681  : 			style.ButtonTextAlign = ImVec2(0.5f, 0.5f);

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@3f000000
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+124], rax

; 682  : 			style.DisplayWindowPadding = ImVec2(22, 22);

	movss	xmm2, DWORD PTR __real@41b00000
	movss	xmm1, DWORD PTR __real@41b00000
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+140], rax

; 683  : 			style.DisplaySafeAreaPadding = ImVec2(4, 4);

	movss	xmm2, DWORD PTR __real@40800000
	movss	xmm1, DWORD PTR __real@40800000
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR style$1[rsp]
	mov	QWORD PTR [rcx+148], rax

; 684  : 			style.AntiAliasedLines = true;

	mov	rax, QWORD PTR style$1[rsp]
	mov	BYTE PTR [rax+160], 1

; 685  : 			style.AntiAliasedFill = true;

	mov	rax, QWORD PTR style$1[rsp]
	mov	BYTE PTR [rax+161], 1

; 686  : 			style.CurveTessellationTol = 1.25f;

	mov	rax, QWORD PTR style$1[rsp]
	movss	xmm0, DWORD PTR __real@3fa00000
	movss	DWORD PTR [rax+164], xmm0

; 687  : 			ImGui::SetColorEditOptions(ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions

	mov	ecx, 76742696				; 04930028H
	call	?SetColorEditOptions@ImGui@@YAXH@Z	; ImGui::SetColorEditOptions
	npad	1

; 688  : 				| ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaBar);
; 689  : 		}
; 690  : 
; 691  : 		return true;

	mov	al, 1

; 692  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1608				; 00000648H
	pop	rdi
	pop	rsi
	ret	0
?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ ENDP ; IronMan::Core::OverlayEngine::InitializeImgui
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
createDeviceFlags$ = 96
featureLevelArray$ = 104
featureLevel$ = 112
sd$ = 128
__$ArrayPad$ = 208
?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ PROC	; IronMan::Core::OverlayEngine::CreateDirect3D

; 168  : 	{

$LN4:
	push	rdi
	sub	rsp, 224				; 000000e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 169  : 		// Setup swap chain
; 170  : 		DXGI_SWAP_CHAIN_DESC sd = { 0 };

	mov	DWORD PTR sd$[rsp], 0
	lea	rax, QWORD PTR sd$[rsp+4]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 68					; 00000044H
	rep stosb

; 171  : 		sd.BufferCount = 2;

	mov	DWORD PTR sd$[rsp+40], 2

; 172  : 		sd.BufferDesc.Width = 0;

	mov	DWORD PTR sd$[rsp], 0

; 173  : 		sd.BufferDesc.Height = 0;

	mov	DWORD PTR sd$[rsp+4], 0

; 174  : 		sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR sd$[rsp+16], 28

; 175  : 		//sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
; 176  : 		sd.BufferDesc.RefreshRate.Numerator = 0;

	mov	DWORD PTR sd$[rsp+8], 0

; 177  : 		sd.BufferDesc.RefreshRate.Denominator = 1;

	mov	DWORD PTR sd$[rsp+12], 1

; 178  : 		sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	mov	DWORD PTR sd$[rsp+64], 2

; 179  : 		sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	mov	DWORD PTR sd$[rsp+36], 32		; 00000020H

; 180  : 		sd.OutputWindow = mOverlayWindow;

	mov	rax, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	mov	QWORD PTR sd$[rsp+48], rax

; 181  : 		sd.SampleDesc.Count = 1;

	mov	DWORD PTR sd$[rsp+28], 1

; 182  : 		sd.SampleDesc.Quality = 0;

	mov	DWORD PTR sd$[rsp+32], 0

; 183  : 		sd.Windowed = TRUE;

	mov	DWORD PTR sd$[rsp+56], 1

; 184  : 		sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	mov	DWORD PTR sd$[rsp+60], 0

; 185  : 
; 186  : 		UINT createDeviceFlags = 0;

	mov	DWORD PTR createDeviceFlags$[rsp], 0

; 187  : 		D3D_FEATURE_LEVEL featureLevel;
; 188  : 		const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };

	mov	DWORD PTR featureLevelArray$[rsp], 45056 ; 0000b000H
	mov	DWORD PTR featureLevelArray$[rsp+4], 40960 ; 0000a000H

; 189  : 		if (D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &mSwapChain, &mDevice, &featureLevel, &mContext) != S_OK)

	lea	rax, OFFSET FLAT:?mContext@OverlayEngine@Core@IronMan@@2PEAUID3D11DeviceContext@@EA ; IronMan::Core::OverlayEngine::mContext
	mov	QWORD PTR [rsp+88], rax
	lea	rax, QWORD PTR featureLevel$[rsp]
	mov	QWORD PTR [rsp+80], rax
	lea	rax, OFFSET FLAT:?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	mov	QWORD PTR [rsp+72], rax
	lea	rax, OFFSET FLAT:?mSwapChain@OverlayEngine@Core@IronMan@@2PEAUIDXGISwapChain@@EA ; IronMan::Core::OverlayEngine::mSwapChain
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR sd$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 7
	mov	DWORD PTR [rsp+40], 2
	lea	rax, QWORD PTR featureLevelArray$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR createDeviceFlags$[rsp]
	xor	r8d, r8d
	mov	edx, 1
	xor	ecx, ecx
	call	D3D11CreateDeviceAndSwapChain
	test	eax, eax
	je	SHORT $LN2@CreateDire

; 190  : 		{
; 191  : 			MessageBoxA(NULL, "Error D3D11CreateDeviceAndSwapChain!", "ERROR", MB_OK | MB_ICONHAND);

	mov	r9d, 16
	lea	r8, OFFSET FLAT:??_C@_05MBDEGLCK@ERROR@
	lea	rdx, OFFSET FLAT:??_C@_0CF@JAIMGOII@Error?5D3D11CreateDeviceAndSwapC@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA

; 192  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@CreateDire
$LN2@CreateDire:

; 193  : 		}
; 194  : 		CreateRenderTarget();

	call	?CreateRenderTarget@OverlayEngine@Core@IronMan@@CAXXZ ; IronMan::Core::OverlayEngine::CreateRenderTarget

; 195  : 		return true;

	mov	al, 1
$LN1@CreateDire:

; 196  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 224				; 000000e0H
	pop	rdi
	ret	0
?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ ENDP	; IronMan::Core::OverlayEngine::CreateDirect3D
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
tv138 = 96
tv136 = 100
tv134 = 104
tv130 = 108
style$ = 112
exStyle$ = 116
tv132 = 120
bb$ = 128
windowClassEx$ = 160
wclass$ = 240
margins$ = 320
__$ArrayPad$ = 336
?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ PROC	; IronMan::Core::OverlayEngine::SetupWindow

; 121  : 	{

$LN6:
	push	rdi
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 122  : 		WNDCLASSEXW windowClassEx = { 0 };

	lea	rax, QWORD PTR windowClassEx$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 80					; 00000050H
	rep stosb

; 123  : 		windowClassEx.cbSize = sizeof(WNDCLASSEXW);

	mov	DWORD PTR windowClassEx$[rsp], 80	; 00000050H

; 124  : 		windowClassEx.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;

	mov	DWORD PTR windowClassEx$[rsp+4], 11

; 125  : 		windowClassEx.lpfnWndProc = WindowProc;

	lea	rax, OFFSET FLAT:?WindowProc@OverlayEngine@Core@IronMan@@CA_JPEAUHWND__@@I_K_J@Z ; IronMan::Core::OverlayEngine::WindowProc
	mov	QWORD PTR windowClassEx$[rsp+8], rax

; 126  : 		windowClassEx.hInstance = GetModuleHandle(NULL);

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleW
	mov	QWORD PTR windowClassEx$[rsp+24], rax

; 127  : 		windowClassEx.hCursor = LoadCursor(NULL, IDC_ARROW);

	mov	edx, 32512				; 00007f00H
	xor	ecx, ecx
	call	QWORD PTR __imp_LoadCursorW
	mov	QWORD PTR windowClassEx$[rsp+40], rax

; 128  : 		windowClassEx.hbrBackground = (HBRUSH)RGB(0, 0, 0);

	mov	QWORD PTR windowClassEx$[rsp+48], 0

; 129  : 		windowClassEx.lpszClassName = L"Qt5QWindowIcon";

	lea	rax, OFFSET FLAT:??_C@_1BO@ILCHKGLN@?$AAQ?$AAt?$AA5?$AAQ?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAI?$AAc?$AAo?$AAn@
	mov	QWORD PTR windowClassEx$[rsp+64], rax

; 130  : 		if (!RegisterClassExW(&windowClassEx))

	lea	rcx, QWORD PTR windowClassEx$[rsp]
	call	QWORD PTR __imp_RegisterClassExW
	movzx	eax, ax
	test	eax, eax
	jne	SHORT $LN2@SetupWindo

; 131  : 			return false;

	xor	al, al
	jmp	$LN1@SetupWindo
$LN2@SetupWindo:

; 132  : 		WNDCLASSEXW wclass;
; 133  : 		GetClassInfoExW(GetModuleHandle(NULL), (L"Qt5QWindowIcon"), &wclass);

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleW
	lea	r8, QWORD PTR wclass$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_1BO@ILCHKGLN@?$AAQ?$AAt?$AA5?$AAQ?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAI?$AAc?$AAo?$AAn@
	mov	rcx, rax
	call	QWORD PTR __imp_GetClassInfoExW

; 134  : 
; 135  : 
; 136  : 		constexpr auto style = WS_POPUP | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPED | WS_POPUPWINDOW;

	mov	DWORD PTR style$[rsp], -2037907456	; 86880000H

; 137  : 		constexpr auto exStyle = WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_PALETTEWINDOW;

	mov	DWORD PTR exStyle$[rsp], 392		; 00000188H

; 138  : 
; 139  : 		OverlayEngine::mOverlayWindow = CreateWindowExW(WS_EX_TOPMOST | WS_EX_TRANSPARENT | WS_EX_NOACTIVATE,

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleW
	mov	QWORD PTR tv132[rsp], rax
	mov	eax, DWORD PTR ?mTargetScreenHeight@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenHeight
	mov	DWORD PTR tv138[rsp], eax
	mov	eax, DWORD PTR ?mTargetScreenWidth@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenWidth
	mov	DWORD PTR tv136[rsp], eax
	mov	eax, DWORD PTR ?mTargetScreenTop@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenTop
	mov	DWORD PTR tv134[rsp], eax
	mov	eax, DWORD PTR ?mTargetScreenLeft@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenLeft
	mov	DWORD PTR tv130[rsp], eax
	mov	QWORD PTR [rsp+88], 0
	mov	rax, QWORD PTR tv132[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	QWORD PTR [rsp+72], 0
	mov	QWORD PTR [rsp+64], 0
	mov	eax, DWORD PTR tv138[rsp]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR tv134[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR tv130[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, -2147483648			; 80000000H
	lea	r8, OFFSET FLAT:??_C@_1M@IEELADJB@?$AAo?$AAb?$AAs?$AA6?$AA4@
	lea	rdx, OFFSET FLAT:??_C@_1BO@ILCHKGLN@?$AAQ?$AAt?$AA5?$AAQ?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAI?$AAc?$AAo?$AAn@
	mov	ecx, 134217768				; 08000028H
	call	QWORD PTR __imp_CreateWindowExW
	mov	QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA, rax ; IronMan::Core::OverlayEngine::mOverlayWindow

; 140  : 			(L"Qt5QWindowIcon"), (L"obs64"), WS_POPUP,
; 141  : 			OverlayEngine::mTargetScreenLeft,
; 142  : 			OverlayEngine::mTargetScreenTop,
; 143  : 			OverlayEngine::mTargetScreenWidth,
; 144  : 			OverlayEngine::mTargetScreenHeight,
; 145  : 			NULL, NULL, GetModuleHandle(NULL), NULL);
; 146  : 		if (!mOverlayWindow)

	cmp	QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA, 0 ; IronMan::Core::OverlayEngine::mOverlayWindow
	jne	SHORT $LN3@SetupWindo

; 147  : 			return false;

	xor	al, al
	jmp	$LN1@SetupWindo
$LN3@SetupWindo:

; 148  : 		SetLayeredWindowAttributes(mOverlayWindow, RGB(0, 0, 0), 255, LWA_ALPHA);

	mov	r9d, 2
	mov	r8b, 255				; 000000ffH
	xor	edx, edx
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_SetLayeredWindowAttributes

; 149  : 		//SetLayeredWindowAttributes(mOverlayWindow, 0, 0, LWA_COLORKEY);
; 150  : 
; 151  : 		MARGINS margins = { -1 };

	mov	DWORD PTR margins$[rsp], -1
	lea	rax, QWORD PTR margins$[rsp+4]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 12
	rep stosb

; 152  : 		if (FAILED(DwmExtendFrameIntoClientArea(mOverlayWindow, &margins)))

	lea	rdx, QWORD PTR margins$[rsp]
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_DwmExtendFrameIntoClientArea
	test	eax, eax
	jge	SHORT $LN4@SetupWindo

; 153  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@SetupWindo
$LN4@SetupWindo:

; 154  : 
; 155  : 		DWM_BLURBEHIND bb = { 0 };

	lea	rax, QWORD PTR bb$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 20
	rep stosb

; 156  : 		bb.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;

	mov	DWORD PTR bb$[rsp], 3

; 157  : 		bb.fEnable = true;

	mov	DWORD PTR bb$[rsp+4], 1

; 158  : 		bb.hRgnBlur = NULL;

	mov	QWORD PTR bb$[rsp+8], 0

; 159  : 		DwmEnableBlurBehindWindow(mOverlayWindow, &bb);

	lea	rdx, QWORD PTR bb$[rsp]
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_DwmEnableBlurBehindWindow

; 160  : 
; 161  : 
; 162  : 		CreateDirect3D();

	call	?CreateDirect3D@OverlayEngine@Core@IronMan@@CA_NXZ ; IronMan::Core::OverlayEngine::CreateDirect3D

; 163  : 		CreateThread(NULL, NULL, ThreadInitGui, InitializeImgui, NULL, NULL);

	mov	QWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	lea	r9, OFFSET FLAT:?InitializeImgui@OverlayEngine@Core@IronMan@@CA_NXZ ; IronMan::Core::OverlayEngine::InitializeImgui
	lea	r8, OFFSET FLAT:?ThreadInitGui@Core@IronMan@@YAKPEAX@Z ; IronMan::Core::ThreadInitGui
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateThread

; 164  : 		return true;

	mov	al, 1
$LN1@SetupWindo:

; 165  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 352				; 00000160H
	pop	rdi
	ret	0
?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ ENDP	; IronMan::Core::OverlayEngine::SetupWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
$T1 = 32
i$2 = 36
findResult$3 = 40
Res$4 = 48
<begin>$L1$5 = 56
<range>$L1$6 = 64
hotkey_callback$7 = 72
<end>$L1$8 = 80
$T9 = 88
$T10 = 96
$T11 = 104
$T12 = 112
?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ PROC	; IronMan::Core::OverlayEngine::ProcessFunction

; 411  : 	{

$LN18:
	sub	rsp, 136				; 00000088H

; 412  : 		static std::unordered_map<int, bool>KeyPress_;

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS0@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA, eax
	jle	SHORT $LN2@ProcessFun
	lea	rcx, OFFSET FLAT:?$TSS0@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA, -1
	jne	SHORT $LN2@ProcessFun
	lea	rcx, OFFSET FLAT:?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A
	call	??0?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@QEAA@XZ ; std::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >::unordered_map<int,bool,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,bool> > >
	lea	rcx, OFFSET FLAT:??__FKeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@YAXXZ ; `IronMan::Core::OverlayEngine::ProcessFunction'::`2'::`dynamic atexit destructor for 'KeyPress_''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS0@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA
	call	_Init_thread_footer
	npad	1
$LN2@ProcessFun:

; 413  : 		for (int i = 0; i < 200; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN5@ProcessFun
$LN3@ProcessFun:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN5@ProcessFun:
	cmp	DWORD PTR i$2[rsp], 200			; 000000c8H
	jge	$LN4@ProcessFun

; 414  : 		{
; 415  : 			auto findResult = mHotkeys.find(i);

	lea	r8, QWORD PTR i$2[rsp]
	lea	rdx, QWORD PTR findResult$3[rsp]
	lea	rcx, OFFSET FLAT:?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
	call	?find@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@AEBH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::find
	npad	1

; 416  : 			if (findResult != mHotkeys.end())

	lea	rdx, QWORD PTR $T9[rsp]
	lea	rcx, OFFSET FLAT:?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
	call	?end@?$_Tree@V?$_Tmap_traits@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR findResult$3[rsp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN9@ProcessFun

; 417  : 			{
; 418  : 				auto Res = KeyPress_.find(findResult->first);

	lea	rcx, QWORD PTR findResult$3[rsp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
	mov	r8, rax
	lea	rdx, QWORD PTR Res$4[rsp]
	lea	rcx, OFFSET FLAT:?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A
	call	??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::find<void>
	npad	1

; 419  : 				if (Res == KeyPress_.end())

	lea	rdx, QWORD PTR $T10[rsp]
	lea	rcx, OFFSET FLAT:?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A
	call	?end@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR Res$4[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@ProcessFun

; 420  : 				{
; 421  : 					KeyPress_.emplace(findResult->first, false);

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR findResult$3[rsp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
	lea	r9, QWORD PTR $T1[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR $T12[rsp]
	lea	rcx, OFFSET FLAT:?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A
	call	??$emplace@AEBH_N@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@_N@1@AEBH$$QEA_N@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::emplace<int const &,bool>
	npad	1

; 422  : 					Res = KeyPress_.find(findResult->first);

	lea	rcx, QWORD PTR findResult$3[rsp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
	mov	r8, rax
	lea	rdx, QWORD PTR $T11[rsp]
	lea	rcx, OFFSET FLAT:?KeyPress_@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4V?$unordered_map@H_NU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBH_N@std@@@2@@std@@A
	call	??$find@X@?$_Hash@V?$_Umap_traits@H_NV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBH_N@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@1@AEBH@Z ; std::_Hash<std::_Umap_traits<int,bool,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,bool> >,0> >::find<void>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR Res$4[rsp], rax
$LN10@ProcessFun:

; 423  : 				}
; 424  : 
; 425  : 				if ((GetAsyncKeyState(findResult->first) & 0x8000) || Res->second)

	lea	rcx, QWORD PTR findResult$3[rsp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
	mov	ecx, DWORD PTR [rax]
	call	QWORD PTR __imp_GetAsyncKeyState
	cwde
	and	eax, 32768				; 00008000H
	test	eax, eax
	jne	SHORT $LN12@ProcessFun
	lea	rcx, QWORD PTR Res$4[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator->
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	je	$LN9@ProcessFun
$LN12@ProcessFun:

; 426  : 				{
; 427  : 					if (!Res->second)

	lea	rcx, QWORD PTR Res$4[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator->
	movzx	eax, BYTE PTR [rax+4]
	test	eax, eax
	jne	SHORT $LN13@ProcessFun

; 428  : 						Res->second = true;

	lea	rcx, QWORD PTR Res$4[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator->
	mov	BYTE PTR [rax+4], 1
$LN13@ProcessFun:

; 429  : 					if (GetAsyncKeyState(findResult->first) == 0)

	lea	rcx, QWORD PTR findResult$3[rsp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
	mov	ecx, DWORD PTR [rax]
	call	QWORD PTR __imp_GetAsyncKeyState
	cwde
	test	eax, eax
	jne	$LN9@ProcessFun

; 430  : 					{
; 431  : 						Res->second = false;

	lea	rcx, QWORD PTR Res$4[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBH_N@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBH_N@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,bool> > > >::operator->
	mov	BYTE PTR [rax+4], 0

; 432  : 						for (const auto& hotkey_callback : findResult->second)

	lea	rcx, QWORD PTR findResult$3[rsp]
	call	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > > >::operator->
	add	rax, 8
	mov	QWORD PTR <range>$L1$6[rsp], rax
	mov	rcx, QWORD PTR <range>$L1$6[rsp]
	call	?_Unchecked_begin@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_begin
	mov	QWORD PTR <begin>$L1$5[rsp], rax
	mov	rcx, QWORD PTR <range>$L1$6[rsp]
	call	?_Unchecked_end@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAPEAV?$function@$$A6AXXZ@2@XZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Unchecked_end
	mov	QWORD PTR <end>$L1$8[rsp], rax
	jmp	SHORT $LN8@ProcessFun
$LN6@ProcessFun:
	mov	rax, QWORD PTR <begin>$L1$5[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR <begin>$L1$5[rsp], rax
$LN8@ProcessFun:
	mov	rax, QWORD PTR <end>$L1$8[rsp]
	cmp	QWORD PTR <begin>$L1$5[rsp], rax
	je	SHORT $LN9@ProcessFun
	mov	rax, QWORD PTR <begin>$L1$5[rsp]
	mov	QWORD PTR hotkey_callback$7[rsp], rax

; 433  : 						{
; 434  : 							if (hotkey_callback)

	mov	rcx, QWORD PTR hotkey_callback$7[rsp]
	call	??B?$function@$$A6AXXZ@std@@QEBA_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@ProcessFun

; 435  : 								hotkey_callback();

	mov	rcx, QWORD PTR hotkey_callback$7[rsp]
	call	??R?$_Func_class@X$$V@std@@QEBAXXZ	; std::_Func_class<void>::operator()
	npad	1
$LN15@ProcessFun:

; 436  : 						}

	jmp	SHORT $LN6@ProcessFun
$LN9@ProcessFun:

; 437  : 					}
; 438  : 
; 439  : 				}
; 440  : 
; 441  : 			}
; 442  : 			continue;

	jmp	$LN3@ProcessFun

; 443  : 		}

	jmp	$LN3@ProcessFun
$LN4@ProcessFun:

; 444  : 	}

	add	rsp, 136				; 00000088H
	ret	0
?ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ ENDP	; IronMan::Core::OverlayEngine::ProcessFunction
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
i$2 = 36
findResult$3 = 40
Res$4 = 48
<begin>$L1$5 = 56
<range>$L1$6 = 64
hotkey_callback$7 = 72
<end>$L1$8 = 80
$T9 = 88
$T10 = 96
$T11 = 104
$T12 = 112
?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA PROC ; `IronMan::Core::OverlayEngine::ProcessFunction'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS0@?1??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ProcessFunction@OverlayEngine@Core@IronMan@@SAXXZ@4HA ENDP ; `IronMan::Core::OverlayEngine::ProcessFunction'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
__$ReturnUdt$ = 48
?GetViewPort@OverlayEngine@Core@IronMan@@SA?AUImVec2@@XZ PROC ; IronMan::Core::OverlayEngine::GetViewPort

; 742  : 	{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 743  : 		return ImVec2((float)mTargetScreenWidth, (float)mTargetScreenHeight);

	cvtsi2ss xmm0, DWORD PTR ?mTargetScreenHeight@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenHeight
	cvtsi2ss xmm1, DWORD PTR ?mTargetScreenWidth@OverlayEngine@Core@IronMan@@2HA ; IronMan::Core::OverlayEngine::mTargetScreenWidth
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0ImVec2@@QEAA@MM@Z			; ImVec2::ImVec2
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 744  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?GetViewPort@OverlayEngine@Core@IronMan@@SA?AUImVec2@@XZ ENDP ; IronMan::Core::OverlayEngine::GetViewPort
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
x$ = 48
y$ = 52
hr$ = 56
tex$1 = 64
data$ = 72
tbsd$2 = 80
n$ = 96
tv89 = 104
tv169 = 112
_srv$3 = 120
srv$4 = 128
desc$5 = 152
__$ArrayPad$ = 200
buffer$ = 224
len$ = 232
?CreateTexture@OverlayEngine@Core@IronMan@@SAPEAXPEBD_K@Z PROC ; IronMan::Core::OverlayEngine::CreateTexture

; 695  : 	{

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 208				; 000000d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 696  : 		HRESULT hr;
; 697  : 		int x, y, n;
; 698  : 		stbi_uc* data = stbi_load_from_memory((stbi_uc*)buffer, (int)len, &x, &y, &n, 0);

	mov	DWORD PTR [rsp+40], 0
	lea	rax, QWORD PTR n$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR y$[rsp]
	lea	r8, QWORD PTR x$[rsp]
	mov	edx, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	stbi_load_from_memory
	mov	QWORD PTR data$[rsp], rax

; 699  : 		if (data)

	cmp	QWORD PTR data$[rsp], 0
	je	$LN2@CreateText

; 700  : 		{
; 701  : 			D3D11_TEXTURE2D_DESC desc = {};

	lea	rax, QWORD PTR desc$5[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 44					; 0000002cH
	rep stosb

; 702  : 			desc.Width = (UINT)x;

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR desc$5[rsp], eax

; 703  : 			desc.Height = (UINT)y;

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR desc$5[rsp+4], eax

; 704  : 			desc.MipLevels = 1;

	mov	DWORD PTR desc$5[rsp+8], 1

; 705  : 			desc.ArraySize = 1;

	mov	DWORD PTR desc$5[rsp+12], 1

; 706  : 			desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR desc$5[rsp+16], 28

; 707  : 			desc.SampleDesc.Count = 1;

	mov	DWORD PTR desc$5[rsp+20], 1

; 708  : 			desc.SampleDesc.Quality = 0;

	mov	DWORD PTR desc$5[rsp+24], 0

; 709  : 			desc.Usage = D3D11_USAGE_DEFAULT;

	mov	DWORD PTR desc$5[rsp+28], 0

; 710  : 			desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;

	mov	DWORD PTR desc$5[rsp+32], 8

; 711  : 			desc.CPUAccessFlags = 0;

	mov	DWORD PTR desc$5[rsp+36], 0

; 712  : 
; 713  : 			D3D11_SUBRESOURCE_DATA tbsd = { 0 };

	lea	rax, QWORD PTR tbsd$2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 714  : 
; 715  : 			tbsd.pSysMem = (void*)data;

	mov	rax, QWORD PTR data$[rsp]
	mov	QWORD PTR tbsd$2[rsp], rax

; 716  : 			tbsd.SysMemPitch = (UINT)(x * 4);

	mov	eax, DWORD PTR x$[rsp]
	shl	eax, 2
	mov	DWORD PTR tbsd$2[rsp+8], eax

; 717  : 			tbsd.SysMemSlicePitch = 0;

	mov	DWORD PTR tbsd$2[rsp+12], 0

; 718  : 
; 719  : 			ID3D11Texture2D* tex;
; 720  : 			hr = mDevice->CreateTexture2D(&desc, &tbsd, &tex);

	mov	rax, QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR tv89[rsp], rax
	lea	r9, QWORD PTR tex$1[rsp]
	lea	r8, QWORD PTR tbsd$2[rsp]
	lea	rdx, QWORD PTR desc$5[rsp]
	mov	rcx, QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	call	QWORD PTR tv89[rsp]
	mov	DWORD PTR hr$[rsp], eax

; 721  : 			assert(SUCCEEDED(hr));
; 722  : 
; 723  : 			ID3D11ShaderResourceView* _srv;
; 724  : 			{
; 725  : 				D3D11_SHADER_RESOURCE_VIEW_DESC srv;
; 726  : 				memset(&srv, 0, sizeof(srv));

	mov	r8d, 24
	xor	edx, edx
	lea	rcx, QWORD PTR srv$4[rsp]
	call	memset

; 727  : 				srv.Format = desc.Format;

	mov	eax, DWORD PTR desc$5[rsp+16]
	mov	DWORD PTR srv$4[rsp], eax

; 728  : 				srv.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;

	mov	DWORD PTR srv$4[rsp+4], 4

; 729  : 				srv.Texture2D.MipLevels = 1;

	mov	DWORD PTR srv$4[rsp+12], 1

; 730  : 				srv.Texture2D.MostDetailedMip = 0;

	mov	DWORD PTR srv$4[rsp+8], 0

; 731  : 				hr = mDevice->CreateShaderResourceView((ID3D11Resource*)tex, &srv, &_srv);

	mov	rax, QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR tv169[rsp], rax
	lea	r9, QWORD PTR _srv$3[rsp]
	lea	r8, QWORD PTR srv$4[rsp]
	mov	rdx, QWORD PTR tex$1[rsp]
	mov	rcx, QWORD PTR ?mDevice@OverlayEngine@Core@IronMan@@2PEAUID3D11Device@@EA ; IronMan::Core::OverlayEngine::mDevice
	call	QWORD PTR tv169[rsp]
	mov	DWORD PTR hr$[rsp], eax

; 732  : 				assert(SUCCEEDED(hr));
; 733  : 			}
; 734  : 			tex->Release();

	mov	rax, QWORD PTR tex$1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR tex$1[rsp]
	call	QWORD PTR [rax+16]

; 735  : 			stbi_image_free(data);

	mov	rcx, QWORD PTR data$[rsp]
	call	stbi_image_free

; 736  : 			return _srv;

	mov	rax, QWORD PTR _srv$3[rsp]
	jmp	SHORT $LN1@CreateText
$LN2@CreateText:

; 737  : 		}
; 738  : 		return nullptr;

	xor	eax, eax
$LN1@CreateText:

; 739  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 208				; 000000d0H
	pop	rdi
	ret	0
?CreateTexture@OverlayEngine@Core@IronMan@@SAPEAXPEBD_K@Z ENDP ; IronMan::Core::OverlayEngine::CreateTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
dwForeID$ = 32
dwCurID$ = 36
hwnd$ = 64
?ActiveWindow@OverlayEngine@Core@IronMan@@SAXPEAUHWND__@@@Z PROC ; IronMan::Core::OverlayEngine::ActiveWindow

; 505  : 	{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 506  : 		auto dwCurID = GetWindowThreadProcessId(GetForegroundWindow(), NULL);

	call	QWORD PTR __imp_GetForegroundWindow
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_GetWindowThreadProcessId
	mov	DWORD PTR dwCurID$[rsp], eax

; 507  : 		auto dwForeID = GetWindowThreadProcessId(hwnd, NULL);

	xor	edx, edx
	mov	rcx, QWORD PTR hwnd$[rsp]
	call	QWORD PTR __imp_GetWindowThreadProcessId
	mov	DWORD PTR dwForeID$[rsp], eax

; 508  : 		AttachThreadInput(dwCurID, dwForeID, TRUE);

	mov	r8d, 1
	mov	edx, DWORD PTR dwForeID$[rsp]
	mov	ecx, DWORD PTR dwCurID$[rsp]
	call	QWORD PTR __imp_AttachThreadInput

; 509  : 		SetForegroundWindow(hwnd);

	mov	rcx, QWORD PTR hwnd$[rsp]
	call	QWORD PTR __imp_SetForegroundWindow

; 510  : 		AttachThreadInput(dwCurID, dwForeID, FALSE);

	xor	r8d, r8d
	mov	edx, DWORD PTR dwForeID$[rsp]
	mov	ecx, DWORD PTR dwCurID$[rsp]
	call	QWORD PTR __imp_AttachThreadInput
	npad	1

; 511  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?ActiveWindow@OverlayEngine@Core@IronMan@@SAXPEAUHWND__@@@Z ENDP ; IronMan::Core::OverlayEngine::ActiveWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
$T1 = 32
vk$ = 64
?RemoveHotkey@OverlayEngine@Core@IronMan@@SAXI@Z PROC	; IronMan::Core::OverlayEngine::RemoveHotkey

; 500  : 	{

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 501  : 		mHotkeys[vk].clear();

	mov	eax, DWORD PTR vk$[rsp]
	mov	DWORD PTR $T1[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
	call	??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::operator[]
	mov	rcx, rax
	call	?clear@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear
	npad	1

; 502  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?RemoveHotkey@OverlayEngine@Core@IronMan@@SAXI@Z ENDP	; IronMan::Core::OverlayEngine::RemoveHotkey
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
$T1 = 32
tv71 = 40
tv73 = 48
vk$ = 80
f$ = 88
?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z PROC ; IronMan::Core::OverlayEngine::RegisterHotkey

; 495  : 	{

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 496  : 		mHotkeys[vk].push_back(f);

	mov	eax, DWORD PTR vk$[rsp]
	mov	DWORD PTR $T1[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?mHotkeys@OverlayEngine@Core@IronMan@@2V?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@A ; IronMan::Core::OverlayEngine::mHotkeys
	call	??A?$map@HV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@@std@@@2@@std@@QEAAAEAV?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@1@$$QEAH@Z ; std::map<int,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >,std::less<int>,std::allocator<std::pair<int const ,std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > > > > >::operator[]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR f$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	mov	rdx, QWORD PTR tv71[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	?push_back@?$vector@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXAEBV?$function@$$A6AXXZ@2@@Z ; std::vector<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::push_back
	npad	1

; 497  : 	}

	mov	rcx, QWORD PTR f$[rsp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	npad	1
	add	rsp, 72					; 00000048H
	ret	0
?RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z ENDP ; IronMan::Core::OverlayEngine::RegisterHotkey
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv71 = 40
tv73 = 48
vk$ = 80
f$ = 88
?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA PROC ; `IronMan::Core::OverlayEngine::RegisterHotkey'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR f$[rbp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??RegisterHotkey@OverlayEngine@Core@IronMan@@SAXIV?$function@$$A6AXXZ@std@@@Z@4HA ENDP ; `IronMan::Core::OverlayEngine::RegisterHotkey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
i$1 = 32
state$2 = 36
?UpdateKeyState@OverlayEngine@Core@IronMan@@SAXXZ PROC	; IronMan::Core::OverlayEngine::UpdateKeyState

; 476  : 	{

$LN10:
	sub	rsp, 56					; 00000038H

; 477  : 		for (int i = 0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@UpdateKeyS
$LN2@UpdateKeyS:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@UpdateKeyS:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	$LN3@UpdateKeyS

; 478  : 		{
; 479  : 			auto state = KeyState::None;

	mov	DWORD PTR state$2[rsp], 1

; 480  : 			mApiKeyMap[i] = GetAsyncKeyState(i);

	mov	ecx, DWORD PTR i$1[rsp]
	call	QWORD PTR __imp_GetAsyncKeyState
	movsxd	rcx, DWORD PTR i$1[rsp]
	lea	rdx, OFFSET FLAT:?mApiKeyMap@OverlayEngine@Core@IronMan@@2PAGA ; IronMan::Core::OverlayEngine::mApiKeyMap
	mov	WORD PTR [rdx+rcx*2], ax

; 481  : 			if (mApiKeyMap[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?mApiKeyMap@OverlayEngine@Core@IronMan@@2PAGA ; IronMan::Core::OverlayEngine::mApiKeyMap
	movzx	eax, WORD PTR [rcx+rax*2]
	test	eax, eax
	je	SHORT $LN5@UpdateKeyS

; 482  : 				state = KeyState::Down;

	mov	DWORD PTR state$2[rsp], 2
	jmp	SHORT $LN6@UpdateKeyS
$LN5@UpdateKeyS:

; 483  : 			else
; 484  : 				state = KeyState::Up;

	mov	DWORD PTR state$2[rsp], 3
$LN6@UpdateKeyS:

; 485  : 			if (state == KeyState::Up && mApiKeyStateMap[i] == KeyState::Down)

	cmp	DWORD PTR state$2[rsp], 3
	jne	SHORT $LN7@UpdateKeyS
	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mApiKeyStateMap
	cmp	DWORD PTR [rcx+rax*4], 2
	jne	SHORT $LN7@UpdateKeyS

; 486  : 			{
; 487  : 				mApiKeyStateMap[i] = KeyState::Pressed;

	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mApiKeyStateMap
	mov	DWORD PTR [rcx+rax*4], 4

; 488  : 			}

	jmp	SHORT $LN8@UpdateKeyS
$LN7@UpdateKeyS:

; 489  : 			else
; 490  : 				mApiKeyStateMap[i] = state;

	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mApiKeyStateMap
	mov	edx, DWORD PTR state$2[rsp]
	mov	DWORD PTR [rcx+rax*4], edx
$LN8@UpdateKeyS:

; 491  : 		}

	jmp	$LN2@UpdateKeyS
$LN3@UpdateKeyS:

; 492  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?UpdateKeyState@OverlayEngine@Core@IronMan@@SAXXZ ENDP	; IronMan::Core::OverlayEngine::UpdateKeyState
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
vk$ = 8
set$ = 16
?SetKeyPressed@OverlayEngine@Core@IronMan@@SAXI_N@Z PROC ; IronMan::Core::OverlayEngine::SetKeyPressed

; 469  : 	{

	mov	BYTE PTR [rsp+16], dl
	mov	DWORD PTR [rsp+8], ecx

; 470  : 		if (vk == 27)

	cmp	DWORD PTR vk$[rsp], 27
	jne	SHORT $LN2@SetKeyPres

; 471  : 			return;

	jmp	SHORT $LN1@SetKeyPres
$LN2@SetKeyPres:

; 472  : 		mApiKeyStateMap[vk] = KeyState::None;

	mov	eax, DWORD PTR vk$[rsp]
	lea	rcx, OFFSET FLAT:?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mApiKeyStateMap
	mov	DWORD PTR [rcx+rax*4], 1
$LN1@SetKeyPres:

; 473  : 	}

	ret	0
?SetKeyPressed@OverlayEngine@Core@IronMan@@SAXI_N@Z ENDP ; IronMan::Core::OverlayEngine::SetKeyPressed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
tv77 = 32
tv74 = 40
vk$ = 64
?WasKeyPressed@OverlayEngine@Core@IronMan@@SA_NI@Z PROC	; IronMan::Core::OverlayEngine::WasKeyPressed

; 462  : 	{

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 463  : 		if (vk == 27)

	cmp	DWORD PTR vk$[rsp], 27
	jne	SHORT $LN2@WasKeyPres

; 464  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@WasKeyPres
$LN2@WasKeyPres:

; 465  : 		return (mApiKeyStateMap[vk] == KeyState::Pressed) || GetDMA().WasKeyPressed(vk);

	mov	eax, DWORD PTR vk$[rsp]
	lea	rcx, OFFSET FLAT:?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mApiKeyStateMap
	cmp	DWORD PTR [rcx+rax*4], 4
	je	SHORT $LN4@WasKeyPres
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR vk$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	?WasKeyPressed@DMAHandler@IronMan@@QEAA_NI@Z ; IronMan::DMAHandler::WasKeyPressed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@WasKeyPres
	mov	DWORD PTR tv77[rsp], 0
	jmp	SHORT $LN5@WasKeyPres
$LN4@WasKeyPres:
	mov	DWORD PTR tv77[rsp], 1
$LN5@WasKeyPres:
	movzx	eax, BYTE PTR tv77[rsp]
$LN1@WasKeyPres:

; 466  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?WasKeyPressed@OverlayEngine@Core@IronMan@@SA_NI@Z ENDP	; IronMan::Core::OverlayEngine::WasKeyPressed
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
tv77 = 32
tv74 = 40
vk$ = 64
?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z PROC	; IronMan::Core::OverlayEngine::IsKeyDown

; 455  : 	{

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 456  : 		if (vk == 27)

	cmp	DWORD PTR vk$[rsp], 27
	jne	SHORT $LN2@IsKeyDown

; 457  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsKeyDown
$LN2@IsKeyDown:

; 458  : 		return mApiKeyStateMap[vk] == KeyState::Down || GetDMA().IsKeyDown(vk);

	mov	eax, DWORD PTR vk$[rsp]
	lea	rcx, OFFSET FLAT:?mApiKeyStateMap@OverlayEngine@Core@IronMan@@2PAW4KeyState@23@A ; IronMan::Core::OverlayEngine::mApiKeyStateMap
	cmp	DWORD PTR [rcx+rax*4], 2
	je	SHORT $LN4@IsKeyDown
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR vk$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	?IsKeyDown@DMAHandler@IronMan@@QEAA_NI@Z ; IronMan::DMAHandler::IsKeyDown
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsKeyDown
	mov	DWORD PTR tv77[rsp], 0
	jmp	SHORT $LN5@IsKeyDown
$LN4@IsKeyDown:
	mov	DWORD PTR tv77[rsp], 1
$LN5@IsKeyDown:
	movzx	eax, BYTE PTR tv77[rsp]
$LN1@IsKeyDown:

; 459  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsKeyDown@OverlayEngine@Core@IronMan@@SA_NI@Z ENDP	; IronMan::Core::OverlayEngine::IsKeyDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
vk$ = 48
?GetKeyState@OverlayEngine@Core@IronMan@@SAFI@Z PROC	; IronMan::Core::OverlayEngine::GetKeyState

; 447  : 	{

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 448  : 		if (vk == 27)

	cmp	DWORD PTR vk$[rsp], 27
	jne	SHORT $LN2@GetKeyStat

; 449  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@GetKeyStat
$LN2@GetKeyStat:

; 450  : 		return GetAsyncKeyState(vk);

	mov	ecx, DWORD PTR vk$[rsp]
	call	QWORD PTR __imp_GetAsyncKeyState
$LN1@GetKeyStat:

; 451  : 		//return mKeyMap[vk];
; 452  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?GetKeyState@OverlayEngine@Core@IronMan@@SAFI@Z ENDP	; IronMan::Core::OverlayEngine::GetKeyState
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?UnTransparent@OverlayEngine@Core@IronMan@@SAXXZ PROC	; IronMan::Core::OverlayEngine::UnTransparent

; 534  : 	{

$LN3:
	sub	rsp, 40					; 00000028H

; 535  : 		SetWindowLong(mOverlayWindow, GWL_EXSTYLE, WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW);

	mov	r8d, 524424				; 00080088H
	mov	edx, -20
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_SetWindowLongW
	npad	1

; 536  : 		//LONG nRet = ::GetWindowLong(mOverlayWindow, GWL_EXSTYLE);
; 537  : 		//SetWindowLong(mOverlayWindow, GWL_EXSTYLE, nRet & ~WS_EX_TRANSPARENT);
; 538  : 		//SetWindowDisplayAffinity(mOverlayWindow, WDA_NONE);
; 539  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?UnTransparent@OverlayEngine@Core@IronMan@@SAXXZ ENDP	; IronMan::Core::OverlayEngine::UnTransparent
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?Transparent@OverlayEngine@Core@IronMan@@SAXXZ PROC	; IronMan::Core::OverlayEngine::Transparent

; 526  : 	{

$LN3:
	sub	rsp, 40					; 00000028H

; 527  : 		SetWindowLong(mOverlayWindow, GWL_EXSTYLE, WS_EX_TOPMOST | WS_EX_TRANSPARENT | WS_EX_LAYERED | WS_EX_TOOLWINDOW);

	mov	r8d, 524456				; 000800a8H
	mov	edx, -20
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_SetWindowLongW
	npad	1

; 528  : 		//LONG nRet = ::GetWindowLong(mOverlayWindow, GWL_EXSTYLE);
; 529  : 		//SetWindowLong(mOverlayWindow, GWL_EXSTYLE, nRet | WS_EX_TRANSPARENT);
; 530  : 		//SetWindowDisplayAffinity(mOverlayWindow, WDA_MONITOR);
; 531  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Transparent@OverlayEngine@Core@IronMan@@SAXXZ ENDP	; IronMan::Core::OverlayEngine::Transparent
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ PROC ; IronMan::Core::OverlayEngine::UpdateTargetWindow

; 514  : 	{

$LN3:
	sub	rsp, 40					; 00000028H

; 515  : 		mTargetScreenWidth = GetSystemMetrics(SM_CXSCREEN);

	xor	ecx, ecx
	call	QWORD PTR __imp_GetSystemMetrics
	mov	DWORD PTR ?mTargetScreenWidth@OverlayEngine@Core@IronMan@@2HA, eax ; IronMan::Core::OverlayEngine::mTargetScreenWidth

; 516  : 		mTargetScreenHeight = GetSystemMetrics(SM_CYSCREEN);

	mov	ecx, 1
	call	QWORD PTR __imp_GetSystemMetrics
	mov	DWORD PTR ?mTargetScreenHeight@OverlayEngine@Core@IronMan@@2HA, eax ; IronMan::Core::OverlayEngine::mTargetScreenHeight

; 517  : 
; 518  : 		//mTargetScreenWidth = 660;
; 519  : 		//mTargetScreenHeight = 660;
; 520  : 
; 521  : 		mTargetScreenLeft = 0;

	mov	DWORD PTR ?mTargetScreenLeft@OverlayEngine@Core@IronMan@@2HA, 0 ; IronMan::Core::OverlayEngine::mTargetScreenLeft

; 522  : 		mTargetScreenTop = 0;

	mov	DWORD PTR ?mTargetScreenTop@OverlayEngine@Core@IronMan@@2HA, 0 ; IronMan::Core::OverlayEngine::mTargetScreenTop

; 523  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ ENDP ; IronMan::Core::OverlayEngine::UpdateTargetWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?bInitSuccess@OverlayEngine@Core@IronMan@@SA_NXZ PROC	; IronMan::Core::OverlayEngine::bInitSuccess

; 99   : 		return InitImGui;

	movzx	eax, BYTE PTR ?InitImGui@Core@IronMan@@3_NA

; 100  : 	}

	ret	0
?bInitSuccess@OverlayEngine@Core@IronMan@@SA_NXZ ENDP	; IronMan::Core::OverlayEngine::bInitSuccess
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?Shutdown@OverlayEngine@Core@IronMan@@SAXXZ PROC	; IronMan::Core::OverlayEngine::Shutdown

; 95   : 	}

	ret	0
?Shutdown@OverlayEngine@Core@IronMan@@SAXXZ ENDP	; IronMan::Core::OverlayEngine::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?Start@OverlayEngine@Core@IronMan@@SAXXZ PROC		; IronMan::Core::OverlayEngine::Start

; 87   : 	{

$LN3:
	sub	rsp, 40					; 00000028H

; 88   : 		Update();

	call	?Update@OverlayEngine@Core@IronMan@@CAXXZ ; IronMan::Core::OverlayEngine::Update

; 89   : 		Tick();

	call	?Tick@OverlayEngine@Core@IronMan@@CAXXZ	; IronMan::Core::OverlayEngine::Tick

; 90   : 		Render();

	call	?Render@OverlayEngine@Core@IronMan@@CAXXZ ; IronMan::Core::OverlayEngine::Render
	npad	1

; 91   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Start@OverlayEngine@Core@IronMan@@SAXXZ ENDP		; IronMan::Core::OverlayEngine::Start
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?HideWindow@OverlayEngine@Core@IronMan@@SAXXZ PROC	; IronMan::Core::OverlayEngine::HideWindow

; 71   : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 72   : 		if (mOverlayWindow)

	cmp	QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA, 0 ; IronMan::Core::OverlayEngine::mOverlayWindow
	je	SHORT $LN2@HideWindow

; 73   : 		{
; 74   : 			ShowWindow(mOverlayWindow, SW_HIDE);

	xor	edx, edx
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_ShowWindow
	npad	1
$LN2@HideWindow:

; 75   : 		}
; 76   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?HideWindow@OverlayEngine@Core@IronMan@@SAXXZ ENDP	; IronMan::Core::OverlayEngine::HideWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?InitWindow@OverlayEngine@Core@IronMan@@SAXXZ PROC	; IronMan::Core::OverlayEngine::InitWindow

; 79   : 	{

$LN3:
	sub	rsp, 40					; 00000028H

; 80   : 		ShowWindow(mOverlayWindow, SW_SHOW);

	mov	edx, 5
	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_ShowWindow

; 81   : 		UpdateWindow(mOverlayWindow);

	mov	rcx, QWORD PTR ?mOverlayWindow@OverlayEngine@Core@IronMan@@2PEAUHWND__@@EA ; IronMan::Core::OverlayEngine::mOverlayWindow
	call	QWORD PTR __imp_UpdateWindow

; 82   : 		OverlayEngine::Transparent();

	call	?Transparent@OverlayEngine@Core@IronMan@@SAXXZ ; IronMan::Core::OverlayEngine::Transparent

; 83   : 		OverlayEngine::UpdateTargetWindow();

	call	?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ ; IronMan::Core::OverlayEngine::UpdateTargetWindow
	npad	1

; 84   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?InitWindow@OverlayEngine@Core@IronMan@@SAXXZ ENDP	; IronMan::Core::OverlayEngine::InitWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DirectX\DirectX11.cpp
_TEXT	SEGMENT
?Initialize@OverlayEngine@Core@IronMan@@SA_NXZ PROC	; IronMan::Core::OverlayEngine::Initialize

; 59   : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 60   : 		// Update target window position
; 61   : 		UpdateTargetWindow();

	call	?UpdateTargetWindow@OverlayEngine@Core@IronMan@@SAXXZ ; IronMan::Core::OverlayEngine::UpdateTargetWindow
	npad	1

; 62   : 
; 63   : 		// Setup overlay window
; 64   : 		if (!SetupWindow())

	call	?SetupWindow@OverlayEngine@Core@IronMan@@CA_NXZ ; IronMan::Core::OverlayEngine::SetupWindow
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Initialize

; 65   : 			return false;

	xor	al, al
	jmp	SHORT $LN1@Initialize
$LN2@Initialize:

; 66   : 
; 67   : 		return true;

	mov	al, 1
$LN1@Initialize:

; 68   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Initialize@OverlayEngine@Core@IronMan@@SA_NXZ ENDP	; IronMan::Core::OverlayEngine::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??BImColor@@QEBA?AUImVec4@@XZ
_TEXT	SEGMENT
this$ = 24
__$ReturnUdt$ = 32
??BImColor@@QEBA?AUImVec4@@XZ PROC			; ImColor::operator ImVec4, COMDAT

; 1745 : 	inline operator ImVec4() const { return Value; }

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR this$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	pop	rdi
	pop	rsi
	ret	0
??BImColor@@QEBA?AUImVec4@@XZ ENDP			; ImColor::operator ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImColor@@QEAA@HHHH@Z
_TEXT	SEGMENT
sc$ = 32
this$ = 64
r$ = 72
g$ = 80
b$ = 88
a$ = 96
??0ImColor@@QEAA@HHHH@Z PROC				; ImColor::ImColor, COMDAT

; 1739 : 	ImColor(int r, int g, int b, int a = 255) { float sc = 1.0f / 255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0ImVec4@@QEAA@XZ			; ImVec4::ImVec4
	movss	xmm0, DWORD PTR __real@3b808081
	movss	DWORD PTR sc$[rsp], xmm0
	cvtsi2ss xmm0, DWORD PTR r$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0
	cvtsi2ss xmm0, DWORD PTR g$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	cvtsi2ss xmm0, DWORD PTR b$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	cvtsi2ss xmm0, DWORD PTR a$[rsp]
	mulss	xmm0, DWORD PTR sc$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0ImColor@@QEAA@HHHH@Z ENDP				; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
_w$ = 40
??0ImVec4@@QEAA@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT

; 190  : 	ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _z$[rsp]
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _w$[rsp]
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImVec4@@QEAA@XZ PROC					; ImVec4::ImVec4, COMDAT

; 189  : 	ImVec4() { x = y = z = w = 0.0f; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+12], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec4@@QEAA@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
??0ImVec2@@QEAA@MM@Z PROC				; ImVec2::ImVec2, COMDAT

; 175  : 	ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _x$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR _y$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ImVec2@@QEAA@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ PROC	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK'', COMDAT

; 157  : 	static const VectorRegister QINV_SIGN_MASK = MakeVectorRegister(-1.f, -1.f, -1.f, 1.f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@bf800000
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EXYZMask@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EXYZMask@Math@Core@IronMan@@YAXXZ PROC		; IronMan::Core::Math::`dynamic initializer for 'XYZMask'', COMDAT

; 155  : 	static const VectorRegister XYZMask = MakeVectorRegister((uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0x00000000);

	sub	rsp, 40					; 00000028H
	xor	r9d, r9d
	mov	r8d, -1					; ffffffffH
	mov	edx, -1					; ffffffffH
	mov	ecx, -1					; ffffffffH
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?XYZMask@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EXYZMask@Math@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::Math::`dynamic initializer for 'XYZMask''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = 0
X$ = 32
Y$ = 40
Z$ = 48
W$ = 56
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 135  : 	{

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 136  : 		return _mm_setr_ps(X, Y, Z, W);

	movss	xmm0, DWORD PTR W$[rsp]
	movss	xmm1, DWORD PTR Z$[rsp]
	movss	xmm2, DWORD PTR Y$[rsp]
	movss	xmm3, DWORD PTR X$[rsp]
	unpcklps xmm1, xmm0
	unpcklps xmm3, xmm2
	movaps	xmm0, xmm3
	movlhps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 137  : 	}

	add	rsp, 24
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
_TEXT	SEGMENT
$T1 = 0
Tmp$ = 16
__$ArrayPad$ = 32
X$ = 64
Y$ = 72
Z$ = 80
W$ = 88
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 119  : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 120  : 		union { VectorRegister v; VectorRegisterInt i; } Tmp;
; 121  : 		Tmp.i = _mm_setr_epi32(X, Y, Z, W);

	movd	xmm0, DWORD PTR W$[rsp]
	movd	xmm1, DWORD PTR Z$[rsp]
	movd	xmm2, DWORD PTR Y$[rsp]
	movd	xmm3, DWORD PTR X$[rsp]
	punpckldq xmm1, xmm0
	punpckldq xmm3, xmm2
	movdqa	xmm0, xmm3
	punpcklqdq xmm0, xmm1
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR Tmp$[rsp], xmm0

; 122  : 		return Tmp.v;

	movaps	xmm0, XMMWORD PTR Tmp$[rsp]

; 123  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	mov	QWORD PTR [rsp+8], rcx

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *,std::_List_node<std::function<void __cdecl(void)>,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::function<void __cdecl(void)>,void *> *,std::_List_node<std::function<void __cdecl(void)>,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Freenode0<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
tv75 = 40
tv73 = 48
this$ = 80
?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear, COMDAT

; 1494 :     void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1495 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1496 :         _My_data._Orphan_non_end();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >::_Orphan_non_end

; 1497 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@XZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::function<void __cdecl(void)>,void *>::_Free_non_head<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >

; 1498 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1499 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 1500 :         _My_data._Mysize        = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1501 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv79 = 32
tv77 = 40
this$ = 64
__$ReturnUdt$ = 72
?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::begin, COMDAT

; 1094 :     _NODISCARD iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1095 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > > >
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1096 :     }

	add	rsp, 56					; 00000038H
	ret	0
?begin@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::~list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >, COMDAT

; 802  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@V?$function@$$A6AXXZ@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >,std::_List_val<std::_List_simple_types<std::function<void __cdecl(void)> > >,1><>
	npad	1

; 803  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@AEAAXXZ ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::_Alloc_sentinel_and_proxy
	npad	1

; 804  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@V?$function@$$A6AXXZ@std@@V?$allocator@V?$function@$$A6AXXZ@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >::list<std::function<void __cdecl(void)>,std::allocator<std::function<void __cdecl(void)> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 80		; 00000050H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@2@QEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0FA@@std@@YA_K_K@Z	; std::_Get_size_of_n<80>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$_List_node@V?$function@$$A6AXXZ@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >::allocator<std::_List_node<std::function<void __cdecl(void)>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$function@$$A6AXXZ@std@@@std@@@std@@SA_KAEBV?$allocator@V?$function@$$A6AXXZ@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::function<void __cdecl(void)> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z PROC ; std::allocator<std::function<void __cdecl(void)> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0EA@@std@@YA_K_K@Z	; std::_Get_size_of_n<64>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAPEAV?$function@$$A6AXXZ@2@_K@Z ENDP ; std::allocator<std::function<void __cdecl(void)> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z PROC ; std::allocator<std::function<void __cdecl(void)> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 64		; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAAXQEAV?$function@$$A6AXXZ@2@_K@Z ENDP ; std::allocator<std::function<void __cdecl(void)> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ PROC ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@V?$function@$$A6AXXZ@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::function<void __cdecl(void)> >::allocator<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z PROC ; std::move<std::function<void __cdecl(void)> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ENDP ; std::move<std::function<void __cdecl(void)> &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z PROC		; std::function<void __cdecl(void)>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$function@$$A6AXXZ@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$function@$$A6AXXZ@std@@QEAAPEAXI@Z ENDP		; std::function<void __cdecl(void)>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$function@$$A6AXXZ@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$function@$$A6AXXZ@std@@QEAA@XZ PROC		; std::function<void __cdecl(void)>::~function<void __cdecl(void)>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::~_Func_class<void>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$function@$$A6AXXZ@std@@QEAA@XZ ENDP		; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA PROC	; `std::function<void __cdecl(void)>::~function<void __cdecl(void)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::~_Func_class<void>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$function@$$A6AXXZ@std@@QEAA@XZ@4HA ENDP	; `std::function<void __cdecl(void)>::~function<void __cdecl(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??B?$function@$$A6AXXZ@std@@QEBA_NXZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??B?$function@$$A6AXXZ@std@@QEBA_NXZ PROC		; std::function<void __cdecl(void)>::operator bool, COMDAT

; 1191 :     explicit operator bool() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1192 :         return !this->_Empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv72[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv72[rsp]

; 1193 :     }

	add	rsp, 56					; 00000038H
	ret	0
??B?$function@$$A6AXXZ@std@@QEBA_NXZ ENDP		; std::function<void __cdecl(void)>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z PROC	; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT

; 1143 :     function(function&& _Right) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::_Func_class<void>
	npad	1

; 1144 :         this->_Reset_move(_STD move(_Right));

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$function@$$A6AXXZ@std@@@std@@YA$$QEAV?$function@$$A6AXXZ@0@AEAV10@@Z ; std::move<std::function<void __cdecl(void)> &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z ; std::_Func_class<void>::_Reset_move
	npad	1

; 1145 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z ENDP	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Right$ = 56
?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA PROC ; `std::function<void __cdecl(void)>::function<void __cdecl(void)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::~_Func_class<void>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@$$QEAV01@@Z@4HA ENDP ; `std::function<void __cdecl(void)>::function<void __cdecl(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z PROC		; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT

; 1092 :     function(const function& _Right) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::_Func_class<void>
	npad	1

; 1093 :         this->_Reset_copy(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z ; std::_Func_class<void>::_Reset_copy
	npad	1

; 1094 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z ENDP		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Right$ = 56
?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::function<void __cdecl(void)>::function<void __cdecl(void)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Func_class@X$$V@std@@QEAA@XZ	; std::_Func_class<void>::~_Func_class<void>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$function@$$A6AXXZ@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::function<void __cdecl(void)>::function<void __cdecl(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z PROC ; std::_Func_class<void>::_Set, COMDAT

; 1048 :     void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1049 :         _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 1050 :     }

	ret	0
?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ENDP ; std::_Func_class<void>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ PROC ; std::_Func_class<void>::_Getimpl, COMDAT

; 1044 :     _Ptrt* _Getimpl() const noexcept { // get pointer to object

	mov	QWORD PTR [rsp+8], rcx

; 1045 :         return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax]

; 1046 :     }

	ret	0
?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ENDP ; std::_Func_class<void>::_Getimpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ
_TEXT	SEGMENT
tv68 = 32
this$ = 64
?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ PROC		; std::_Func_class<void>::_Local, COMDAT

; 1032 :     bool _Local() const noexcept { // test for locally stored copy of object

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1033 :         return _Getimpl() == static_cast<const void*>(&_Mystorage);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, rcx
	jne	SHORT $LN3@Local
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@Local
$LN3@Local:
	mov	DWORD PTR tv68[rsp], 0
$LN4@Local:
	movzx	eax, BYTE PTR tv68[rsp]

; 1034 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ ENDP		; std::_Func_class<void>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ
_TEXT	SEGMENT
tv78 = 32
tv71 = 40
tv81 = 48
this$ = 80
?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ PROC		; std::_Func_class<void>::_Tidy, COMDAT

; 1001 :     void _Tidy() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1002 :         if (!_Empty()) { // destroy callable object and maybe delete it

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Tidy

; 1003 :             _Getimpl()->_Delete_this(!_Local());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR tv71[rsp], rax
	mov	rax, QWORD PTR tv71[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ ; std::_Func_class<void>::_Local
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@Tidy
	mov	BYTE PTR tv78[rsp], 1
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	BYTE PTR tv78[rsp], 0
$LN5@Tidy:
	movzx	edx, BYTE PTR tv78[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	QWORD PTR tv81[rsp]

; 1004 :             _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
	npad	1
$LN2@Tidy:

; 1005 :         }
; 1006 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ ENDP		; std::_Func_class<void>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z
_TEXT	SEGMENT
tv76 = 32
tv83 = 40
this$ = 64
_Right$ = 72
?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z PROC ; std::_Func_class<void>::_Reset_move, COMDAT

; 948  :     void _Reset_move(_Func_class&& _Right) noexcept { // move _Right's stored object

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 949  :         if (!_Right._Empty()) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	$LN2@Reset_move

; 950  :             if (_Right._Local()) { // move and tidy

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Local@?$_Func_class@X$$V@std@@AEBA_NXZ ; std::_Func_class<void>::_Local
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Reset_move

; 951  :                 _Set(_Right._Getimpl()->_Move(&_Mystorage));

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR tv76[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv76[rsp]
	call	QWORD PTR tv83[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set

; 952  :                 _Right._Tidy();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ	; std::_Func_class<void>::_Tidy
	npad	1

; 953  :             } else { // steal from _Right

	jmp	SHORT $LN4@Reset_move
$LN3@Reset_move:

; 954  :                 _Set(_Right._Getimpl());

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set

; 955  :                 _Right._Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
	npad	1
$LN4@Reset_move:
$LN2@Reset_move:

; 956  :             }
; 957  :         }
; 958  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Reset_move@?$_Func_class@X$$V@std@@IEAAX$$QEAV12@@Z ENDP ; std::_Func_class<void>::_Reset_move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z
_TEXT	SEGMENT
tv72 = 32
tv79 = 40
this$ = 64
_Right$ = 72
?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z PROC ; std::_Func_class<void>::_Reset_copy, COMDAT

; 942  :     void _Reset_copy(const _Func_class& _Right) { // copy _Right's stored object

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 943  :         if (!_Right._Empty()) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Reset_copy

; 944  :             _Set(_Right._Getimpl()->_Copy(&_Mystorage));

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR tv72[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv72[rsp]
	call	QWORD PTR tv79[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
	npad	1
$LN2@Reset_copy:

; 945  :         }
; 946  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Reset_copy@?$_Func_class@X$$V@std@@IEAAXAEBV12@@Z ENDP ; std::_Func_class<void>::_Reset_copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ PROC		; std::_Func_class<void>::_Empty, COMDAT

; 938  :     bool _Empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 939  :         return !_Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	test	rax, rax
	jne	SHORT $LN3@Empty
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv67[rsp], 0
$LN4@Empty:
	movzx	eax, BYTE PTR tv67[rsp]

; 940  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ENDP		; std::_Func_class<void>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??1?$_Func_class@X$$V@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Func_class@X$$V@std@@QEAA@XZ PROC			; std::_Func_class<void>::~_Func_class<void>, COMDAT

; 928  :     ~_Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 929  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Func_class@X$$V@std@@IEAAXXZ	; std::_Func_class<void>::_Tidy
	npad	1

; 930  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Func_class@X$$V@std@@QEAA@XZ ENDP			; std::_Func_class<void>::~_Func_class<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??R?$_Func_class@X$$V@std@@QEBAXXZ
_TEXT	SEGMENT
_Impl$ = 32
this$ = 64
??R?$_Func_class@X$$V@std@@QEBAXXZ PROC			; std::_Func_class<void>::operator(), COMDAT

; 920  :     _Ret operator()(_Types... _Args) const {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 921  :         if (_Empty()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Empty@?$_Func_class@X$$V@std@@IEBA_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator

; 922  :             _Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
	npad	1
$LN2@operator:

; 923  :         }
; 924  :         const auto _Impl = _Getimpl();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getimpl@?$_Func_class@X$$V@std@@AEBAPEAV?$_Func_base@X$$V@2@XZ ; std::_Func_class<void>::_Getimpl
	mov	QWORD PTR _Impl$[rsp], rax

; 925  :         return _Impl->_Do_call(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR _Impl$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Impl$[rsp]
	call	QWORD PTR [rax+16]
	npad	1
$LN3@operator:

; 926  :     }

	add	rsp, 56					; 00000038H
	ret	0
??R?$_Func_class@X$$V@std@@QEBAXXZ ENDP			; std::_Func_class<void>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\functional
;	COMDAT ??0?$_Func_class@X$$V@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_Func_class@X$$V@std@@QEAA@XZ PROC			; std::_Func_class<void>::_Func_class<void>, COMDAT

; 916  :     _Func_class() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 917  :         _Set(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Set@?$_Func_class@X$$V@std@@AEAAXPEAV?$_Func_base@X$$V@2@@Z ; std::_Func_class<void>::_Set
	npad	1

; 918  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Func_class@X$$V@std@@QEAA@XZ ENDP			; std::_Func_class<void>::_Func_class<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 416  : [[noreturn]] inline void _Throw_tree_length_error() {

$LN3:
	sub	rsp, 40					; 00000028H

; 417  :     _Xlength_error("map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BB@GCADKGJO@map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Throw_tree:

; 418  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Do_hash@?$hash@H@std@@SA_KAEBH@Z
_TEXT	SEGMENT
_Keyval$ = 48
?_Do_hash@?$hash@H@std@@SA_KAEBH@Z PROC			; std::hash<int>::_Do_hash, COMDAT

; 2355 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2356 :         return _Hash_representation(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$_Hash_representation@H@std@@YA_KAEBH@Z ; std::_Hash_representation<int>

; 2357 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_hash@?$hash@H@std@@SA_KAEBH@Z ENDP			; std::hash<int>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z PROC ; std::_Conditionally_enabled_hash<int,1>::operator(), COMDAT

; 2337 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2338 :         return hash<_Kty>::_Do_hash(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	?_Do_hash@?$hash@H@std@@SA_KAEBH@Z	; std::hash<int>::_Do_hash

; 2339 :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$_Conditionally_enabled_hash@H$00@std@@QEBA_KAEBH@Z ENDP ; std::_Conditionally_enabled_hash<int,1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xbit_ops.h
;	COMDAT ?_Ceiling_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Value$ = 48
?_Ceiling_of_log_2@std@@YAK_K@Z PROC			; std::_Ceiling_of_log_2, COMDAT

; 51   : _NODISCARD inline unsigned long _Ceiling_of_log_2(const size_t _Value) noexcept { // returns ceil(log_2(_Value))

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 52   :                                                                                   // pre: _Value > 1
; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	mov	rax, QWORD PTR _Value$[rsp]
	dec	rax
	mov	rcx, rax
	call	?_Floor_of_log_2@std@@YAK_K@Z		; std::_Floor_of_log_2
	inc	eax

; 54   : }

	add	rsp, 40					; 00000028H
	ret	0
?_Ceiling_of_log_2@std@@YAK_K@Z ENDP			; std::_Ceiling_of_log_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xbit_ops.h
;	COMDAT ?_Floor_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Result$ = 0
_Value$ = 32
?_Floor_of_log_2@std@@YAK_K@Z PROC			; std::_Floor_of_log_2, COMDAT

; 24   : _NODISCARD inline unsigned long _Floor_of_log_2(size_t _Value) noexcept { // returns floor(log_2(_Value))

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	mov	rax, QWORD PTR _Value$[rsp]
	or	rax, 1
	mov	QWORD PTR _Value$[rsp], rax

; 26   :     unsigned long _Result;
; 27   : 
; 28   : #ifdef _M_CEE_PURE
; 29   : #ifdef _WIN64
; 30   :     _Result = 63;
; 31   : #else // ^^^ 64-bit / 32-bit vvv
; 32   :     _Result = 31;
; 33   : #endif // ^^^ 32-bit ^^^
; 34   : 
; 35   :     while ((size_t{1} << _Result) > _Value) {
; 36   :         --_Result;
; 37   :     }
; 38   : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 39   : #ifdef _WIN64
; 40   :     // CodeQL [SM02313] _Result is always initialized: the code above guarantees that _Value is non-zero.
; 41   :     _BitScanReverse64(&_Result, _Value);

	mov	rax, QWORD PTR _Value$[rsp]
	bsr	rax, rax
	mov	DWORD PTR _Result$[rsp], eax

; 42   : #else // ^^^ 64-bit / 32-bit vvv
; 43   :     // CodeQL [SM02313] _Result is always initialized: the code above guarantees that _Value is non-zero.
; 44   :     _BitScanReverse(&_Result, _Value);
; 45   : #endif // ^^^ 32-bit ^^^
; 46   : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 47   : 
; 48   :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 49   : }

	add	rsp, 24
	ret	0
?_Floor_of_log_2@std@@YAK_K@Z ENDP			; std::_Floor_of_log_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\cmath
;	COMDAT ?pow@@YAMMM@Z
_TEXT	SEGMENT
_Xx$ = 48
_Yx$ = 56
?pow@@YAMMM@Z PROC					; pow, COMDAT

; 223  : _NODISCARD _Check_return_ inline float pow(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 224  :     return _CSTD powf(_Xx, _Yx);

	movss	xmm1, DWORD PTR _Yx$[rsp]
	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	powf
	npad	1

; 225  : }

	add	rsp, 40					; 00000028H
	ret	0
?pow@@YAMMM@Z ENDP					; pow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\cmath
;	COMDAT ?ldexp@@YAMMH@Z
_TEXT	SEGMENT
_Xx$ = 48
_Yx$ = 56
?ldexp@@YAMMH@Z PROC					; ldexp, COMDAT

; 163  : _NODISCARD _Check_return_ inline float ldexp(_In_ float _Xx, _In_ int _Yx) noexcept /* strengthened */ {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 164  :     return _CSTD ldexpf(_Xx, _Yx);

	mov	edx, DWORD PTR _Yx$[rsp]
	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	ldexpf
	npad	1

; 165  : }

	add	rsp, 40					; 00000028H
	ret	0
?ldexp@@YAMMH@Z ENDP					; ldexp
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decwref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT

; 1165 :     void _Decwref() noexcept { // decrement weak reference count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1166 :         if (_MT_DECR(_Weaks) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 12
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decwref

; 1167 :             _Delete_this();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+8]
	npad	1
$LN2@Decwref:

; 1168 :         }
; 1169 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decwref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT

; 1158 :     void _Decref() noexcept { // decrement use count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1159 :         if (_MT_DECR(_Uses) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decref

; 1160 :             _Destroy();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax]

; 1161 :             _Decwref();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decwref@_Ref_count_base@std@@QEAAXXZ	; std::_Ref_count_base::_Decwref
	npad	1
$LN2@Decref:

; 1162 :         }
; 1163 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
this$ = 64
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 831  :     _CONSTEXPR20 void _Construct_empty() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 832  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 833  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 834  : 
; 835  :         // initialize basic_string data members
; 836  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 838  :         _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 842  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 684  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 685  :         _Construct_empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 686  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT

; 214  :     constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1187 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT ldexpf
_TEXT	SEGMENT
_X$ = 48
_Y$ = 56
ldexpf	PROC						; COMDAT

; 755  :     {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 756  :         return (float)ldexp(_X, _Y);

	cvtss2sd xmm0, DWORD PTR _X$[rsp]
	mov	edx, DWORD PTR _Y$[rsp]
	call	ldexp
	cvtsd2ss xmm0, xmm0

; 757  :     }

	add	rsp, 40					; 00000028H
	ret	0
ldexpf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_Val$ = 32
_First$ = 40
_Count$ = 48
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2290 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2291 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@Fnv1a_appe
$LN2@Fnv1a_appe:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@Fnv1a_appe:
	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Idx$1[rsp], rax
	jae	SHORT $LN3@Fnv1a_appe

; 2292 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Val$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2293 :         _Val *= _FNV_prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR _Val$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2294 :     }

	jmp	SHORT $LN2@Fnv1a_appe
$LN3@Fnv1a_appe:

; 2295 : 
; 2296 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]

; 2297 : }

	add	rsp, 24
	ret	0
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
