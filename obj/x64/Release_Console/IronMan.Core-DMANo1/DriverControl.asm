; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z	; std::_Fnv1a_append_bytes
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?hash_@@YA?B_KPEBD@Z				; hash_
PUBLIC	??0CriticalSection@IronMan@@QEAA@XZ		; IronMan::CriticalSection::CriticalSection
PUBLIC	??1CriticalSection@IronMan@@QEAA@XZ		; IronMan::CriticalSection::~CriticalSection
PUBLIC	?lock@CriticalSection@IronMan@@QEAAXXZ		; IronMan::CriticalSection::lock
PUBLIC	?unlock@CriticalSection@IronMan@@QEAAXXZ	; IronMan::CriticalSection::unlock
PUBLIC	??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ; IronMan::CSLock::CSLock
PUBLIC	??1CSLock@IronMan@@QEAA@XZ			; IronMan::CSLock::~CSLock
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	??0DriverControl@Core@IronMan@@QEAA@XZ		; IronMan::Core::DriverControl::DriverControl
PUBLIC	??1DriverControl@Core@IronMan@@QEAA@XZ		; IronMan::Core::DriverControl::~DriverControl
PUBLIC	?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ ; IronMan::Core::DriverControl::Instance
PUBLIC	?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ ; IronMan::Core::DriverControl::EnsureLoaded
PUBLIC	?ReadMemCon@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z ; IronMan::Core::DriverControl::ReadMemCon
PUBLIC	?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z ; IronMan::Core::DriverControl::NotifyRegistry
PUBLIC	?ReadMem@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z ; IronMan::Core::DriverControl::ReadMem
PUBLIC	?ProtectProcess@DriverControl@Core@IronMan@@QEAAJXZ ; IronMan::Core::DriverControl::ProtectProcess
PUBLIC	?Instance@DynImport@IronMan@@SAAEAV12@XZ	; IronMan::DynImport::Instance
PUBLIC	??0DynImport@IronMan@@QEAA@XZ			; IronMan::DynImport::DynImport
PUBLIC	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z		; std::equal_to<unsigned __int64>::operator()
PUBLIC	??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
PUBLIC	?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z		; std::hash<unsigned __int64>::_Do_hash
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
PUBLIC	??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate
PUBLIC	??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter
PUBLIC	?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
PUBLIC	??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
PUBLIC	??1DynImport@IronMan@@QEAA@XZ			; IronMan::DynImport::~DynImport
PUBLIC	??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance''
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z ; IronMan::DynImport::safeCall<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *),_UNICODE_STRING *,wchar_t const (&)[4]>
PUBLIC	??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *)>
PUBLIC	??$forward@PEAU_UNICODE_STRING@@@std@@YA$$QEAPEAU_UNICODE_STRING@@AEAPEAU1@@Z ; std::forward<_UNICODE_STRING *>
PUBLIC	??$forward@AEAY03$$CB_W@std@@YAAEAY03$$CB_WAEAY03$$CB_W@Z ; std::forward<wchar_t const (&)[4]>
PUBLIC	??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long &>
PUBLIC	??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
PUBLIC	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
PUBLIC	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z		; std::_Get_size_of_n<40>
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
PUBLIC	??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long)>
PUBLIC	??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z	; std::forward<void *>
PUBLIC	??$forward@K@std@@YA$$QEAKAEAK@Z		; std::forward<unsigned long>
PUBLIC	??$forward@AEAK@std@@YAAEAKAEAK@Z		; std::forward<unsigned long &>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
PUBLIC	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$forward@M@std@@YA$$QEAMAEAM@Z		; std::forward<float>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
PUBLIC	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>
PUBLIC	??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>
PUBLIC	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>
PUBLIC	??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >
PUBLIC	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
PUBLIC	??$_Hash_representation@_K@std@@YA_KAEB_K@Z	; std::_Hash_representation<unsigned __int64>
PUBLIC	??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z	; std::_Fnv1a_append_value<unsigned __int64>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance
PUBLIC	?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
PUBLIC	??_C@_17LGKOMLJ@?$AA?4?$AA?4?$AA?4@		; `string'
PUBLIC	??_C@_0BF@EKFKPNAI@RtlInitUnicodeString@	; `string'
PUBLIC	??_C@_0O@OMDJGLHA@NtSetValueKey@		; `string'
PUBLIC	??_C@_0CB@HDNGBLOB@EnsureLoaded?3?$CF08X?5NtSetValueKey@ ; `string'
PUBLIC	??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ ; `string'
PUBLIC	??_C@_0CI@NGIEIMGJ@EnsureLoaded?3?$CF08X?5NtSetValueKey@ ; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	__real@3f800000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	_Init_thread_header:PROC
EXTRN	_Init_thread_abort:PROC
EXTRN	_Init_thread_footer:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	?Print@Console@IronMan@@YA_NPEBDZZ:PROC		; IronMan::Console::Print
EXTRN	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ:PROC ; IronMan::Utils::FormatString
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	?InitializeOnce@IronMan@@YA_NXZ:PROC		; IronMan::InitializeOnce
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
_BSS	ENDS
;	COMDAT ?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A
_BSS	SEGMENT
?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A DB 068H DUP (?) ; `IronMan::DynImport::Instance'::`2'::instance
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA DD 01H DUP (?) ; `IronMan::DynImport::Instance'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?instance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4V234@A
_BSS	SEGMENT
?instance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4V234@A DQ 01H DUP (?) ; `IronMan::Core::DriverControl::Instance'::`2'::instance
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4HA DD 01H DUP (?) ; `IronMan::Core::DriverControl::Instance'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hash_@@YA?B_KPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+107
	DD	imagerel $unwind$?hash_@@YA?B_KPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CriticalSection@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??0CriticalSection@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CriticalSection@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??1CriticalSection@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@CriticalSection@IronMan@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?lock@CriticalSection@IronMan@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unlock@CriticalSection@IronMan@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?unlock@CriticalSection@IronMan@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CSLock@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$??1CSLock@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA DD imagerel ?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA
	DD	imagerel ?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ DD imagerel $LN11
	DD	imagerel $LN11+940
	DD	imagerel $unwind$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD imagerel ?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DD	imagerel ?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
$pdata$?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD imagerel ?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DD	imagerel ?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
$pdata$?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD imagerel ?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DD	imagerel ?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
$pdata$?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD imagerel ?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DD	imagerel ?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
$pdata$?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD imagerel ?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DD	imagerel ?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ReadMemCon@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$?ReadMemCon@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z
$pdata$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z DD imagerel $LN7
	DD	imagerel $LN7+361
	DD	imagerel $unwind$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA DD imagerel ?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA
	DD	imagerel ?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA
$pdata$?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA DD imagerel ?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA
	DD	imagerel ?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ReadMem@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$?ReadMem@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Instance@DynImport@IronMan@@SAAEAV12@XZ DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$?Instance@DynImport@IronMan@@SAAEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA DD imagerel ?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA
	DD	imagerel ?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0DynImport@IronMan@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$??0DynImport@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1DynImport@IronMan@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$??1DynImport@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z DD imagerel $LN5
	DD	imagerel $LN5+115
	DD	imagerel $unwind$??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN5
	DD	imagerel $LN5+261
	DD	imagerel $unwind$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z DD imagerel $LN5
	DD	imagerel $LN5+257
	DD	imagerel $unwind$??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ DD imagerel ??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ
	DD	imagerel ??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ+22
	DD	imagerel $unwind$??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z DD imagerel $LN5
	DD	imagerel $LN5+257
	DD	imagerel $unwind$??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+388
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN5
	DD	imagerel $LN5+261
	DD	imagerel $unwind$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0CI@NGIEIMGJ@EnsureLoaded?3?$CF08X?5NtSetValueKey@
CONST	SEGMENT
??_C@_0CI@NGIEIMGJ@EnsureLoaded?3?$CF08X?5NtSetValueKey@ DB 'EnsureLoaded'
	DB	':%08X NtSetValueKey2   :%wZ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
CONST	SEGMENT
??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ DB '['
	DB	0e8H, 0beH, 093H, 0e5H, 087H, 0baH, 0e4H, 0bfH, 0a1H, 0e6H, 081H
	DB	0afH, '] %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HDNGBLOB@EnsureLoaded?3?$CF08X?5NtSetValueKey@
CONST	SEGMENT
??_C@_0CB@HDNGBLOB@EnsureLoaded?3?$CF08X?5NtSetValueKey@ DB 'EnsureLoaded'
	DB	':%08X NtSetValueKey1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OMDJGLHA@NtSetValueKey@
CONST	SEGMENT
??_C@_0O@OMDJGLHA@NtSetValueKey@ DB 'NtSetValueKey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EKFKPNAI@RtlInitUnicodeString@
CONST	SEGMENT
??_C@_0BF@EKFKPNAI@RtlInitUnicodeString@ DB 'RtlInitUnicodeString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17LGKOMLJ@?$AA?4?$AA?4?$AA?4@
CONST	SEGMENT
??_C@_17LGKOMLJ@?$AA?4?$AA?4?$AA?4@ DB '.', 00H, '.', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	0a9H, 02H
	DB	00H
	DB	'"'
	DB	02H
	DB	012H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010e11H
	DD	0e20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	0a9H, 02H
	DB	00H
	DB	'"'
	DB	02H
	DB	012H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 010e11H
	DD	0e20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1DynImport@IronMan@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1DynImport@IronMan@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1DynImport@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1DynImport@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1DynImport@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'<'
	DB	04H
	DB	0dcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0DynImport@IronMan@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0DynImport@IronMan@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0DynImport@IronMan@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0DynImport@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??0DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0DynImport@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0DynImport@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Instance@DynImport@IronMan@@SAAEAV12@XZ DB 06H
	DB	00H
	DB	00H
	DB	'|'
	DB	02H
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Instance@DynImport@IronMan@@SAAEAV12@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Instance@DynImport@IronMan@@SAAEAV12@XZ DB 08H
	DD	imagerel $stateUnwindMap$?Instance@DynImport@IronMan@@SAAEAV12@XZ
	DD	imagerel $ip2state$?Instance@DynImport@IronMan@@SAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Instance@DynImport@IronMan@@SAAEAV12@XZ DD 010411H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Instance@DynImport@IronMan@@SAAEAV12@XZ
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z
	DD	025H
	DD	0151H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ
	DD	018H
	DD	0392H
voltbl	ENDS
xdata	SEGMENT
$unwind$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ DD 010411H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ
$cppxdata$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ DB 08H
	DD	imagerel $stateUnwindMap$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ
	DD	imagerel $ip2state$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ
$stateUnwindMap$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA
$ip2state$?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ DB 06H
	DB	00H
	DB	00H
	DB	'|'
	DB	02H
	DB	'2'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ DD 042019H
	DD	039010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ
	DD	01b2H
$cppxdata$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ DB 08H
	DD	imagerel $stateUnwindMap$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ
	DD	imagerel $ip2state$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ
$stateUnwindMap$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DB	05eH
	DD	imagerel ?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DB	086H
	DD	imagerel ?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
	DB	0aeH
	DD	imagerel ?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA
$ip2state$?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ DB 016H
	DB	00H
	DB	00H
	DB	0e4H
	DB	02H
	DB	090H
	DB	00H
	DB	0e4H
	DB	04H
	DB	'4'
	DB	00H
	DB	080H
	DB	06H
	DB	'J'
	DB	00H
	DB	0f6H
	DB	08H
	DB	0a8H
	DB	00H
	DB	'=', 02H
	DB	0aH
	DB	098H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA DD 020601H
	DD	050023206H
$unwind$?ReadMemCon@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z DD 011701H
	DD	04217H
$unwind$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z DD 022d19H
	DD	01d011bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z
	DD	0d2H
$cppxdata$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z DB 08H
	DD	imagerel $stateUnwindMap$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z
	DD	imagerel $ip2state$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z
$stateUnwindMap$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA
$ip2state$?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z DB 0aH
	DB	00H
	DB	00H
	DB	0b2H
	DB	02H
	DB	'>'
	DB	00H
	DB	0c0H
	DB	04H
	DB	096H
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ReadMem@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CSLock@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1CSLock@IronMan@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1CSLock@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CSLock@IronMan@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1CSLock@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unlock@CriticalSection@IronMan@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@CriticalSection@IronMan@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CriticalSection@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1CriticalSection@IronMan@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1CriticalSection@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CriticalSection@IronMan@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1CriticalSection@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CriticalSection@IronMan@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hash_@@YA?B_KPEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
_TEXT	SEGMENT
_Val$ = 48
_Keyval$ = 56
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z PROC	; std::_Fnv1a_append_value<unsigned __int64>, COMDAT

; 2310 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2311 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2312 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	mov	r8d, 8
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	call	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ; std::_Fnv1a_append_bytes

; 2313 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ENDP	; std::_Fnv1a_append_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Hash_representation@_K@std@@YA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 48
??$_Hash_representation@_K@std@@YA_KAEB_K@Z PROC	; std::_Hash_representation<unsigned __int64>, COMDAT

; 2316 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2317 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, -3750763034362895579		; cbf29ce484222325H
	call	??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ; std::_Fnv1a_append_value<unsigned __int64>

; 2318 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Hash_representation@_K@std@@YA_KAEB_K@Z ENDP	; std::_Hash_representation<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv76 = 32
tv73 = 40
this$ = 64
_Keyval1$ = 72
_Keyval2$ = 80
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>, COMDAT

; 155  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  :         // test if _Keyval1 NOT equal to _Keyval2
; 157  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR _Keyval2$[rsp]
	mov	rdx, QWORD PTR _Keyval1$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z	; std::equal_to<unsigned __int64>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv76[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv76[rsp]

; 158  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();
; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	ret	0
??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 40
this$ = 80
_Keyval$ = 88
_Hashval$ = 96
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>, COMDAT

; 1213 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1214 :         if constexpr (_Traits::_Multi) {
; 1215 :             return _Find_first(_Keyval, _Hashval);
; 1216 :         } else {
; 1217 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1218 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Target$1[rsp], rax

; 1219 :             if (_Target) {

	cmp	QWORD PTR _Target$1[rsp], 0
	je	SHORT $LN2@Find

; 1220 :                 return _Target;

	mov	rax, QWORD PTR _Target$1[rsp]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1221 :             }
; 1222 : 
; 1223 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@Find:

; 1224 :         }
; 1225 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_KUimport@IronMan@@@?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Kfn<unsigned __int64 const ,IronMan::import>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find_last<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv75 = 32
this$ = 64
_Keyval$ = 72
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>, COMDAT

; 148  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 149  :         // hash _Keyval to size_t value
; 150  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()

; 151  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 123  : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KUimport@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::import> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CB_KUimport@IronMan@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KUimport@IronMan@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::destroy<std::pair<unsigned __int64 const ,IronMan::import> >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > ><std::pair<unsigned __int64 const ,IronMan::import> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 32
_Al$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 802  : 
; 803  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 804  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 805  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 806  :         } else {
; 807  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 808  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 809  :         }
; 810  : 
; 811  : #if _HAS_CXX20
; 812  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 813  :         // but likely more impactful to throughput.
; 814  :         if (_STD is_constant_evaluated()) {
; 815  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 816  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 817  :                 _STD construct_at(_Ptr + _Idx);
; 818  :             }
; 819  :         }
; 820  : #endif // _HAS_CXX20
; 821  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 822  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 823  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAK@std@@YAAEAKAEAK@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAK@std@@YAAEAKAEAK@Z PROC			; std::forward<unsigned long &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAK@std@@YAAEAKAEAK@Z ENDP			; std::forward<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@K@std@@YA$$QEAKAEAK@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@K@std@@YA$$QEAKAEAK@Z PROC			; std::forward<unsigned long>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@K@std@@YA$$QEAKAEAK@Z ENDP			; std::forward<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z PROC		; std::forward<void *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z ENDP		; std::forward<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::DynImport::get<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long)>, COMDAT

; 229  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 230  : 			InitializeOnce();

	call	?InitializeOnce@IronMan@@YA_NXZ		; IronMan::InitializeOnce

; 231  : 
; 232  : 			CSLock lck(_mapGuard);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ; IronMan::CSLock::CSLock
	npad	1

; 233  : 
; 234  : 			auto iter = _funcs.find(hash_(name.c_str()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv83[rsp], rax
	mov	rcx, QWORD PTR name$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR $T1[rsp], rax
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR iter$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
	npad	1

; 235  : 			if (iter != _funcs.end() && *reinterpret_cast<int64_t*>(iter->second.func) == iter->second.codehash)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv133[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@get
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv142[rsp], rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv142[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN2@get

; 236  : 				return reinterpret_cast<T>(iter->second.func);

	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR $T2[rsp], rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T2[rsp]
	jmp	SHORT $LN1@get
$LN2@get:

; 237  : 
; 238  : 			return nullptr;

	mov	QWORD PTR $T3[rsp], 0
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T3[rsp]
$LN1@get:

; 239  : 		}

	add	rsp, 120				; 00000078H
	ret	0
??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::DynImport::get<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::DynImport::get<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR lck$[rbp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::DynImport::get<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>, COMDAT

; 1229 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1230 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Find<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1231 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<40>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<40>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KUimport@IronMan@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> ><std::pair<unsigned __int64 const ,IronMan::import> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx], xmm0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv81 = 48
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
<_Val2_1>$ = 104
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv79[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv73 = 40
tv75 = 48
tv84 = 56
this$ = 80
_Al$ = 88
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>, COMDAT

; 267  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	npad	1

; 268  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 269  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 33
$T2 = 34
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1116 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	mov	QWORD PTR [rsp+8], rcx

; 1117 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1118 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1119 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1120 : 
; 1121 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1122 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1123 :             _Xlength_error("size is too long for _Size_type");
; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 1128 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z
_TEXT	SEGMENT
tv133 = 48
tv129 = 52
tv93 = 56
tv91 = 60
pfn$ = 64
tv95 = 72
tv89 = 80
tv87 = 88
tv131 = 96
this$ = 128
name$ = 136
<args_0>$ = 144
<args_1>$ = 152
<args_2>$ = 160
<args_3>$ = 168
<args_4>$ = 176
<args_5>$ = 184
??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z PROC ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long>, COMDAT

; 250  : 		{

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 251  : 			auto pfn = DynImport::get<T>(name);

	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long)>
	mov	QWORD PTR pfn$[rsp], rax

; 252  : 			return pfn ? pfn(std::forward<Args>(args)...) : STATUS_ORDINAL_NOT_FOUND;

	cmp	QWORD PTR pfn$[rsp], 0
	je	$LN3@safeNative
	mov	rax, QWORD PTR pfn$[rsp]
	mov	QWORD PTR tv131[rsp], rax
	mov	rcx, QWORD PTR <args_5>$[rsp]
	call	??$forward@K@std@@YA$$QEAKAEAK@Z	; std::forward<unsigned long>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv129[rsp], eax
	mov	rcx, QWORD PTR <args_4>$[rsp]
	call	??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z ; std::forward<void *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv95[rsp], rax
	mov	rcx, QWORD PTR <args_3>$[rsp]
	call	??$forward@K@std@@YA$$QEAKAEAK@Z	; std::forward<unsigned long>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv93[rsp], eax
	mov	rcx, QWORD PTR <args_2>$[rsp]
	call	??$forward@K@std@@YA$$QEAKAEAK@Z	; std::forward<unsigned long>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv91[rsp], eax
	mov	rcx, QWORD PTR <args_1>$[rsp]
	call	??$forward@PEAU_UNICODE_STRING@@@std@@YA$$QEAPEAU_UNICODE_STRING@@AEAPEAU1@@Z ; std::forward<_UNICODE_STRING *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv89[rsp], rax
	mov	rcx, QWORD PTR <args_0>$[rsp]
	call	??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z ; std::forward<void *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv87[rsp], rax
	mov	eax, DWORD PTR tv129[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv95[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR tv93[rsp]
	mov	r8d, DWORD PTR tv91[rsp]
	mov	rdx, QWORD PTR tv89[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	QWORD PTR tv131[rsp]
	mov	DWORD PTR tv133[rsp], eax
	jmp	SHORT $LN4@safeNative
$LN3@safeNative:
	mov	DWORD PTR tv133[rsp], -1073741512	; ffffffffc0000138H
$LN4@safeNative:
	mov	eax, DWORD PTR tv133[rsp]

; 253  : 		}

	add	rsp, 120				; 00000078H
	ret	0
??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z ENDP ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ
text$yd	SEGMENT
??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ PROC ; `IronMan::Core::DriverControl::Instance'::`2'::`dynamic atexit destructor for 'instance'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?instance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4V234@A
	call	??1DriverControl@Core@IronMan@@QEAA@XZ	; IronMan::Core::DriverControl::~DriverControl
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ ENDP ; `IronMan::Core::DriverControl::Instance'::`2'::`dynamic atexit destructor for 'instance''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z
_TEXT	SEGMENT
tv133 = 48
tv129 = 52
tv93 = 56
tv91 = 60
pfn$ = 64
tv95 = 72
tv89 = 80
tv87 = 88
tv131 = 96
this$ = 128
name$ = 136
<args_0>$ = 144
<args_1>$ = 152
<args_2>$ = 160
<args_3>$ = 168
<args_4>$ = 176
<args_5>$ = 184
??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z PROC ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long &>, COMDAT

; 250  : 		{

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 251  : 			auto pfn = DynImport::get<T>(name);

	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$get@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@Z@DynImport@IronMan@@QEAAP6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long)>
	mov	QWORD PTR pfn$[rsp], rax

; 252  : 			return pfn ? pfn(std::forward<Args>(args)...) : STATUS_ORDINAL_NOT_FOUND;

	cmp	QWORD PTR pfn$[rsp], 0
	je	$LN3@safeNative
	mov	rax, QWORD PTR pfn$[rsp]
	mov	QWORD PTR tv131[rsp], rax
	mov	rcx, QWORD PTR <args_5>$[rsp]
	call	??$forward@AEAK@std@@YAAEAKAEAK@Z	; std::forward<unsigned long &>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv129[rsp], eax
	mov	rcx, QWORD PTR <args_4>$[rsp]
	call	??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z ; std::forward<void *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv95[rsp], rax
	mov	rcx, QWORD PTR <args_3>$[rsp]
	call	??$forward@K@std@@YA$$QEAKAEAK@Z	; std::forward<unsigned long>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv93[rsp], eax
	mov	rcx, QWORD PTR <args_2>$[rsp]
	call	??$forward@K@std@@YA$$QEAKAEAK@Z	; std::forward<unsigned long>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv91[rsp], eax
	mov	rcx, QWORD PTR <args_1>$[rsp]
	call	??$forward@PEAU_UNICODE_STRING@@@std@@YA$$QEAPEAU_UNICODE_STRING@@AEAPEAU1@@Z ; std::forward<_UNICODE_STRING *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv89[rsp], rax
	mov	rcx, QWORD PTR <args_0>$[rsp]
	call	??$forward@PEAX@std@@YA$$QEAPEAXAEAPEAX@Z ; std::forward<void *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv87[rsp], rax
	mov	eax, DWORD PTR tv129[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tv95[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR tv93[rsp]
	mov	r8d, DWORD PTR tv91[rsp]
	mov	rdx, QWORD PTR tv89[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	QWORD PTR tv131[rsp]
	mov	DWORD PTR tv133[rsp], eax
	jmp	SHORT $LN4@safeNative
$LN3@safeNative:
	mov	DWORD PTR tv133[rsp], -1073741512	; ffffffffc0000138H
$LN4@safeNative:
	mov	eax, DWORD PTR tv133[rsp]

; 253  : 		}

	add	rsp, 120				; 00000078H
	ret	0
??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z ENDP ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAY03$$CB_W@std@@YAAEAY03$$CB_WAEAY03$$CB_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAY03$$CB_W@std@@YAAEAY03$$CB_WAEAY03$$CB_W@Z PROC ; std::forward<wchar_t const (&)[4]>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAY03$$CB_W@std@@YAAEAY03$$CB_WAEAY03$$CB_W@Z ENDP ; std::forward<wchar_t const (&)[4]>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAU_UNICODE_STRING@@@std@@YA$$QEAPEAU_UNICODE_STRING@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU_UNICODE_STRING@@@std@@YA$$QEAPEAU_UNICODE_STRING@@AEAPEAU1@@Z PROC ; std::forward<_UNICODE_STRING *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAU_UNICODE_STRING@@@std@@YA$$QEAPEAU_UNICODE_STRING@@AEAPEAU1@@Z ENDP ; std::forward<_UNICODE_STRING *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::DynImport::get<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *)>, COMDAT

; 229  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 230  : 			InitializeOnce();

	call	?InitializeOnce@IronMan@@YA_NXZ		; IronMan::InitializeOnce

; 231  : 
; 232  : 			CSLock lck(_mapGuard);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ; IronMan::CSLock::CSLock
	npad	1

; 233  : 
; 234  : 			auto iter = _funcs.find(hash_(name.c_str()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv83[rsp], rax
	mov	rcx, QWORD PTR name$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rcx, rax
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR $T1[rsp], rax
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR iter$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	call	??$find@X@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::find<void>
	npad	1

; 235  : 			if (iter != _funcs.end() && *reinterpret_cast<int64_t*>(iter->second.func) == iter->second.codehash)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv133[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR tv133[rsp]
	call	?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@get
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv142[rsp], rax
	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR tv142[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN2@get

; 236  : 				return reinterpret_cast<T>(iter->second.func);

	lea	rcx, QWORD PTR iter$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR $T2[rsp], rax
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T2[rsp]
	jmp	SHORT $LN1@get
$LN2@get:

; 237  : 
; 238  : 			return nullptr;

	mov	QWORD PTR $T3[rsp], 0
	lea	rcx, QWORD PTR lck$[rsp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	mov	rax, QWORD PTR $T3[rsp]
$LN1@get:

; 239  : 		}

	add	rsp, 120				; 00000078H
	ret	0
??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::DynImport::get<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
iter$ = 32
lck$ = 40
$T1 = 48
tv83 = 56
tv133 = 64
tv142 = 72
$T2 = 80
$T3 = 88
$T4 = 96
this$ = 128
name$ = 136
?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::DynImport::get<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *)>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR lck$[rbp]
	call	??1CSLock@IronMan@@QEAA@XZ		; IronMan::CSLock::~CSLock
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::DynImport::get<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z
_TEXT	SEGMENT
pfn$ = 32
tv76 = 40
tv74 = 48
tv78 = 56
this$ = 80
name$ = 88
<args_0>$ = 96
<args_1>$ = 104
??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z PROC ; IronMan::DynImport::safeCall<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *),_UNICODE_STRING *,wchar_t const (&)[4]>, COMDAT

; 264  : 		{

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 265  : 			auto pfn = DynImport::get<T>(name);

	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$get@P6AXPEAU_UNICODE_STRING@@PEB_W@Z@DynImport@IronMan@@QEAAP6AXPEAU_UNICODE_STRING@@PEB_W@ZAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::DynImport::get<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *)>
	mov	QWORD PTR pfn$[rsp], rax

; 266  : 			return pfn ? pfn(std::forward<Args>(args)...) : std::invoke_result_t<T, Args...>();

	cmp	QWORD PTR pfn$[rsp], 0
	je	SHORT $LN3@safeCall
	mov	rax, QWORD PTR pfn$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR <args_1>$[rsp]
	call	??$forward@AEAY03$$CB_W@std@@YAAEAY03$$CB_WAEAY03$$CB_W@Z ; std::forward<wchar_t const (&)[4]>
	mov	QWORD PTR tv76[rsp], rax
	mov	rcx, QWORD PTR <args_0>$[rsp]
	call	??$forward@PEAU_UNICODE_STRING@@@std@@YA$$QEAPEAU_UNICODE_STRING@@AEAPEAU1@@Z ; std::forward<_UNICODE_STRING *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	QWORD PTR tv78[rsp]
	npad	1
$LN3@safeCall:

; 267  : 		}

	add	rsp, 72					; 00000048H
	ret	0
??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z ENDP ; IronMan::DynImport::safeCall<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *),_UNICODE_STRING *,wchar_t const (&)[4]>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->, COMDAT

; 241  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KUimport@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KUimport@IronMan@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::import> *>::pointer_to

; 243  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KUimport@IronMan@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=, COMDAT

; 201  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 202  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 203  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KUimport@IronMan@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ
text$yd	SEGMENT
??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ PROC ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance'', COMDAT
$LN3:
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance
	call	??1DynImport@IronMan@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ ENDP ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1DynImport@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1DynImport@IronMan@@QEAA@XZ PROC			; IronMan::DynImport::~DynImport, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??1CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::~CriticalSection
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1DynImport@IronMan@@QEAA@XZ ENDP			; IronMan::DynImport::~DynImport
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::~DynImport'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::~DynImport'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::~DynImport'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::~CriticalSection
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::~DynImport'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >, COMDAT

; 323  :     ~_Hash_vec() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy
	npad	1

; 325  : #if _ITERATOR_DEBUG_LEVEL != 0
; 326  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());
; 327  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 328  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 329  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv92 = 48
this$ = 80
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy, COMDAT

; 313  :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 314  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 315  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>

; 316  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate

; 317  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 318  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 319  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@Tidy:

; 320  :         }
; 321  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size, COMDAT

; 1772 :     float& _Max_bucket_size() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1773 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1774 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end, COMDAT

; 796  :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 797  :         return _List.end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 798  :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >, COMDAT

; 378  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > ><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 7
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 8

; 379  :         // construct empty hash table
; 380  :         _Max_bucket_size() = _Bucket_size;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 381  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end
	mov	r8, QWORD PTR [rax]
	mov	edx, 16
	mov	rcx, QWORD PTR tv132[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::_Assign_grow
	npad	1

; 382  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 383  :         _Stl_internal_check_container_invariants();
; 384  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 385  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter, COMDAT

; 1126 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1127 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > const >
	mov	r8, rax
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1128 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Make_iter@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::~list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Al$ = 72
??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >, COMDAT

; 806  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::import> > >,1><std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > const &>
	npad	1

; 807  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::_Alloc_sentinel_and_proxy
	npad	1

; 808  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@U?$pair@$$CB_KUimport@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::list<std::pair<unsigned __int64 const ,IronMan::import>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 40		; 00000028H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z	; std::_Get_size_of_n<40>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KUimport@IronMan@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,IronMan::import>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR _Traits$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Umap_traits@_KUimport@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>::_Umap_traits<unsigned __int64,IronMan::import,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,IronMan::import> >::allocator<std::pair<unsigned __int64 const ,IronMan::import> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 48
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z PROC		; std::hash<unsigned __int64>::_Do_hash, COMDAT

; 2355 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2356 :         return _Hash_representation(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$_Hash_representation@_K@std@@YA_KAEB_K@Z ; std::_Hash_representation<unsigned __int64>

; 2357 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z ENDP		; std::hash<unsigned __int64>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z PROC ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator(), COMDAT

; 2337 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2338 :         return hash<_Kty>::_Do_hash(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z	; std::hash<unsigned __int64>::_Do_hash

; 2339 :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ENDP ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z PROC		; std::equal_to<unsigned __int64>::operator(), COMDAT

; 634  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 635  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 636  :     }

	add	rsp, 24
	ret	0
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z ENDP		; std::equal_to<unsigned __int64>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size, COMDAT

; 160  :     _NODISCARD float& _Get_max_bucket_size() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 161  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 162  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
tv75 = 40
this$ = 64
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >, COMDAT

; 137  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR $T3[rsp], xmm0
	lea	r9, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	movzx	edx, BYTE PTR $T2[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ??0DynImport@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0DynImport@IronMan@@QEAA@XZ PROC			; IronMan::DynImport::DynImport, COMDAT

; 219  : 		DynImport() = default;

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >::unordered_map<unsigned __int64,IronMan::import,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,IronMan::import> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::CriticalSection
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0DynImport@IronMan@@QEAA@XZ ENDP			; IronMan::DynImport::DynImport
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::DynImport'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$unordered_map@_KUimport@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@4@V?$allocator@U?$pair@$$CB_KUimport@IronMan@@@std@@@4@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::DynImport'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::DynImport::DynImport'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1CriticalSection@IronMan@@QEAA@XZ	; IronMan::CriticalSection::~CriticalSection
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0DynImport@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::DynImport::DynImport'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\DynImport.hpp
;	COMDAT ?Instance@DynImport@IronMan@@SAAEAV12@XZ
_TEXT	SEGMENT
?Instance@DynImport@IronMan@@SAAEAV12@XZ PROC		; IronMan::DynImport::Instance, COMDAT

; 214  : 		{

$LN5:
	sub	rsp, 40					; 00000028H

; 215  : 			static DynImport instance;

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA, eax ; `IronMan::DynImport::Instance'::`2'::$TSS0
	jle	SHORT $LN2@Instance
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA, -1 ; `IronMan::DynImport::Instance'::`2'::$TSS0
	jne	SHORT $LN2@Instance
	lea	rcx, OFFSET FLAT:?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance
	call	??0DynImport@IronMan@@QEAA@XZ		; IronMan::DynImport::DynImport
	lea	rcx, OFFSET FLAT:??__Finstance@?1??Instance@DynImport@IronMan@@SAAEAV12@XZ@YAXXZ ; `IronMan::DynImport::Instance'::`2'::`dynamic atexit destructor for 'instance''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
	call	_Init_thread_footer
	npad	1
$LN2@Instance:

; 216  : 			return instance;

	lea	rax, OFFSET FLAT:?instance@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4V23@A ; `IronMan::DynImport::Instance'::`2'::instance

; 217  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?Instance@DynImport@IronMan@@SAAEAV12@XZ ENDP		; IronMan::DynImport::Instance
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA PROC ; `IronMan::DynImport::Instance'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DynImport@IronMan@@SAAEAV23@XZ@4HA ; `IronMan::DynImport::Instance'::`2'::$TSS0
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Instance@DynImport@IronMan@@SAAEAV12@XZ@4HA ENDP ; `IronMan::DynImport::Instance'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
this$ = 8
?ProtectProcess@DriverControl@Core@IronMan@@QEAAJXZ PROC ; IronMan::Core::DriverControl::ProtectProcess

; 17   : 	{

	mov	QWORD PTR [rsp+8], rcx

; 18   : 		// Not loaded
; 19   : 		if (!NT_SUCCESS(_loadStatus))

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jge	SHORT $LN2@ProtectPro

; 20   : 			return STATUS_DEVICE_DOES_NOT_EXIST;

	mov	eax, -1073741632			; ffffffffc00000c0H
$LN2@ProtectPro:

; 21   : 
; 22   : 		/*DWORD bytes = 0;
; 23   : 		PROTECT_PROCESS pProcess = { 0 };
; 24   : 		pProcess.OperationId = EASYSUPPORT_PROTECTPROCESS;
; 25   : 		pProcess.ProcessId = GetCurrentProcessId();
; 26   : 
; 27   : 		return NotifyRegistry(&pProcess, sizeof(pProcess));*/
; 28   : 	}

	ret	0
?ProtectProcess@DriverControl@Core@IronMan@@QEAAJXZ ENDP ; IronMan::Core::DriverControl::ProtectProcess
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
bytes$ = 32
this$ = 64
pid$ = 72
base$ = 80
size$ = 88
buffer$ = 96
?ReadMem@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z PROC ; IronMan::Core::DriverControl::ReadMem

; 32   : 	{

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 33   : 		if (!base) return STATUS_DEVICE_DOES_NOT_EXIST;

	cmp	QWORD PTR base$[rsp], 0
	jne	SHORT $LN2@ReadMem
	mov	eax, -1073741632			; ffffffffc00000c0H
	jmp	SHORT $LN1@ReadMem
$LN2@ReadMem:

; 34   : 		if (buffer) RtlZeroMemory(buffer, size);

	cmp	QWORD PTR buffer$[rsp], 0
	je	SHORT $LN3@ReadMem
	mov	r8, QWORD PTR size$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset
	npad	1
$LN3@ReadMem:

; 35   : 
; 36   : 		// Not loaded
; 37   : 		if (!NT_SUCCESS(_loadStatus))

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jge	SHORT $LN4@ReadMem

; 38   : 			return STATUS_DEVICE_DOES_NOT_EXIST;

	mov	eax, -1073741632			; ffffffffc00000c0H
	jmp	SHORT $LN1@ReadMem
$LN4@ReadMem:

; 39   : 
; 40   : 
; 41   : 		DWORD bytes = 0;

	mov	DWORD PTR bytes$[rsp], 0
$LN1@ReadMem:

; 42   : 		//COPY_MEMORY copyMem = { 0 };
; 43   : 		//copyMem.OperationId = EASYSUPPORT_COPY_MEMORY;
; 44   : 		/*copyMem.pid = pid ^ 0x5007;
; 45   : 		copyMem.targetPtr = base ^ 0xFF50071234;
; 46   : 		copyMem.localbuf = (ULONGLONG)buffer ^ 0xFF12345007;
; 47   : 		copyMem.size = (ULONG)size ^ 0x5007;
; 48   : 		copyMem.write = FALSE;
; 49   : 
; 50   : 		return NotifyRegistry(&copyMem, sizeof(copyMem));*/
; 51   : 	}

	add	rsp, 56					; 00000038H
	ret	0
?ReadMem@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z ENDP ; IronMan::Core::DriverControl::ReadMem
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
status$ = 64
tv92 = 68
$T1 = 72
$T2 = 76
$T3 = 80
tv74 = 88
$T4 = 96
$T5 = 104
$T6 = 112
tv90 = 120
sign$ = 128
$T7 = 144
$T8 = 176
__$ArrayPad$ = 208
this$ = 240
lpBuffer$ = 248
length$ = 256
Reg$ = 264
?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z PROC ; IronMan::Core::DriverControl::NotifyRegistry

; 9    : 	{

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 10   : 		UNICODE_STRING sign;
; 11   : 		SAFE_CALL(RtlInitUnicodeString, &sign, L"...");

	call	?Instance@DynImport@IronMan@@SAAEAV12@XZ ; IronMan::DynImport::Instance
	mov	QWORD PTR tv74[rsp], rax
	lea	rax, QWORD PTR sign$[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_0BF@EKFKPNAI@RtlInitUnicodeString@
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r9, OFFSET FLAT:??_C@_17LGKOMLJ@?$AA?4?$AA?4?$AA?4@
	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z ; IronMan::DynImport::safeCall<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *),_UNICODE_STRING *,wchar_t const (&)[4]>
	npad	1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 12   : 		NTSTATUS status = SAFE_NATIVE_CALL(NtSetValueKey, (HANDLE)0x55667788, (PUNICODE_STRING)&sign, (ULONG)0, (ULONG)REG_BINARY, (PVOID)lpBuffer, (ULONG)length);

	call	?Instance@DynImport@IronMan@@SAAEAV12@XZ ; IronMan::DynImport::Instance
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR lpBuffer$[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	DWORD PTR $T1[rsp], 3
	mov	DWORD PTR $T2[rsp], 0
	lea	rax, QWORD PTR sign$[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	QWORD PTR $T6[rsp], 1432778632		; 55667788H
	lea	rdx, OFFSET FLAT:??_C@_0O@OMDJGLHA@NtSetValueKey@
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, QWORD PTR length$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T5[rsp]
	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXAEAK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK31AEAK@Z ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long &>
	mov	DWORD PTR status$[rsp], eax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 13   : 		return status == STATUS_BAD_DATA ? STATUS_SUCCESS : status;

	cmp	DWORD PTR status$[rsp], -1073739509	; ffffffffc000090bH
	jne	SHORT $LN3@NotifyRegi
	mov	DWORD PTR tv92[rsp], 0
	jmp	SHORT $LN4@NotifyRegi
$LN3@NotifyRegi:
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR tv92[rsp], eax
$LN4@NotifyRegi:
	mov	eax, DWORD PTR tv92[rsp]

; 14   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	ret	0
?NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z ENDP ; IronMan::Core::DriverControl::NotifyRegistry
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
status$ = 64
tv92 = 68
$T1 = 72
$T2 = 76
$T3 = 80
tv74 = 88
$T4 = 96
$T5 = 104
$T6 = 112
tv90 = 120
sign$ = 128
$T7 = 144
$T8 = 176
__$ArrayPad$ = 208
this$ = 240
lpBuffer$ = 248
length$ = 256
Reg$ = 264
?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA PROC ; `IronMan::Core::DriverControl::NotifyRegistry'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA ENDP ; `IronMan::Core::DriverControl::NotifyRegistry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
status$ = 64
tv92 = 68
$T1 = 72
$T2 = 76
$T3 = 80
tv74 = 88
$T4 = 96
$T5 = 104
$T6 = 112
tv90 = 120
sign$ = 128
$T7 = 144
$T8 = 176
__$ArrayPad$ = 208
this$ = 240
lpBuffer$ = 248
length$ = 256
Reg$ = 264
?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA PROC ; `IronMan::Core::DriverControl::NotifyRegistry'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??NotifyRegistry@DriverControl@Core@IronMan@@QEAAJPEBXK_N@Z@4HA ENDP ; `IronMan::Core::DriverControl::NotifyRegistry'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
this$ = 48
pid$ = 56
base$ = 64
size$ = 72
buffer$ = 80
?ReadMemCon@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z PROC ; IronMan::Core::DriverControl::ReadMemCon

; 88   : 	{

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 89   : 		if (!base) return STATUS_DEVICE_DOES_NOT_EXIST;

	cmp	QWORD PTR base$[rsp], 0
	jne	SHORT $LN2@ReadMemCon
	mov	eax, -1073741632			; ffffffffc00000c0H
	jmp	SHORT $LN1@ReadMemCon
$LN2@ReadMemCon:

; 90   : 		if (buffer) RtlZeroMemory(buffer, size);

	cmp	QWORD PTR buffer$[rsp], 0
	je	SHORT $LN3@ReadMemCon
	mov	r8, QWORD PTR size$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset
	npad	1
$LN3@ReadMemCon:

; 91   : 
; 92   : 		// Not loaded
; 93   : 		if (!NT_SUCCESS(_loadStatus))

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jge	SHORT $LN4@ReadMemCon

; 94   : 			return STATUS_DEVICE_DOES_NOT_EXIST;

	mov	eax, -1073741632			; ffffffffc00000c0H
$LN4@ReadMemCon:
$LN1@ReadMemCon:

; 95   : 
; 96   : 		//DWORD bytes = 0;
; 97   : 		//COPY_MEMORY copyMem = { 0 };
; 98   : 		//copyMem.OperationId = PROTO_READ;
; 99   : 		//copyMem.pid = pid;
; 100  : 		//copyMem.targetPtr = base;
; 101  : 		//copyMem.localbuf = (ULONGLONG)buffer;
; 102  : 		//copyMem.size = (ULONG)size;
; 103  : 		//copyMem.write = FALSE;
; 104  : 		//copyMem.mdl = FALSE;
; 105  : 
; 106  : 		//return NotifyRegistry(&copyMem, sizeof(copyMem));
; 107  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?ReadMemCon@DriverControl@Core@IronMan@@QEAAJK_K0PEAX@Z ENDP ; IronMan::Core::DriverControl::ReadMemCon
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
status$ = 64
tv182 = 68
$T1 = 72
$T2 = 76
$T3 = 80
$T4 = 84
$T5 = 88
$T6 = 92
$T7 = 96
$T8 = 104
$T9 = 112
tv79 = 120
tv74 = 128
tv185 = 136
$T10 = 144
tv140 = 152
$T11 = 160
$T12 = 168
$T13 = 176
tv157 = 184
tv152 = 192
tv189 = 200
tv179 = 208
sign$ = 216
$T14 = 232
$T15 = 256
$T16 = 272
$T17 = 304
$T18 = 336
$T19 = 368
$T20 = 400
__$ArrayPad$ = 432
this$ = 480
?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ PROC	; IronMan::Core::DriverControl::EnsureLoaded

; 73   : 	{

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 456				; 000001c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 74   : 		NTSTATUS status = SAFE_NATIVE_CALL(NtSetValueKey, (HANDLE)0x11223344, (PUNICODE_STRING)NULL, (ULONG)0, (ULONG)0, (PVOID)NULL, (ULONG)0);

	call	?Instance@DynImport@IronMan@@SAAEAV12@XZ ; IronMan::DynImport::Instance
	mov	QWORD PTR tv79[rsp], rax
	mov	DWORD PTR $T1[rsp], 0
	mov	QWORD PTR $T7[rsp], 0
	mov	DWORD PTR $T2[rsp], 0
	mov	DWORD PTR $T3[rsp], 0
	mov	QWORD PTR $T8[rsp], 0
	mov	QWORD PTR $T9[rsp], 287454020		; 11223344H
	lea	rdx, OFFSET FLAT:??_C@_0O@OMDJGLHA@NtSetValueKey@
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T8[rsp]
	lea	r8, QWORD PTR $T9[rsp]
	lea	rdx, QWORD PTR $T16[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long>
	mov	DWORD PTR status$[rsp], eax
	lea	rcx, QWORD PTR $T16[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 75   : 
; 76   : 		CONSOLE_INFO("EnsureLoaded:%08X NtSetValueKey1", status);

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	r8, OFFSET FLAT:??_C@_0CB@HDNGBLOB@EnsureLoaded?3?$CF08X?5NtSetValueKey@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T19[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv185[rsp], rax
	mov	rcx, QWORD PTR tv185[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	edx, DWORD PTR status$[rsp]
	mov	rcx, rax
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T19[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 77   : 
; 78   : 		UNICODE_STRING sign;
; 79   : 		SAFE_CALL(RtlInitUnicodeString, &sign, L"...");

	call	?Instance@DynImport@IronMan@@SAAEAV12@XZ ; IronMan::DynImport::Instance
	mov	QWORD PTR tv140[rsp], rax
	lea	rax, QWORD PTR sign$[rsp]
	mov	QWORD PTR $T10[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_0BF@EKFKPNAI@RtlInitUnicodeString@
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r9, OFFSET FLAT:??_C@_17LGKOMLJ@?$AA?4?$AA?4?$AA?4@
	lea	r8, QWORD PTR $T10[rsp]
	lea	rdx, QWORD PTR $T17[rsp]
	mov	rcx, QWORD PTR tv140[rsp]
	call	??$safeCall@P6AXPEAU_UNICODE_STRING@@PEB_W@ZPEAU1@AEAY03$$CB_W@DynImport@IronMan@@QEAA?A_PAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAU_UNICODE_STRING@@AEAY03$$CB_W@Z ; IronMan::DynImport::safeCall<void (__cdecl*)(_UNICODE_STRING *,wchar_t const *),_UNICODE_STRING *,wchar_t const (&)[4]>
	npad	1
	lea	rcx, QWORD PTR $T17[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 80   : 
; 81   : 		if (NT_SUCCESS(status))

	cmp	DWORD PTR status$[rsp], 0
	jl	$LN2@EnsureLoad

; 82   : 			status = SAFE_NATIVE_CALL(NtSetValueKey, (HANDLE)0x55667788, (PUNICODE_STRING)&sign, (ULONG)0, (ULONG)REG_BINARY, (PVOID)NULL, (ULONG)0);

	call	?Instance@DynImport@IronMan@@SAAEAV12@XZ ; IronMan::DynImport::Instance
	mov	QWORD PTR tv157[rsp], rax
	mov	DWORD PTR $T4[rsp], 0
	mov	QWORD PTR $T11[rsp], 0
	mov	DWORD PTR $T5[rsp], 3
	mov	DWORD PTR $T6[rsp], 0
	lea	rax, QWORD PTR sign$[rsp]
	mov	QWORD PTR $T12[rsp], rax
	mov	QWORD PTR $T13[rsp], 1432778632		; 55667788H
	lea	rdx, OFFSET FLAT:??_C@_0O@OMDJGLHA@NtSetValueKey@
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR $T11[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T12[rsp]
	lea	r8, QWORD PTR $T13[rsp]
	lea	rdx, QWORD PTR $T18[rsp]
	mov	rcx, QWORD PTR tv157[rsp]
	call	??$safeNativeCall@P6AJPEAXPEAU_UNICODE_STRING@@KK0K@ZPEAXPEAU1@KKPEAXK@DynImport@IronMan@@QEAAJAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QEAPEAX$$QEAPEAU_UNICODE_STRING@@$$QEAK313@Z ; IronMan::DynImport::safeNativeCall<long (__cdecl*)(void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long),void *,_UNICODE_STRING *,unsigned long,unsigned long,void *,unsigned long>
	mov	DWORD PTR status$[rsp], eax
	lea	rcx, QWORD PTR $T18[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN2@EnsureLoad:

; 83   : 		CONSOLE_INFO("EnsureLoaded:%08X NtSetValueKey2   :%wZ", status, sign);

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	rax, QWORD PTR $T14[rsp]
	lea	rcx, QWORD PTR sign$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	r8, OFFSET FLAT:??_C@_0CI@NGIEIMGJ@EnsureLoaded?3?$CF08X?5NtSetValueKey@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T20[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv152[rsp], rax
	mov	rax, QWORD PTR tv152[rsp]
	mov	QWORD PTR tv189[rsp], rax
	mov	rcx, QWORD PTR tv189[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv179[rsp], rax
	lea	rax, QWORD PTR $T15[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	r8, QWORD PTR $T15[rsp]
	mov	edx, DWORD PTR status$[rsp]
	mov	rcx, QWORD PTR tv179[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T20[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 84   : 		return status == STATUS_NO_KEY ? (_loadStatus = STATUS_SUCCESS) : status;

	cmp	DWORD PTR status$[rsp], -1073739508	; ffffffffc000090cH
	jne	SHORT $LN4@EnsureLoad
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0
	mov	DWORD PTR tv182[rsp], 0
	jmp	SHORT $LN5@EnsureLoad
$LN4@EnsureLoad:
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR tv182[rsp], eax
$LN5@EnsureLoad:
	mov	eax, DWORD PTR tv182[rsp]

; 85   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 456				; 000001c8H
	pop	rdi
	pop	rsi
	ret	0
?EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ ENDP	; IronMan::Core::DriverControl::EnsureLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
status$ = 64
tv182 = 68
$T1 = 72
$T2 = 76
$T3 = 80
$T4 = 84
$T5 = 88
$T6 = 92
$T7 = 96
$T8 = 104
$T9 = 112
tv79 = 120
tv74 = 128
tv185 = 136
$T10 = 144
tv140 = 152
$T11 = 160
$T12 = 168
$T13 = 176
tv157 = 184
tv152 = 192
tv189 = 200
tv179 = 208
sign$ = 216
$T14 = 232
$T15 = 256
$T16 = 272
$T17 = 304
$T18 = 336
$T19 = 368
$T20 = 400
__$ArrayPad$ = 432
this$ = 480
?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA PROC ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T16[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA ENDP ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
status$ = 64
tv182 = 68
$T1 = 72
$T2 = 76
$T3 = 80
$T4 = 84
$T5 = 88
$T6 = 92
$T7 = 96
$T8 = 104
$T9 = 112
tv79 = 120
tv74 = 128
tv185 = 136
$T10 = 144
tv140 = 152
$T11 = 160
$T12 = 168
$T13 = 176
tv157 = 184
tv152 = 192
tv189 = 200
tv179 = 208
sign$ = 216
$T14 = 232
$T15 = 256
$T16 = 272
$T17 = 304
$T18 = 336
$T19 = 368
$T20 = 400
__$ArrayPad$ = 432
this$ = 480
?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA PROC ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T19[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA ENDP ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
status$ = 64
tv182 = 68
$T1 = 72
$T2 = 76
$T3 = 80
$T4 = 84
$T5 = 88
$T6 = 92
$T7 = 96
$T8 = 104
$T9 = 112
tv79 = 120
tv74 = 128
tv185 = 136
$T10 = 144
tv140 = 152
$T11 = 160
$T12 = 168
$T13 = 176
tv157 = 184
tv152 = 192
tv189 = 200
tv179 = 208
sign$ = 216
$T14 = 232
$T15 = 256
$T16 = 272
$T17 = 304
$T18 = 336
$T19 = 368
$T20 = 400
__$ArrayPad$ = 432
this$ = 480
?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA PROC ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T17[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA ENDP ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
status$ = 64
tv182 = 68
$T1 = 72
$T2 = 76
$T3 = 80
$T4 = 84
$T5 = 88
$T6 = 92
$T7 = 96
$T8 = 104
$T9 = 112
tv79 = 120
tv74 = 128
tv185 = 136
$T10 = 144
tv140 = 152
$T11 = 160
$T12 = 168
$T13 = 176
tv157 = 184
tv152 = 192
tv189 = 200
tv179 = 208
sign$ = 216
$T14 = 232
$T15 = 256
$T16 = 272
$T17 = 304
$T18 = 336
$T19 = 368
$T20 = 400
__$ArrayPad$ = 432
this$ = 480
?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA PROC ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T18[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA ENDP ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
status$ = 64
tv182 = 68
$T1 = 72
$T2 = 76
$T3 = 80
$T4 = 84
$T5 = 88
$T6 = 92
$T7 = 96
$T8 = 104
$T9 = 112
tv79 = 120
tv74 = 128
tv185 = 136
$T10 = 144
tv140 = 152
$T11 = 160
$T12 = 168
$T13 = 176
tv157 = 184
tv152 = 192
tv189 = 200
tv179 = 208
sign$ = 216
$T14 = 232
$T15 = 256
$T16 = 272
$T17 = 304
$T18 = 336
$T19 = 368
$T20 = 400
__$ArrayPad$ = 432
this$ = 480
?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA PROC ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T20[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??EnsureLoaded@DriverControl@Core@IronMan@@QEAAJXZ@4HA ENDP ; `IronMan::Core::DriverControl::EnsureLoaded'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ PROC	; IronMan::Core::DriverControl::Instance

; 63   : 	{

$LN5:
	sub	rsp, 40					; 00000028H

; 64   : 		static DriverControl instance;

	mov	eax, OFFSET FLAT:_Init_thread_epoch
	mov	eax, eax
	mov	ecx, DWORD PTR _tls_index
	mov	rdx, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	eax, DWORD PTR [rax+rcx]
	cmp	DWORD PTR ?$TSS0@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4HA, eax
	jle	SHORT $LN2@Instance
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4HA
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4HA, -1
	jne	SHORT $LN2@Instance
	lea	rcx, OFFSET FLAT:?instance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4V234@A
	call	??0DriverControl@Core@IronMan@@QEAA@XZ	; IronMan::Core::DriverControl::DriverControl
	lea	rcx, OFFSET FLAT:??__Finstance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@YAXXZ ; `IronMan::Core::DriverControl::Instance'::`2'::`dynamic atexit destructor for 'instance''
	call	atexit
	npad	1
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4HA
	call	_Init_thread_footer
	npad	1
$LN2@Instance:

; 65   : 		return instance;

	lea	rax, OFFSET FLAT:?instance@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4V234@A

; 66   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ ENDP	; IronMan::Core::DriverControl::Instance
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA PROC ; `IronMan::Core::DriverControl::Instance'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?$TSS0@?1??Instance@DriverControl@Core@IronMan@@SAAEAV234@XZ@4HA
	call	_Init_thread_abort
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Instance@DriverControl@Core@IronMan@@SAAEAV123@XZ@4HA ENDP ; `IronMan::Core::DriverControl::Instance'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
this$ = 8
??1DriverControl@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::DriverControl::~DriverControl

; 59   : 	{

	mov	QWORD PTR [rsp+8], rcx

; 60   : 	}

	ret	0
??1DriverControl@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::DriverControl::~DriverControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DriverControl.cpp
; File D:\c++\paoda\Core\DriverControl.h
; File D:\c++\paoda\Core\DriverControl.cpp
_TEXT	SEGMENT
this$ = 8
??0DriverControl@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::DriverControl::DriverControl

; 54   : 	{

	mov	QWORD PTR [rsp+8], rcx
; File D:\c++\paoda\Core\DriverControl.h

; 42   : 		DWORD	 _localPid = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 43   : 	private:
; 44   : 		DriverControl(const DriverControl&) = delete;
; 45   : 		DriverControl& operator = (const DriverControl&) = delete;
; 46   : 	private:
; 47   : 		NTSTATUS _loadStatus = STATUS_NOT_FOUND;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], -1073741275		; ffffffffc0000225H
; File D:\c++\paoda\Core\DriverControl.cpp

; 56   : 	}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0DriverControl@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::DriverControl::DriverControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??1CSLock@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CSLock@IronMan@@QEAA@XZ PROC				; IronMan::CSLock::~CSLock, COMDAT

; 297  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 298  : 			_cs.unlock();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?unlock@CriticalSection@IronMan@@QEAAXXZ ; IronMan::CriticalSection::unlock
	npad	1

; 299  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??1CSLock@IronMan@@QEAA@XZ ENDP				; IronMan::CSLock::~CSLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z
_TEXT	SEGMENT
this$ = 48
cs$ = 56
??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z PROC	; IronMan::CSLock::CSLock, COMDAT

; 292  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 291  : 			: _cs(cs)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cs$[rsp]
	mov	QWORD PTR [rax], rcx

; 293  : 			cs.lock();

	mov	rcx, QWORD PTR cs$[rsp]
	call	?lock@CriticalSection@IronMan@@QEAAXXZ	; IronMan::CriticalSection::lock
	npad	1

; 294  : 		}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0CSLock@IronMan@@QEAA@AEAVCriticalSection@1@@Z ENDP	; IronMan::CSLock::CSLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ?unlock@CriticalSection@IronMan@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?unlock@CriticalSection@IronMan@@QEAAXXZ PROC		; IronMan::CriticalSection::unlock, COMDAT

; 276  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 277  : 			LeaveCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1

; 278  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?unlock@CriticalSection@IronMan@@QEAAXXZ ENDP		; IronMan::CriticalSection::unlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ?lock@CriticalSection@IronMan@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?lock@CriticalSection@IronMan@@QEAAXXZ PROC		; IronMan::CriticalSection::lock, COMDAT

; 271  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 272  : 			EnterCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_EnterCriticalSection
	npad	1

; 273  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?lock@CriticalSection@IronMan@@QEAAXXZ ENDP		; IronMan::CriticalSection::lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??1CriticalSection@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CriticalSection@IronMan@@QEAA@XZ PROC		; IronMan::CriticalSection::~CriticalSection, COMDAT

; 266  : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 267  : 			DeleteCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_DeleteCriticalSection
	npad	1

; 268  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??1CriticalSection@IronMan@@QEAA@XZ ENDP		; IronMan::CriticalSection::~CriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\Misc\Utils.hpp
;	COMDAT ??0CriticalSection@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0CriticalSection@IronMan@@QEAA@XZ PROC		; IronMan::CriticalSection::CriticalSection, COMDAT

; 260  : 		CriticalSection()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 261  : 		{
; 262  : 			InitializeCriticalSection(&_native);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_InitializeCriticalSection
	npad	1

; 263  : 		}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0CriticalSection@IronMan@@QEAA@XZ ENDP		; IronMan::CriticalSection::CriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?hash_@@YA?B_KPEBD@Z
_TEXT	SEGMENT
ret$ = 0
str$ = 32
?hash_@@YA?B_KPEBD@Z PROC				; hash_, COMDAT

; 203  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 204  : 	hash_t ret{ basis };

	mov	rax, -3750763034361777355		; cbf29ce484333335H
	mov	QWORD PTR ret$[rsp], rax
$LN2@hash_:

; 205  : 
; 206  : 	while (*str) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@hash_

; 207  : 		ret ^= *str;

	mov	rax, QWORD PTR str$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR ret$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 208  : 		ret *= prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR ret$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 209  : 		str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 210  : 	}

	jmp	SHORT $LN2@hash_
$LN3@hash_:

; 211  : 
; 212  : 	return ret;

	mov	rax, QWORD PTR ret$[rsp]

; 213  : }

	add	rsp, 24
	ret	0
?hash_@@YA?B_KPEBD@Z ENDP				; hash_
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3074 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3075 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3076 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2941 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2944 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2948 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2952 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2349 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2350 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2351 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2352 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2353 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2354 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2355 :         );
; 2356 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 746  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 511  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 512  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 513  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1187 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 417  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 418  :         // find length of null-terminated string
; 419  : #if _HAS_CXX17
; 420  : #ifdef __cpp_char8_t
; 421  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 422  : #if _HAS_U8_INTRINSICS
; 423  :             return __builtin_u8strlen(_First);
; 424  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 425  :             return _Primary_char_traits::length(_First);
; 426  : #endif // ^^^ no u8 intrinsics ^^^
; 427  :         } else
; 428  : #endif // defined(__cpp_char8_t)
; 429  :         {
; 430  :             return __builtin_strlen(_First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	mov	QWORD PTR tv68[rsp], -1
$LL3@length:
	inc	QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR tv67[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL3@length
	mov	rax, QWORD PTR tv68[rsp]

; 431  :         }
; 432  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 434  : #endif // ^^^ !_HAS_CXX17 ^^^
; 435  :     }

	add	rsp, 24
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 87   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 88   :                 _First1[_Idx] = _First2[_Idx];
; 89   :             }
; 90   : 
; 91   :             return _First1;
; 92   :         }
; 93   : #endif // _HAS_CXX20
; 94   : 
; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 96   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 97   : 
; 98   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 99   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_Val$ = 32
_First$ = 40
_Count$ = 48
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2290 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2291 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@Fnv1a_appe
$LN2@Fnv1a_appe:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@Fnv1a_appe:
	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Idx$1[rsp], rax
	jae	SHORT $LN3@Fnv1a_appe

; 2292 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Val$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2293 :         _Val *= _FNV_prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR _Val$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2294 :     }

	jmp	SHORT $LN2@Fnv1a_appe
$LN3@Fnv1a_appe:

; 2295 : 
; 2296 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]

; 2297 : }

	add	rsp, 24
	ret	0
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
