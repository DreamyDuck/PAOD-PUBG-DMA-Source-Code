; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	?m_Instance@Package@Core@IronMan@@0PEAV123@EA	; IronMan::Core::Package::m_Instance
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
_BSS	SEGMENT
?m_Instance@Package@Core@IronMan@@0PEAV123@EA DQ 01H DUP (?) ; IronMan::Core::Package::m_Instance
_BSS	ENDS
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z	; std::_Narrow_char_traits<char,int>::eq
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z	; std::_Narrow_char_traits<char,int>::not_eof
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??0exception@std@@QEAA@QEBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	RtlSecureZeroMemory
PUBLIC	?hash_@@YA?B_KPEBD@Z				; hash_
PUBLIC	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UEAA@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QEAA@AEBV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UEAAPEAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?iostream_category@std@@YAAEBVerror_category@1@XZ ; std::iostream_category
PUBLIC	??1error_category@std@@UEAA@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QEBA_NAEBV01@@Z		; std::error_category::operator==
PUBLIC	??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
PUBLIC	??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_code::error_code
PUBLIC	?value@error_code@std@@QEBAHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QEBAHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NAEBVerror_condition@0@0@Z		; std::operator==
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UEAA@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QEAA@AEBV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UEAAPEAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QEAA@Verror_code@1@PEBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UEAA@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QEAA@AEBV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UEAAPEAXI@Z		; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UEBAPEBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??1_Iostream_error_category2@std@@UEAA@XZ	; std::_Iostream_error_category2::~_Iostream_error_category2
PUBLIC	??_G_Iostream_error_category2@std@@UEAAPEAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??1_Facet_base@std@@UEAA@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QEAA@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UEAAPEAXI@Z		; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QEAA@PEBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QEAA@XZ			; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	??0?$_Yarn@D@std@@QEAA@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QEAA@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QEBAPEBDXZ		; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AEAAXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QEAA@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QEAA@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AEAAXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	?_Incref@facet@locale@std@@UEAAXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IEAA@_K@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MEAA@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MEAAPEAXI@Z		; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QEAA@AEBV01@@Z			; std::locale::locale
PUBLIC	??0locale@std@@QEAA@XZ				; std::locale::locale
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	?_C_str@locale@std@@QEBAPEBDXZ			; std::locale::_C_str
PUBLIC	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z	; std::locale::_Getfacet
PUBLIC	??_Glocale@std@@QEAAPEAXI@Z			; std::locale::`scalar deleting destructor'
PUBLIC	??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??0ctype_base@std@@QEAA@_K@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UEAA@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UEAAPEAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?is@?$ctype@D@std@@QEBA_NFD@Z			; std::ctype<char>::is
PUBLIC	?widen@?$ctype@D@std@@QEBADD@Z			; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z	; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MEAA@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IEAAXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MEBADD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MEBADD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MEBADD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MEBADDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MEAAPEAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ; std::_Adl_verify_range<char *,char const *>
PUBLIC	??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UEAA@XZ		; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QEAA@AEBV012@@Z	; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UEAAPEAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QEAAXH_N@Z			; std::ios_base::clear
PUBLIC	?clear@ios_base@std@@QEAAXH@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QEBAHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QEBA_NXZ			; std::ios_base::good
PUBLIC	?fail@ios_base@std@@QEBA_NXZ			; std::ios_base::fail
PUBLIC	?flags@ios_base@std@@QEBAHXZ			; std::ios_base::flags
PUBLIC	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ	; std::ios_base::getloc
PUBLIC	?swap@ios_base@std@@QEAAXAEAV12@@Z		; std::ios_base::swap
PUBLIC	??1ios_base@std@@UEAA@XZ			; std::ios_base::~ios_base
PUBLIC	??0ios_base@std@@IEAA@XZ			; std::ios_base::ios_base
PUBLIC	?_Init@ios_base@std@@IEAAXXZ			; std::ios_base::_Init
PUBLIC	??_Gios_base@std@@UEAAPEAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	??$addressof@Vios_base@std@@@std@@YAPEAVios_base@0@AEAV10@@Z ; std::addressof<std::ios_base>
PUBLIC	??$swap@H$0A@@std@@YAXAEAH0@Z			; std::swap<int,0>
PUBLIC	??$swap@_J$0A@@std@@YAXAEA_J0@Z			; std::swap<__int64,0>
PUBLIC	??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z ; std::swap<std::ios_base::_Iosarray *,0>
PUBLIC	??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z ; std::swap<std::ios_base::_Fnarray *,0>
PUBLIC	??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z ; std::swap<std::locale *,0>
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z ; std::basic_ios<char,std::char_traits<char> >::swap
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
PUBLIC	?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::swap
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::read
PUBLIC	?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg
PUBLIC	??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z ; std::basic_streambuf<char,std::char_traits<char> >::swap
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sgetn
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pbase
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
PUBLIC	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
PUBLIC	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_no_alias
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ	; IronMan::Core::Package::GetPackage
PUBLIC	??1Package@Core@IronMan@@QEAA@XZ		; IronMan::Core::Package::~Package
PUBLIC	?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; IronMan::Core::Package::Load
PUBLIC	?FindFileEntryHash@Package@Core@IronMan@@QEAAPEAUFileEntryHash@123@_K@Z ; IronMan::Core::Package::FindFileEntryHash
PUBLIC	?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z ; IronMan::Core::Package::FindFile
PUBLIC	?Release@Package@Core@IronMan@@QEAAXXZ		; IronMan::Core::Package::Release
PUBLIC	??0Package@Core@IronMan@@AEAA@XZ		; IronMan::Core::Package::Package
PUBLIC	??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_G?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	??0?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAA@XZ ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocator<IronMan::Core::Package::FileEntryHash>
PUBLIC	?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z ; std::allocator<IronMan::Core::Package::FileEntryHash>::deallocate
PUBLIC	?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size
PUBLIC	??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
PUBLIC	??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::~vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
PUBLIC	?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::push_back
PUBLIC	?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::clear
PUBLIC	?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_end
PUBLIC	?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size
PUBLIC	?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::capacity
PUBLIC	?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Change_array
PUBLIC	?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Tidy
PUBLIC	?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAXPEAUFileEntryHash@Package@Core@IronMan@@0@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
PUBLIC	?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first
PUBLIC	??_GPackage@Core@IronMan@@QEAAPEAXI@Z		; IronMan::Core::Package::`scalar deleting destructor'
PUBLIC	??$_Unfancy_maybe_null@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ; std::_Unfancy_maybe_null<IronMan::Core::Package::FileEntryHash>
PUBLIC	??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >
PUBLIC	??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_one_at_back<IronMan::Core::Package::FileEntryHash const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1><>
PUBLIC	??$addressof@V?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$move@AEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z		; std::max<char *>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z ; std::exchange<char *,std::nullptr_t>
PUBLIC	??$exchange@HH@std@@YAHAEAH$$QEAH@Z		; std::exchange<int,int>
PUBLIC	??$swap@D$0A@@std@@YAXAEAD0@Z			; std::swap<char,0>
PUBLIC	??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z ; std::swap<std::basic_ostream<char,std::char_traits<char> > *,0>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$addressof@V?$basic_streambuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_streambuf<char,std::char_traits<char> > >
PUBLIC	??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ	; std::locale::id::_Get_index<0>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$move@AEAH@std@@YA$$QEAHAEAH@Z		; std::move<int &>
PUBLIC	??$move@AEA_J@std@@YA$$QEA_JAEA_J@Z		; std::move<__int64 &>
PUBLIC	??$move@AEAPEAU_Iosarray@ios_base@std@@@std@@YA$$QEAPEAU_Iosarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Iosarray * &>
PUBLIC	??$move@AEAPEAU_Fnarray@ios_base@std@@@std@@YA$$QEAPEAU_Fnarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Fnarray * &>
PUBLIC	??$move@AEAPEAVlocale@std@@@std@@YA$$QEAPEAVlocale@0@AEAPEAV10@@Z ; std::move<std::locale * &>
PUBLIC	??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back_with_unused_capacity<IronMan::Core::Package::FileEntryHash const &>
PUBLIC	??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_reallocate<IronMan::Core::Package::FileEntryHash const &>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$move@AEAD@std@@YA$$QEADAEAD@Z		; std::move<char &>
PUBLIC	??$move@AEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAPEAV10@@Z ; std::move<std::basic_ostream<char,std::char_traits<char> > * &>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::_Construct_in_place<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<IronMan::Core::Package::FileEntryHash> >
PUBLIC	??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Unfancy@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Core::Package::FileEntryHash>
PUBLIC	??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>
PUBLIC	??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z		; std::_Get_size_of_n<24>
PUBLIC	??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$addressof@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ; std::addressof<IronMan::Core::Package::FileEntryHash>
PUBLIC	??$_Get_unwrapped@AEBQEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_TAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Core::Package::FileEntryHash * const &>
PUBLIC	??$move@AEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ; std::move<IronMan::Core::Package::FileEntryHash &>
PUBLIC	??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z ; std::_Copy_memmove<IronMan::Core::Package::FileEntryHash *,IronMan::Core::Package::FileEntryHash *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@PEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::~_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Release
PUBLIC	??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back<IronMan::Core::Package::FileEntryHash>
PUBLIC	??$_To_address@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_PAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_To_address<IronMan::Core::Package::FileEntryHash *>
PUBLIC	??$move@AEAPEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAPEAUFileEntryHash@Package@Core@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Core::Package::FileEntryHash * &>
PUBLIC	??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z ; std::_Copy_memmove_tail<IronMan::Core::Package::FileEntryHash *>
PUBLIC	??$forward@UFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash>
PUBLIC	??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash>
PUBLIC	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	_TI5?AVfailure@ios_base@std@@
PUBLIC	_CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_8?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_03HHGDFOHI@PAK@				; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	_purecall:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	atexit:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	??0_Lockit@std@@QEAA@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QEAA@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	strcmp:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xruntime_error@std@@YAXPEBD@Z:PROC		; std::_Xruntime_error
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UEAAPEAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UEAAPEAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UEAAPEAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPEBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Iostream_error_category2@std@@UEAAPEAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UEAAPEAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_Getctype:PROC
EXTRN	_Tolower:PROC
EXTRN	_Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPEAV12@PEBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPEAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MEAAPEAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPEAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UEAAPEAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MEAAPEAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UEAAPEAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Addstd@ios_base@std@@SAXPEAV12@@Z:PROC	; std::ios_base::_Addstd
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UEAAPEAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	??_E?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:QWORD		; std::ctype<char>::id
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+73
	DD	imagerel $unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+411
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+252
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_cast@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_cast@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_cast@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_cast@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlSecureZeroMemory DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$RtlSecureZeroMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hash_@@YA?B_KPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+107
	DD	imagerel $unwind$?hash_@@YA?B_KPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1runtime_error@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1runtime_error@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gruntime_error@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gruntime_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?iostream_category@std@@YAAEBVerror_category@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?iostream_category@std@@YAAEBVerror_category@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8error_category@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$??8error_category@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+110
	DD	imagerel $unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA DD imagerel ?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
	DD	imagerel ?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8std@@YA_NAEBVerror_condition@0@0@Z DD imagerel $LN5
	DD	imagerel $LN5+126
	DD	imagerel $unwind$??8std@@YA_NAEBVerror_condition@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD imagerel $LN8
	DD	imagerel $LN8+228
	DD	imagerel $unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD imagerel ?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD imagerel ?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DD	imagerel ?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD imagerel ?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DD	imagerel ?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA+41
	DD	imagerel $unwind$?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+291
	DD	imagerel $unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_System_error@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1_System_error@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$??0_System_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G_System_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA DD imagerel ?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA DD imagerel ?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
	DD	imagerel ?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1system_error@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1system_error@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0system_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gsystem_error@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gsystem_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA DD imagerel ?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA
	DD	imagerel ?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Iostream_error_category2@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1_Iostream_error_category2@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Iostream_error_category2@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G_Iostream_error_category2@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Facet_base@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G_Facet_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Locinfo@std@@QEAA@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+194
	DD	imagerel $unwind$??0_Locinfo@std@@QEAA@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Locinfo@std@@QEAA@XZ DD imagerel $LN10
	DD	imagerel $LN10+147
	DD	imagerel $unwind$??1_Locinfo@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA DD imagerel ?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA DD imagerel ?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA DD imagerel ?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA DD imagerel ?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Yarn@D@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Yarn@D@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$_Yarn@D@std@@QEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?c_str@?$_Yarn@D@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Yarn@D@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?_Tidy@?$_Yarn@D@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Yarn@_W@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Yarn@_W@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0facet@locale@std@@IEAA@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??0facet@locale@std@@IEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA DD imagerel ?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1facet@locale@std@@MEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$??1facet@locale@std@@MEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA DD imagerel ?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gfacet@locale@std@@MEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gfacet@locale@std@@MEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0locale@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0locale@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0locale@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$??0locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+109
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_C_str@locale@std@@QEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?_C_str@locale@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Glocale@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Glocale@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ctype_base@std@@QEAA@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0ctype_base@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA DD imagerel ?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ctype_base@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$??1ctype_base@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gctype_base@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gctype_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is@?$ctype@D@std@@QEBA_NFD@Z DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$?is@?$ctype@D@std@@QEBA_NFD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?widen@?$ctype@D@std@@QEBADD@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?widen@?$ctype@D@std@@QEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD imagerel ?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD imagerel $LN10
	DD	imagerel $LN10+243
	DD	imagerel $unwind$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ctype@D@std@@MEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??1?$ctype@D@std@@MEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$ctype@D@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+93
	DD	imagerel $unwind$?_Tidy@?$ctype@D@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_tolower@?$ctype@D@std@@MEBADD@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?do_tolower@?$ctype@D@std@@MEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_toupper@?$ctype@D@std@@MEBADD@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?do_toupper@?$ctype@D@std@@MEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$ctype@D@std@@MEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$ctype@D@std@@MEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD imagerel $LN11
	DD	imagerel $LN11+258
	DD	imagerel $unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA DD imagerel ?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA
	DD	imagerel ?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1failure@ios_base@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1failure@ios_base@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0failure@ios_base@std@@QEAA@AEBV012@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0failure@ios_base@std@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA DD imagerel ?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA
	DD	imagerel ?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gfailure@ios_base@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gfailure@ios_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@ios_base@std@@QEAAXH_N@Z DD imagerel $LN9
	DD	imagerel $LN9+230
	DD	imagerel $unwind$?clear@ios_base@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@ios_base@std@@QEAAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?clear@ios_base@std@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?good@ios_base@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?good@ios_base@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fail@ios_base@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?fail@ios_base@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA DD imagerel ?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA
	DD	imagerel ?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@ios_base@std@@QEAAXAEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+249
	DD	imagerel $unwind$?swap@ios_base@std@@QEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ios_base@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??1ios_base@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@ios_base@std@@IEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+192
	DD	imagerel $unwind$?_Init@ios_base@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gios_base@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gios_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@H$0A@@std@@YAXAEAH0@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$swap@H$0A@@std@@YAXAEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@_J$0A@@std@@YAXAEA_J0@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$swap@_J$0A@@std@@YAXAEA_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+101
	DD	imagerel $unwind$?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA DD imagerel ?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA
	DD	imagerel ?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD imagerel $LN6
	DD	imagerel $LN6+221
	DD	imagerel $unwind$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA+42
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z DD imagerel $LN20
	DD	imagerel $LN20+618
	DD	imagerel $unwind$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA DD imagerel ?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA
	DD	imagerel ?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA DD imagerel ?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA
	DD	imagerel ?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA+76
	DD	imagerel $unwind$?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z DD imagerel $LN12
	DD	imagerel $LN12+269
	DD	imagerel $unwind$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA DD imagerel ?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA
	DD	imagerel ?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA DD imagerel ?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA
	DD	imagerel ?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA+70
	DD	imagerel $unwind$?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z DD imagerel $LN12
	DD	imagerel $LN12+389
	DD	imagerel $unwind$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA DD imagerel ?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA
	DD	imagerel ?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA DD imagerel ?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA
	DD	imagerel ?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA+76
	DD	imagerel $unwind$?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+262
	DD	imagerel $unwind$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+413
	DD	imagerel $unwind$?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD imagerel $LN5
	DD	imagerel $LN5+77
	DD	imagerel $unwind$?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD imagerel $LN5
	DD	imagerel $LN5+77
	DD	imagerel $unwind$?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD imagerel $LN7
	DD	imagerel $LN7+134
	DD	imagerel $unwind$?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+156
	DD	imagerel $unwind$?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN9
	DD	imagerel $LN9+286
	DD	imagerel $unwind$?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD imagerel $LN10
	DD	imagerel $LN10+309
	DD	imagerel $unwind$?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+187
	DD	imagerel $unwind$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA DD imagerel ?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
	DD	imagerel ?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA+27
	DD	imagerel $unwind$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DD imagerel $LN13
	DD	imagerel $LN13+189
	DD	imagerel $unwind$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD imagerel ?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
	DD	imagerel ?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD imagerel ?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
	DD	imagerel ?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA+70
	DD	imagerel $unwind$?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN4
	DD	imagerel $LN4+146
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+113
	DD	imagerel $unwind$?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN16
	DD	imagerel $LN16+755
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+238
	DD	imagerel $unwind$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ DD imagerel $LN8
	DD	imagerel $LN8+266
	DD	imagerel $unwind$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN31
	DD	imagerel $LN31+925
	DD	imagerel $unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN18
	DD	imagerel $LN18+600
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z DD imagerel $LN11
	DD	imagerel $LN11+379
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+229
	DD	imagerel $unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ DD imagerel $LN7
	DD	imagerel $LN7+97
	DD	imagerel $unwind$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA DD imagerel ?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1Package@Core@IronMan@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+110
	DD	imagerel $unwind$??1Package@Core@IronMan@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN22
	DD	imagerel $LN22+1346
	DD	imagerel $unwind$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$pdata$?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$pdata$?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?FindFileEntryHash@Package@Core@IronMan@@QEAAPEAUFileEntryHash@123@_K@Z DD imagerel $LN8
	DD	imagerel $LN8+145
	DD	imagerel $unwind$?FindFileEntryHash@Package@Core@IronMan@@QEAAPEAUFileEntryHash@123@_K@Z
$pdata$?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z DD imagerel $LN10
	DD	imagerel $LN10+336
	DD	imagerel $unwind$?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z
$pdata$?Release@Package@Core@IronMan@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$?Release@Package@Core@IronMan@@QEAAXXZ
$pdata$??0Package@Core@IronMan@@AEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+131
	DD	imagerel $unwind$??0Package@Core@IronMan@@AEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA DD imagerel ?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA
$pdata$?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA DD imagerel ?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+218
	DD	imagerel $unwind$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+45
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN8
	DD	imagerel $LN8+239
	DD	imagerel $unwind$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA+45
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD imagerel ?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD imagerel ?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DD	imagerel ?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+101
	DD	imagerel $unwind$??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+138
	DD	imagerel $unwind$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA+35
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA+35
	DD	imagerel $unwind$?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$??_G?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+254
	DD	imagerel $unwind$?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+211
	DD	imagerel $unwind$?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GPackage@Core@IronMan@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GPackage@Core@IronMan@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z DD imagerel $LN4
	DD	imagerel $LN4+135
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+210
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+81
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD imagerel $LN3
	DD	imagerel $LN3+130
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+450
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+388
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+354
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@HH@std@@YAHAEAH$$QEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$exchange@HH@std@@YAHAEAH$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@D$0A@@std@@YAXAEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$swap@D$0A@@std@@YAXAEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ DD imagerel $LN6
	DD	imagerel $LN6+97
	DD	imagerel $unwind$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA DD imagerel ?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA
	DD	imagerel ?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z DD imagerel $LN3
	DD	imagerel $LN3+151
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z DD imagerel $LN8
	DD	imagerel $LN8+665
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA DD imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+234
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z DD imagerel $LN3
	DD	imagerel $LN3+159
	DD	imagerel $unwind$??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD imagerel ??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@system_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 01H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVfailure@ios_base@std@@@8
	DD	imagerel ??_R3failure@ios_base@std@@8
	DD	imagerel ??_R4failure@ios_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD imagerel ??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD imagerel ??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ctype_base@std@@8
	DD	imagerel ??_R1A@?0A@EA@facet@locale@std@@8
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	imagerel ??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 01H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$ctype@D@std@@@8
	DD	imagerel ??_R3?$ctype@D@std@@8
	DD	imagerel ??_R4?$ctype@D@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD imagerel ??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD imagerel ??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@facet@locale@std@@8
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	imagerel ??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 01H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AUctype_base@std@@@8
	DD	imagerel ??_R3ctype_base@std@@8
	DD	imagerel ??_R4ctype_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD imagerel ??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD imagerel ??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@_Crt_new_delete@std@@8 DD imagerel ??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD imagerel ??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD imagerel ??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	imagerel ??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 01H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVfacet@locale@std@@@8
	DD	imagerel ??_R3facet@locale@std@@8
	DD	imagerel ??_R4facet@locale@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD imagerel ??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD imagerel ??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 01H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Facet_base@std@@@8
	DD	imagerel ??_R3_Facet_base@std@@8
	DD	imagerel ??_R4_Facet_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD imagerel ??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD imagerel ??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 01H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Iostream_error_category2@std@@@8
	DD	imagerel ??_R3_Iostream_error_category2@std@@8
	DD	imagerel ??_R4_Iostream_error_category2@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD imagerel ??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD imagerel ??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 01H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	imagerel ??_R3system_error@std@@8
	DD	imagerel ??_R4system_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD imagerel ??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 01H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	imagerel ??_R3_System_error@std@@8
	DD	imagerel ??_R4_System_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD imagerel ??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD imagerel ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD imagerel ??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD imagerel ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 01H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	imagerel ??_R3runtime_error@std@@8
	DD	imagerel ??_R4runtime_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istringstream@DU?$char_traits@D@std@@V?$allo'
	DB	'cator@D@2@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	090H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$rs	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 01H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVios_base@std@@@8
	DD	imagerel ??_R3ios_base@std@@8
	DD	imagerel ??_R4ios_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DQ FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DQ	0000000000000005H
_DATA	ENDS
;	COMDAT ??_C@_03HHGDFOHI@PAK@
CONST	SEGMENT
??_C@_03HHGDFOHI@PAK@ DB 'PAK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
CONST	SEGMENT
??_8?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ DD 00H ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	090H
CONST	ENDS
;	COMDAT ??_7?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT _CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40
xdata$x	SEGMENT
_CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40 DD 00H
	DD	imagerel ??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0failure@ios_base@std@@QEAA@AEBV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT _CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
_CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	imagerel _CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40
	DD	imagerel _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
_TI5?AVfailure@ios_base@std@@ DD 00H
	DD	imagerel ??1failure@ios_base@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DQ FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DQ	FLAT:??_Eios_base@std@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DQ FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DQ	FLAT:??_Efailure@ios_base@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DQ FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DQ	FLAT:??_E?$ctype@D@std@@MEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
	DQ	FLAT:?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
	DQ	FLAT:?do_tolower@?$ctype@D@std@@MEBADD@Z
	DQ	FLAT:?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
	DQ	FLAT:?do_toupper@?$ctype@D@std@@MEBADD@Z
	DQ	FLAT:?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z
	DQ	FLAT:?do_widen@?$ctype@D@std@@MEBADD@Z
	DQ	FLAT:?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z
	DQ	FLAT:?do_narrow@?$ctype@D@std@@MEBADDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DQ FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DQ	FLAT:??_Ectype_base@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DQ FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DQ	FLAT:??_Efacet@locale@std@@MEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DQ FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DQ	FLAT:??_E_Facet_base@std@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DQ FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DQ	FLAT:??_E_Iostream_error_category2@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_Iostream_error_category2@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0_System_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0system_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DQ FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DQ	FLAT:??_Esystem_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DQ FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DQ	FLAT:??_E_System_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0runtime_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DQ FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DQ	FLAT:??_Eruntime_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z DD 031001H
	DD	0700c6210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z DB 06H
	DB	00H
	DB	00H
	DB	0f1H, 04H
	DB	02H
	DB	01H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z DD 021611H
	DD	0190116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ DB 06H
	DB	00H
	DB	00H
	DB	'B'
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ DB 08H
	DD	imagerel $stateUnwindMap$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ
	DD	imagerel $ip2state$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@D$0A@@std@@YAXAEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@HH@std@@YAHAEAH$$QEAH@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 08H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	imagerel $ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'p'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010911H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	0a9H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GPackage@Core@IronMan@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	0beH
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
	DD	imagerel $ip2state$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'`'
	DB	04H
	DB	0d6H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
	DD	imagerel $ip2state$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 011811H
	DD	06218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	'~'
	DB	02H
	DB	'`'
	DB	04H
	DB	0c2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010d11H
	DD	0620dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01bH
	DD	052aH
voltbl	ENDS
xdata	SEGMENT
$unwind$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ DD 010411H
	DD	08204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ
$cppxdata$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ
	DD	imagerel $ip2state$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ
$stateUnwindMap$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA
$ip2state$?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ DB 06H
	DB	00H
	DB	00H
	DB	':'
	DB	02H
	DB	'X'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA DD 020601H
	DD	050023206H
$unwind$??1Package@Core@IronMan@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Package@Core@IronMan@@QEAA@XZ
$cppxdata$??1Package@Core@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1Package@Core@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1Package@Core@IronMan@@QEAA@XZ
$stateUnwindMap$??1Package@Core@IronMan@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA
$ip2state$??1Package@Core@IronMan@@QEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	012H
	DB	04H
	DB	't'
	DB	02H
	DB	'('
	DB	00H
	ORG $+3
$unwind$?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 022319H
	DD	0570111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	02a2H
$cppxdata$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DD	imagerel $stateUnwindMap$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
$stateUnwindMap$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
$ip2state$?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB '*'
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'\'
	DB	00H
	DB	'.'
	DB	02H
	DB	09cH
	DB	00H
	DB	'.'
	DB	02H
	DB	0e6H
	DB	00H
	DB	'.'
	DB	02H
	DB	'`'
	DB	00H
	DB	'.'
	DB	02H
	DB	'D'
	DB	04H
	DB	'`'
	DB	06H
	DB	'4'
	DB	04H
	DB	09H, 03H
	DB	02H
	DB	01cH
	DB	00H
	DB	'.'
	DB	04H
	DB	0c9H, 07H
	DB	02H
	DB	01cH
	DB	00H
	DB	'('
	DB	04H
	DB	0aH
	DB	02H
	DB	01cH
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?FindFileEntryHash@Package@Core@IronMan@@QEAAPEAUFileEntryHash@123@_K@Z DD 010e01H
	DD	0820eH
$unwind$?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z DD 011301H
	DD	0a213H
$unwind$?Release@Package@Core@IronMan@@QEAAXXZ DD 010901H
	DD	06209H
$unwind$??0Package@Core@IronMan@@AEAA@XZ DD 020a11H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Package@Core@IronMan@@AEAA@XZ
$cppxdata$??0Package@Core@IronMan@@AEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0Package@Core@IronMan@@AEAA@XZ
	DD	imagerel $ip2state$??0Package@Core@IronMan@@AEAA@XZ
$stateUnwindMap$??0Package@Core@IronMan@@AEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA
$ip2state$??0Package@Core@IronMan@@AEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	082H
	DB	02H
	DB	'V'
	DB	04H
	DB	018H
	DB	00H
	ORG $+3
$unwind$?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 021001H
	DD	0110110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'0'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
	DD	imagerel $ip2state$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	0d4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 06H
	DB	00H
	DB	00H
	DB	'0'
	DB	02H
	DB	'~'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 0aH
	DB	00H
	DB	00H
	DB	08aH
	DB	02H
	DB	'2'
	DB	04H
	DB	'4'
	DB	02H
	DB	'`'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 02H
	DB	00H
	DD	imagerel ?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 018H
	DD	imagerel $stateUnwindMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	DD	imagerel $tryMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	DD	imagerel $ip2state$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA DB 02H
	DB	00H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA DB 049H
	DD	imagerel $stateUnwindMap$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
	DD	imagerel $ip2state$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
	DB	'p'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	0adH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DD	imagerel ?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 058H
	DD	imagerel $stateUnwindMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	imagerel $tryMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	imagerel $ip2state$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA DD 020a01H
	DD	05006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z DB 0aH
	DB	00H
	DB	00H
	DB	'U', 02H
	DB	02H
	DB	'X'
	DB	04H
	DB	0d4H
	DB	02H
	DB	086H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z DB 02H
	DB	00H
	DD	imagerel ?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z DB 018H
	DD	imagerel $stateUnwindMap$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
	DD	imagerel $tryMap$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
	DD	imagerel $ip2state$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z DD 021619H
	DD	0130116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z DB 0aH
	DB	00H
	DB	00H
	DB	'v'
	DB	02H
	DB	'8'
	DB	04H
	DB	0d0H
	DB	02H
	DB	't'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z DB 02H
	DB	00H
	DD	imagerel ?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z DB 018H
	DD	imagerel $stateUnwindMap$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
	DD	imagerel $tryMap$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
	DD	imagerel $ip2state$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z DD 011319H
	DD	0c213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z DB 0aH
	DB	00H
	DB	00H
	DB	0e5H, 04H
	DB	02H
	DB	01eH
	DB	00H
	DB	016H
	DB	04H
	DB	0a9H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z DB 02H
	DB	00H
	DD	imagerel ?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA
	DB	030H
	DB	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z DB 018H
	DD	imagerel $stateUnwindMap$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
	DD	imagerel $tryMap$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
	DD	imagerel $ip2state$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z DD 021019H
	DD	0110110H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DB 06H
	DB	00H
	DB	00H
	DB	090H
	DB	02H
	DB	'-', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	imagerel $ip2state$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 011811H
	DD	06218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'('
	DB	02H
	DB	'd'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	DD	imagerel $ip2state$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DB 06H
	DB	00H
	DB	00H
	DB	'V'
	DB	02H
	DB	'D'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DB 08H
	DD	imagerel $stateUnwindMap$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	DD	imagerel $ip2state$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DD 010d11H
	DD	0a20dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	imagerel $ip2state$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@_J$0A@@std@@YAXAEA_J0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@H$0A@@std@@YAXAEAH0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gios_base@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@ios_base@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ios_base@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ios_base@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1ios_base@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ios_base@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ios_base@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@ios_base@std@@QEAAXAEAV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ DB 04H
	DB	00H
	DB	00H
	DB	'T'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ DB 048H
	DD	imagerel $stateUnwindMap$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
	DD	imagerel $ip2state$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fail@ios_base@std@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?good@ios_base@std@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@ios_base@std@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@ios_base@std@@QEAAXH_N@Z DD 011201H
	DD	0e212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gfailure@ios_base@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0failure@ios_base@std@@QEAA@AEBV012@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0failure@ios_base@std@@QEAA@AEBV012@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0failure@ios_base@std@@QEAA@AEBV012@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0failure@ios_base@std@@QEAA@AEBV012@@Z
	DD	imagerel $ip2state$??0failure@ios_base@std@@QEAA@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0failure@ios_base@std@@QEAA@AEBV012@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0failure@ios_base@std@@QEAA@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1failure@ios_base@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1failure@ios_base@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1failure@ios_base@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1failure@ios_base@std@@UEAA@XZ
	DD	imagerel $ip2state$??1failure@ios_base@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1failure@ios_base@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1failure@ios_base@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z DB 06H
	DB	00H
	DB	00H
	DB	'|'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z
	DD	imagerel $ip2state$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z DD 031511H
	DD	070116215H
	DD	06010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DB 0aH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	'!', 02H
	DB	04H
	DB	'v'
	DB	02H
	DB	'*'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 010911H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$ctype@D@std@@MEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_toupper@?$ctype@D@std@@MEBADD@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_tolower@?$ctype@D@std@@MEBADD@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$ctype@D@std@@IEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$ctype@D@std@@IEAAXXZ DB 040H
	DD	imagerel $ip2state$?_Tidy@?$ctype@D@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$ctype@D@std@@IEAAXXZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$ctype@D@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z DD 031001H
	DD	0700c8210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ctype@D@std@@MEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'0'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$ctype@D@std@@MEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ctype@D@std@@MEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$ctype@D@std@@MEAA@XZ
	DD	imagerel $ip2state$??1?$ctype@D@std@@MEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ctype@D@std@@MEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ctype@D@std@@MEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 0eH
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	'b'
	DB	04H
	DB	'\'
	DB	02H
	DB	012H
	DB	04H
	DB	014H
	DB	06H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 08H
	DD	imagerel $stateUnwindMap$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
	DD	imagerel $ip2state$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD 021111H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
	DD	imagerel $ip2state$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DD 011311H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?widen@?$ctype@D@std@@QEBADD@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is@?$ctype@D@std@@QEBA_NFD@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gctype_base@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ctype_base@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ctype_base@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ctype_base@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1ctype_base@std@@UEAA@XZ
	DD	imagerel $ip2state$??1ctype_base@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ctype_base@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ctype_base@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ctype_base@std@@QEAA@_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ctype_base@std@@QEAA@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ctype_base@std@@QEAA@_K@Z DB 048H
	DD	imagerel $stateUnwindMap$??0ctype_base@std@@QEAA@_K@Z
	DD	imagerel $ip2state$??0ctype_base@std@@QEAA@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ctype_base@std@@QEAA@_K@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ctype_base@std@@QEAA@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Glocale@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_C_str@locale@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0locale@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0locale@std@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??0locale@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0locale@std@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0locale@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0locale@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gfacet@locale@std@@MEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1facet@locale@std@@MEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1facet@locale@std@@MEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1facet@locale@std@@MEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1facet@locale@std@@MEAA@XZ
	DD	imagerel $ip2state$??1facet@locale@std@@MEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1facet@locale@std@@MEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1facet@locale@std@@MEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0facet@locale@std@@IEAA@_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0facet@locale@std@@IEAA@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0facet@locale@std@@IEAA@_K@Z DB 048H
	DD	imagerel $stateUnwindMap$??0facet@locale@std@@IEAA@_K@Z
	DD	imagerel $ip2state$??0facet@locale@std@@IEAA@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0facet@locale@std@@IEAA@_K@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0facet@locale@std@@IEAA@_K@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	013H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ DB 040H
	DD	imagerel $ip2state$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Yarn@_W@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$_Yarn@D@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$_Yarn@D@std@@AEAAXXZ DB 040H
	DD	imagerel $ip2state$?_Tidy@?$_Yarn@D@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Yarn@D@std@@AEAAXXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$_Yarn@D@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$_Yarn@D@std@@QEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Yarn@D@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ DD 031001H
	DD	0700c8210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Locinfo@std@@QEAA@XZ DB 012H
	DB	00H
	DB	00H
	DB	012H
	DB	0eH
	DB	016H
	DB	0cH
	DB	'$'
	DB	0aH
	DB	'$'
	DB	08H
	DB	'$'
	DB	06H
	DB	'$'
	DB	04H
	DB	'$'
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1_Locinfo@std@@QEAA@XZ DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Locinfo@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1_Locinfo@std@@QEAA@XZ
	DD	imagerel $ip2state$??1_Locinfo@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Locinfo@std@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Locinfo@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_Locinfo@std@@QEAA@PEBD@Z DB 012H
	DB	00H
	DB	00H
	DB	'J'
	DB	02H
	DB	'$'
	DB	04H
	DB	'$'
	DB	06H
	DB	'$'
	DB	08H
	DB	'$'
	DB	0aH
	DB	'$'
	DB	0cH
	DB	'$'
	DB	0eH
	DB	'N'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_Locinfo@std@@QEAA@PEBD@Z DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_Locinfo@std@@QEAA@PEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0_Locinfo@std@@QEAA@PEBD@Z
	DD	imagerel $ip2state$??0_Locinfo@std@@QEAA@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Locinfo@std@@QEAA@PEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_Locinfo@std@@QEAA@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Facet_base@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Iostream_error_category2@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Iostream_error_category2@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1_Iostream_error_category2@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Iostream_error_category2@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1_Iostream_error_category2@std@@UEAA@XZ
	DD	imagerel $ip2state$??1_Iostream_error_category2@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Iostream_error_category2@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Iostream_error_category2@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 08H
	DB	00H
	DB	00H
	DB	086H
	DB	02H
	DB	'('
	DB	00H
	DB	'.'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 08H
	DD	imagerel $stateUnwindMap$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	imagerel $ip2state$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gsystem_error@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0system_error@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0system_error@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0system_error@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0system_error@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0system_error@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0system_error@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1system_error@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1system_error@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1system_error@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1system_error@std@@UEAA@XZ
	DD	imagerel $ip2state$??1system_error@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1system_error@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1system_error@std@@UEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	08bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DB 08H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	'^'
	DB	06H
	DB	':'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
	DD	imagerel $ip2state$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DD 032419H
	DD	07011c215H
	DD	06010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_System_error@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'@'
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_System_error@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_System_error@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0_System_error@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0_System_error@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@QEAA@AEBV01@@Z DD 031011H
	DD	0700c4210H
	DD	0600bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_System_error@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_System_error@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1_System_error@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_System_error@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1_System_error@std@@UEAA@XZ
	DD	imagerel $ip2state$??1_System_error@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_System_error@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_System_error@std@@UEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	0109H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 0cH
	DB	00H
	DB	00H
	DB	0aaH
	DB	02H
	DB	'p'
	DB	00H
	DB	'L'
	DB	04H
	DB	'&'
	DB	08H
	DB	'v'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DB	086H
	DD	imagerel ?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 042a19H
	DD	0190118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	0b2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01dH
	DB	0d1H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'T'
	DB	04H
	DB	094H
	DB	06H
	DB	':'
	DB	04H
	DB	'V'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 08H
	DD	imagerel $stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	imagerel $ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 012219H
	DD	0e213H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8std@@YA_NAEBVerror_condition@0@0@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 04H
	DB	00H
	DB	00H
	DB	0b0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DB 08H
	DD	imagerel $stateUnwindMap$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	imagerel $ip2state$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8error_category@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?iostream_category@std@@YAAEBVerror_category@1@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gruntime_error@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0runtime_error@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0runtime_error@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0runtime_error@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0runtime_error@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0runtime_error@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0runtime_error@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1runtime_error@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1runtime_error@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1runtime_error@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1runtime_error@std@@UEAA@XZ
	DD	imagerel $ip2state$??1runtime_error@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1runtime_error@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1runtime_error@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hash_@@YA?B_KPEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlSecureZeroMemory DD 020f01H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_cast@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_cast@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_cast@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_cast@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_cast@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_cast@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_cast@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_cast@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_cast@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_cast@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_cast@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_cast@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_cast@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_cast@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_cast@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'B'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_cast@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_cast@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_cast@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_cast@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_cast@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 040H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	09aH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	'*'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a4H
	DB	02H
	DB	'j'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@QEBD@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@QEBD@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBD@Z DD 020f19H
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z DD 010801H
	DD	06208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z DD 010c01H
	DD	0220cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD 010c01H
	DD	0220cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
	movsxd	rax, DWORD PTR [rcx-4]
	sub	rcx, rax
	jmp	??_E?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
??_E?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
	movsxd	rax, DWORD PTR [rcx-4]
	sub	rcx, rax
	jmp	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@UFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash>
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 24
	rep movsb

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@UFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z PROC ; std::forward<IronMan::Core::Package::FileEntryHash>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@UFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ENDP ; std::forward<IronMan::Core::Package::FileEntryHash>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z
_TEXT	SEGMENT
_Dest_ch$ = 32
_Dest_ptr$ = 40
_First_ch$ = 64
_Dest$ = 72
_Byte_count$ = 80
_Object_count$ = 88
??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z PROC ; std::_Copy_memmove_tail<IronMan::Core::Package::FileEntryHash *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_PAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_To_address<IronMan::Core::Package::FileEntryHash *>
	mov	QWORD PTR _Dest_ptr$[rsp], rax

; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));

	mov	rax, QWORD PTR _Dest_ptr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	call	memmove
	npad	1

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

	mov	rax, QWORD PTR _Byte_count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z ENDP ; std::_Copy_memmove_tail<IronMan::Core::Package::FileEntryHash *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAPEAUFileEntryHash@Package@Core@IronMan@@AEAPEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAPEAUFileEntryHash@Package@Core@IronMan@@AEAPEAU1234@@Z PROC ; std::move<IronMan::Core::Package::FileEntryHash * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAPEAUFileEntryHash@Package@Core@IronMan@@AEAPEAU1234@@Z ENDP ; std::move<IronMan::Core::Package::FileEntryHash * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_To_address@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_PAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_PAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z PROC ; std::_To_address<IronMan::Core::Package::FileEntryHash *>, COMDAT

; 4641 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4642 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4643 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4644 : }

	ret	0
??$_To_address@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_PAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ENDP ; std::_To_address<IronMan::Core::Package::FileEntryHash *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
tv74 = 48
this$ = 80
<_Vals_0>$ = 88
??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back<IronMan::Core::Package::FileEntryHash>, COMDAT

; 1806 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@UFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Core::Package::FileEntryHash>
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$construct@UFileEntryHash@Package@Core@IronMan@@U1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@$$QEAU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash>

; 1808 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 24
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1809 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back<IronMan::Core::Package::FileEntryHash>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Release, COMDAT

; 1811 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1812 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1813 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1814 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::~_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 1801 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >
	npad	1

; 1803 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::~_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@PEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@PEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@PEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z
_TEXT	SEGMENT
_First_ptr$ = 32
_Last_ptr$ = 40
_First_ch$ = 48
_Last_ch$ = 56
_Object_count$ = 64
_Byte_count$ = 72
_First$ = 96
_Last$ = 104
_Dest$ = 112
??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z PROC ; std::_Copy_memmove<IronMan::Core::Package::FileEntryHash *,IronMan::Core::Package::FileEntryHash *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_PAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_To_address<IronMan::Core::Package::FileEntryHash *>
	mov	QWORD PTR _First_ptr$[rsp], rax

; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_PAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_To_address<IronMan::Core::Package::FileEntryHash *>
	mov	QWORD PTR _Last_ptr$[rsp], rax

; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	rcx, QWORD PTR _Last_ptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	mov	QWORD PTR _Object_count$[rsp], rax

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));

	mov	rax, QWORD PTR _First_ptr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));

	mov	rax, QWORD PTR _Last_ptr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Byte_count$[rsp], rax

; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$move@AEAPEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAPEAUFileEntryHash@Package@Core@IronMan@@AEAPEAU1234@@Z ; std::move<IronMan::Core::Package::FileEntryHash * &>
	mov	r9, QWORD PTR _Object_count$[rsp]
	mov	r8, QWORD PTR _Byte_count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _First_ch$[rsp]
	call	??$_Copy_memmove_tail@PEAUFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEBDQEAU1234@_K2@Z ; std::_Copy_memmove_tail<IronMan::Core::Package::FileEntryHash *>

; 4787 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z ENDP ; std::_Copy_memmove<IronMan::Core::Package::FileEntryHash *,IronMan::Core::Package::FileEntryHash *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z PROC ; std::move<IronMan::Core::Package::FileEntryHash &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ENDP ; std::move<IronMan::Core::Package::FileEntryHash &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_TAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_TAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z PROC ; std::_Get_unwrapped<IronMan::Core::Package::FileEntryHash * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_TAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ENDP ; std::_Get_unwrapped<IronMan::Core::Package::FileEntryHash * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z PROC ; std::addressof<IronMan::Core::Package::FileEntryHash>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ENDP ; std::addressof<IronMan::Core::Package::FileEntryHash>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<24>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 24
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z PROC ; std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_TAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Core::Package::FileEntryHash * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAUFileEntryHash@Package@Core@IronMan@@@std@@YA?A_TAEBQEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_Get_unwrapped<IronMan::Core::Package::FileEntryHash * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Core::Package::FileEntryHash>
	mov	r8, rax
	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove@PEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@00@Z ; std::_Copy_memmove<IronMan::Core::Package::FileEntryHash *,IronMan::Core::Package::FileEntryHash *>

; 1956 :             return _Dest + (_ULast - _UFirst);

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	imul	rax, rax, 24
	mov	rcx, QWORD PTR _Dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Uninitiali

; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@PEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 24
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAUFileEntryHash@Package@Core@IronMan@@@std@@YA$$QEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ; std::move<IronMan::Core::Package::FileEntryHash &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@UFileEntryHash@Package@Core@IronMan@@@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAX$$QEAUFileEntryHash@Package@Core@IronMan@@@Z ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back<IronMan::Core::Package::FileEntryHash>
	npad	1

; 1963 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1964 : 
; 1965 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::~_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1966 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ENDP ; std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >::~_Uninitialized_backout_al<std::allocator<IronMan::Core::Package::FileEntryHash> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash const &>
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 24
	rep movsb

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z PROC ; std::_Unfancy<IronMan::Core::Package::FileEntryHash>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ENDP ; std::_Unfancy<IronMan::Core::Package::FileEntryHash>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv79 = 32
this$ = 64
??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :             if (_New_begin != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >

; 608  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z ; std::allocator<IronMan::Core::Package::FileEntryHash>::deallocate
	npad	1
$LN2@Reallocati:

; 609  :             }
; 610  :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 80
<_Args_0>$ = 88
??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z PROC ; std::_Construct_in_place<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAU1234@@Z ; std::addressof<IronMan::Core::Package::FileEntryHash>
	mov	rdx, rax
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash const &>
	mov	rdi, QWORD PTR $T1[rsp]
	mov	rsi, rax
	mov	ecx, 24
	rep movsb

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ENDP ; std::_Construct_in_place<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ; std::forward<std::_Facet_base * &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 123  : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAPEAV10@@Z PROC ; std::move<std::basic_ostream<char,std::char_traits<char> > * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAPEAV10@@Z ENDP ; std::move<std::basic_ostream<char,std::char_traits<char> > * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAD@std@@YA$$QEADAEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAD@std@@YA$$QEADAEAD@Z PROC			; std::move<char &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAD@std@@YA$$QEADAEAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 32
_Al$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 802  : 
; 803  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 804  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 805  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 806  :         } else {
; 807  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 808  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 809  :         }
; 810  : 
; 811  : #if _HAS_CXX20
; 812  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 813  :         // but likely more impactful to throughput.
; 814  :         if (_STD is_constant_evaluated()) {
; 815  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 816  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 817  :                 _STD construct_at(_Ptr + _Idx);
; 818  :             }
; 819  :         }
; 820  : #endif // _HAS_CXX20
; 821  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 822  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 823  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_reallocate<IronMan::Core::Package::FileEntryHash const &>, COMDAT

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 863  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 864  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 865  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	mov	QWORD PTR _Whereoff$[rsp], rax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	mov	QWORD PTR _Oldsize$[rsp], rax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 873  :             _Xlength();

	call	?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Xlength
	npad	1
$LN2@Emplace_re:

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 877  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 878  : 
; 879  :         const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);

	lea	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<IronMan::Core::Package::FileEntryHash> >
	mov	QWORD PTR _Newvec$[rsp], rax

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rax, QWORD PTR _Whereoff$[rsp], 24
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

	mov	rax, QWORD PTR _Al$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax
	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Guard$[rsp+8], rax
	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	QWORD PTR _Guard$[rsp+16], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+24], rax
	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Guard$[rsp+32], rax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;

	lea	rax, QWORD PTR _Guard$[rsp+24]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash const &>
	mov	QWORD PTR tv132[rsp], rax
	imul	rax, QWORD PTR _Whereoff$[rsp], 24
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Unfancy@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ; std::_Unfancy<IronMan::Core::Package::FileEntryHash>
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SAXAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@1@QEAUFileEntryHash@Package@Core@IronMan@@AEBU3456@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::construct<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>

; 886  :         _Constructed_first = _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 24
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Constructed_first$[rsp]
	mov	QWORD PTR [rcx], rax

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >
	npad	1

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

	jmp	SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >

; 896  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Constructed_first$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	imul	rax, QWORD PTR _Whereoff$[rsp], 24
	mov	rcx, QWORD PTR _Newvec$[rsp]
	lea	rax, QWORD PTR [rcx+rax+24]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAUFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@0PEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Uninitialized_move<IronMan::Core::Package::FileEntryHash *,std::allocator<IronMan::Core::Package::FileEntryHash> >
	npad	1
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

	mov	QWORD PTR _Guard$[rsp+8], 0

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Change_array
	npad	1

; 902  :         return _Newvec + _Whereoff;

	imul	rax, QWORD PTR _Whereoff$[rsp], 24
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Reallocation_guard::~_Reallocation_guard
	mov	rax, QWORD PTR $T1[rsp]

; 903  :     }

	add	rsp, 200				; 000000c8H
	ret	0
$LN7@Emplace_re:
??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_reallocate<IronMan::Core::Package::FileEntryHash const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Newcapacity$ = 72
_My_data$ = 80
_Oldsize$ = 88
_Constructed_last$ = 96
_Constructed_first$ = 104
_Newsize$ = 112
tv132 = 120
tv130 = 128
$T1 = 136
_Guard$ = 144
this$ = 208
_Whereptr$ = 216
<_Val_0>$ = 224
?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA PROC ; `std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_reallocate<IronMan::Core::Package::FileEntryHash const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Reallocation_guard@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Reallocation_guard::~_Reallocation_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z@4HA ENDP ; `std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_reallocate<IronMan::Core::Package::FileEntryHash const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
tv74 = 48
tv72 = 56
_Result$ = 64
this$ = 96
<_Val_0>$ = 104
??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back_with_unused_capacity<IronMan::Core::Package::FileEntryHash const &>, COMDAT

; 837  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 838  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 839  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 840  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 841  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 842  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 843  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 844  :             _ASAN_VECTOR_MODIFY(1);
; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash const &>
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR tv72[rsp]
	call	??$_Construct_in_place@UFileEntryHash@Package@Core@IronMan@@AEBU1234@@std@@YAXAEAUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::_Construct_in_place<IronMan::Core::Package::FileEntryHash,IronMan::Core::Package::FileEntryHash const &>
	npad	1

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAXPEAUFileEntryHash@Package@Core@IronMan@@0@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Orphan_range

; 853  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 854  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 24
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 855  : 
; 856  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 857  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back_with_unused_capacity<IronMan::Core::Package::FileEntryHash const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z PROC ; std::forward<IronMan::Core::Package::FileEntryHash const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ENDP ; std::forward<IronMan::Core::Package::FileEntryHash const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAVlocale@std@@@std@@YA$$QEAPEAVlocale@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVlocale@std@@@std@@YA$$QEAPEAVlocale@0@AEAPEAV10@@Z PROC ; std::move<std::locale * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAVlocale@std@@@std@@YA$$QEAPEAVlocale@0@AEAPEAV10@@Z ENDP ; std::move<std::locale * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAU_Fnarray@ios_base@std@@@std@@YA$$QEAPEAU_Fnarray@ios_base@0@AEAPEAU120@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAU_Fnarray@ios_base@std@@@std@@YA$$QEAPEAU_Fnarray@ios_base@0@AEAPEAU120@@Z PROC ; std::move<std::ios_base::_Fnarray * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAU_Fnarray@ios_base@std@@@std@@YA$$QEAPEAU_Fnarray@ios_base@0@AEAPEAU120@@Z ENDP ; std::move<std::ios_base::_Fnarray * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAPEAU_Iosarray@ios_base@std@@@std@@YA$$QEAPEAU_Iosarray@ios_base@0@AEAPEAU120@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAU_Iosarray@ios_base@std@@@std@@YA$$QEAPEAU_Iosarray@ios_base@0@AEAPEAU120@@Z PROC ; std::move<std::ios_base::_Iosarray * &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAPEAU_Iosarray@ios_base@std@@@std@@YA$$QEAPEAU_Iosarray@ios_base@0@AEAPEAU120@@Z ENDP ; std::move<std::ios_base::_Iosarray * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEA_J@std@@YA$$QEA_JAEA_J@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEA_J@std@@YA$$QEA_JAEA_J@Z PROC		; std::move<__int64 &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEA_J@std@@YA$$QEA_JAEA_J@Z ENDP		; std::move<__int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAH@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAH@std@@YA$$QEAHAEAH@Z PROC			; std::move<int &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAH@std@@YA$$QEAHAEAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Ptr$ = 72
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT

; 3352 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	lea	r8, QWORD PTR _Ptr$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT

; 3437 :     _CONSTEXPR23 pointer release() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3438 :         return _STD exchange(_Mypair._Myval2, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>

; 3439 :     }

	add	rsp, 56					; 00000038H
	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
tv75 = 32
tv77 = 40
this$ = 64
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT

; 3407 :     _CONSTEXPR23 ~unique_ptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3408 :         if (_Mypair._Myval2) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@unique_ptr

; 3409 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
	npad	1
$LN2@unique_ptr:

; 3410 :         }
; 3411 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv71 = 40
tv72 = 48
this$ = 80
_Ptr$ = 88
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT

; 3297 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3298 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3299 :         delete _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv71[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR tv71[rsp]
	mov	QWORD PTR tv72[rsp], rax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	QWORD PTR tv72[rsp], 0
$LN4@operator:

; 3300 :     }

	add	rsp, 72					; 00000048H
	ret	0
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ
_TEXT	SEGMENT
_Lock$1 = 32
this$ = 64
??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ PROC		; std::locale::id::_Get_index<0>, COMDAT

; 88   :         size_t _Get_index() { // get stamp, with lazy allocation

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 89   :             if (_Id == 0) { // still zero, allocate stamp

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN2@Get_index

; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 91   :                 if (_Id == 0) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN3@Get_index

; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	movsxd	rax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
$LN3@Get_index:

; 93   :                 }
; 94   :                 _END_LOCK()

	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	npad	1
$LN2@Get_index:

; 95   :             }
; 96   :             return _Id;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]

; 97   :         }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ ENDP		; std::locale::id::_Get_index<0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
this$ = 64
?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA PROC ; `std::locale::id::_Get_index<0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Lock$1[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Get_index@$0A@@id@locale@std@@QEAA_KXZ@4HA ENDP ; `std::locale::id::_Get_index<0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$basic_streambuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_streambuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_streambuf<char,std::char_traits<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$basic_streambuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_streambuf<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z PROC ; std::swap<std::basic_ostream<char,std::char_traits<char> > *,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAPEAV10@@Z ; std::move<std::basic_ostream<char,std::char_traits<char> > * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAPEAV10@@Z ; std::move<std::basic_ostream<char,std::char_traits<char> > * &>
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAPEAV10@@Z ; std::move<std::basic_ostream<char,std::char_traits<char> > * &>
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::swap<std::basic_ostream<char,std::char_traits<char> > *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@D$0A@@std@@YAXAEAD0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@D$0A@@std@@YAXAEAD0@Z PROC			; std::swap<char,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEAD@std@@YA$$QEADAEAD@Z	; std::move<char &>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR _Tmp$[rsp], al

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAD@std@@YA$$QEADAEAD@Z	; std::move<char &>
	mov	rcx, QWORD PTR _Left$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEAD@std@@YA$$QEADAEAD@Z	; std::move<char &>
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@D$0A@@std@@YAXAEAD0@Z ENDP			; std::swap<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@HH@std@@YAHAEAH$$QEAH@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@HH@std@@YAHAEAH$$QEAH@Z PROC		; std::exchange<int,int>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR _Old_val$[rsp], eax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx

; 775  :     return _Old_val;

	mov	eax, DWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@HH@std@@YAHAEAH$$QEAH@Z ENDP		; std::exchange<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z PROC	; std::exchange<char *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z ENDP	; std::exchange<char *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_New_capacity$ = 48
_New_ptr$ = 56
_Alproxy$ = 64
_Al$ = 72
tv135 = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8d, 16
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	rax, QWORD PTR _Count$[rsp]
	inc	rax
	mov	QWORD PTR tv135[rsp], rax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR tv135[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 33
$T2 = 34
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1078 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1079 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1080 :         _Left = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	npad	1

; 1081 :     }
; 1082 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ptr$ = 96
_Count$ = 104
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 1505 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1505 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1116 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	mov	QWORD PTR [rsp+8], rcx

; 1117 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1118 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1119 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1120 : 
; 1121 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1122 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1123 :             _Xlength_error("size is too long for _Size_type");
; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 1128 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 110  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	mov	QWORD PTR [rsp+8], rcx

; 111  :             return _Ok;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+8]

; 112  :         }

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
_TEXT	SEGMENT
tv86 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 108  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

$LN4:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rdx, QWORD PTR _Istr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv86[rsp], rax
	movzx	edx, BYTE PTR _Noskip$[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+8], al
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv86 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 32
tv72 = 40
this$ = 64
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 93   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 94   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR tv72[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv72[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 95   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 96   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 97   :             }
; 98   :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 32
tv73 = 40
this$ = 64
_Istr$ = 72
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 86   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Istr$[rsp]
	mov	QWORD PTR [rax], rcx

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR tv73[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv73[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 88   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 89   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+8]
	npad	1
$LN2@Sentry_bas:

; 90   :             }
; 91   :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_ostream.hpp
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 122  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	mov	QWORD PTR [rsp+8], rcx

; 123  :             return _Ok;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+8]

; 124  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_ostream.hpp
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
_Zero_uncaught_exceptions$ = 33
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 107  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 108  : #if !_HAS_EXCEPTIONS
; 109  :             const bool _Zero_uncaught_exceptions = true;
; 110  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@sentry
	mov	BYTE PTR tv72[rsp], 1
	jmp	SHORT $LN5@sentry
$LN4@sentry:
	mov	BYTE PTR tv72[rsp], 0
$LN5@sentry:
	movzx	eax, BYTE PTR tv72[rsp]
	mov	BYTE PTR _Zero_uncaught_exceptions$[rsp], al

; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	movzx	eax, BYTE PTR _Zero_uncaught_exceptions$[rsp]
	test	eax, eax
	je	SHORT $LN2@sentry

; 117  :                 this->_Myostr._Osfx();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
	npad	1
$LN2@sentry:

; 118  :             }
; 119  :         }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv72 = 32
_Zero_uncaught_exceptions$ = 33
this$ = 64
?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_ostream.hpp
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rdx, QWORD PTR _Ostr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	npad	1

; 91   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 92   :                 _Ok = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 0

; 93   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	QWORD PTR _Tied$[rsp], rax

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	cmp	QWORD PTR _Tied$[rsp], 0
	je	SHORT $LN4@sentry
	mov	rcx, QWORD PTR _Ostr$[rsp]
	call	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
	cmp	QWORD PTR _Tied$[rsp], rax
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 98   :                 _Ok = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 1

; 99   :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	mov	rcx, QWORD PTR _Tied$[rsp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN1@sentry:

; 104  :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_ostream.hpp
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 32
tv72 = 40
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR tv72[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv72[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 78   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_ostream.hpp
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 32
tv73 = 40
this$ = 64
_Ostr$ = 72
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	mov	QWORD PTR [rax], rcx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR tv73[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv73[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 71   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+8]
	npad	1
$LN2@Sentry_bas:

; 73   :             }
; 74   :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z PROC		; std::max<char *>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z ENDP		; std::max<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAA@XZ ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocator<IronMan::Core::Package::FileEntryHash>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
tv83 = 48
tv81 = 56
this$ = 80
<_Val_0>$ = 88
??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_one_at_back<IronMan::Core::Package::FileEntryHash const &>, COMDAT

; 824  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 825  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 826  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 827  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 828  : 
; 829  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_back_with_unused_capacity<IronMan::Core::Package::FileEntryHash const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBUFileEntryHash@Package@Core@IronMan@@@std@@YAAEBUFileEntryHash@Package@Core@IronMan@@AEBU1234@@Z ; std::forward<IronMan::Core::Package::FileEntryHash const &>
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv81[rsp], rax
	mov	r8, QWORD PTR tv83[rsp]
	mov	rdx, QWORD PTR tv81[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAPEAUFileEntryHash@Package@Core@IronMan@@QEAU2345@AEBU2345@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_reallocate<IronMan::Core::Package::FileEntryHash const &>
$LN1@Emplace_on:

; 834  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_one_at_back<IronMan::Core::Package::FileEntryHash const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z PROC ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1095 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1096 :     using _Ty = typename _Alloc::value_type;
; 1097 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1098 :         for (; _First != _Last; ++_First) {
; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

	ret	0
??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z PROC ; std::_Unfancy_maybe_null<IronMan::Core::Package::FileEntryHash>, COMDAT

; 79   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 80   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 81   : }

	ret	0
??$_Unfancy_maybe_null@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ENDP ; std::_Unfancy_maybe_null<IronMan::Core::Package::FileEntryHash>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GPackage@Core@IronMan@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GPackage@Core@IronMan@@QEAAPEAXI@Z PROC		; IronMan::Core::Package::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1Package@Core@IronMan@@QEAA@XZ	; IronMan::Core::Package::~Package
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 304				; 00000130H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GPackage@Core@IronMan@@QEAAPEAXI@Z ENDP		; IronMan::Core::Package::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal, COMDAT

; 2215 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2216 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first

; 2217 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal, COMDAT

; 2211 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2212 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Get_first

; 2213 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Orphan_range@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAXPEAUFileEntryHash@Package@Core@IronMan@@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAXPEAUFileEntryHash@Package@Core@IronMan@@0@Z PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Orphan_range, COMDAT

; 2208 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAXPEAUFileEntryHash@Package@Core@IronMan@@0@Z ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Xlength, COMDAT

; 2168 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2169 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlength:

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@CAXXZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Tidy, COMDAT

; 2066 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2067 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2068 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2069 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2070 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2071 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2072 : 
; 2073 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2074 : 
; 2075 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z ; std::allocator<IronMan::Core::Package::FileEntryHash>::deallocate

; 2079 : 
; 2080 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 2081 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 2082 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2083 :         }
; 2084 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Change_array, COMDAT

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2047 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2048 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 2049 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 2050 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 2051 : 
; 2052 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z ; std::allocator<IronMan::Core::Package::FileEntryHash>::deallocate
	npad	1
$LN2@Change_arr:

; 2058 :         }
; 2059 : 
; 2060 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 2061 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, QWORD PTR _Newsize$[rsp], 24
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

	imul	rax, QWORD PTR _Newcapacity$[rsp], 24
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 2063 :         _ASAN_VECTOR_CREATE;
; 2064 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K1@Z ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Calculate_growth, COMDAT

; 1991 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1992 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1993 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1994 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1995 : 
; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1997 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 2003 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2004 :         }
; 2005 : 
; 2006 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 2007 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::capacity, COMDAT

; 1907 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1908 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx

; 1910 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size, COMDAT

; 1903 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1904 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEBAAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@@Z ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1905 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ
_TEXT	SEGMENT
this$ = 48
?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_end, COMDAT

; 1885 :     _NODISCARD _CONSTEXPR20 _Ty* _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1886 :         return _Unfancy_maybe_null(_Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy_maybe_null@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ; std::_Unfancy_maybe_null<IronMan::Core::Package::FileEntryHash>

; 1887 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ
_TEXT	SEGMENT
this$ = 48
?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_begin, COMDAT

; 1877 :     _NODISCARD _CONSTEXPR20 _Ty* _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1878 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy_maybe_null@UFileEntryHash@Package@Core@IronMan@@@std@@YAPEAUFileEntryHash@Package@Core@IronMan@@PEAU1234@@Z ; std::_Unfancy_maybe_null<IronMan::Core::Package::FileEntryHash>

; 1879 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
_Myfirst$ = 48
tv82 = 56
tv84 = 64
tv80 = 72
this$ = 96
?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::clear, COMDAT

; 1792 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1793 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1794 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1795 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1796 : 
; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;

	jmp	SHORT $LN1@clear
$LN2@clear:

; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Getal
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv80[rsp], rax
	mov	r8, QWORD PTR tv82[rsp]
	mov	rdx, QWORD PTR tv84[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$_Destroy_range@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@YAXPEAUFileEntryHash@Package@Core@IronMan@@QEAU1234@AEAV?$allocator@UFileEntryHash@Package@Core@IronMan@@@0@@Z ; std::_Destroy_range<std::allocator<IronMan::Core::Package::FileEntryHash> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN1@clear:

; 1808 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::push_back, COMDAT

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 918  :         _Emplace_one_at_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEBUFileEntryHash@Package@Core@IronMan@@@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAAEAUFileEntryHash@Package@Core@IronMan@@AEBU2345@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Emplace_one_at_back<IronMan::Core::Package::FileEntryHash const &>
	npad	1

; 919  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::~vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 814  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 815  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@AEAAXXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Tidy
	npad	1

; 816  : #if _ITERATOR_DEBUG_LEVEL != 0
; 817  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 818  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 819  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 820  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::~vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
tv78 = 48
this$ = 80
??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >, COMDAT

; 655  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@V?$_Vector_val@U?$_Simple_types@UFileEntryHash@Package@Core@IronMan@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1>::_Compressed_pair<std::allocator<IronMan::Core::Package::FileEntryHash>,std::_Vector_val<std::_Simple_types<IronMan::Core::Package::FileEntryHash> >,1><>
	npad	1

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 657  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@SA_KAEBV?$allocator@UFileEntryHash@Package@Core@IronMan@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<IronMan::Core::Package::FileEntryHash> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z PROC ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z	; std::_Get_size_of_n<24>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@_K@Z ENDP ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z PROC ; std::allocator<IronMan::Core::Package::FileEntryHash>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 24
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAAXQEAUFileEntryHash@Package@Core@IronMan@@_K@Z ENDP ; std::allocator<IronMan::Core::Package::FileEntryHash>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAA@XZ PROC ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocator<IronMan::Core::Package::FileEntryHash>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@QEAA@XZ ENDP ; std::allocator<IronMan::Core::Package::FileEntryHash>::allocator<IronMan::Core::Package::FileEntryHash>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	rcx, rax
	call	??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	rcx, rax
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 144				; 00000090H
	mov	rcx, rax
	call	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 144				; 00000090H
	mov	edx, 240				; 000000f0H
	mov	rcx, rax
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 144				; 00000090H
	add	rsp, 40					; 00000028H
	ret	0
??_G?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 676  :     ~basic_istringstream() noexcept override {}

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax-144]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:??_7?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rcx+rax-144], rdx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax-144]
	movsxd	rax, DWORD PTR [rax+4]
	sub	rax, 144				; 00000090H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx-144]
	movsxd	rcx, DWORD PTR [rcx+4]
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx-148], eax
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 128				; 00000080H
	mov	rcx, rax
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 120				; 00000078H
	mov	rcx, rax
	call	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	sub	rcx, 144				; 00000090H
	add	rcx, 24
	call	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	sub	rcx, 144				; 00000090H
	add	rcx, 16
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
tv84 = 32
this$ = 64
_Right$ = 72
??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 658  :         noexcept(_Choose_pocma_v<_Alloc> != _Pocma_values::_No_propagate_allocators) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 659  :         if (this != _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@V?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> > >
	cmp	QWORD PTR this$[rsp], rax
	je	SHORT $LN2@operator

; 660  :             _Mybase::swap(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::swap

; 661  :             _Stringbuffer._Assign_rv_no_alias(_STD move(_Right._Stringbuffer));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$move@AEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_no_alias
	npad	1
$LN2@operator:

; 662  :         }
; 663  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 664  :     }

	add	rsp, 56					; 00000038H
	ret	0
??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 32
tv165 = 40
this$ = 64
_Str$ = 72
_Mode$ = 80
$initVBases$ = 88
??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 629  :         : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::in) {}

$LN8:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0
	cmp	DWORD PTR $initVBases$[rsp], 0
	je	SHORT $LN2@basic_istr
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_8?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	rcx, rax
	call	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
$LN2@basic_istr:
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:??_7?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rcx+rax], rdx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	sub	rax, 144				; 00000090H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rcx+4]
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx-4], eax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv165[rsp], rax
	mov	eax, DWORD PTR _Mode$[rsp]
	or	eax, 1
	mov	r8d, eax
	mov	rdx, QWORD PTR _Str$[rsp]
	mov	rcx, QWORD PTR tv165[rsp]
	call	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv165 = 40
this$ = 64
_Str$ = 72
_Mode$ = 80
$initVBases$ = 88
?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 144				; 00000090H
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv165 = 40
this$ = 64
_Str$ = 72
_Mode$ = 80
$initVBases$ = 88
?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv165 = 40
this$ = 64
_Str$ = 72
_Mode$ = 80
$initVBases$ = 88
?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 623  :     basic_istringstream() : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(ios_base::in) {}

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0
	cmp	DWORD PTR $initVBases$[rsp], 0
	je	SHORT $LN2@basic_istr
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_8?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	rcx, rax
	call	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
$LN2@basic_istr:
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@V?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > >
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:??_7?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rcx+rax], rdx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	sub	rax, 144				; 00000090H
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rcx+4]
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx-4], eax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv163[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv163[rsp]
	call	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 144				; 00000090H
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv163 = 40
this$ = 64
$initVBases$ = 72
?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\FilePak.cpp
; File D:\c++\paoda\Core\FilePak.h
; File D:\c++\paoda\Core\FilePak.cpp
_TEXT	SEGMENT
tv71 = 32
this$ = 64
??0Package@Core@IronMan@@AEAA@XZ PROC			; IronMan::Core::Package::Package

; 149  : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
; File D:\c++\paoda\Core\FilePak.h

; 62   : 		ptr_t fileBuf = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 63   : 		ptr_t fileSize = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
; File D:\c++\paoda\Core\FilePak.cpp

; 149  : 	{

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv71[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv71[rsp]
	call	??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 148  : 		m_Header()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 149  : 	{

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 272				; 00000110H
	mov	rcx, rax
	call	??0?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
	npad	1

; 147  : 		:m_bLoaded(false),

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+296], 0

; 150  : 
; 151  : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0Package@Core@IronMan@@AEAA@XZ ENDP			; IronMan::Core::Package::Package
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv71 = 32
this$ = 64
?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA PROC	; `IronMan::Core::Package::Package'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0Package@Core@IronMan@@AEAA@XZ@4HA ENDP	; `IronMan::Core::Package::Package'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
tv71 = 32
this$ = 64
?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA PROC	; `IronMan::Core::Package::Package'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 272				; 00000110H
	call	??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::~vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0Package@Core@IronMan@@AEAA@XZ@4HA ENDP	; `IronMan::Core::Package::Package'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\FilePak.cpp
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
?Release@Package@Core@IronMan@@QEAAXXZ PROC		; IronMan::Core::Package::Release

; 139  : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 140  : 		if (m_Instance)

	cmp	QWORD PTR ?m_Instance@Package@Core@IronMan@@0PEAV123@EA, 0 ; IronMan::Core::Package::m_Instance
	je	SHORT $LN2@Release

; 141  : 		{
; 142  : 			delete m_Instance;

	mov	rax, QWORD PTR ?m_Instance@Package@Core@IronMan@@0PEAV123@EA ; IronMan::Core::Package::m_Instance
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN4@Release
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_GPackage@Core@IronMan@@QEAAPEAXI@Z
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN5@Release
$LN4@Release:
	mov	QWORD PTR tv69[rsp], 0
$LN5@Release:

; 143  : 			m_Instance = nullptr;

	mov	QWORD PTR ?m_Instance@Package@Core@IronMan@@0PEAV123@EA, 0 ; IronMan::Core::Package::m_Instance
$LN2@Release:

; 144  : 		}
; 145  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?Release@Package@Core@IronMan@@QEAAXXZ ENDP		; IronMan::Core::Package::Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\FilePak.cpp
_TEXT	SEGMENT
j$1 = 32
buffer$2 = 40
entry$3 = 48
tv88 = 56
tv132 = 64
this$ = 96
fileNameHash$ = 104
outData$ = 112
?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z PROC	; IronMan::Core::Package::FindFile

; 116  : 	{

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 117  : 		if (outData != nullptr)

	cmp	QWORD PTR outData$[rsp], 0
	je	$LN5@FindFile

; 118  : 		{
; 119  : 			char* buffer = nullptr;

	mov	QWORD PTR buffer$2[rsp], 0

; 120  : 			if (auto entry = FindFileEntryHash(fileNameHash))

	mov	rdx, QWORD PTR fileNameHash$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FindFileEntryHash@Package@Core@IronMan@@QEAAPEAUFileEntryHash@123@_K@Z ; IronMan::Core::Package::FindFileEntryHash
	mov	QWORD PTR entry$3[rsp], rax
	cmp	QWORD PTR entry$3[rsp], 0
	je	$LN6@FindFile

; 121  : 			{
; 122  : 				buffer = (char*)malloc(entry->size);

	mov	rax, QWORD PTR entry$3[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	ecx, eax
	call	malloc
	mov	QWORD PTR buffer$2[rsp], rax

; 123  : 				m_PackageFile.seekg(entry->offset, std::ifstream::beg); //seek to the offset of the file in the .pak file

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv88[rsp], rax
	mov	rax, QWORD PTR entry$3[rsp]
	mov	eax, DWORD PTR [rax+20]
	xor	r8d, r8d
	mov	edx, eax
	mov	rcx, QWORD PTR tv88[rsp]
	call	?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z ; std::basic_istream<char,std::char_traits<char> >::seekg

; 124  : 				m_PackageFile.read(buffer, entry->size);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR entry$3[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	r8d, eax
	mov	rdx, QWORD PTR buffer$2[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::read
	npad	1

; 125  : 
; 126  : 				for (unsigned int j = 0; j < entry->size; j++)

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN4@FindFile
$LN2@FindFile:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN4@FindFile:
	mov	rax, QWORD PTR entry$3[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	DWORD PTR j$1[rsp], eax
	jae	SHORT $LN3@FindFile

; 127  : 				{
; 128  : 					if (m_Header.additionEncrypt) buffer[j] -= m_Header.encryptVal; //decrypt it

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+268]
	test	eax, eax
	je	SHORT $LN7@FindFile
	mov	rax, QWORD PTR this$[rsp]
	movsx	eax, BYTE PTR [rax+269]
	mov	ecx, DWORD PTR j$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR j$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN8@FindFile
$LN7@FindFile:

; 129  : 					else buffer[j] += m_Header.encryptVal;

	mov	rax, QWORD PTR this$[rsp]
	movsx	eax, BYTE PTR [rax+269]
	mov	ecx, DWORD PTR j$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR j$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	mov	BYTE PTR [rdx+rcx], al
$LN8@FindFile:

; 130  : 				}

	jmp	SHORT $LN2@FindFile
$LN3@FindFile:

; 131  : 				*outData = buffer;

	mov	rax, QWORD PTR outData$[rsp]
	mov	rcx, QWORD PTR buffer$2[rsp]
	mov	QWORD PTR [rax], rcx

; 132  : 
; 133  : 				return entry->size;

	mov	rax, QWORD PTR entry$3[rsp]
	mov	eax, DWORD PTR [rax+16]
	jmp	SHORT $LN1@FindFile
$LN6@FindFile:
$LN5@FindFile:

; 134  : 			}
; 135  : 		}
; 136  : 		return 0;

	xor	eax, eax
$LN1@FindFile:

; 137  : 	}

	add	rsp, 88					; 00000058H
	ret	0
?FindFile@Package@Core@IronMan@@QEAA_K_KPEAPEAX@Z ENDP	; IronMan::Core::Package::FindFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\FilePak.cpp
_TEXT	SEGMENT
<begin>$L0$1 = 32
<range>$L0$2 = 40
entry$3 = 48
<end>$L0$4 = 56
this$ = 80
fileNameHash$ = 88
?FindFileEntryHash@Package@Core@IronMan@@QEAAPEAUFileEntryHash@123@_K@Z PROC ; IronMan::Core::Package::FindFileEntryHash

; 104  : 	{

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 105  : 		if (m_bLoaded)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+296]
	test	eax, eax
	je	SHORT $LN5@FindFileEn

; 106  : 		{
; 107  : 			for (auto& entry : m_Entries)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 272				; 00000110H
	mov	QWORD PTR <range>$L0$2[rsp], rax
	mov	rcx, QWORD PTR <range>$L0$2[rsp]
	call	?_Unchecked_begin@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_begin
	mov	QWORD PTR <begin>$L0$1[rsp], rax
	mov	rcx, QWORD PTR <range>$L0$2[rsp]
	call	?_Unchecked_end@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAPEAUFileEntryHash@Package@Core@IronMan@@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::_Unchecked_end
	mov	QWORD PTR <end>$L0$4[rsp], rax
	jmp	SHORT $LN4@FindFileEn
$LN2@FindFileEn:
	mov	rax, QWORD PTR <begin>$L0$1[rsp]
	add	rax, 24
	mov	QWORD PTR <begin>$L0$1[rsp], rax
$LN4@FindFileEn:
	mov	rax, QWORD PTR <end>$L0$4[rsp]
	cmp	QWORD PTR <begin>$L0$1[rsp], rax
	je	SHORT $LN3@FindFileEn
	mov	rax, QWORD PTR <begin>$L0$1[rsp]
	mov	QWORD PTR entry$3[rsp], rax

; 108  : 			{
; 109  : 				if (entry.name == fileNameHash)

	mov	rax, QWORD PTR entry$3[rsp]
	mov	rcx, QWORD PTR fileNameHash$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN6@FindFileEn

; 110  : 					return &entry;

	mov	rax, QWORD PTR entry$3[rsp]
	jmp	SHORT $LN1@FindFileEn
$LN6@FindFileEn:

; 111  : 			}

	jmp	SHORT $LN2@FindFileEn
$LN3@FindFileEn:
$LN5@FindFileEn:

; 112  : 		}
; 113  : 		return nullptr;//PAK file isn't loaded, or entry isn't found

	xor	eax, eax
$LN1@FindFileEn:

; 114  : 	}

	add	rsp, 72					; 00000048H
	ret	0
?FindFileEntryHash@Package@Core@IronMan@@QEAAPEAUFileEntryHash@123@_K@Z ENDP ; IronMan::Core::Package::FindFileEntryHash
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\FilePak.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 36
$T6 = 37
$T7 = 38
j$8 = 40
f$ = 48
i$9 = 56
buffer$10 = 64
file_size_signed$ = 72
file_size$ = 80
file_data$ = 88
tv86 = 96
$T11 = 104
tv138 = 112
tv299 = 120
tv180 = 128
$T12 = 136
tv214 = 144
tv288 = 152
$T13 = 160
$T14 = 168
entryHash$15 = 408
str$ = 432
entry$16 = 464
__$ArrayPad$ = 672
this$ = 704
packagePath$ = 712
?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; IronMan::Core::Package::Load

; 27   : 	{

$LN22:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 696				; 000002b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 28   : 		FILE* f;
; 29   : 		if ((f = fopen(packagePath.c_str(), ("rb"))) == NULL)

	mov	rcx, QWORD PTR packagePath$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	lea	rdx, OFFSET FLAT:??_C@_02JDPG@rb@
	mov	rcx, rax
	call	fopen
	mov	QWORD PTR f$[rsp], rax
	cmp	QWORD PTR f$[rsp], 0
	jne	SHORT $LN8@Load

; 30   : 			return false;

	mov	BYTE PTR $T1[rsp], 0
	mov	rcx, QWORD PTR packagePath$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	$LN1@Load
$LN8@Load:

; 31   : 
; 32   : 		long file_size_signed;
; 33   : 		if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))

	mov	r8d, 2
	xor	edx, edx
	mov	rcx, QWORD PTR f$[rsp]
	call	fseek
	test	eax, eax
	jne	SHORT $LN10@Load
	mov	rcx, QWORD PTR f$[rsp]
	call	ftell
	mov	DWORD PTR file_size_signed$[rsp], eax
	cmp	DWORD PTR file_size_signed$[rsp], -1
	je	SHORT $LN10@Load
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR f$[rsp]
	call	fseek
	test	eax, eax
	je	SHORT $LN9@Load
$LN10@Load:

; 34   : 		{
; 35   : 			fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose
	npad	1

; 36   : 			return false;

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR packagePath$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T2[rsp]
	jmp	$LN1@Load
$LN9@Load:

; 37   : 		}
; 38   : 
; 39   : 		auto file_size = fileSize = (size_t)file_size_signed;

	movsxd	rax, DWORD PTR file_size_signed$[rsp]
	mov	QWORD PTR tv86[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR tv86[rsp]
	mov	QWORD PTR file_size$[rsp], rax

; 40   : 
; 41   : 		fileBuf = (ptr_t)new char[fileSize];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T11[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T11[rsp]
	mov	QWORD PTR [rax], rcx

; 42   : 		/*if (!NT_SUCCESS(AllocateMem(PID, fileBuf, fileSize, MEM_COMMIT, PAGE_READWRITE)))
; 43   : 			return false;
; 44   : 
; 45   : 		if (!NT_SUCCESS(ConcealVAD(PID, fileBuf, fileSize)))
; 46   : 			return false;*/
; 47   : 
; 48   : 
; 49   : 		void* file_data = (void*)fileBuf;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR file_data$[rsp], rax

; 50   : 		if (file_data == NULL)

	cmp	QWORD PTR file_data$[rsp], 0
	jne	SHORT $LN11@Load

; 51   : 		{
; 52   : 			fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose
	npad	1

; 53   : 			return false;

	mov	BYTE PTR $T3[rsp], 0
	mov	rcx, QWORD PTR packagePath$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T3[rsp]
	jmp	$LN1@Load
$LN11@Load:

; 54   : 		}
; 55   : 		if (fread(file_data, 1, file_size, f) != file_size)

	mov	r9, QWORD PTR f$[rsp]
	mov	r8, QWORD PTR file_size$[rsp]
	mov	edx, 1
	mov	rcx, QWORD PTR file_data$[rsp]
	call	fread
	cmp	rax, QWORD PTR file_size$[rsp]
	je	SHORT $LN12@Load

; 56   : 		{
; 57   : 			fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose
	npad	1

; 58   : 			return false;

	mov	BYTE PTR $T4[rsp], 0
	mov	rcx, QWORD PTR packagePath$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T4[rsp]
	jmp	$LN1@Load
$LN12@Load:

; 59   : 		}
; 60   : 		fclose(f);

	mov	rcx, QWORD PTR f$[rsp]
	call	fclose

; 61   : 		std::string str((char*)file_data, file_size);

	mov	r8, QWORD PTR file_size$[rsp]
	mov	rdx, QWORD PTR file_data$[rsp]
	lea	rcx, QWORD PTR str$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 62   : 		m_PackageFile = std::istringstream(str, std::ios_base::in | std::ios_base::binary);

	mov	r9d, 1
	mov	r8d, 33					; 00000021H
	lea	rdx, QWORD PTR str$[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR tv138[rsp]
	mov	QWORD PTR tv299[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rdx, QWORD PTR tv299[rsp]
	mov	rcx, rax
	call	??4?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	lea	rcx, QWORD PTR $T14[rsp]
	call	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	npad	1

; 63   : 		if (m_PackageFile.good())

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+16]
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	$LN13@Load

; 64   : 		{
; 65   : 			m_PackageFile.read((char*)&m_Header, sizeof(PackageHeader));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv180[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	r8d, 16
	mov	rdx, rax
	mov	rcx, QWORD PTR tv180[rsp]
	call	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::read
	npad	1

; 66   : 
; 67   : 			if (strcmp(m_Header.fileID, ("PAK")) != 0 || !(m_Header.numberFiles > 0) || m_Header.version != 1)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	lea	rdx, OFFSET FLAT:??_C@_03HHGDFOHI@PAK@
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN15@Load
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+264], 0
	jle	SHORT $LN15@Load
	mov	rax, QWORD PTR this$[rsp]
	movsx	eax, BYTE PTR [rax+262]
	cmp	eax, 1
	je	SHORT $LN14@Load
$LN15@Load:

; 68   : 			{
; 69   : 				return false;

	mov	BYTE PTR $T5[rsp], 0
	lea	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR packagePath$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T5[rsp]
	jmp	$LN1@Load
$LN14@Load:

; 70   : 			}
; 71   : 
; 72   : 			m_Entries.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 272				; 00000110H
	mov	rcx, rax
	call	?clear@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXXZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::clear
	npad	1

; 73   : 			char* buffer;
; 74   : 			for (int i = 0; i < m_Header.numberFiles; i++)

	mov	DWORD PTR i$9[rsp], 0
	jmp	SHORT $LN4@Load
$LN2@Load:
	mov	eax, DWORD PTR i$9[rsp]
	inc	eax
	mov	DWORD PTR i$9[rsp], eax
$LN4@Load:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+264]
	cmp	DWORD PTR i$9[rsp], eax
	jge	$LN3@Load

; 75   : 			{
; 76   : 				buffer = new char[sizeof(FileEntry)];

	mov	ecx, 208				; 000000d0H
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T12[rsp], rax
	mov	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR buffer$10[rsp], rax

; 77   : 				FileEntry entry;
; 78   : 				m_PackageFile.read(buffer, sizeof(FileEntry));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv214[rsp], rax
	mov	r8d, 208				; 000000d0H
	mov	rdx, QWORD PTR buffer$10[rsp]
	mov	rcx, QWORD PTR tv214[rsp]
	call	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z ; std::basic_istream<char,std::char_traits<char> >::read
	npad	1

; 79   : 
; 80   : 				for (int j = 0; j < sizeof(FileEntry); j++)

	mov	DWORD PTR j$8[rsp], 0
	jmp	SHORT $LN7@Load
$LN5@Load:
	mov	eax, DWORD PTR j$8[rsp]
	inc	eax
	mov	DWORD PTR j$8[rsp], eax
$LN7@Load:
	movsxd	rax, DWORD PTR j$8[rsp]
	cmp	rax, 208				; 000000d0H
	jae	SHORT $LN6@Load

; 81   : 				{
; 82   : 					if (m_Header.additionEncrypt) buffer[j] -= m_Header.encryptVal; //decrypt each byte

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+268]
	test	eax, eax
	je	SHORT $LN16@Load
	mov	rax, QWORD PTR this$[rsp]
	movsx	eax, BYTE PTR [rax+269]
	movsxd	rcx, DWORD PTR j$8[rsp]
	mov	rdx, QWORD PTR buffer$10[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	sub	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR j$8[rsp]
	mov	rdx, QWORD PTR buffer$10[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN17@Load
$LN16@Load:

; 83   : 					else buffer[j] += m_Header.encryptVal;

	mov	rax, QWORD PTR this$[rsp]
	movsx	eax, BYTE PTR [rax+269]
	movsxd	rcx, DWORD PTR j$8[rsp]
	mov	rdx, QWORD PTR buffer$10[rsp]
	movsx	ecx, BYTE PTR [rdx+rcx]
	add	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR j$8[rsp]
	mov	rdx, QWORD PTR buffer$10[rsp]
	mov	BYTE PTR [rdx+rcx], al
$LN17@Load:

; 84   : 				}

	jmp	$LN5@Load
$LN6@Load:

; 85   : 
; 86   : 				memcpy(&entry, buffer, sizeof(FileEntry)); //store the decrypted stuff into the entry

	mov	r8d, 208				; 000000d0H
	mov	rdx, QWORD PTR buffer$10[rsp]
	lea	rcx, QWORD PTR entry$16[rsp]
	call	memcpy

; 87   : 
; 88   : 				FileEntryHash entryHash;
; 89   : 				entryHash.name = hash_(entry.name);

	lea	rcx, QWORD PTR entry$16[rsp]
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR entryHash$15[rsp], rax

; 90   : 				entryHash.fullname = hash_(entry.fullname);

	lea	rcx, QWORD PTR entry$16[rsp+50]
	call	?hash_@@YA?B_KPEBD@Z			; hash_
	mov	QWORD PTR entryHash$15[rsp+8], rax

; 91   : 				entryHash.size = entry.size;

	mov	eax, DWORD PTR entry$16[rsp+200]
	mov	DWORD PTR entryHash$15[rsp+16], eax

; 92   : 				entryHash.offset = entry.offset;

	mov	eax, DWORD PTR entry$16[rsp+204]
	mov	DWORD PTR entryHash$15[rsp+20], eax

; 93   : 				m_Entries.push_back(entryHash); //append to the vector

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 272				; 00000110H
	mov	QWORD PTR tv288[rsp], rax
	lea	rdx, QWORD PTR entryHash$15[rsp]
	mov	rcx, QWORD PTR tv288[rsp]
	call	?push_back@?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAAXAEBUFileEntryHash@Package@Core@IronMan@@@Z ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::push_back
	npad	1

; 94   : 				delete[] buffer;

	mov	rax, QWORD PTR buffer$10[rsp]
	mov	QWORD PTR $T13[rsp], rax
	mov	rcx, QWORD PTR $T13[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1

; 95   : 			}

	jmp	$LN2@Load
$LN3@Load:

; 96   : 			m_bLoaded = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+296], 1

; 97   : 			str.clear();

	lea	rcx, QWORD PTR str$[rsp]
	call	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
	npad	1

; 98   : 			return true;

	mov	BYTE PTR $T6[rsp], 1
	lea	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR packagePath$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T6[rsp]
	jmp	SHORT $LN1@Load
$LN13@Load:

; 99   : 		}
; 100  : 		return false;

	mov	BYTE PTR $T7[rsp], 0
	lea	rcx, QWORD PTR str$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR packagePath$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	movzx	eax, BYTE PTR $T7[rsp]
$LN1@Load:

; 101  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 696				; 000002b8H
	ret	0
?Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; IronMan::Core::Package::Load
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 36
$T6 = 37
$T7 = 38
j$8 = 40
f$ = 48
i$9 = 56
buffer$10 = 64
file_size_signed$ = 72
file_size$ = 80
file_data$ = 88
tv86 = 96
$T11 = 104
tv138 = 112
tv299 = 120
tv180 = 128
$T12 = 136
tv214 = 144
tv288 = 152
$T13 = 160
$T14 = 168
entryHash$15 = 408
str$ = 432
entry$16 = 464
__$ArrayPad$ = 672
this$ = 704
packagePath$ = 712
?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Core::Package::Load'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR packagePath$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Core::Package::Load'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 36
$T6 = 37
$T7 = 38
j$8 = 40
f$ = 48
i$9 = 56
buffer$10 = 64
file_size_signed$ = 72
file_size$ = 80
file_data$ = 88
tv86 = 96
$T11 = 104
tv138 = 112
tv299 = 120
tv180 = 128
$T12 = 136
tv214 = 144
tv288 = 152
$T13 = 160
$T14 = 168
entryHash$15 = 408
str$ = 432
entry$16 = 464
__$ArrayPad$ = 672
this$ = 704
packagePath$ = 712
?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Core::Package::Load'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR str$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Core::Package::Load'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 36
$T6 = 37
$T7 = 38
j$8 = 40
f$ = 48
i$9 = 56
buffer$10 = 64
file_size_signed$ = 72
file_size$ = 80
file_data$ = 88
tv86 = 96
$T11 = 104
tv138 = 112
tv299 = 120
tv180 = 128
$T12 = 136
tv214 = 144
tv288 = 152
$T13 = 160
$T14 = 168
entryHash$15 = 408
str$ = 432
entry$16 = 464
__$ArrayPad$ = 672
this$ = 704
packagePath$ = 712
?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `IronMan::Core::Package::Load'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T14[rbp]
	call	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??Load@Package@Core@IronMan@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `IronMan::Core::Package::Load'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\FilePak.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1Package@Core@IronMan@@QEAA@XZ PROC			; IronMan::Core::Package::~Package

; 17   : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 18   : 		if (fileBuf)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Package

; 19   : 		{
; 20   : 			RtlSecureZeroMemory((void*)fileBuf, fileSize);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	RtlSecureZeroMemory
	npad	1

; 21   : 			delete[](void*)fileBuf;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1
$LN2@Package:

; 22   : 			//FreeMem(PID, fileBuf, fileSize, MEM_RELEASE);
; 23   : 		}
; 24   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 272				; 00000110H
	mov	rcx, rax
	call	??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::~vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1Package@Core@IronMan@@QEAA@XZ ENDP			; IronMan::Core::Package::~Package
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::Core::Package::~Package'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 16
	call	??_D?$basic_istringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1Package@Core@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::Core::Package::~Package'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::Core::Package::~Package'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 272				; 00000110H
	call	??1?$vector@UFileEntryHash@Package@Core@IronMan@@V?$allocator@UFileEntryHash@Package@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >::~vector<IronMan::Core::Package::FileEntryHash,std::allocator<IronMan::Core::Package::FileEntryHash> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1Package@Core@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::Core::Package::~Package'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\FilePak.cpp
_TEXT	SEGMENT
$T1 = 32
tv76 = 40
$T2 = 48
?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ PROC	; IronMan::Core::Package::GetPackage

; 12   : 	{

$LN7:
	sub	rsp, 72					; 00000048H

; 13   : 		if (m_Instance == nullptr) { m_Instance = new Package(); }

	cmp	QWORD PTR ?m_Instance@Package@Core@IronMan@@0PEAV123@EA, 0 ; IronMan::Core::Package::m_Instance
	jne	SHORT $LN2@GetPackage
	mov	ecx, 304				; 00000130H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN4@GetPackage
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0Package@Core@IronMan@@AEAA@XZ	; IronMan::Core::Package::Package
	mov	QWORD PTR tv76[rsp], rax
	jmp	SHORT $LN5@GetPackage
$LN4@GetPackage:
	mov	QWORD PTR tv76[rsp], 0
$LN5@GetPackage:
	mov	rax, QWORD PTR tv76[rsp]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR ?m_Instance@Package@Core@IronMan@@0PEAV123@EA, rax ; IronMan::Core::Package::m_Instance
$LN2@GetPackage:

; 14   : 		return m_Instance;

	mov	rax, QWORD PTR ?m_Instance@Package@Core@IronMan@@0PEAV123@EA ; IronMan::Core::Package::m_Instance

; 15   : 	}

	add	rsp, 72					; 00000048H
	ret	0
?GetPackage@Package@Core@IronMan@@SAPEAV123@XZ ENDP	; IronMan::Core::Package::GetPackage
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv76 = 40
$T2 = 48
?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA PROC ; `IronMan::Core::Package::GetPackage'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 304				; 00000130H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetPackage@Package@Core@IronMan@@SAPEAV123@XZ@4HA ENDP ; `IronMan::Core::Package::GetPackage'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 64   :     operator streamoff() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 65   :         // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 66   :         // basic_filebuf would set _Fpos.
; 67   :         return _Myoff + _Fpos;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]

; 68   :     }

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 16
_Off$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z PROC ; std::pointer_traits<char *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@D@std@@YAPEADAEAD@Z	; std::addressof<char>

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ENDP ; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 120				; 00000078H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z
_TEXT	SEGMENT
_State$ = 0
_Mode$ = 32
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT

; 578  :     static int _Getstate(ios_base::openmode _Mode) noexcept { // convert open mode to stream state bits

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 579  :         int _State = 0;

	mov	DWORD PTR _State$[rsp], 0

; 580  :         if (!(_Mode & ios_base::in)) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@Getstate

; 581  :             _State |= _Noread;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax
$LN2@Getstate:

; 582  :         }
; 583  : 
; 584  :         if (!(_Mode & ios_base::out)) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN3@Getstate

; 585  :             _State |= _Constant;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 2
	mov	DWORD PTR _State$[rsp], eax
$LN3@Getstate:

; 586  :         }
; 587  : 
; 588  :         if (_Mode & ios_base::app) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN4@Getstate

; 589  :             _State |= _Append;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 8
	mov	DWORD PTR _State$[rsp], eax
$LN4@Getstate:

; 590  :         }
; 591  : 
; 592  :         if (_Mode & ios_base::ate) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN5@Getstate

; 593  :             _State |= _Atend;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 16
	mov	DWORD PTR _State$[rsp], eax
$LN5@Getstate:

; 594  :         }
; 595  : 
; 596  :         return _State;

	mov	eax, DWORD PTR _State$[rsp]

; 597  :     }

	add	rsp, 24
	ret	0
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
_TEXT	SEGMENT
tv88 = 32
tv141 = 40
tv139 = 48
tv143 = 56
this$ = 80
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT

; 558  :     void _Tidy() noexcept { // discard any allocated buffer and clear pointers

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 559  :         if (_Mystate & _Allocated) {

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 1
	test	eax, eax
	je	$LN2@Tidy

; 560  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 116				; 00000074H
	mov	QWORD PTR tv143[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	test	rax, rax
	je	SHORT $LN4@Tidy
	mov	rcx, QWORD PTR this$[rsp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	mov	QWORD PTR tv88[rsp], rax
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	rcx, QWORD PTR this$[rsp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	mov	QWORD PTR tv88[rsp], rax
$LN5@Tidy:
	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	rcx, QWORD PTR tv88[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
	mov	QWORD PTR tv139[rsp], rax
	mov	r8, QWORD PTR tv141[rsp]
	mov	rdx, QWORD PTR tv139[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN2@Tidy:

; 561  :                 static_cast<typename allocator_traits<allocator_type>::size_type>(
; 562  :                     (_Mysb::pptr() ? _Mysb::epptr() : _Mysb::egptr()) - _Mysb::eback()));
; 563  :         }
; 564  : 
; 565  :         _Mysb::setg(nullptr, nullptr, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg

; 566  :         _Mysb::setp(nullptr, nullptr);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp

; 567  :         _Seekhigh = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+104], 0

; 568  :         _Mystate &= ~_Allocated;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, -2
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+112], eax

; 569  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z
_TEXT	SEGMENT
_Pnew$1 = 32
_Newsize$2 = 40
tv135 = 48
tv139 = 56
this$ = 80
_Ptr$ = 88
_Count$ = 96
_State$ = 104
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT

; 497  :     void _Init(const _Elem* _Ptr, const _Mysize_type _Count, int _State) {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 498  :         // initialize buffer to [_Ptr, _Ptr + _Count), set state
; 499  :         _State &= ~_From_rvalue;

	mov	eax, DWORD PTR _State$[rsp]
	and	eax, -33				; ffffffffffffffdfH
	mov	DWORD PTR _State$[rsp], eax

; 500  : 
; 501  :         if (_Count > INT_MAX) { // TRANSITION, VSO-485517

	cmp	QWORD PTR _Count$[rsp], 2147483647	; 7fffffffH
	jbe	SHORT $LN2@Init

; 502  :             _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
	npad	1
$LN2@Init:

; 503  :         }
; 504  : 
; 505  :         if (_Count != 0 && (_State & (_Noread | _Constant)) != (_Noread | _Constant)) {

	cmp	QWORD PTR _Count$[rsp], 0
	je	$LN3@Init
	mov	eax, DWORD PTR _State$[rsp]
	and	eax, 6
	cmp	eax, 6
	je	$LN3@Init

; 506  :             // finite buffer that can be read or written, set it up
; 507  :             _Mysize_type _Newsize = _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Newsize$2[rsp], rax

; 508  :             const auto _Pnew      = _Unfancy(_Allocate_at_least_helper(_Al, _Newsize));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 116				; 00000074H
	lea	rdx, QWORD PTR _Newsize$2[rsp]
	mov	rcx, rax
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	rcx, rax
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Pnew$1[rsp], rax

; 509  :             _Traits::copy(_Pnew, _Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Pnew$1[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 510  :             _Seekhigh = _Pnew + _Newsize;

	mov	rax, QWORD PTR _Newsize$2[rsp]
	mov	rcx, QWORD PTR _Pnew$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 511  : 
; 512  :             if (!(_State & _Noread)) {

	mov	eax, DWORD PTR _State$[rsp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN5@Init

; 513  :                 _Mysb::setg(_Pnew, _Pnew, _Seekhigh); // setup read buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	r9, QWORD PTR [rax+104]
	mov	r8, QWORD PTR _Pnew$1[rsp]
	mov	rdx, QWORD PTR _Pnew$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
	npad	1
$LN5@Init:

; 514  :             }
; 515  : 
; 516  :             if (!(_State & _Constant)) { // setup write buffer, and maybe read buffer

	mov	eax, DWORD PTR _State$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN6@Init

; 517  :                 _Mysb::setp(_Pnew, (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew, _Seekhigh);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR tv139[rsp], rax
	mov	eax, DWORD PTR _State$[rsp]
	and	eax, 24
	test	eax, eax
	je	SHORT $LN9@Init
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR tv135[rsp], rax
	jmp	SHORT $LN10@Init
$LN9@Init:
	mov	rax, QWORD PTR _Pnew$1[rsp]
	mov	QWORD PTR tv135[rsp], rax
$LN10@Init:
	mov	r9, QWORD PTR tv139[rsp]
	mov	r8, QWORD PTR tv135[rsp]
	mov	rdx, QWORD PTR _Pnew$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
	npad	1

; 518  : 
; 519  :                 if (_State & _Noread) { // maintain "_Allocated == eback() points to buffer base" invariant

	mov	eax, DWORD PTR _State$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN7@Init

; 520  :                     _Mysb::setg(_Pnew, _Pnew, _Pnew);

	mov	r9, QWORD PTR _Pnew$1[rsp]
	mov	r8, QWORD PTR _Pnew$1[rsp]
	mov	rdx, QWORD PTR _Pnew$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
	npad	1
$LN7@Init:
$LN6@Init:

; 521  :                 }
; 522  :             }
; 523  : 
; 524  :             _State |= _Allocated;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 1
	mov	DWORD PTR _State$[rsp], eax

; 525  :         } else {

	jmp	SHORT $LN4@Init
$LN3@Init:

; 526  :             _Seekhigh = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+104], 0
$LN4@Init:

; 527  :         }
; 528  : 
; 529  :         _Mystate = _State;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _State$[rsp]
	mov	DWORD PTR [rax+112], ecx
$LN8@Init:

; 530  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
tv69 = 32
tv75 = 33
_Need_read_but_cannot$ = 34
_Need_write_but_cannot$ = 35
_Pptr_old$ = 40
_Seeklow$ = 48
_Off$ = 56
tv131 = 64
_Gptr_old$ = 72
_Newptr$ = 80
_Seekdist$ = 88
this$ = 112
__$ReturnUdt$ = 120
_Pos$ = 128
_Mode$ = 136
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT

; 460  :     pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) override {

$LN18:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 461  :         const bool _Need_read_but_cannot  = (_Mode & ios_base::in) != 0 && (_Mystate & _Noread) != 0;

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@seekpos
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN12@seekpos
	mov	BYTE PTR tv69[rsp], 1
	jmp	SHORT $LN13@seekpos
$LN12@seekpos:
	mov	BYTE PTR tv69[rsp], 0
$LN13@seekpos:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR _Need_read_but_cannot$[rsp], al

; 462  :         const bool _Need_write_but_cannot = (_Mode & ios_base::out) != 0 && (_Mystate & _Constant) != 0;

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN14@seekpos
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN14@seekpos
	mov	BYTE PTR tv75[rsp], 1
	jmp	SHORT $LN15@seekpos
$LN14@seekpos:
	mov	BYTE PTR tv75[rsp], 0
$LN15@seekpos:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR _Need_write_but_cannot$[rsp], al

; 463  :         if (_Need_read_but_cannot || _Need_write_but_cannot) {

	movzx	eax, BYTE PTR _Need_read_but_cannot$[rsp]
	test	eax, eax
	jne	SHORT $LN3@seekpos
	movzx	eax, BYTE PTR _Need_write_but_cannot$[rsp]
	test	eax, eax
	je	SHORT $LN2@seekpos
$LN3@seekpos:

; 464  :             return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@seekpos
$LN2@seekpos:

; 465  :         }
; 466  : 
; 467  :         // change position to _Pos, according to _Mode
; 468  :         const auto _Off      = static_cast<streamoff>(_Pos);

	mov	rcx, QWORD PTR _Pos$[rsp]
	call	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ	; std::fpos<_Mbstatet>::operator __int64
	mov	QWORD PTR _Off$[rsp], rax

; 469  :         const auto _Gptr_old = _Mysb::gptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	QWORD PTR _Gptr_old$[rsp], rax

; 470  :         const auto _Pptr_old = (_Mystate & _Constant) ? nullptr : _Mysb::pptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN16@seekpos
	mov	QWORD PTR tv131[rsp], 0
	jmp	SHORT $LN17@seekpos
$LN16@seekpos:
	mov	rcx, QWORD PTR this$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	QWORD PTR tv131[rsp], rax
$LN17@seekpos:
	mov	rax, QWORD PTR tv131[rsp]
	mov	QWORD PTR _Pptr_old$[rsp], rax

; 471  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

	cmp	QWORD PTR _Pptr_old$[rsp], 0
	je	SHORT $LN4@seekpos
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pptr_old$[rsp]
	cmp	QWORD PTR [rax+104], rcx
	jae	SHORT $LN4@seekpos

; 472  :             _Seekhigh = _Pptr_old;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pptr_old$[rsp]
	mov	QWORD PTR [rax+104], rcx
$LN4@seekpos:

; 473  :         }
; 474  : 
; 475  :         const auto _Seeklow  = _Mysb::eback();

	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	QWORD PTR _Seeklow$[rsp], rax

; 476  :         const auto _Seekdist = _Seekhigh - _Seeklow;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Seeklow$[rsp]
	mov	rax, QWORD PTR [rax+104]
	sub	rax, rcx
	mov	QWORD PTR _Seekdist$[rsp], rax

; 477  :         if (static_cast<unsigned long long>(_Off) > static_cast<unsigned long long>(_Seekdist)) {

	mov	rax, QWORD PTR _Seekdist$[rsp]
	cmp	QWORD PTR _Off$[rsp], rax
	jbe	SHORT $LN5@seekpos

; 478  :             return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@seekpos
$LN5@seekpos:

; 479  :         }
; 480  : 
; 481  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

	cmp	QWORD PTR _Off$[rsp], 0
	je	SHORT $LN6@seekpos
	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@seekpos
	cmp	QWORD PTR _Gptr_old$[rsp], 0
	je	SHORT $LN7@seekpos
$LN8@seekpos:
	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN6@seekpos
	cmp	QWORD PTR _Pptr_old$[rsp], 0
	jne	SHORT $LN6@seekpos
$LN7@seekpos:

; 482  :             return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@seekpos
$LN6@seekpos:

; 483  :         }
; 484  : 
; 485  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Seeklow$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Newptr$[rsp], rax

; 486  :         if ((_Mode & ios_base::in) && _Gptr_old) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@seekpos
	cmp	QWORD PTR _Gptr_old$[rsp], 0
	je	SHORT $LN9@seekpos

; 487  :             _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);

	mov	rax, QWORD PTR this$[rsp]
	mov	r9, QWORD PTR [rax+104]
	mov	r8, QWORD PTR _Newptr$[rsp]
	mov	rdx, QWORD PTR _Seeklow$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
	npad	1
$LN9@seekpos:

; 488  :         }
; 489  : 
; 490  :         if ((_Mode & ios_base::out) && _Pptr_old) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@seekpos
	cmp	QWORD PTR _Pptr_old$[rsp], 0
	je	SHORT $LN10@seekpos

; 491  :             _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());

	mov	rcx, QWORD PTR this$[rsp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	mov	r9, rax
	mov	r8, QWORD PTR _Newptr$[rsp]
	mov	rdx, QWORD PTR _Seeklow$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
	npad	1
$LN10@seekpos:

; 492  :         }
; 493  : 
; 494  :         return pos_type{_Off};

	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekpos:

; 495  :     }

	add	rsp, 104				; 00000068H
	ret	0
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv69 = 32
tv75 = 33
_Need_read_but_cannot$ = 34
_Need_write_but_cannot$ = 35
_Seeklow$ = 40
tv142 = 48
_Pptr_old$ = 56
_Newoff$ = 64
_Gptr_old$ = 72
tv129 = 80
_Seekdist$ = 88
_Newptr$ = 96
_Both$1 = 104
this$ = 128
__$ReturnUdt$ = 136
_Off$ = 144
_Way$ = 152
_Mode$ = 160
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT

; 394  :         off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode = ios_base::in | ios_base::out) override {

$LN31:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 395  :         const bool _Need_read_but_cannot  = (_Mode & ios_base::in) != 0 && (_Mystate & _Noread) != 0;

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN25@seekoff
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN25@seekoff
	mov	BYTE PTR tv69[rsp], 1
	jmp	SHORT $LN26@seekoff
$LN25@seekoff:
	mov	BYTE PTR tv69[rsp], 0
$LN26@seekoff:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR _Need_read_but_cannot$[rsp], al

; 396  :         const bool _Need_write_but_cannot = (_Mode & ios_base::out) != 0 && (_Mystate & _Constant) != 0;

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN27@seekoff
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN27@seekoff
	mov	BYTE PTR tv75[rsp], 1
	jmp	SHORT $LN28@seekoff
$LN27@seekoff:
	mov	BYTE PTR tv75[rsp], 0
$LN28@seekoff:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR _Need_write_but_cannot$[rsp], al

; 397  :         if (_Need_read_but_cannot || _Need_write_but_cannot) {

	movzx	eax, BYTE PTR _Need_read_but_cannot$[rsp]
	test	eax, eax
	jne	SHORT $LN5@seekoff
	movzx	eax, BYTE PTR _Need_write_but_cannot$[rsp]
	test	eax, eax
	je	SHORT $LN4@seekoff
$LN5@seekoff:

; 398  :             return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@seekoff
$LN4@seekoff:

; 399  :         }
; 400  : 
; 401  :         // change position by _Off, according to _Way, _Mode
; 402  :         const auto _Gptr_old = _Mysb::gptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	QWORD PTR _Gptr_old$[rsp], rax

; 403  :         const auto _Pptr_old = (_Mystate & _Constant) ? nullptr : _Mysb::pptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN29@seekoff
	mov	QWORD PTR tv129[rsp], 0
	jmp	SHORT $LN30@seekoff
$LN29@seekoff:
	mov	rcx, QWORD PTR this$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	QWORD PTR tv129[rsp], rax
$LN30@seekoff:
	mov	rax, QWORD PTR tv129[rsp]
	mov	QWORD PTR _Pptr_old$[rsp], rax

; 404  :         if (_Pptr_old && _Seekhigh < _Pptr_old) { // update high-water pointer

	cmp	QWORD PTR _Pptr_old$[rsp], 0
	je	SHORT $LN6@seekoff
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pptr_old$[rsp]
	cmp	QWORD PTR [rax+104], rcx
	jae	SHORT $LN6@seekoff

; 405  :             _Seekhigh = _Pptr_old;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pptr_old$[rsp]
	mov	QWORD PTR [rax+104], rcx
$LN6@seekoff:

; 406  :         }
; 407  : 
; 408  :         const auto _Seeklow  = _Mysb::eback();

	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	QWORD PTR _Seeklow$[rsp], rax

; 409  :         const auto _Seekdist = _Seekhigh - _Seeklow;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Seeklow$[rsp]
	mov	rax, QWORD PTR [rax+104]
	sub	rax, rcx
	mov	QWORD PTR _Seekdist$[rsp], rax

; 410  :         off_type _Newoff;
; 411  :         switch (_Way) {

	mov	eax, DWORD PTR _Way$[rsp]
	mov	DWORD PTR tv142[rsp], eax
	cmp	DWORD PTR tv142[rsp], 0
	je	SHORT $LN7@seekoff
	cmp	DWORD PTR tv142[rsp], 1
	je	SHORT $LN9@seekoff
	cmp	DWORD PTR tv142[rsp], 2
	je	SHORT $LN8@seekoff
	jmp	$LN17@seekoff
$LN7@seekoff:

; 412  :         case ios_base::beg:
; 413  :             _Newoff = 0;

	mov	QWORD PTR _Newoff$[rsp], 0

; 414  :             break;

	jmp	$LN2@seekoff
$LN8@seekoff:

; 415  :         case ios_base::end:
; 416  :             _Newoff = _Seekdist;

	mov	rax, QWORD PTR _Seekdist$[rsp]
	mov	QWORD PTR _Newoff$[rsp], rax

; 417  :             break;

	jmp	$LN2@seekoff
$LN9@seekoff:

; 418  :         case ios_base::cur:
; 419  :             {
; 420  :                 constexpr auto _Both = ios_base::in | ios_base::out;

	mov	DWORD PTR _Both$1[rsp], 3

; 421  :                 if ((_Mode & _Both) != _Both) { // prohibited by N4950 [tab:stringbuf.seekoff.pos]

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 3
	cmp	eax, 3
	je	SHORT $LN10@seekoff

; 422  :                     if (_Mode & ios_base::in) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@seekoff

; 423  :                         if (_Gptr_old || !_Seeklow) {

	cmp	QWORD PTR _Gptr_old$[rsp], 0
	jne	SHORT $LN14@seekoff
	cmp	QWORD PTR _Seeklow$[rsp], 0
	jne	SHORT $LN13@seekoff
$LN14@seekoff:

; 424  :                             _Newoff = _Gptr_old - _Seeklow;

	mov	rax, QWORD PTR _Seeklow$[rsp]
	mov	rcx, QWORD PTR _Gptr_old$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Newoff$[rsp], rax

; 425  :                             break;

	jmp	SHORT $LN2@seekoff
$LN13@seekoff:

; 426  :                         }

	jmp	SHORT $LN12@seekoff
$LN11@seekoff:

; 427  :                     } else if ((_Mode & ios_base::out) && (_Pptr_old || !_Seeklow)) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN15@seekoff
	cmp	QWORD PTR _Pptr_old$[rsp], 0
	jne	SHORT $LN16@seekoff
	cmp	QWORD PTR _Seeklow$[rsp], 0
	jne	SHORT $LN15@seekoff
$LN16@seekoff:

; 428  :                         _Newoff = _Pptr_old - _Seeklow;

	mov	rax, QWORD PTR _Seeklow$[rsp]
	mov	rcx, QWORD PTR _Pptr_old$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Newoff$[rsp], rax

; 429  :                         break;

	jmp	SHORT $LN2@seekoff
$LN15@seekoff:
$LN12@seekoff:
$LN10@seekoff:
$LN17@seekoff:

; 430  :                     }
; 431  :                 }
; 432  :             }
; 433  : 
; 434  :             _FALLTHROUGH;
; 435  :         default:
; 436  :             return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@seekoff
$LN2@seekoff:

; 437  :         }
; 438  : 
; 439  :         if (static_cast<unsigned long long>(_Off) + _Newoff > static_cast<unsigned long long>(_Seekdist)) {

	mov	rax, QWORD PTR _Newoff$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	add	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR _Seekdist$[rsp]
	jbe	SHORT $LN18@seekoff

; 440  :             return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@seekoff
$LN18@seekoff:

; 441  :         }
; 442  : 
; 443  :         _Off += _Newoff;

	mov	rax, QWORD PTR _Newoff$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Off$[rsp], rax

; 444  :         if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {

	cmp	QWORD PTR _Off$[rsp], 0
	je	SHORT $LN19@seekoff
	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN21@seekoff
	cmp	QWORD PTR _Gptr_old$[rsp], 0
	je	SHORT $LN20@seekoff
$LN21@seekoff:
	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN19@seekoff
	cmp	QWORD PTR _Pptr_old$[rsp], 0
	jne	SHORT $LN19@seekoff
$LN20@seekoff:

; 445  :             return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@seekoff
$LN19@seekoff:

; 446  :         }
; 447  : 
; 448  :         const auto _Newptr = _Seeklow + _Off; // may perform nullptr + 0

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Seeklow$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Newptr$[rsp], rax

; 449  :         if ((_Mode & ios_base::in) && _Gptr_old) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@seekoff
	cmp	QWORD PTR _Gptr_old$[rsp], 0
	je	SHORT $LN22@seekoff

; 450  :             _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);

	mov	rax, QWORD PTR this$[rsp]
	mov	r9, QWORD PTR [rax+104]
	mov	r8, QWORD PTR _Newptr$[rsp]
	mov	rdx, QWORD PTR _Seeklow$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
	npad	1
$LN22@seekoff:

; 451  :         }
; 452  : 
; 453  :         if ((_Mode & ios_base::out) && _Pptr_old) {

	mov	eax, DWORD PTR _Mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN23@seekoff
	cmp	QWORD PTR _Pptr_old$[rsp], 0
	je	SHORT $LN23@seekoff

; 454  :             _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());

	mov	rcx, QWORD PTR this$[rsp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	mov	r9, rax
	mov	r8, QWORD PTR _Newptr$[rsp]
	mov	rdx, QWORD PTR _Seeklow$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
	npad	1
$LN23@seekoff:

; 455  :         }
; 456  : 
; 457  :         return pos_type{_Off};

	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@seekoff:

; 458  :     }

	add	rsp, 120				; 00000078H
	ret	0
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
_TEXT	SEGMENT
_Gptr$ = 32
_Local_highwater$ = 40
_Pptr$ = 48
tv154 = 56
tv152 = 64
this$ = 96
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT

; 367  :     int_type underflow() override { // get an element from stream, but don't point past it

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 368  :         const auto _Gptr = _Mysb::gptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	QWORD PTR _Gptr$[rsp], rax

; 369  :         if (!_Gptr) { // no character buffer, fail

	cmp	QWORD PTR _Gptr$[rsp], 0
	jne	SHORT $LN2@underflow

; 370  :             return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	jmp	$LN1@underflow
$LN2@underflow:

; 371  :         }
; 372  : 
; 373  :         if (_Gptr < _Mysb::egptr()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	cmp	QWORD PTR _Gptr$[rsp], rax
	jae	SHORT $LN3@underflow

; 374  :             return _Traits::to_int_type(*_Gptr);

	mov	rax, QWORD PTR _Gptr$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	jmp	$LN1@underflow
$LN3@underflow:

; 375  :         }
; 376  : 
; 377  :         // try to add initialized characters from the put area into the get area
; 378  :         const auto _Pptr = _Mysb::pptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	QWORD PTR _Pptr$[rsp], rax

; 379  :         if (!_Pptr || (_Mystate & _Noread)) { // no put area or read disallowed

	cmp	QWORD PTR _Pptr$[rsp], 0
	je	SHORT $LN5@underflow
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN4@underflow
$LN5@underflow:

; 380  :             return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	jmp	$LN1@underflow
$LN4@underflow:

; 381  :         }
; 382  : 
; 383  :         const auto _Local_highwater = (_STD max)(_Seekhigh, _Pptr);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	lea	rdx, QWORD PTR _Pptr$[rsp]
	mov	rcx, rax
	call	??$max@PEAD@std@@YAAEBQEADAEBQEAD0@Z	; std::max<char *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Local_highwater$[rsp], rax

; 384  :         if (_Local_highwater <= _Gptr) { // nothing in the put area to take

	mov	rax, QWORD PTR _Gptr$[rsp]
	cmp	QWORD PTR _Local_highwater$[rsp], rax
	ja	SHORT $LN6@underflow

; 385  :             return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	jmp	SHORT $LN1@underflow
$LN6@underflow:

; 386  :         }
; 387  : 
; 388  :         _Seekhigh = _Local_highwater;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Local_highwater$[rsp]
	mov	QWORD PTR [rax+104], rcx

; 389  :         _Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Local_highwater);

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	QWORD PTR tv154[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	QWORD PTR tv152[rsp], rax
	mov	r9, QWORD PTR _Local_highwater$[rsp]
	mov	r8, QWORD PTR tv154[rsp]
	mov	rdx, QWORD PTR tv152[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg

; 390  :         return _Traits::to_int_type(*_Mysb::gptr());

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	movzx	ecx, BYTE PTR [rax]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
$LN1@underflow:

; 391  :     }

	add	rsp, 88					; 00000058H
	ret	0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
tv94 = 32
tv92 = 33
tv154 = 34
_Gptr$ = 40
this$ = 64
_Meta$ = 72
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT

; 350  :     int_type pbackfail(int_type _Meta = _Traits::eof()) override { // put an element back to stream

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 351  :         const auto _Gptr = _Mysb::gptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	QWORD PTR _Gptr$[rsp], rax

; 352  :         if (!_Gptr || _Gptr <= _Mysb::eback()
; 353  :             || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])

	cmp	QWORD PTR _Gptr$[rsp], 0
	je	SHORT $LN3@pbackfail
	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	cmp	QWORD PTR _Gptr$[rsp], rax
	jbe	SHORT $LN3@pbackfail
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	edx, DWORD PTR _Meta$[rsp]
	mov	ecx, eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@pbackfail
	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Gptr$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tv94[rsp], al
	mov	ecx, DWORD PTR _Meta$[rsp]
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	mov	BYTE PTR tv92[rsp], al
	movzx	edx, BYTE PTR tv94[rsp]
	movzx	ecx, BYTE PTR tv92[rsp]
	call	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ; std::_Narrow_char_traits<char,int>::eq
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@pbackfail
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN2@pbackfail
$LN3@pbackfail:

; 354  :                 && (_Mystate & _Constant))) { // can't put back, fail
; 355  :             return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	jmp	SHORT $LN1@pbackfail
$LN2@pbackfail:

; 356  :         }
; 357  : 
; 358  :         // back up one position and store put-back character
; 359  :         _Mysb::gbump(-1);

	mov	edx, -1
	mov	rcx, QWORD PTR this$[rsp]
	call	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
	npad	1

; 360  :         if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	edx, DWORD PTR _Meta$[rsp]
	mov	ecx, eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@pbackfail

; 361  :             *_Mysb::gptr() = _Traits::to_char_type(_Meta);

	mov	ecx, DWORD PTR _Meta$[rsp]
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	mov	BYTE PTR tv154[rsp], al
	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	movzx	ecx, BYTE PTR tv154[rsp]
	mov	BYTE PTR [rax], cl
$LN4@pbackfail:

; 362  :         }
; 363  : 
; 364  :         return _Traits::not_eof(_Meta);

	mov	ecx, DWORD PTR _Meta$[rsp]
	call	?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z ; std::_Narrow_char_traits<char,int>::not_eof
$LN1@pbackfail:

; 365  :     }

	add	rsp, 56					; 00000038H
	ret	0
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
tv131 = 32
tv223 = 33
_Newptr$ = 40
_Oldsize$ = 48
_Pptr$ = 56
_Newsize$ = 64
_Oldptr$ = 72
_Epptr$ = 80
_New_pnext$ = 88
tv199 = 96
tv197 = 104
tv210 = 112
this$ = 144
_Meta$ = 152
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT

; 293  :     int_type overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

$LN16:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 294  :         if (_Mystate & _Constant) {

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN2@overflow

; 295  :             return _Traits::eof(); // array nonmutable, fail

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	jmp	$LN1@overflow
$LN2@overflow:

; 296  :         }
; 297  : 
; 298  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	edx, DWORD PTR _Meta$[rsp]
	mov	ecx, eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@overflow

; 299  :             return _Traits::not_eof(_Meta); // EOF, return success code

	mov	ecx, DWORD PTR _Meta$[rsp]
	call	?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z ; std::_Narrow_char_traits<char,int>::not_eof
	jmp	$LN1@overflow
$LN3@overflow:

; 300  :         }
; 301  : 
; 302  :         const auto _Pptr  = _Mysb::pptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	QWORD PTR _Pptr$[rsp], rax

; 303  :         const auto _Epptr = _Mysb::epptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	mov	QWORD PTR _Epptr$[rsp], rax

; 304  :         if (_Pptr && _Pptr < _Epptr) { // room in buffer, store it

	cmp	QWORD PTR _Pptr$[rsp], 0
	je	SHORT $LN4@overflow
	mov	rax, QWORD PTR _Epptr$[rsp]
	cmp	QWORD PTR _Pptr$[rsp], rax
	jae	SHORT $LN4@overflow

; 305  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	ecx, DWORD PTR _Meta$[rsp]
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	mov	BYTE PTR tv131[rsp], al
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	movzx	ecx, BYTE PTR tv131[rsp]
	mov	BYTE PTR [rax], cl

; 306  :             _Seekhigh        = _Pptr + 1;

	mov	rax, QWORD PTR _Pptr$[rsp]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 307  :             return _Meta;

	mov	eax, DWORD PTR _Meta$[rsp]
	jmp	$LN1@overflow
$LN4@overflow:

; 308  :         }
; 309  : 
; 310  :         // grow buffer and store element
; 311  :         _Mysize_type _Oldsize = 0;

	mov	QWORD PTR _Oldsize$[rsp], 0

; 312  :         const auto _Oldptr    = _Mysb::eback();

	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	QWORD PTR _Oldptr$[rsp], rax

; 313  :         if (_Pptr) {

	cmp	QWORD PTR _Pptr$[rsp], 0
	je	SHORT $LN5@overflow

; 314  :             _Oldsize = static_cast<_Mysize_type>(_Epptr - _Oldptr);

	mov	rax, QWORD PTR _Oldptr$[rsp]
	mov	rcx, QWORD PTR _Epptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Oldsize$[rsp], rax
$LN5@overflow:

; 315  :         }
; 316  : 
; 317  :         _Mysize_type _Newsize;
; 318  :         if (_Oldsize < _MINSIZE) {

	cmp	QWORD PTR _Oldsize$[rsp], 32		; 00000020H
	jae	SHORT $LN6@overflow

; 319  :             _Newsize = _MINSIZE;

	mov	QWORD PTR _Newsize$[rsp], 32		; 00000020H
	jmp	SHORT $LN7@overflow
$LN6@overflow:

; 320  :         } else if (_Oldsize < INT_MAX / 2) { // grow by 50 percent

	cmp	QWORD PTR _Oldsize$[rsp], 1073741823	; 3fffffffH
	jae	SHORT $LN8@overflow

; 321  :             _Newsize = _Oldsize << 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	shl	rax, 1
	mov	QWORD PTR _Newsize$[rsp], rax
	jmp	SHORT $LN9@overflow
$LN8@overflow:

; 322  :         } else if (_Oldsize < INT_MAX) {

	cmp	QWORD PTR _Oldsize$[rsp], 2147483647	; 7fffffffH
	jae	SHORT $LN10@overflow

; 323  :             _Newsize = INT_MAX;

	mov	QWORD PTR _Newsize$[rsp], 2147483647	; 7fffffffH

; 324  :         } else { // buffer can't grow, fail

	jmp	SHORT $LN11@overflow
$LN10@overflow:

; 325  :             return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	jmp	$LN1@overflow
$LN11@overflow:
$LN9@overflow:
$LN7@overflow:

; 326  :         }
; 327  : 
; 328  :         const auto _Newptr = _Unfancy(_Allocate_at_least_helper(_Al, _Newsize));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 116				; 00000074H
	lea	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, rax
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	rcx, rax
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Newptr$[rsp], rax

; 329  :         _Traits::copy(_Newptr, _Oldptr, _Oldsize);

	mov	r8, QWORD PTR _Oldsize$[rsp]
	mov	rdx, QWORD PTR _Oldptr$[rsp]
	mov	rcx, QWORD PTR _Newptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 330  : 
; 331  :         const auto _New_pnext = _Newptr + _Oldsize;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	mov	rcx, QWORD PTR _Newptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_pnext$[rsp], rax

; 332  :         _Seekhigh             = _New_pnext + 1; // to include _Meta

	mov	rax, QWORD PTR _New_pnext$[rsp]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 333  : 
; 334  :         _Mysb::setp(_Newptr, _New_pnext, _Newptr + _Newsize);

	mov	rax, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR _Newptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, rax
	mov	r8, QWORD PTR _New_pnext$[rsp]
	mov	rdx, QWORD PTR _Newptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
	npad	1

; 335  :         if (_Mystate & _Noread) { // maintain eback() == allocated pointer invariant

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN12@overflow

; 336  :             _Mysb::setg(_Newptr, _Newptr, _Newptr);

	mov	r9, QWORD PTR _Newptr$[rsp]
	mov	r8, QWORD PTR _Newptr$[rsp]
	mov	rdx, QWORD PTR _Newptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
	npad	1

; 337  :         } else { // if readable, set the get area to initialized region

	jmp	SHORT $LN13@overflow
$LN12@overflow:

; 338  :             _Mysb::setg(_Newptr, _Newptr + (_Mysb::gptr() - _Oldptr), _Seekhigh);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR tv199[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	sub	rax, QWORD PTR _Oldptr$[rsp]
	mov	rcx, QWORD PTR _Newptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv197[rsp], rax
	mov	r9, QWORD PTR tv199[rsp]
	mov	r8, QWORD PTR tv197[rsp]
	mov	rdx, QWORD PTR _Newptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
	npad	1
$LN13@overflow:

; 339  :         }
; 340  : 
; 341  :         if (_Mystate & _Allocated) {

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN14@overflow

; 342  :             _Al.deallocate(_Ptr_traits::pointer_to(*_Oldptr), _Oldsize);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 116				; 00000074H
	mov	QWORD PTR tv210[rsp], rax
	mov	rcx, QWORD PTR _Oldptr$[rsp]
	call	?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char *>::pointer_to
	mov	r8, QWORD PTR _Oldsize$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv210[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN14@overflow:

; 343  :         }
; 344  : 
; 345  :         _Mystate |= _Allocated;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+112]
	or	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+112], eax

; 346  :         *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	ecx, DWORD PTR _Meta$[rsp]
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	mov	BYTE PTR tv223[rsp], al
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	movzx	ecx, BYTE PTR tv223[rsp]
	mov	BYTE PTR [rax], cl

; 347  :         return _Meta;

	mov	eax, DWORD PTR _Meta$[rsp]
$LN1@overflow:

; 348  :     }

	add	rsp, 136				; 00000088H
	ret	0
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 172  :     ~basic_stringbuf() noexcept override {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rax], rcx

; 173  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	npad	1

; 174  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_no_alias, COMDAT

; 139  :         noexcept(_Choose_pocma_v<_Alloc> != _Pocma_values::_No_propagate_allocators) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 140  :         // pre: this != std::addressof(_Right)
; 141  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	npad	1

; 142  :         if constexpr (_Choose_pocma_v<_Alloc> == _Pocma_values::_No_propagate_allocators) {
; 143  :             if (_Al == _Right._Al) {
; 144  :                 _Take_contents(_STD move(_Right));
; 145  :             } else {
; 146  :                 _Copy_into_self_and_tidy(_STD move(_Right));
; 147  :             }
; 148  :         } else {
; 149  :             _Pocma(_Al, _Right._Al);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 116				; 00000074H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 116				; 00000074H
	mov	rdx, rax
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >

; 150  :             _Take_contents(_STD move(_Right));

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 151  :         }
; 152  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Assign_rv_no_alias@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_no_alias
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
this$ = 64
_Right$ = 72
?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 96   :     void _Take_contents(basic_stringbuf&& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 97   :         // pre: *this holds no dynamic buffer and _Al == _Right._Al
; 98   :         _Seekhigh = _STD exchange(_Right._Seekhigh, nullptr);

	mov	QWORD PTR $T2[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 104				; 00000068H
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	??$exchange@PEAD$$T@std@@YAPEADAEAPEAD$$QEA$$T@Z ; std::exchange<char *,std::nullptr_t>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+104], rax

; 99   :         _Mystate  = _STD exchange(_Right._Mystate, 0);

	mov	DWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 112				; 00000070H
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@HH@std@@YAHAEAH$$QEAH@Z	; std::exchange<int,int>
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+112], eax

; 100  :         _Mysb::swap(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z ; std::basic_streambuf<char,std::char_traits<char> >::swap
	npad	1

; 101  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Take_contents@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
tv130 = 32
tv128 = 40
tv94 = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 38   :     explicit basic_stringbuf(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 39   :         : _Al(_Str.get_allocator()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 116				; 00000074H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Str$[rsp]
	call	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator

; 40   :         _Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));

	mov	ecx, DWORD PTR _Mode$[rsp]
	call	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
	mov	DWORD PTR tv130[rsp], eax
	mov	rcx, QWORD PTR _Str$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR tv128[rsp], rax
	mov	rcx, QWORD PTR _Str$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv94[rsp], rax
	mov	r9d, DWORD PTR tv130[rsp]
	mov	r8, QWORD PTR tv128[rsp]
	mov	rdx, QWORD PTR tv94[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
	npad	1

; 41   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv130 = 32
tv128 = 40
tv94 = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 48
_Mode$ = 56
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 36   :     explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+104], 0
	mov	ecx, DWORD PTR _Mode$[rsp]
	call	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+112], eax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 116				; 00000074H
	mov	rcx, rax
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Mode$ = 56
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_ostream.hpp
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
_TEXT	SEGMENT
_State$1 = 32
_Rdbuf$ = 40
tv135 = 48
tv150 = 56
_Ok$2 = 64
this$ = 96
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT

; 562  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 563  :         const auto _Rdbuf = _Myios::rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 564  :         if (_Rdbuf) { // buffer exists, flush it

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@flush

; 565  :             const sentry _Ok(*this);

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 566  : 
; 567  :             if (_Ok) {

	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@flush

; 568  :                 ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$1[rsp], 0

; 569  :                 _TRY_IO_BEGIN
; 570  :                 if (_Rdbuf->pubsync() == -1) {

	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	cmp	eax, -1
	jne	SHORT $LN5@flush

; 571  :                     _State |= ios_base::badbit; // sync failed

	mov	eax, DWORD PTR _State$1[rsp]
	or	eax, 4
	mov	DWORD PTR _State$1[rsp], eax
$LN5@flush:
	jmp	SHORT $LN10@flush
$LN11@flush:
$LN10@flush:

; 572  :                 }
; 573  :                 _CATCH_IO_END
; 574  :                 _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv150[rsp], rax
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$1[rsp]
	mov	rcx, QWORD PTR tv150[rsp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN3@flush:

; 575  :             }
; 576  :         }

	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	npad	1
$LN2@flush:

; 577  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 578  :     }

	add	rsp, 88					; 00000058H
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$1 = 32
_Rdbuf$ = 40
tv135 = 48
tv150 = 56
_Ok$2 = 64
this$ = 96
?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$2[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$1 = 32
_Rdbuf$ = 40
tv135 = 48
tv150 = 56
_Ok$2 = 64
this$ = 96
?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::catch$1

; 573  :                 _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv135[rbp], rax
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, QWORD PTR tv135[rbp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN11@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_ostream.hpp
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv153 = 32
this$ = 64
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT

; 159  :     void __CLR_OR_THIS_CALL _Osfx() noexcept { // perform any wrapup

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 160  :         _TRY_BEGIN
; 161  :         if (this->good() && this->flags() & ios_base::unitbuf) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	$LN3@Osfx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@Osfx

; 162  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	rcx, rax
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	cmp	eax, -1
	jne	SHORT $LN3@Osfx

; 163  :                 _Myios::setstate(ios_base::badbit);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv153[rsp], rax
	xor	r8d, r8d
	mov	edx, 4
	mov	rcx, QWORD PTR tv153[rsp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN3@Osfx:
	jmp	SHORT $LN8@Osfx
$LN9@Osfx:
$LN8@Osfx:

; 164  :             }
; 165  :         }
; 166  :         _CATCH_ALL
; 167  :         _CATCH_END
; 168  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv153 = 32
this$ = 64
?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::_Osfx'::`1'::catch$0

; 166  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ$0:

; 167  :         _CATCH_END

	lea	rax, $LN9@catch$0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::_Osfx'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 104				; 00000068H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT

; 380  :     virtual void __CLR_OR_THIS_CALL imbue(const locale&) {} // set locale to argument (do nothing)

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 8
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT

; 376  :     virtual int __CLR_OR_THIS_CALL sync() { // synchronize with external agent (do nothing)

	mov	QWORD PTR [rsp+8], rcx

; 377  :         return 0;

	xor	eax, eax

; 378  :     }

	ret	0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT

; 371  :     virtual basic_streambuf* __CLR_OR_THIS_CALL setbuf(_Elem*, streamsize) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 372  :         // offer buffer to external agent (do nothing)
; 373  :         return this;

	mov	rax, QWORD PTR this$[rsp]

; 374  :     }

	ret	0
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
__formal$ = 64
__formal$ = 72
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT

; 366  :     virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 367  :         // change to specified position, according to mode
; 368  :         return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 369  :     }

	add	rsp, 40					; 00000028H
	ret	0
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
__formal$ = 64
__formal$ = 72
__formal$ = 80
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT

; 361  :         off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 362  :         // change position by offset, according to way and mode
; 363  :         return pos_type{off_type{-1}};

	mov	rdx, -1
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 364  :     }

	add	rsp, 40					; 00000028H
	ret	0
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
_TEXT	SEGMENT
tv87 = 32
tv128 = 36
tv94 = 40
_Size$1 = 48
tv89 = 56
_Start_count$ = 64
this$ = 96
_Ptr$ = 104
_Count$ = 112
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT

; 335  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 336  :         // put _Count characters to stream
; 337  :         const streamsize _Start_count = _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Start_count$[rsp], rax
$LN2@xsputn:

; 338  :         while (0 < _Count) {

	cmp	QWORD PTR _Count$[rsp], 0
	jle	$LN3@xsputn

; 339  :             streamsize _Size = _Pnavail();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
	mov	QWORD PTR _Size$1[rsp], rax

; 340  :             if (0 < _Size) { // copy to write buffer

	cmp	QWORD PTR _Size$1[rsp], 0
	jle	SHORT $LN4@xsputn

; 341  :                 if (_Count < _Size) {

	mov	rax, QWORD PTR _Size$1[rsp]
	cmp	QWORD PTR _Count$[rsp], rax
	jge	SHORT $LN6@xsputn

; 342  :                     _Size = _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Size$1[rsp], rax
$LN6@xsputn:

; 343  :                 }
; 344  : 
; 345  :                 _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));

	mov	rcx, QWORD PTR this$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	r8, QWORD PTR _Size$1[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 346  :                 _Ptr += _Size;

	mov	rax, QWORD PTR _Size$1[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Ptr$[rsp], rax

; 347  :                 _Count -= _Size;

	mov	rax, QWORD PTR _Size$1[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rsp], rax

; 348  :                 pbump(static_cast<int>(_Size));

	mov	edx, DWORD PTR _Size$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
	npad	1
	jmp	SHORT $LN5@xsputn
$LN4@xsputn:

; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv89[rsp], rax
	mov	rax, QWORD PTR _Ptr$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	mov	DWORD PTR tv87[rsp], eax
	mov	edx, DWORD PTR tv87[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv89[rsp]
	mov	DWORD PTR tv128[rsp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv94[rsp], eax
	mov	edx, DWORD PTR tv128[rsp]
	mov	ecx, DWORD PTR tv94[rsp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@xsputn

; 350  :                 break; // single character put failed, quit

	jmp	SHORT $LN3@xsputn

; 351  :             } else { // count character successfully put

	jmp	SHORT $LN8@xsputn
$LN7@xsputn:

; 352  :                 ++_Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 353  :                 --_Count;

	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN8@xsputn:
$LN5@xsputn:

; 354  :             }
; 355  :         }

	jmp	$LN2@xsputn
$LN3@xsputn:

; 356  : 
; 357  :         return _Start_count - _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Start_count$[rsp]
	sub	rcx, rax
	mov	rax, rcx

; 358  :     }

	add	rsp, 88					; 00000058H
	ret	0
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
_TEXT	SEGMENT
_Meta$1 = 32
_Size$2 = 40
_Start_count$ = 48
this$ = 80
_Ptr$ = 88
_Count$ = 96
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT

; 306  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) { // get _Count characters from stream

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 307  :         const streamsize _Start_count = _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Start_count$[rsp], rax
$LN2@xsgetn:

; 308  : 
; 309  :         while (0 < _Count) {

	cmp	QWORD PTR _Count$[rsp], 0
	jle	$LN3@xsgetn

; 310  :             streamsize _Size = _Gnavail();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	QWORD PTR _Size$2[rsp], rax

; 311  :             if (0 < _Size) { // copy from read buffer

	cmp	QWORD PTR _Size$2[rsp], 0
	jle	SHORT $LN4@xsgetn

; 312  :                 if (_Count < _Size) {

	mov	rax, QWORD PTR _Size$2[rsp]
	cmp	QWORD PTR _Count$[rsp], rax
	jge	SHORT $LN6@xsgetn

; 313  :                     _Size = _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Size$2[rsp], rax
$LN6@xsgetn:

; 314  :                 }
; 315  : 
; 316  :                 _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	r8, QWORD PTR _Size$2[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 317  :                 _Ptr += _Size;

	mov	rax, QWORD PTR _Size$2[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Ptr$[rsp], rax

; 318  :                 _Count -= _Size;

	mov	rax, QWORD PTR _Size$2[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rsp], rax

; 319  :                 gbump(static_cast<int>(_Size));

	mov	edx, DWORD PTR _Size$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
	npad	1

; 320  :             } else {

	jmp	SHORT $LN5@xsgetn
$LN4@xsgetn:

; 321  :                 const int_type _Meta = uflow();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+56]
	mov	DWORD PTR _Meta$1[rsp], eax

; 322  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	edx, DWORD PTR _Meta$1[rsp]
	mov	ecx, eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@xsgetn

; 323  :                     break; // end of file, quit

	jmp	SHORT $LN3@xsgetn
$LN7@xsgetn:

; 324  :                 }
; 325  : 
; 326  :                 // get a single character
; 327  :                 *_Ptr++ = _Traits::to_char_type(_Meta);

	mov	ecx, DWORD PTR _Meta$1[rsp]
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 328  :                 --_Count;

	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
$LN5@xsgetn:

; 329  :             }
; 330  :         }

	jmp	$LN2@xsgetn
$LN3@xsgetn:

; 331  : 
; 332  :         return _Start_count - _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Start_count$[rsp]
	sub	rcx, rax
	mov	rax, rcx

; 333  :     }

	add	rsp, 72					; 00000048H
	ret	0
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
tv83 = 32
tv75 = 36
tv73 = 40
this$ = 64
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT

; 302  :     virtual int_type __CLR_OR_THIS_CALL uflow() { // get a character from stream, point past it

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 303  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+48]
	mov	DWORD PTR tv75[rsp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv73[rsp], eax
	mov	edx, DWORD PTR tv75[rsp]
	mov	ecx, DWORD PTR tv73[rsp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@uflow
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv83[rsp], eax
	jmp	SHORT $LN4@uflow
$LN3@uflow:
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
	movzx	ecx, BYTE PTR [rax]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	mov	DWORD PTR tv83[rsp], eax
$LN4@uflow:
	mov	eax, DWORD PTR tv83[rsp]

; 304  :     }

	add	rsp, 56					; 00000038H
	ret	0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT

; 298  :     virtual int_type __CLR_OR_THIS_CALL underflow() { // get a character from stream, but don't point past it

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 299  :         return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof

; 300  :     }

	add	rsp, 40					; 00000028H
	ret	0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
_TEXT	SEGMENT
this$ = 8
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT

; 294  :     virtual streamsize __CLR_OR_THIS_CALL showmanyc() {

	mov	QWORD PTR [rsp+8], rcx

; 295  :         return 0;

	xor	eax, eax

; 296  :     }

	ret	0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 289  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type = _Traits::eof()) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 290  :         // put a character back to stream (always fail)
; 291  :         return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof

; 292  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT

; 285  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type = _Traits::eof()) { // put a character to stream (always fail)

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 286  :         return _Traits::eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof

; 287  :     }

	add	rsp, 40					; 00000028H
	ret	0
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT

; 264  :     void __CLR_OR_THIS_CALL _Init() noexcept { // initialize buffer parameters for no buffers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 265  :         _IGfirst = &_Gfirst;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 266  :         _IPfirst = &_Pfirst;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 267  :         _IGnext  = &_Gnext;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 268  :         _IPnext  = &_Pnext;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 269  :         _IGcount = &_Gcount;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 270  :         _IPcount = &_Pcount;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 76					; 0000004cH
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+88], rax

; 271  :         setp(nullptr, nullptr);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp

; 272  :         setg(nullptr, nullptr, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
	npad	1

; 273  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT

; 260  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const noexcept { // count number of available positions in write buffer

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 261  :         return *_IPnext ? *_IPcount : 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Pnavail
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN4@Pnavail
$LN3@Pnavail:
	mov	DWORD PTR tv69[rsp], 0
$LN4@Pnavail:
	movsxd	rax, DWORD PTR tv69[rsp]

; 262  :     }

	add	rsp, 24
	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
_TEXT	SEGMENT
tv76 = 0
this$ = 32
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT

; 255  :     _Elem* __CLR_OR_THIS_CALL _Pninc() noexcept { // increment current position in write buffer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 256  :         --*_IPcount;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	DWORD PTR [rcx], eax

; 257  :         return (*_IPnext)++;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR tv76[rsp]

; 258  :     }

	add	rsp, 24
	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Next$ = 24
_Last$ = 32
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT

; 248  :     void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 249  :         // set pointers for write buffer, extended version
; 250  :         *_IPfirst = _First;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 251  :         *_IPnext  = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR _Next$[rsp]
	mov	QWORD PTR [rax], rcx

; 252  :         *_IPcount = static_cast<int>(_Last - _Next);

	mov	rax, QWORD PTR _Next$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	DWORD PTR [rcx], eax

; 253  :     }

	ret	0
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT

; 241  :     void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Last) noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 242  :         // set pointers for write buffer
; 243  :         *_IPfirst = _First;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 244  :         *_IPnext  = _First;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 245  :         *_IPcount = static_cast<int>(_Last - _First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	DWORD PTR [rcx], eax

; 246  :     }

	ret	0
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT

; 235  :     void __CLR_OR_THIS_CALL pbump(int _Off) noexcept /* strengthened */ {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 236  :         // alter current position in write buffer by _Off
; 237  :         *_IPcount -= _Off;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	ecx, DWORD PTR _Off$[rsp]
	mov	eax, DWORD PTR [rax]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	DWORD PTR [rcx], eax

; 238  :         *_IPnext += _Off;

	movsxd	rax, DWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rcx], rax

; 239  :     }

	ret	0
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT

; 231  :     streamsize __CLR_OR_THIS_CALL _Gnavail() const noexcept { // count number of available elements in read buffer

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 232  :         return *_IGnext ? *_IGcount : 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Gnavail
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN4@Gnavail
$LN3@Gnavail:
	mov	DWORD PTR tv69[rsp], 0
$LN4@Gnavail:
	movsxd	rax, DWORD PTR tv69[rsp]

; 233  :     }

	add	rsp, 24
	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
_TEXT	SEGMENT
tv72 = 0
this$ = 32
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT

; 226  :     _Elem* __CLR_OR_THIS_CALL _Gnpreinc() noexcept { // preincrement current position in read buffer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 227  :         --*_IGcount;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	DWORD PTR [rcx], eax

; 228  :         return ++(*_IGnext);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR tv72[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR tv72[rsp]

; 229  :     }

	add	rsp, 24
	ret	0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
_TEXT	SEGMENT
tv76 = 0
this$ = 32
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT

; 221  :     _Elem* __CLR_OR_THIS_CALL _Gninc() noexcept { // increment current position in read buffer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 222  :         --*_IGcount;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	DWORD PTR [rcx], eax

; 223  :         return (*_IGnext)++;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR tv76[rsp]

; 224  :     }

	add	rsp, 24
	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT

; 212  :     _Elem* __CLR_OR_THIS_CALL epptr() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 213  :         return *_IPnext + *_IPcount;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movsxd	rcx, DWORD PTR [rcx]
	add	rcx, QWORD PTR [rax]
	mov	rax, rcx

; 214  :     }

	ret	0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Next$ = 24
_Last$ = 32
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT

; 205  :     void __CLR_OR_THIS_CALL setg(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 206  :         // set pointers for read buffer
; 207  :         *_IGfirst = _First;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR _Next$[rsp]
	mov	QWORD PTR [rax], rcx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	mov	rax, QWORD PTR _Next$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	DWORD PTR [rcx], eax

; 210  :     }

	ret	0
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT

; 199  :     void __CLR_OR_THIS_CALL gbump(int _Off) noexcept /* strengthened */ {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 200  :         // alter current position in read buffer by _Off
; 201  :         *_IGcount -= _Off;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]
	mov	ecx, DWORD PTR _Off$[rsp]
	mov	eax, DWORD PTR [rax]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	DWORD PTR [rcx], eax

; 202  :         *_IGnext += _Off;

	movsxd	rax, DWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rcx], rax

; 203  :     }

	ret	0
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT

; 195  :     _Elem* __CLR_OR_THIS_CALL egptr() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 196  :         return *_IGnext + *_IGcount;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	movsxd	rcx, DWORD PTR [rcx]
	add	rcx, QWORD PTR [rax]
	mov	rax, rcx

; 197  :     }

	ret	0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT

; 191  :     _Elem* __CLR_OR_THIS_CALL pptr() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 192  :         return *_IPnext;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax]

; 193  :     }

	ret	0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbase, COMDAT

; 187  :     _Elem* __CLR_OR_THIS_CALL pbase() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 188  :         return *_IPfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax]

; 189  :     }

	ret	0
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT

; 183  :     _Elem* __CLR_OR_THIS_CALL gptr() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 184  :         return *_IGnext;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax]

; 185  :     }

	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT

; 179  :     _Elem* __CLR_OR_THIS_CALL eback() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 180  :         return *_IGfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rax]

; 181  :     }

	ret	0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 176  :     virtual void __CLR_OR_THIS_CALL _Unlock() {} // clear the thread lock (overridden by basic_filebuf)

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT

; 174  :     virtual void __CLR_OR_THIS_CALL _Lock() {} // set the thread lock (overridden by basic_filebuf)

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
_TEXT	SEGMENT
tv86 = 32
tv87 = 36
tv80 = 40
tv78 = 44
this$ = 64
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT

; 137  :     int_type __CLR_OR_THIS_CALL snextc() { // point to next character and return it

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 138  :         return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	cmp	rax, 1
	jle	SHORT $LN5@snextc
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
	movzx	ecx, BYTE PTR [rax]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	mov	DWORD PTR tv87[rsp], eax
	jmp	SHORT $LN6@snextc
$LN5@snextc:
	mov	rcx, QWORD PTR this$[rsp]
	call	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
	mov	DWORD PTR tv80[rsp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv78[rsp], eax
	mov	edx, DWORD PTR tv80[rsp]
	mov	ecx, DWORD PTR tv78[rsp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@snextc
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv86[rsp], eax
	jmp	SHORT $LN4@snextc
$LN3@snextc:
	mov	rcx, QWORD PTR this$[rsp]
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR tv86[rsp], eax
$LN4@snextc:
	mov	eax, DWORD PTR tv86[rsp]
	mov	DWORD PTR tv87[rsp], eax
$LN6@snextc:
	mov	eax, DWORD PTR tv87[rsp]

; 139  :              : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
; 140  :                                                               : sgetc();
; 141  :     }

	add	rsp, 56					; 00000038H
	ret	0
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z
_TEXT	SEGMENT
tv71 = 32
this$ = 64
_Ptr$ = 72
_Count$ = 80
?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetn, COMDAT

; 133  :         streamsize _Count) { // get up to _Count characters into array beginning at _Ptr

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 134  :         return xsgetn(_Ptr, _Count);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR tv71[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv71[rsp]

; 135  :     }

	add	rsp, 56					; 00000038H
	ret	0
?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
_TEXT	SEGMENT
tv75 = 32
this$ = 64
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT

; 128  :     int_type __CLR_OR_THIS_CALL sgetc() { // get a character and don't point past it

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	test	rax, rax
	jle	SHORT $LN3@sgetc
	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	movzx	ecx, BYTE PTR [rax]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	mov	DWORD PTR tv75[rsp], eax
	jmp	SHORT $LN4@sgetc
$LN3@sgetc:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+48]
	mov	DWORD PTR tv75[rsp], eax
$LN4@sgetc:
	mov	eax, DWORD PTR tv75[rsp]

; 130  :     }

	add	rsp, 56					; 00000038H
	ret	0
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
_TEXT	SEGMENT
tv75 = 32
this$ = 64
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT

; 124  :     int_type __CLR_OR_THIS_CALL sbumpc() { // get a character and point past it

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	test	rax, rax
	jle	SHORT $LN3@sbumpc
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
	movzx	ecx, BYTE PTR [rax]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	mov	DWORD PTR tv75[rsp], eax
	jmp	SHORT $LN4@sbumpc
$LN3@sbumpc:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+56]
	mov	DWORD PTR tv75[rsp], eax
$LN4@sbumpc:
	mov	eax, DWORD PTR tv75[rsp]

; 126  :     }

	add	rsp, 56					; 00000038H
	ret	0
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
_TEXT	SEGMENT
this$ = 48
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT

; 120  :     int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 121  :         return sync();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+104]

; 122  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv73 = 48
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Way$ = 104
_Mode$ = 112
?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff, COMDAT

; 76   :         ios_base::openmode _Mode = ios_base::in | ios_base::out) { // change position by _Off, according to _Way, _Mode

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 77   :         return seekoff(_Off, _Way, _Mode);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR tv73[rsp], rax
	mov	eax, DWORD PTR _Mode$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR _Way$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv73[rsp]
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 78   :     }

	add	rsp, 72					; 00000048H
	ret	0
?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT

; 67   :     virtual __CLR_OR_THIS_CALL ~basic_streambuf() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rax], rcx

; 68   :         delete _Plocale;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@basic_stre
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_Glocale@std@@QEAAPEAXI@Z
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN4@basic_stre
$LN3@basic_stre:
	mov	QWORD PTR tv70[rsp], 0
$LN4@basic_stre:

; 69   :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z
_TEXT	SEGMENT
tv94 = 32
tv92 = 40
tv90 = 48
_Pend$1 = 56
_Pnext0$2 = 64
_Pfirst0$3 = 72
tv146 = 80
tv144 = 88
tv142 = 96
_Gend$4 = 104
_Gnext0$5 = 112
_Gfirst0$6 = 120
this$ = 144
_Right$ = 152
?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::swap, COMDAT

; 44   :     void __CLR_OR_THIS_CALL swap(basic_streambuf& _Right) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 45   :         if (this != _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@V?$basic_streambuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_streambuf<char,std::char_traits<char> > >
	cmp	QWORD PTR this$[rsp], rax
	je	$LN2@swap

; 46   :             _Elem* _Pfirst0 = pbase();

	mov	rcx, QWORD PTR this$[rsp]
	call	?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pbase
	mov	QWORD PTR _Pfirst0$3[rsp], rax

; 47   :             _Elem* _Pnext0  = pptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	QWORD PTR _Pnext0$2[rsp], rax

; 48   :             _Elem* _Pend    = epptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	mov	QWORD PTR _Pend$1[rsp], rax

; 49   :             _Elem* _Gfirst0 = eback();

	mov	rcx, QWORD PTR this$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	QWORD PTR _Gfirst0$6[rsp], rax

; 50   :             _Elem* _Gnext0  = gptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	QWORD PTR _Gnext0$5[rsp], rax

; 51   :             _Elem* _Gend    = egptr();

	mov	rcx, QWORD PTR this$[rsp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	mov	QWORD PTR _Gend$4[rsp], rax

; 52   : 
; 53   :             setp(_Right.pbase(), _Right.pptr(), _Right.epptr());

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	mov	QWORD PTR tv94[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pbase
	mov	QWORD PTR tv90[rsp], rax
	mov	r9, QWORD PTR tv94[rsp]
	mov	r8, QWORD PTR tv92[rsp]
	mov	rdx, QWORD PTR tv90[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp

; 54   :             _Right.setp(_Pfirst0, _Pnext0, _Pend);

	mov	r9, QWORD PTR _Pend$1[rsp]
	mov	r8, QWORD PTR _Pnext0$2[rsp]
	mov	rdx, QWORD PTR _Pfirst0$3[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp

; 55   : 
; 56   :             setg(_Right.eback(), _Right.gptr(), _Right.egptr());

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	mov	QWORD PTR tv146[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	QWORD PTR tv144[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	QWORD PTR tv142[rsp], rax
	mov	r9, QWORD PTR tv146[rsp]
	mov	r8, QWORD PTR tv144[rsp]
	mov	rdx, QWORD PTR tv142[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg

; 57   :             _Right.setg(_Gfirst0, _Gnext0, _Gend);

	mov	r9, QWORD PTR _Gend$4[rsp]
	mov	r8, QWORD PTR _Gnext0$5[rsp]
	mov	rdx, QWORD PTR _Gfirst0$6[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg

; 58   : 
; 59   :             _STD swap(_Plocale, _Right._Plocale);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 96					; 00000060H
	mov	rdx, rax
	call	??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z ; std::swap<std::locale *,0>
	npad	1
$LN2@swap:

; 60   :         }
; 61   :     }

	add	rsp, 136				; 00000088H
	ret	0
?swap@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\streambuf
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv86 = 40
this$ = 64
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT

; 23   :     __CLR_OR_THIS_CALL basic_streambuf() : _Plocale(new locale) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rax], rcx

; 26   : 
; 27   :     __CLR_OR_THIS_CALL basic_streambuf(_Uninitialized) noexcept {}
; 28   : 
; 29   :     __CLR_OR_THIS_CALL basic_streambuf(const basic_streambuf& _Right) : _Plocale(new locale{_Right.getloc()}) {
; 30   :         _Init();
; 31   :         setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
; 32   :         setg(_Right.eback(), _Right.gptr(), _Right.egptr());
; 33   :     }
; 34   : 
; 35   :     basic_streambuf& __CLR_OR_THIS_CALL operator=(const basic_streambuf& _Right) {
; 36   :         if (this != _STD addressof(_Right)) {
; 37   :             setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
; 38   :             setg(_Right.eback(), _Right.gptr(), _Right.egptr());
; 39   :             pubimbue(_Right.getloc());
; 40   :         }
; 41   :         return *this;
; 42   :     }
; 43   : 
; 44   :     void __CLR_OR_THIS_CALL swap(basic_streambuf& _Right) noexcept /* strengthened */ {
; 45   :         if (this != _STD addressof(_Right)) {
; 46   :             _Elem* _Pfirst0 = pbase();
; 47   :             _Elem* _Pnext0  = pptr();
; 48   :             _Elem* _Pend    = epptr();
; 49   :             _Elem* _Gfirst0 = eback();
; 50   :             _Elem* _Gnext0  = gptr();
; 51   :             _Elem* _Gend    = egptr();
; 52   : 
; 53   :             setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
; 54   :             _Right.setp(_Pfirst0, _Pnext0, _Pend);
; 55   : 
; 56   :             setg(_Right.eback(), _Right.gptr(), _Right.egptr());
; 57   :             _Right.setg(_Gfirst0, _Gnext0, _Gend);
; 58   : 
; 59   :             _STD swap(_Plocale, _Right._Plocale);
; 60   :         }
; 61   :     }
; 62   : 
; 63   : public:
; 64   :     using char_type   = _Elem;
; 65   :     using traits_type = _Traits;
; 66   : 
; 67   :     virtual __CLR_OR_THIS_CALL ~basic_streambuf() noexcept {
; 68   :         delete _Plocale;
; 69   :     }
; 70   : 
; 71   :     using int_type = typename _Traits::int_type;
; 72   :     using pos_type = typename _Traits::pos_type;
; 73   :     using off_type = typename _Traits::off_type;
; 74   : 
; 75   :     pos_type __CLR_OR_THIS_CALL pubseekoff(off_type _Off, ios_base::seekdir _Way,
; 76   :         ios_base::openmode _Mode = ios_base::in | ios_base::out) { // change position by _Off, according to _Way, _Mode
; 77   :         return seekoff(_Off, _Way, _Mode);
; 78   :     }
; 79   : 
; 80   : #if _HAS_OLD_IOSTREAMS_MEMBERS
; 81   :     pos_type __CLR_OR_THIS_CALL pubseekoff(off_type _Off, ios_base::seek_dir _Way,
; 82   :         ios_base::open_mode _Mode) { // change position by _Off, according to _Way, _Mode (old style)
; 83   :         return pubseekoff(_Off, static_cast<ios_base::seekdir>(_Way), static_cast<ios_base::openmode>(_Mode));
; 84   :     }
; 85   : #endif // _HAS_OLD_IOSTREAMS_MEMBERS
; 86   : 
; 87   :     pos_type __CLR_OR_THIS_CALL pubseekpos(pos_type _Pos,
; 88   :         ios_base::openmode _Mode = ios_base::in | ios_base::out) { // change position to _Pos, according to _Mode
; 89   :         return seekpos(_Pos, _Mode);
; 90   :     }
; 91   : 
; 92   : #if _HAS_OLD_IOSTREAMS_MEMBERS
; 93   :     pos_type __CLR_OR_THIS_CALL pubseekpos(pos_type _Pos,
; 94   :         ios_base::open_mode _Mode) { // change position to _Pos, according to _Mode (old style)
; 95   :         return seekpos(_Pos, static_cast<ios_base::openmode>(_Mode));
; 96   :     }
; 97   : #endif // _HAS_OLD_IOSTREAMS_MEMBERS
; 98   : 
; 99   :     basic_streambuf* __CLR_OR_THIS_CALL pubsetbuf(_Elem* _Buffer,
; 100  :         streamsize _Count) { // offer _Buffer to external agent
; 101  :         return setbuf(_Buffer, _Count);
; 102  :     }
; 103  : 
; 104  :     locale __CLR_OR_THIS_CALL pubimbue(const locale& _Newlocale) { // set locale to argument
; 105  :         locale _Oldlocale = *_Plocale;
; 106  :         imbue(_Newlocale);
; 107  :         *_Plocale = _Newlocale;
; 108  :         return _Oldlocale;
; 109  :     }
; 110  : 
; 111  :     locale __CLR_OR_THIS_CALL getloc() const noexcept /* strengthened */ { // get locale
; 112  :         return *_Plocale;
; 113  :     }
; 114  : 
; 115  :     streamsize __CLR_OR_THIS_CALL in_avail() {
; 116  :         streamsize _Res = _Gnavail();
; 117  :         return 0 < _Res ? _Res : showmanyc();
; 118  :     }
; 119  : 
; 120  :     int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent
; 121  :         return sync();
; 122  :     }
; 123  : 
; 124  :     int_type __CLR_OR_THIS_CALL sbumpc() { // get a character and point past it
; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
; 126  :     }
; 127  : 
; 128  :     int_type __CLR_OR_THIS_CALL sgetc() { // get a character and don't point past it
; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
; 130  :     }
; 131  : 
; 132  :     streamsize __CLR_OR_THIS_CALL sgetn(_Elem* _Ptr,
; 133  :         streamsize _Count) { // get up to _Count characters into array beginning at _Ptr
; 134  :         return xsgetn(_Ptr, _Count);
; 135  :     }
; 136  : 
; 137  :     int_type __CLR_OR_THIS_CALL snextc() { // point to next character and return it
; 138  :         return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())
; 139  :              : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
; 140  :                                                               : sgetc();
; 141  :     }
; 142  : 
; 143  :     int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch) { // put back _Ch
; 144  :         if (gptr() && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1])) {
; 145  :             return _Traits::to_int_type(*_Gndec());
; 146  :         }
; 147  : 
; 148  :         return pbackfail(_Traits::to_int_type(_Ch));
; 149  :     }
; 150  : 
; 151  : #if _HAS_OLD_IOSTREAMS_MEMBERS
; 152  :     void __CLR_OR_THIS_CALL stossc() { // point past a character
; 153  :         if (0 < _Gnavail()) {
; 154  :             _Gninc();
; 155  :         } else {
; 156  :             uflow();
; 157  :         }
; 158  :     }
; 159  : #endif // _HAS_OLD_IOSTREAMS_MEMBERS
; 160  : 
; 161  :     int_type __CLR_OR_THIS_CALL sungetc() { // back up one position
; 162  :         return gptr() && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
; 163  :     }
; 164  : 
; 165  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character
; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
; 167  :     }
; 168  : 
; 169  :     streamsize __CLR_OR_THIS_CALL sputn(const _Elem* _Ptr,
; 170  :         streamsize _Count) { // put _Count characters from array beginning at _Ptr
; 171  :         return xsputn(_Ptr, _Count);
; 172  :     }
; 173  : 
; 174  :     virtual void __CLR_OR_THIS_CALL _Lock() {} // set the thread lock (overridden by basic_filebuf)
; 175  : 
; 176  :     virtual void __CLR_OR_THIS_CALL _Unlock() {} // clear the thread lock (overridden by basic_filebuf)
; 177  : 
; 178  : protected:
; 179  :     _Elem* __CLR_OR_THIS_CALL eback() const noexcept /* strengthened */ {
; 180  :         return *_IGfirst;
; 181  :     }
; 182  : 
; 183  :     _Elem* __CLR_OR_THIS_CALL gptr() const noexcept /* strengthened */ {
; 184  :         return *_IGnext;
; 185  :     }
; 186  : 
; 187  :     _Elem* __CLR_OR_THIS_CALL pbase() const noexcept /* strengthened */ {
; 188  :         return *_IPfirst;
; 189  :     }
; 190  : 
; 191  :     _Elem* __CLR_OR_THIS_CALL pptr() const noexcept /* strengthened */ {
; 192  :         return *_IPnext;
; 193  :     }
; 194  : 
; 195  :     _Elem* __CLR_OR_THIS_CALL egptr() const noexcept /* strengthened */ {
; 196  :         return *_IGnext + *_IGcount;
; 197  :     }
; 198  : 
; 199  :     void __CLR_OR_THIS_CALL gbump(int _Off) noexcept /* strengthened */ {
; 200  :         // alter current position in read buffer by _Off
; 201  :         *_IGcount -= _Off;
; 202  :         *_IGnext += _Off;
; 203  :     }
; 204  : 
; 205  :     void __CLR_OR_THIS_CALL setg(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept /* strengthened */ {
; 206  :         // set pointers for read buffer
; 207  :         *_IGfirst = _First;
; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);
; 210  :     }
; 211  : 
; 212  :     _Elem* __CLR_OR_THIS_CALL epptr() const noexcept /* strengthened */ {
; 213  :         return *_IPnext + *_IPcount;
; 214  :     }
; 215  : 
; 216  :     _Elem* __CLR_OR_THIS_CALL _Gndec() noexcept { // decrement current position in read buffer
; 217  :         ++*_IGcount;
; 218  :         return --*_IGnext;
; 219  :     }
; 220  : 
; 221  :     _Elem* __CLR_OR_THIS_CALL _Gninc() noexcept { // increment current position in read buffer
; 222  :         --*_IGcount;
; 223  :         return (*_IGnext)++;
; 224  :     }
; 225  : 
; 226  :     _Elem* __CLR_OR_THIS_CALL _Gnpreinc() noexcept { // preincrement current position in read buffer
; 227  :         --*_IGcount;
; 228  :         return ++(*_IGnext);
; 229  :     }
; 230  : 
; 231  :     streamsize __CLR_OR_THIS_CALL _Gnavail() const noexcept { // count number of available elements in read buffer
; 232  :         return *_IGnext ? *_IGcount : 0;
; 233  :     }
; 234  : 
; 235  :     void __CLR_OR_THIS_CALL pbump(int _Off) noexcept /* strengthened */ {
; 236  :         // alter current position in write buffer by _Off
; 237  :         *_IPcount -= _Off;
; 238  :         *_IPnext += _Off;
; 239  :     }
; 240  : 
; 241  :     void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Last) noexcept /* strengthened */ {
; 242  :         // set pointers for write buffer
; 243  :         *_IPfirst = _First;
; 244  :         *_IPnext  = _First;
; 245  :         *_IPcount = static_cast<int>(_Last - _First);
; 246  :     }
; 247  : 
; 248  :     void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept /* strengthened */ {
; 249  :         // set pointers for write buffer, extended version
; 250  :         *_IPfirst = _First;
; 251  :         *_IPnext  = _Next;
; 252  :         *_IPcount = static_cast<int>(_Last - _Next);
; 253  :     }
; 254  : 
; 255  :     _Elem* __CLR_OR_THIS_CALL _Pninc() noexcept { // increment current position in write buffer
; 256  :         --*_IPcount;
; 257  :         return (*_IPnext)++;
; 258  :     }
; 259  : 
; 260  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const noexcept { // count number of available positions in write buffer
; 261  :         return *_IPnext ? *_IPcount : 0;
; 262  :     }
; 263  : 
; 264  :     void __CLR_OR_THIS_CALL _Init() noexcept { // initialize buffer parameters for no buffers
; 265  :         _IGfirst = &_Gfirst;
; 266  :         _IPfirst = &_Pfirst;
; 267  :         _IGnext  = &_Gnext;
; 268  :         _IPnext  = &_Pnext;
; 269  :         _IGcount = &_Gcount;
; 270  :         _IPcount = &_Pcount;
; 271  :         setp(nullptr, nullptr);
; 272  :         setg(nullptr, nullptr, nullptr);
; 273  :     }
; 274  : 
; 275  :     void __CLR_OR_THIS_CALL _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn, int* _Pc) noexcept {
; 276  :         // initialize buffer parameters as specified
; 277  :         _IGfirst = _Gf;
; 278  :         _IPfirst = _Pf;
; 279  :         _IGnext  = _Gn;
; 280  :         _IPnext  = _Pn;
; 281  :         _IGcount = _Gc;
; 282  :         _IPcount = _Pc;
; 283  :     }
; 284  : 
; 285  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type = _Traits::eof()) { // put a character to stream (always fail)
; 286  :         return _Traits::eof();
; 287  :     }
; 288  : 
; 289  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type = _Traits::eof()) {
; 290  :         // put a character back to stream (always fail)
; 291  :         return _Traits::eof();
; 292  :     }
; 293  : 
; 294  :     virtual streamsize __CLR_OR_THIS_CALL showmanyc() {
; 295  :         return 0;
; 296  :     }
; 297  : 
; 298  :     virtual int_type __CLR_OR_THIS_CALL underflow() { // get a character from stream, but don't point past it
; 299  :         return _Traits::eof();
; 300  :     }
; 301  : 
; 302  :     virtual int_type __CLR_OR_THIS_CALL uflow() { // get a character from stream, point past it
; 303  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
; 304  :     }
; 305  : 
; 306  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) { // get _Count characters from stream
; 307  :         const streamsize _Start_count = _Count;
; 308  : 
; 309  :         while (0 < _Count) {
; 310  :             streamsize _Size = _Gnavail();
; 311  :             if (0 < _Size) { // copy from read buffer
; 312  :                 if (_Count < _Size) {
; 313  :                     _Size = _Count;
; 314  :                 }
; 315  : 
; 316  :                 _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
; 317  :                 _Ptr += _Size;
; 318  :                 _Count -= _Size;
; 319  :                 gbump(static_cast<int>(_Size));
; 320  :             } else {
; 321  :                 const int_type _Meta = uflow();
; 322  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
; 323  :                     break; // end of file, quit
; 324  :                 }
; 325  : 
; 326  :                 // get a single character
; 327  :                 *_Ptr++ = _Traits::to_char_type(_Meta);
; 328  :                 --_Count;
; 329  :             }
; 330  :         }
; 331  : 
; 332  :         return _Start_count - _Count;
; 333  :     }
; 334  : 
; 335  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) {
; 336  :         // put _Count characters to stream
; 337  :         const streamsize _Start_count = _Count;
; 338  :         while (0 < _Count) {
; 339  :             streamsize _Size = _Pnavail();
; 340  :             if (0 < _Size) { // copy to write buffer
; 341  :                 if (_Count < _Size) {
; 342  :                     _Size = _Count;
; 343  :                 }
; 344  : 
; 345  :                 _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
; 346  :                 _Ptr += _Size;
; 347  :                 _Count -= _Size;
; 348  :                 pbump(static_cast<int>(_Size));
; 349  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {
; 350  :                 break; // single character put failed, quit
; 351  :             } else { // count character successfully put
; 352  :                 ++_Ptr;
; 353  :                 --_Count;
; 354  :             }
; 355  :         }
; 356  : 
; 357  :         return _Start_count - _Count;
; 358  :     }
; 359  : 
; 360  :     virtual pos_type __CLR_OR_THIS_CALL seekoff(
; 361  :         off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
; 362  :         // change position by offset, according to way and mode
; 363  :         return pos_type{off_type{-1}};
; 364  :     }
; 365  : 
; 366  :     virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
; 367  :         // change to specified position, according to mode
; 368  :         return pos_type{off_type{-1}};
; 369  :     }
; 370  : 
; 371  :     virtual basic_streambuf* __CLR_OR_THIS_CALL setbuf(_Elem*, streamsize) {
; 372  :         // offer buffer to external agent (do nothing)
; 373  :         return this;
; 374  :     }
; 375  : 
; 376  :     virtual int __CLR_OR_THIS_CALL sync() { // synchronize with external agent (do nothing)
; 377  :         return 0;
; 378  :     }
; 379  : 
; 380  :     virtual void __CLR_OR_THIS_CALL imbue(const locale&) {} // set locale to argument (do nothing)
; 381  : 
; 382  : private:
; 383  :     _Elem* _Gfirst{}; // beginning of read buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 384  :     _Elem* _Pfirst{}; // beginning of write buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 385  :     _Elem** _IGfirst{}; // pointer to beginning of read buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 386  :     _Elem** _IPfirst{}; // pointer to beginning of write buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], 0

; 387  :     _Elem* _Gnext{}; // current position in read buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+40], 0

; 388  :     _Elem* _Pnext{}; // current position in write buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 0

; 389  :     _Elem** _IGnext{}; // pointer to current position in read buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0

; 390  :     _Elem** _IPnext{}; // pointer to current position in write buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+64], 0

; 391  : 
; 392  :     int _Gcount{}; // length of read buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+72], 0

; 393  :     int _Pcount{}; // length of write buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+76], 0

; 394  :     int* _IGcount{}; // pointer to length of read buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0

; 395  :     int* _IPcount{}; // pointer to length of write buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+88], 0

; 23   :     __CLR_OR_THIS_CALL basic_streambuf() : _Plocale(new locale) {

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@basic_stre
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0locale@std@@QEAA@XZ			; std::locale::locale
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN4@basic_stre
$LN3@basic_stre:
	mov	QWORD PTR tv86[rsp], 0
$LN4@basic_stre:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR tv86[rsp]
	mov	QWORD PTR [rax+96], rcx

; 24   :         _Init();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
	npad	1

; 25   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 24
	mov	rcx, rax
	call	??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 24
	mov	edx, 120				; 00000078H
	mov	rcx, rax
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	sub	rax, 24
	add	rsp, 40					; 00000028H
	ret	0
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
_TEXT	SEGMENT
_State$ = 48
_Oldstate$ = 52
tv91 = 56
tv162 = 64
tv181 = 72
tv196 = 80
$T1 = 88
_Ok$ = 96
$T2 = 112
this$ = 160
_Off$ = 168
_Way$ = 176
?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::seekg, COMDAT

; 677  :     basic_istream& __CLR_OR_THIS_CALL seekg(off_type _Off, ios_base::seekdir _Way) {

$LN12:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 678  :         // change input stream position by _Off, according to _Way
; 679  :         ios_base::iostate _State    = ios_base::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 680  :         ios_base::iostate _Oldstate = _Myios::rdstate();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdstate@ios_base@std@@QEBAHXZ		; std::ios_base::rdstate
	mov	DWORD PTR _Oldstate$[rsp], eax

; 681  :         _Myios::clear(_Oldstate & ~ios_base::eofbit);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv91[rsp], rax
	mov	eax, DWORD PTR _Oldstate$[rsp]
	and	eax, -2
	xor	r8d, r8d
	mov	edx, eax
	mov	rcx, QWORD PTR tv91[rsp]
	call	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear

; 682  :         const sentry _Ok(*this, true);

	mov	r8b, 1
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 683  : 
; 684  :         if (!this->fail()) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fail@ios_base@std@@QEBA_NXZ		; std::ios_base::fail
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@seekg

; 685  :             _TRY_IO_BEGIN
; 686  :             if (static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)) == -1) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv162[rsp], rax
	mov	DWORD PTR [rsp+32], 1
	mov	r9d, DWORD PTR _Way$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR tv162[rsp]
	call	?pubseekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pubseekoff
	mov	rcx, rax
	call	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ	; std::fpos<_Mbstatet>::operator __int64
	cmp	rax, -1
	jne	SHORT $LN4@seekg

; 687  :                 _State |= ios_base::failbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 2
	mov	DWORD PTR _State$[rsp], eax
$LN4@seekg:
	jmp	SHORT $LN2@seekg
$LN10@seekg:
$LN2@seekg:

; 688  :             }
; 689  :             _CATCH_IO_END
; 690  :         }
; 691  : 
; 692  :         _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv196[rsp], rax
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, QWORD PTR tv196[rsp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1

; 693  :         return *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	mov	rax, QWORD PTR $T1[rsp]

; 694  :     }

	add	rsp, 152				; 00000098H
	ret	0
?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::seekg
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 48
_Oldstate$ = 52
tv91 = 56
tv162 = 64
tv181 = 72
tv196 = 80
$T1 = 88
_Ok$ = 96
$T2 = 112
this$ = 160
_Off$ = 168
_Way$ = 176
?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::seekg'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::seekg'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 48
_Oldstate$ = 52
tv91 = 56
tv162 = 64
tv181 = 72
tv196 = 80
$T1 = 88
_Ok$ = 96
$T2 = 112
this$ = 160
_Off$ = 168
_Way$ = 176
?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::seekg'::`1'::catch$1

; 689  :             _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv181[rbp], rax
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, QWORD PTR tv181[rbp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN10@catch$1
	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::seekg'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
_TEXT	SEGMENT
_State$ = 32
_Num$1 = 40
tv92 = 48
tv142 = 56
tv157 = 64
$T2 = 72
_Ok$ = 80
this$ = 112
_Str$ = 120
_Count$ = 128
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z PROC ; std::basic_istream<char,std::char_traits<char> >::read, COMDAT

; 531  :     basic_istream& __CLR_OR_THIS_CALL read(_Elem* _Str, streamsize _Count) { // read up to _Count characters into buffer

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 532  :         ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 533  :         _Chcount                 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 534  :         const sentry _Ok(*this, true);

	mov	r8b, 1
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 535  : 
; 536  :         if (_Ok && 0 < _Count) { // state okay, use facet to extract

	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@read
	cmp	QWORD PTR _Count$[rsp], 0
	jle	SHORT $LN2@read

; 537  :             _TRY_IO_BEGIN
; 538  :             const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv92[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Str$[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sgetn
	mov	QWORD PTR _Num$1[rsp], rax

; 539  :             _Chcount              = _Num;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Num$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 540  : 
; 541  :             if (_Num != _Count) {

	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Num$1[rsp], rax
	je	SHORT $LN4@read

; 542  :                 _State |= ios_base::eofbit | ios_base::failbit; // short read

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 3
	mov	DWORD PTR _State$[rsp], eax
$LN4@read:
	jmp	SHORT $LN2@read
$LN10@read:
$LN2@read:

; 543  :             }
; 544  :             _CATCH_IO_END
; 545  :         }
; 546  : 
; 547  :         _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv157[rsp], rax
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, QWORD PTR tv157[rsp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1

; 548  :         return *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	mov	rax, QWORD PTR $T2[rsp]

; 549  :     }

	add	rsp, 104				; 00000068H
	ret	0
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::read
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
_Num$1 = 40
tv92 = 48
tv142 = 56
tv157 = 64
$T2 = 72
_Ok$ = 80
this$ = 112
_Str$ = 120
_Count$ = 128
?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::read'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::read'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
_Num$1 = 40
tv92 = 48
tv142 = 56
tv157 = 64
$T2 = 72
_Ok$ = 80
this$ = 112
_Str$ = 120
_Count$ = 128
?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::read'::`1'::catch$1

; 544  :             _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv142[rbp], rax
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, QWORD PTR tv142[rbp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN10@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::read'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
_TEXT	SEGMENT
_Eof$ = 32
_Meta$1 = 36
_Tied$ = 40
tv92 = 48
tv170 = 56
tv263 = 64
tv261 = 72
_Ctype_fac$2 = 80
tv230 = 88
tv247 = 96
$T3 = 104
this$ = 144
_Noskip$ = 152
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT

; 121  :     bool __CLR_OR_THIS_CALL _Ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed

$LN20:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 122  :         if (!this->good()) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Ipfx

; 123  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv92[rsp], rax
	xor	r8d, r8d
	mov	edx, 2
	mov	rcx, QWORD PTR tv92[rsp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 124  :             return false;

	xor	al, al
	jmp	$LN1@Ipfx
$LN5@Ipfx:

; 125  :         }
; 126  : 
; 127  :         // state okay, flush tied stream and skip whitespace
; 128  :         const auto _Tied = _Myios::tie();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	QWORD PTR _Tied$[rsp], rax

; 129  :         if (_Tied) {

	cmp	QWORD PTR _Tied$[rsp], 0
	je	SHORT $LN6@Ipfx

; 130  :             _Tied->flush();

	mov	rcx, QWORD PTR _Tied$[rsp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	npad	1
$LN6@Ipfx:

; 131  :         }
; 132  : 
; 133  :         bool _Eof = false;

	mov	BYTE PTR _Eof$[rsp], 0

; 134  :         if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace

	movzx	eax, BYTE PTR _Noskip$[rsp]
	test	eax, eax
	jne	$LN7@Ipfx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 1
	test	eax, eax
	je	$LN7@Ipfx

; 135  :             const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv170[rsp], rax
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR tv170[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv263[rsp], rax
	mov	rax, QWORD PTR tv263[rsp]
	mov	QWORD PTR tv261[rsp], rax
	mov	rcx, QWORD PTR tv261[rsp]
	call	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	mov	QWORD PTR _Ctype_fac$2[rsp], rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	npad	1

; 136  : 
; 137  :             _TRY_IO_BEGIN
; 138  :             int_type _Meta = _Myios::rdbuf()->sgetc();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	rcx, rax
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR _Meta$1[rsp], eax

; 139  : 
; 140  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

	jmp	SHORT $LN4@Ipfx
$LN2@Ipfx:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	rcx, rax
	call	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
	mov	DWORD PTR _Meta$1[rsp], eax
$LN4@Ipfx:

; 141  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	edx, DWORD PTR _Meta$1[rsp]
	mov	ecx, eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Ipfx

; 142  :                     _Eof = true;

	mov	BYTE PTR _Eof$[rsp], 1

; 143  :                     break;

	jmp	SHORT $LN3@Ipfx
	jmp	SHORT $LN10@Ipfx
$LN9@Ipfx:

; 144  :                 } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

	mov	ecx, DWORD PTR _Meta$1[rsp]
	call	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
	movzx	r8d, al
	mov	dx, 72					; 00000048H
	mov	rcx, QWORD PTR _Ctype_fac$2[rsp]
	call	?is@?$ctype@D@std@@QEBA_NFD@Z		; std::ctype<char>::is
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@Ipfx

; 145  :                     break; // not whitespace, quit

	jmp	SHORT $LN3@Ipfx
$LN10@Ipfx:

; 146  :                 }
; 147  :             }

	jmp	SHORT $LN2@Ipfx
$LN3@Ipfx:
	jmp	SHORT $LN7@Ipfx
$LN18@Ipfx:
$LN7@Ipfx:

; 148  :             _CATCH_IO_END
; 149  :         }
; 150  : 
; 151  :         if (_Eof) {

	movzx	eax, BYTE PTR _Eof$[rsp]
	test	eax, eax
	je	SHORT $LN12@Ipfx

; 152  :             _Myios::setstate(ios_base::eofbit | ios_base::failbit);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv247[rsp], rax
	xor	r8d, r8d
	mov	edx, 3
	mov	rcx, QWORD PTR tv247[rsp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN12@Ipfx:

; 153  :         }
; 154  : 
; 155  :         return this->good();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
$LN1@Ipfx:

; 156  :     }

	add	rsp, 136				; 00000088H
	ret	0
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Eof$ = 32
_Meta$1 = 36
_Tied$ = 40
tv92 = 48
tv170 = 56
tv263 = 64
tv261 = 72
_Ctype_fac$2 = 80
tv230 = 88
tv247 = 96
$T3 = 104
this$ = 144
_Noskip$ = 152
?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::_Ipfx'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::_Ipfx'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Eof$ = 32
_Meta$1 = 36
_Tied$ = 40
tv92 = 48
tv170 = 56
tv263 = 64
tv261 = 72
_Ctype_fac$2 = 80
tv230 = 88
tv247 = 96
$T3 = 104
this$ = 144
_Noskip$ = 152
?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::_Ipfx'::`1'::catch$1

; 148  :             _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv230[rbp], rax
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, QWORD PTR tv230[rbp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN18@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::_Ipfx'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT

; 78   :     __CLR_OR_THIS_CALL ~basic_istream() noexcept override {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax-24]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rcx+rax-24], rdx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax-24]
	movsxd	rax, DWORD PTR [rax+4]
	sub	rax, 24
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx-24]
	movsxd	rcx, DWORD PTR [rcx+4]
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx-28], eax
	ret	0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z
_TEXT	SEGMENT
tv87 = 32
this$ = 64
_Right$ = 72
?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::swap, COMDAT

; 69   :     void __CLR_OR_THIS_CALL swap(basic_istream& _Right) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 70   :         _Myios::swap(_Right);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv87[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Right$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR tv87[rsp]
	call	?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z ; std::basic_ios<char,std::char_traits<char> >::swap

; 71   :         _STD swap(_Chcount, _Right._Chcount);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	??$swap@_J$0A@@std@@YAXAEA_J0@Z		; std::swap<__int64,0>
	npad	1

; 72   :     }

	add	rsp, 56					; 00000038H
	ret	0
?swap@?$basic_istream@DU?$char_traits@D@std@@@std@@IEAAXAEAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\istream
;	COMDAT ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
$T1 = 32
tv151 = 40
this$ = 64
_Strbuf$ = 72
_Isstd$ = 80
$initVBases$ = 88
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >, COMDAT

; 49   :     explicit __CLR_OR_THIS_CALL basic_istream(_Mysb* _Strbuf, bool _Isstd = false) : _Chcount(0) {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0
	cmp	DWORD PTR $initVBases$[rsp], 0
	je	SHORT $LN2@basic_istr
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
$LN2@basic_istr:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rcx+rax], rdx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	sub	rax, 24
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rcx+4]
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx-4], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 50   :         _Myios::init(_Strbuf, _Isstd);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv151[rsp], rax
	movzx	r8d, BYTE PTR _Isstd$[rsp]
	mov	rdx, QWORD PTR _Strbuf$[rsp]
	mov	rcx, QWORD PTR tv151[rsp]
	call	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
	npad	1

; 51   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv151 = 40
this$ = 64
_Strbuf$ = 72
_Isstd$ = 80
$initVBases$ = 88
?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 96					; 00000060H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT

; 160  :     __CLR_OR_THIS_CALL basic_ios() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0ios_base@std@@IEAA@XZ		; std::ios_base::ios_base
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rax], rcx

; 161  : 
; 162  : private:
; 163  :     _Mysb* _Mystrbuf{}; // pointer to stream buffer

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0

; 164  :     _Myos* _Tiestr{}; // pointer to tied output stream

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0

; 165  :     _Elem _Fillch{}; // the fill character

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+88], 0

; 160  :     __CLR_OR_THIS_CALL basic_ios() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA PROC ; `std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ios_base@std@@UEAA@XZ		; std::ios_base::~ios_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ@4HA ENDP ; `std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
this$ = 48
_Strbuf$ = 56
_Isstd$ = 64
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT

; 144  :     void __CLR_OR_THIS_CALL init(_Mysb* _Strbuf = nullptr, bool _Isstd = false) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 145  :         // initialize with stream buffer pointer
; 146  :         _Init(); // initialize ios_base

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@ios_base@std@@IEAAXXZ		; std::ios_base::_Init

; 147  :         _Mystrbuf = _Strbuf;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Strbuf$[rsp]
	mov	QWORD PTR [rax+72], rcx

; 148  :         _Tiestr   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+80], 0

; 149  :         _Fillch   = widen(' ');

	mov	dl, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+88], al

; 150  : 
; 151  :         if (!_Mystrbuf) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 0
	jne	SHORT $LN2@init

; 152  :             setstate(badbit);

	xor	r8d, r8d
	mov	edx, 4
	mov	rcx, QWORD PTR this$[rsp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN2@init:

; 153  :         }
; 154  : 
; 155  :         if (_Isstd) {

	movzx	eax, BYTE PTR _Isstd$[rsp]
	test	eax, eax
	je	SHORT $LN3@init

; 156  :             _Addstd(this); // special handling for standard streams

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Addstd@ios_base@std@@SAXPEAV12@@Z	; std::ios_base::_Addstd
	npad	1
$LN3@init:

; 157  :         }
; 158  :     }

	add	rsp, 40					; 00000028H
	ret	0
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IEAAXPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z PROC ; std::basic_ios<char,std::char_traits<char> >::swap, COMDAT

; 132  :     void __CLR_OR_THIS_CALL swap(basic_ios& _Right) noexcept { // swap all but rdbuf() with right

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 133  :         ios_base::swap(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?swap@ios_base@std@@QEAAXAEAV12@@Z	; std::ios_base::swap

; 134  :         _STD swap(_Fillch, _Right._Fillch);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 88					; 00000058H
	mov	rdx, rax
	call	??$swap@D$0A@@std@@YAXAEAD0@Z		; std::swap<char,0>

; 135  :         _STD swap(_Tiestr, _Right._Tiestr);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 80					; 00000050H
	mov	rdx, rax
	call	??$swap@PEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@$0A@@std@@YAXAEAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@0@Z ; std::swap<std::basic_ostream<char,std::char_traits<char> > *,0>
	npad	1

; 136  :     }

	add	rsp, 40					; 00000028H
	ret	0
?swap@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
_TEXT	SEGMENT
$T1 = 32
tv82 = 40
tv81 = 48
tv79 = 56
$T2 = 64
this$ = 96
_Byte$ = 104
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT

; 112  :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 113  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR tv82[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	mov	QWORD PTR tv79[rsp], rax
	movzx	edx, BYTE PTR _Byte$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	?widen@?$ctype@D@std@@QEBADD@Z		; std::ctype<char>::widen
	mov	BYTE PTR $T1[rsp], al
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	movzx	eax, BYTE PTR $T1[rsp]

; 114  :     }

	add	rsp, 88					; 00000058H
	ret	0
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv82 = 40
tv81 = 48
tv79 = 56
$T2 = 64
this$ = 96
_Byte$ = 104
?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA PROC ; `std::basic_ios<char,std::char_traits<char> >::widen'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA ENDP ; `std::basic_ios<char,std::char_traits<char> >::widen'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT

; 77   :     _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 78   :         return _Mystrbuf;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]

; 79   :     }

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT

; 67   :     _Myos* __CLR_OR_THIS_CALL tie() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 68   :         return _Tiestr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]

; 69   :     }

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
_TEXT	SEGMENT
this$ = 48
_State$ = 56
_Reraise$ = 64
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT

; 49   :     void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Reraise = false) {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 50   :         // merge _State into state, possibly reraise exception
; 51   :         clear(rdstate() | _State, _Reraise);

	mov	rcx, QWORD PTR this$[rsp]
	call	?rdstate@ios_base@std@@QEBAHXZ		; std::ios_base::rdstate
	or	eax, DWORD PTR _State$[rsp]
	movzx	r8d, BYTE PTR _Reraise$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
	npad	1

; 52   :     }

	add	rsp, 40					; 00000028H
	ret	0
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
_TEXT	SEGMENT
tv78 = 32
tv72 = 36
tv74 = 40
this$ = 64
_State$ = 72
_Reraise$ = 80
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT

; 38   :     void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 39   :         // set state, possibly reraise exception
; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

	movzx	eax, BYTE PTR _Reraise$[rsp]
	mov	BYTE PTR tv78[rsp], al
	mov	eax, DWORD PTR _State$[rsp]
	mov	DWORD PTR tv74[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN3@clear
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN4@clear
$LN3@clear:
	mov	DWORD PTR tv72[rsp], 4
$LN4@clear:
	mov	eax, DWORD PTR tv72[rsp]
	mov	ecx, DWORD PTR tv74[rsp]
	or	ecx, eax
	mov	eax, ecx
	movzx	r8d, BYTE PTR tv78[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@ios_base@std@@QEAAXH_N@Z		; std::ios_base::clear
	npad	1

; 41   :     }

	add	rsp, 56					; 00000038H
	ret	0
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\ios
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT

; 36   :     __CLR_OR_THIS_CALL ~basic_ios() noexcept override {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ios_base@std@@UEAA@XZ		; std::ios_base::~ios_base
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA PROC ; `std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ios_base@std@@UEAA@XZ		; std::ios_base::~ios_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ@4HA ENDP ; `std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z PROC ; std::swap<std::locale *,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEAPEAVlocale@std@@@std@@YA$$QEAPEAVlocale@0@AEAPEAV10@@Z ; std::move<std::locale * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAPEAVlocale@std@@@std@@YA$$QEAPEAVlocale@0@AEAPEAV10@@Z ; std::move<std::locale * &>
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEAPEAVlocale@std@@@std@@YA$$QEAPEAVlocale@0@AEAPEAV10@@Z ; std::move<std::locale * &>
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z ENDP ; std::swap<std::locale *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z PROC ; std::swap<std::ios_base::_Fnarray *,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEAPEAU_Fnarray@ios_base@std@@@std@@YA$$QEAPEAU_Fnarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Fnarray * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAPEAU_Fnarray@ios_base@std@@@std@@YA$$QEAPEAU_Fnarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Fnarray * &>
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEAPEAU_Fnarray@ios_base@std@@@std@@YA$$QEAPEAU_Fnarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Fnarray * &>
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z ENDP ; std::swap<std::ios_base::_Fnarray *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z PROC ; std::swap<std::ios_base::_Iosarray *,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEAPEAU_Iosarray@ios_base@std@@@std@@YA$$QEAPEAU_Iosarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Iosarray * &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAPEAU_Iosarray@ios_base@std@@@std@@YA$$QEAPEAU_Iosarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Iosarray * &>
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEAPEAU_Iosarray@ios_base@std@@@std@@YA$$QEAPEAU_Iosarray@ios_base@0@AEAPEAU120@@Z ; std::move<std::ios_base::_Iosarray * &>
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z ENDP ; std::swap<std::ios_base::_Iosarray *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@_J$0A@@std@@YAXAEA_J0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@_J$0A@@std@@YAXAEA_J0@Z PROC			; std::swap<__int64,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEA_J@std@@YA$$QEA_JAEA_J@Z	; std::move<__int64 &>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEA_J@std@@YA$$QEA_JAEA_J@Z	; std::move<__int64 &>
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEA_J@std@@YA$$QEA_JAEA_J@Z	; std::move<__int64 &>
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@_J$0A@@std@@YAXAEA_J0@Z ENDP			; std::swap<__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$swap@H$0A@@std@@YAXAEAH0@Z
_TEXT	SEGMENT
_Tmp$ = 32
_Left$ = 64
_Right$ = 72
??$swap@H$0A@@std@@YAXAEAH0@Z PROC			; std::swap<int,0>, COMDAT

; 138  :     noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 139  :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$move@AEAH@std@@YA$$QEAHAEAH@Z	; std::move<int &>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR _Tmp$[rsp], eax

; 140  :     _Left    = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAH@std@@YA$$QEAHAEAH@Z	; std::move<int &>
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 141  :     _Right   = _STD move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$move@AEAH@std@@YA$$QEAHAEAH@Z	; std::move<int &>
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
??$swap@H$0A@@std@@YAXAEAH0@Z ENDP			; std::swap<int,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@Vios_base@std@@@std@@YAPEAVios_base@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@Vios_base@std@@@std@@YAPEAVios_base@0@AEAV10@@Z PROC ; std::addressof<std::ios_base>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@Vios_base@std@@@std@@YAPEAVios_base@0@AEAV10@@Z ENDP ; std::addressof<std::ios_base>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gios_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gios_base@std@@UEAAPEAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ios_base@std@@UEAA@XZ		; std::ios_base::~ios_base
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 72					; 00000048H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gios_base@std@@UEAAPEAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?_Init@ios_base@std@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 32
tv83 = 40
this$ = 64
?_Init@ios_base@std@@IEAAXXZ PROC			; std::ios_base::_Init, COMDAT

; 378  :     void __CLR_OR_THIS_CALL _Init() { // initialize a new ios_base

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 379  :         _Ploc   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+64], 0

; 380  :         _Stdstr = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 381  :         _Except = goodbit;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+20], 0

; 382  :         _Fmtfl  = skipws | dec;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 513			; 00000201H

; 383  :         _Prec   = 6;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], 6

; 384  :         _Wide   = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+40], 0

; 385  :         _Arr    = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 0

; 386  :         _Calls  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0

; 387  :         clear(goodbit);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@ios_base@std@@QEAAXH@Z		; std::ios_base::clear
	npad	1

; 388  :         _Ploc = new locale;

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@Init
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0locale@std@@QEAA@XZ			; std::locale::locale
	mov	QWORD PTR tv83[rsp], rax
	jmp	SHORT $LN4@Init
$LN3@Init:
	mov	QWORD PTR tv83[rsp], 0
$LN4@Init:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR tv83[rsp]
	mov	QWORD PTR [rax+64], rcx

; 389  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Init@ios_base@std@@IEAAXXZ ENDP			; std::ios_base::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ??0ios_base@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ios_base@std@@IEAA@XZ PROC				; std::ios_base::ios_base, COMDAT

; 376  :     __CLR_OR_THIS_CALL ios_base() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7ios_base@std@@6B@
	mov	QWORD PTR [rax], rcx

; 373  :     size_t _Stdstr{0}; // if > 0 index of standard stream to suppress destruction

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 377  : 
; 378  :     void __CLR_OR_THIS_CALL _Init() { // initialize a new ios_base
; 379  :         _Ploc   = nullptr;
; 380  :         _Stdstr = 0;
; 381  :         _Except = goodbit;
; 382  :         _Fmtfl  = skipws | dec;
; 383  :         _Prec   = 6;
; 384  :         _Wide   = 0;
; 385  :         _Arr    = nullptr;
; 386  :         _Calls  = nullptr;
; 387  :         clear(goodbit);
; 388  :         _Ploc = new locale;
; 389  :     }
; 390  : 
; 391  : private:
; 392  :     struct _Iosarray : _Crt_new_delete { // list element for open-ended sparse array of longs/pointers
; 393  :     public:
; 394  :         __CLR_OR_THIS_CALL _Iosarray(int _Idx, _Iosarray* _Link)
; 395  :             : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) {} // construct node for index _Idx and link it in
; 396  : 
; 397  :         _Iosarray* _Next; // pointer to next node
; 398  :         int _Index; // index of this node
; 399  :         long _Lo; // stored long value
; 400  :         void* _Vp; // stored pointer value
; 401  :     };
; 402  : 
; 403  :     struct _Fnarray : _Crt_new_delete { // list element for open-ended sparse array of event handlers
; 404  :         __CLR_OR_THIS_CALL _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
; 405  :             : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) {} // construct node for index _Idx and link it in
; 406  : 
; 407  :         _Fnarray* _Next; // pointer to next node
; 408  :         int _Index; // index of this node
; 409  :         event_callback _Pfn; // pointer to event handler
; 410  :     };
; 411  : 
; 412  :     void __CLR_OR_THIS_CALL _Callfns(event _Ev) { // call all event handlers, reporting event
; 413  :         for (_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next) {
; 414  :             (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
; 415  :         }
; 416  :     }
; 417  : 
; 418  :     _Iosarray& __CLR_OR_THIS_CALL _Findarr(int _Idx) { // locate or make a variable array element
; 419  :         _Iosarray* _Ptr1;
; 420  :         _Iosarray* _Ptr2;
; 421  : 
; 422  :         for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next) {
; 423  :             if (_Ptr1->_Index == _Idx) {
; 424  :                 return *_Ptr1; // found element, return it
; 425  :             } else if (!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp) {
; 426  :                 _Ptr2 = _Ptr1; // found recycling candidate
; 427  :             }
; 428  :         }
; 429  : 
; 430  :         if (_Ptr2) { // recycle existing element
; 431  :             _Ptr2->_Index = _Idx;
; 432  :             return *_Ptr2;
; 433  :         }
; 434  : 
; 435  :         _Arr = new _Iosarray(_Idx, _Arr); // make a new element
; 436  :         return *_Arr;
; 437  :     }
; 438  : 
; 439  :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // discard storage for an ios_base
; 440  :         _Callfns(erase_event);
; 441  :         _Iosarray* _Ptr1;
; 442  :         _Iosarray* _Ptr2;
; 443  : 
; 444  :         for (_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2) { // delete array element
; 445  :             _Ptr2 = _Ptr1->_Next;
; 446  :             delete _Ptr1;
; 447  :         }
; 448  :         _Arr = nullptr;
; 449  : 
; 450  :         _Fnarray* _Pfa1;
; 451  :         _Fnarray* _Pfa2;
; 452  :         for (_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2) { // delete callback element
; 453  :             _Pfa2 = _Pfa1->_Next;
; 454  :             delete _Pfa1;
; 455  :         }
; 456  :         _Calls = nullptr;
; 457  :     }
; 458  : 
; 459  :     iostate _Mystate{}; // stream state

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], 0

; 460  :     iostate _Except{}; // exception mask

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+20], 0

; 461  :     fmtflags _Fmtfl{}; // format flags

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 0

; 462  :     streamsize _Prec{}; // field precision

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], 0

; 463  :     streamsize _Wide{}; // field width

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+40], 0

; 464  :     _Iosarray* _Arr{nullptr}; // pointer to first node of long/pointer array

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 0

; 465  :     _Fnarray* _Calls{nullptr}; // pointer to first node of call list

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 0

; 466  :     locale* _Ploc{nullptr}; // pointer to locale

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+64], 0

; 376  :     __CLR_OR_THIS_CALL ios_base() {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0ios_base@std@@IEAA@XZ ENDP				; std::ios_base::ios_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ??1ios_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ios_base@std@@UEAA@XZ PROC				; std::ios_base::~ios_base, COMDAT

; 367  :     virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7ios_base@std@@6B@
	mov	QWORD PTR [rax], rcx

; 368  :         _Ios_base_dtor(this);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z ; std::ios_base::_Ios_base_dtor
	npad	1

; 369  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1ios_base@std@@UEAA@XZ ENDP				; std::ios_base::~ios_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?swap@ios_base@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?swap@ios_base@std@@QEAAXAEAV12@@Z PROC			; std::ios_base::swap, COMDAT

; 353  :     void __CLR_OR_THIS_CALL swap(ios_base& _Right) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 354  :         if (this != _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@Vios_base@std@@@std@@YAPEAVios_base@0@AEAV10@@Z ; std::addressof<std::ios_base>
	cmp	QWORD PTR this$[rsp], rax
	je	$LN2@swap

; 355  :             _STD swap(_Mystate, _Right._Mystate);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 16
	mov	rdx, rax
	call	??$swap@H$0A@@std@@YAXAEAH0@Z		; std::swap<int,0>

; 356  :             _STD swap(_Except, _Right._Except);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 20
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 20
	mov	rdx, rax
	call	??$swap@H$0A@@std@@YAXAEAH0@Z		; std::swap<int,0>

; 357  :             _STD swap(_Fmtfl, _Right._Fmtfl);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 24
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 24
	mov	rdx, rax
	call	??$swap@H$0A@@std@@YAXAEAH0@Z		; std::swap<int,0>

; 358  :             _STD swap(_Prec, _Right._Prec);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 32					; 00000020H
	mov	rdx, rax
	call	??$swap@_J$0A@@std@@YAXAEA_J0@Z		; std::swap<__int64,0>

; 359  :             _STD swap(_Wide, _Right._Wide);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 40					; 00000028H
	mov	rdx, rax
	call	??$swap@_J$0A@@std@@YAXAEA_J0@Z		; std::swap<__int64,0>

; 360  : 
; 361  :             _STD swap(_Arr, _Right._Arr);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 48					; 00000030H
	mov	rdx, rax
	call	??$swap@PEAU_Iosarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Iosarray@ios_base@0@0@Z ; std::swap<std::ios_base::_Iosarray *,0>

; 362  :             _STD swap(_Calls, _Right._Calls);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 56					; 00000038H
	mov	rdx, rax
	call	??$swap@PEAU_Fnarray@ios_base@std@@$0A@@std@@YAXAEAPEAU_Fnarray@ios_base@0@0@Z ; std::swap<std::ios_base::_Fnarray *,0>

; 363  :             _STD swap(_Ploc, _Right._Ploc);

	mov	rax, QWORD PTR _Right$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 64					; 00000040H
	mov	rdx, rax
	call	??$swap@PEAVlocale@std@@$0A@@std@@YAXAEAPEAVlocale@0@0@Z ; std::swap<std::locale *,0>
	npad	1
$LN2@swap:

; 364  :         }
; 365  :     }

	add	rsp, 40					; 00000028H
	ret	0
?swap@ios_base@std@@QEAAXAEAV12@@Z ENDP			; std::ios_base::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?getloc@ios_base@std@@QEBA?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT

; 288  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const noexcept /* strengthened */ { // get locale

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 289  :         return *_Ploc;

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0locale@std@@QEAA@AEBV01@@Z		; std::locale::locale
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 290  :     }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA PROC ; `std::ios_base::getloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??getloc@ios_base@std@@QEBA?AVlocale@2@XZ@4HA ENDP ; `std::ios_base::getloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?flags@ios_base@std@@QEBAHXZ PROC			; std::ios_base::flags, COMDAT

; 236  :     _NODISCARD fmtflags __CLR_OR_THIS_CALL flags() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 237  :         return _Fmtfl;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]

; 238  :     }

	ret	0
?flags@ios_base@std@@QEBAHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?fail@ios_base@std@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 32
this$ = 64
?fail@ios_base@std@@QEBA_NXZ PROC			; std::ios_base::fail, COMDAT

; 213  :     _NODISCARD bool __CLR_OR_THIS_CALL fail() const noexcept /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 214  :         return rdstate() & (ios_base::badbit | ios_base::failbit);

	mov	rcx, QWORD PTR this$[rsp]
	call	?rdstate@ios_base@std@@QEBAHXZ		; std::ios_base::rdstate
	and	eax, 6
	test	eax, eax
	je	SHORT $LN3@fail
	mov	BYTE PTR tv68[rsp], 1
	jmp	SHORT $LN4@fail
$LN3@fail:
	mov	BYTE PTR tv68[rsp], 0
$LN4@fail:
	movzx	eax, BYTE PTR tv68[rsp]

; 215  :     }

	add	rsp, 56					; 00000038H
	ret	0
?fail@ios_base@std@@QEBA_NXZ ENDP			; std::ios_base::fail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?good@ios_base@std@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?good@ios_base@std@@QEBA_NXZ PROC			; std::ios_base::good, COMDAT

; 205  :     _NODISCARD bool __CLR_OR_THIS_CALL good() const noexcept /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 206  :         return rdstate() == ios_base::goodbit;

	mov	rcx, QWORD PTR this$[rsp]
	call	?rdstate@ios_base@std@@QEBAHXZ		; std::ios_base::rdstate
	test	eax, eax
	jne	SHORT $LN3@good
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@good
$LN3@good:
	mov	DWORD PTR tv67[rsp], 0
$LN4@good:
	movzx	eax, BYTE PTR tv67[rsp]

; 207  :     }

	add	rsp, 56					; 00000038H
	ret	0
?good@ios_base@std@@QEBA_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?rdstate@ios_base@std@@QEBAHXZ PROC			; std::ios_base::rdstate, COMDAT

; 186  :     _NODISCARD iostate __CLR_OR_THIS_CALL rdstate() const noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 187  :         return _Mystate;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]

; 188  :     }

	ret	0
?rdstate@ios_base@std@@QEBAHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
_State$ = 56
?clear@ios_base@std@@QEAAXH@Z PROC			; std::ios_base::clear, COMDAT

; 176  :     void __CLR_OR_THIS_CALL clear(iostate _State = goodbit) { // set state to argument

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 177  :         clear(_State, false);

	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@ios_base@std@@QEAAXH_N@Z		; std::ios_base::clear
	npad	1

; 178  :     }

	add	rsp, 40					; 00000028H
	ret	0
?clear@ios_base@std@@QEAAXH@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QEAAXH_N@Z
_TEXT	SEGMENT
_Filtered$ = 32
_Msg$1 = 40
$T2 = 48
$T3 = 64
this$ = 128
_State$ = 136
_Reraise$ = 144
?clear@ios_base@std@@QEAAXH_N@Z PROC			; std::ios_base::clear, COMDAT

; 154  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

$LN9:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 155  :         _State &= _Statmask;

	mov	eax, DWORD PTR _State$[rsp]
	and	eax, 23
	mov	DWORD PTR _State$[rsp], eax

; 156  :         _Mystate             = _State;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _State$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 157  :         const auto _Filtered = _State & _Except;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	ecx, DWORD PTR _State$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR _Filtered$[rsp], eax

; 158  :         if (_Filtered) {

	cmp	DWORD PTR _Filtered$[rsp], 0
	je	$LN2@clear

; 159  :             if (_Reraise) {

	movzx	eax, BYTE PTR _Reraise$[rsp]
	test	eax, eax
	je	SHORT $LN3@clear

; 160  :                 _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
$LN3@clear:

; 161  :             }
; 162  : 
; 163  :             const char* _Msg;
; 164  :             if (_Filtered & ios_base::badbit) {

	mov	eax, DWORD PTR _Filtered$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN4@clear

; 165  :                 _Msg = "ios_base::badbit set";

	lea	rax, OFFSET FLAT:??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
	mov	QWORD PTR _Msg$1[rsp], rax
	jmp	SHORT $LN5@clear
$LN4@clear:

; 166  :             } else if (_Filtered & ios_base::failbit) {

	mov	eax, DWORD PTR _Filtered$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN6@clear

; 167  :                 _Msg = "ios_base::failbit set";

	lea	rax, OFFSET FLAT:??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
	mov	QWORD PTR _Msg$1[rsp], rax

; 168  :             } else {

	jmp	SHORT $LN7@clear
$LN6@clear:

; 169  :                 _Msg = "ios_base::eofbit set";

	lea	rax, OFFSET FLAT:??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
	mov	QWORD PTR _Msg$1[rsp], rax
$LN7@clear:
$LN5@clear:

; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

	mov	edx, 1
	lea	rcx, QWORD PTR $T2[rsp]
	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	mov	r8, rax
	mov	rdx, QWORD PTR _Msg$1[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z ; std::ios_base::failure::failure
	lea	rdx, OFFSET FLAT:_TI5?AVfailure@ios_base@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	npad	1
$LN2@clear:
$LN8@clear:

; 173  :         }
; 174  :     }

	add	rsp, 120				; 00000078H
	ret	0
?clear@ios_base@std@@QEAAXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfailure@ios_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gfailure@ios_base@std@@UEAAPEAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1failure@ios_base@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gfailure@ios_base@std@@UEAAPEAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0failure@ios_base@std@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0failure@ios_base@std@@QEAA@AEBV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0system_error@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7failure@ios_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0failure@ios_base@std@@QEAA@AEBV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::ios_base::failure::failure'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1system_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0failure@ios_base@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::ios_base::failure::failure'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1failure@ios_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1failure@ios_base@std@@UEAA@XZ PROC			; std::ios_base::failure::~failure, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1system_error@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1failure@ios_base@std@@UEAA@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA PROC	; `std::ios_base::failure::~failure'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1system_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1failure@ios_base@std@@UEAA@XZ@4HA ENDP	; `std::ios_base::failure::~failure'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
_Message$ = 88
_Errcode$ = 96
??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z PROC ; std::ios_base::failure::failure, COMDAT

; 116  :         explicit failure(const char* _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 117  :             : system_error(_Errcode, _Message) {} // construct with message

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	mov	r8, QWORD PTR _Message$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@PEBD@Z ; std::system_error::system_error
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7failure@ios_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z ENDP ; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
_Message$ = 88
_Errcode$ = 96
?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA PROC ; `std::ios_base::failure::failure'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1system_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z@4HA ENDP ; `std::ios_base::failure::failure'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z PROC ; std::_Adl_verify_range<char *,char const *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ENDP ; std::_Adl_verify_range<char *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 432  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 433  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 434  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	rax, QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	QWORD PTR _Psave$2[rsp], rax

; 435  : 
; 436  :     const size_t _Id         = _Facet::id._Get_index();

	lea	rcx, OFFSET FLAT:?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
	call	??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ ; std::locale::id::_Get_index<0>
	mov	QWORD PTR _Id$6[rsp], rax

; 437  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	rdx, QWORD PTR _Id$6[rsp]
	mov	rcx, QWORD PTR _Loc$[rsp]
	call	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ; std::locale::_Getfacet
	mov	QWORD PTR _Pf$4[rsp], rax

; 438  : 
; 439  :     if (!_Pf) {

	cmp	QWORD PTR _Pf$4[rsp], 0
	jne	$LN2@use_facet

; 440  :         if (_Psave) {

	cmp	QWORD PTR _Psave$2[rsp], 0
	je	SHORT $LN3@use_facet

; 441  :             _Pf = _Psave; // lazy facet already allocated

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 442  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	rdx, QWORD PTR _Loc$[rsp]
	lea	rcx, QWORD PTR _Psave$2[rsp]
	call	?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::ctype<char>::_Getcat
	cmp	rax, -1
	jne	SHORT $LN5@use_facet

; 443  : #if _HAS_EXCEPTIONS
; 444  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 445  : #else
; 446  :             _CSTD abort(); // lazy disallowed
; 447  : #endif
; 448  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 449  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pfmod$3[rsp], rax

; 450  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	rdx, QWORD PTR _Pfmod$3[rsp]
	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	npad	1

; 451  : 
; 452  : #if defined(_M_CEE)
; 453  :             _Facet_Register_m(_Pfmod);
; 454  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 455  :             _Facet_Register(_Pfmod);

	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 456  : #endif // ^^^ !defined(_M_CEE) ^^^
; 457  : 
; 458  :             _Pfmod->_Incref();

	mov	rax, QWORD PTR _Pfmod$3[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	QWORD PTR [rax+8]

; 459  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB, rax ; std::_Facetptr<std::ctype<char> >::_Psave

; 460  :             _Pf                       = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax

; 461  : 
; 462  :             (void) _Psave_guard.release();

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
	npad	1

; 463  :         }

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	npad	1
$LN2@use_facet:

; 464  :     }
; 465  : 
; 466  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	rax, QWORD PTR _Pf$4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	mov	rax, QWORD PTR $T7[rsp]

; 467  :     _END_LOCK()
; 468  : } // end of use_facet body

	add	rsp, 104				; 00000068H
	ret	0
$LN10@use_facet:
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Lock$1[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Psave_guard$5[rbp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$ctype@D@std@@MEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$ctype@D@std@@MEAAPEAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$ctype@D@std@@MEAA@XZ		; std::ctype<char>::~ctype<char>
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$ctype@D@std@@MEAAPEAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
__formal$ = 72
_Dest$ = 80
?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z PROC	; std::ctype<char>::do_narrow, COMDAT

; 2873 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

$LN3:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2874 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ; std::_Adl_verify_range<char const *,char const *>

; 2875 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	call	memcpy

; 2876 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 2877 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z ENDP	; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MEBADDD@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
__formal$ = 24
?do_narrow@?$ctype@D@std@@MEBADDD@Z PROC		; std::ctype<char>::do_narrow, COMDAT

; 2868 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx

; 2869 :         return _Ch;

	movzx	eax, BYTE PTR _Ch$[rsp]

; 2870 :     }

	ret	0
?do_narrow@?$ctype@D@std@@MEBADDD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z PROC	; std::ctype<char>::do_widen, COMDAT

; 2862 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2863 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ; std::_Adl_verify_range<char const *,char const *>

; 2864 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	call	memcpy

; 2865 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 2866 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z ENDP	; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MEBADD@Z
_TEXT	SEGMENT
this$ = 8
_Byte$ = 16
?do_widen@?$ctype@D@std@@MEBADD@Z PROC			; std::ctype<char>::do_widen, COMDAT

; 2857 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx

; 2858 :         return _Byte;

	movzx	eax, BYTE PTR _Byte$[rsp]

; 2859 :     }

	ret	0
?do_widen@?$ctype@D@std@@MEBADD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z PROC	; std::ctype<char>::do_toupper, COMDAT

; 2848 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2849 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ; std::_Adl_verify_range<char *,char const *>
	npad	1

; 2850 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_toupper
$LN2@do_toupper:
	mov	rax, QWORD PTR _First$[rsp]
	inc	rax
	mov	QWORD PTR _First$[rsp], rax
$LN4@do_toupper:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_toupper

; 2851 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, QWORD PTR _First$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	rdx, rax
	call	_Toupper
	mov	rcx, QWORD PTR _First$[rsp]
	mov	BYTE PTR [rcx], al

; 2852 :         }

	jmp	SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2853 : 
; 2854 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2855 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z ENDP	; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MEBADD@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
?do_toupper@?$ctype@D@std@@MEBADD@Z PROC		; std::ctype<char>::do_toupper, COMDAT

; 2843 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2844 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	movzx	ecx, BYTE PTR _Ch$[rsp]
	mov	rdx, rax
	call	_Toupper

; 2845 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_toupper@?$ctype@D@std@@MEBADD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z PROC	; std::ctype<char>::do_tolower, COMDAT

; 2834 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2835 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ; std::_Adl_verify_range<char *,char const *>
	npad	1

; 2836 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_tolower
$LN2@do_tolower:
	mov	rax, QWORD PTR _First$[rsp]
	inc	rax
	mov	QWORD PTR _First$[rsp], rax
$LN4@do_tolower:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_tolower

; 2837 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, QWORD PTR _First$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	rdx, rax
	call	_Tolower
	mov	rcx, QWORD PTR _First$[rsp]
	mov	BYTE PTR [rcx], al

; 2838 :         }

	jmp	SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2839 : 
; 2840 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2841 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z ENDP	; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MEBADD@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
?do_tolower@?$ctype@D@std@@MEBADD@Z PROC		; std::ctype<char>::do_tolower, COMDAT

; 2829 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2830 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	movzx	ecx, BYTE PTR _Ch$[rsp]
	mov	rdx, rax
	call	_Tolower

; 2831 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_tolower@?$ctype@D@std@@MEBADD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Tidy@?$ctype@D@std@@IEAAXXZ PROC			; std::ctype<char>::_Tidy, COMDAT

; 2819 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2820 :         if (0 < _Ctype._Delfl) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jle	SHORT $LN2@Tidy

; 2821 :             _CSTD free(const_cast<short*>(_Ctype._Table));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	free
	npad	1
	jmp	SHORT $LN3@Tidy
$LN2@Tidy:

; 2822 :         } else if (_Ctype._Delfl < 0) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jge	SHORT $LN3@Tidy

; 2823 :             delete[] _Ctype._Table;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1
$LN3@Tidy:

; 2824 :         }
; 2825 : 
; 2826 :         _CSTD free(_Ctype._LocaleName);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	free
	npad	1

; 2827 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$ctype@D@std@@IEAAXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 96
_Lobj$ = 104
?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z PROC	; std::ctype<char>::_Init, COMDAT

; 2815 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 2816 :         _Ctype = _Lobj._Getctype();

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+16]
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb

; 2817 :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z ENDP	; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ctype@D@std@@MEAA@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT

; 2811 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$ctype@D@std@@6B@
	mov	QWORD PTR [rax], rcx

; 2812 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$ctype@D@std@@IEAAXXZ		; std::ctype<char>::_Tidy
	npad	1

; 2813 :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$ctype@D@std@@MEAA@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA PROC		; `std::ctype<char>::~ctype<char>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$ctype@D@std@@MEAA@XZ@4HA ENDP		; `std::ctype<char>::~ctype<char>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv91 = 48
tv133 = 56
tv130 = 64
tv90 = 72
$T3 = 80
$T4 = 88
_Ppf$ = 208
_Ploc$ = 216
?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2792 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	DWORD PTR $T1[rsp], 0

; 2793 :         if (_Ppf && !*_Ppf) {

	cmp	QWORD PTR _Ppf$[rsp], 0
	je	$LN2@Getcat
	mov	rax, QWORD PTR _Ppf$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	$LN2@Getcat

; 2794 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN4@Getcat
	mov	rcx, QWORD PTR _Ploc$[rsp]
	call	?_C_str@locale@std@@QEBAPEBDXZ		; std::locale::_C_str
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0_Locinfo@std@@QEAA@PEBD@Z		; std::_Locinfo::_Locinfo
	mov	QWORD PTR tv133[rsp], rax
	mov	rax, QWORD PTR tv133[rsp]
	mov	QWORD PTR tv130[rsp], rax
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR tv130[rsp]
	mov	QWORD PTR tv90[rsp], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv90[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z ; std::ctype<char>::ctype<char>
	mov	QWORD PTR tv91[rsp], rax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	QWORD PTR tv91[rsp], 0
$LN5@Getcat:
	mov	rax, QWORD PTR tv91[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR _Ppf$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rax], rcx
	mov	eax, DWORD PTR $T1[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T1[rsp], -2
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
	npad	1
$LN2@Getcat:

; 2795 :         }
; 2796 : 
; 2797 :         return _X_CTYPE;

	mov	eax, 2

; 2798 :     }

	add	rsp, 200				; 000000c8H
	ret	0
?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ENDP ; std::ctype<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv91 = 48
tv133 = 56
tv130 = 64
tv90 = 72
$T3 = 80
$T4 = 88
_Ppf$ = 208
_Ploc$ = 216
?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::ctype<char>::_Getcat'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::ctype<char>::_Getcat'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv91 = 48
tv133 = 56
tv130 = 64
tv90 = 72
$T3 = 80
$T4 = 88
_Ppf$ = 208
_Ploc$ = 216
?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::ctype<char>::_Getcat'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::ctype<char>::_Getcat'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
_TEXT	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z PROC		; std::ctype<char>::ctype<char>, COMDAT

; 2788 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Refs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0ctype_base@std@@QEAA@_K@Z		; std::ctype_base::ctype_base
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$ctype@D@std@@6B@
	mov	QWORD PTR [rax], rcx

; 2789 :         _Init(_Lobj);

	mov	rdx, QWORD PTR _Lobj$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z ; std::ctype<char>::_Init
	npad	1

; 2790 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA PROC ; `std::ctype<char>::ctype<char>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA ENDP ; `std::ctype<char>::ctype<char>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QEBADD@Z
_TEXT	SEGMENT
tv70 = 32
this$ = 64
_Byte$ = 72
?widen@?$ctype@D@std@@QEBADD@Z PROC			; std::ctype<char>::widen, COMDAT

; 2751 :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2752 :         return do_widen(_Byte);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR tv70[rsp], rax
	movzx	edx, BYTE PTR _Byte$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv70[rsp]

; 2753 :     }

	add	rsp, 56					; 00000038H
	ret	0
?widen@?$ctype@D@std@@QEBADD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?is@?$ctype@D@std@@QEBA_NFD@Z
_TEXT	SEGMENT
tv73 = 0
this$ = 32
_Maskval$ = 40
_Ch$ = 48
?is@?$ctype@D@std@@QEBA_NFD@Z PROC			; std::ctype<char>::is, COMDAT

; 2699 :     bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2700 :         return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;

	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	movsx	eax, WORD PTR [rcx+rax*2]
	movsx	ecx, WORD PTR _Maskval$[rsp]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN3@is
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN4@is
$LN3@is:
	mov	DWORD PTR tv73[rsp], 0
$LN4@is:
	movzx	eax, BYTE PTR tv73[rsp]

; 2701 :     }

	add	rsp, 24
	ret	0
?is@?$ctype@D@std@@QEBA_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gctype_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gctype_base@std@@UEAAPEAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gctype_base@std@@UEAAPEAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??1ctype_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ctype_base@std@@UEAA@XZ PROC				; std::ctype_base::~ctype_base, COMDAT

; 2447 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept override {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7ctype_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1ctype_base@std@@UEAA@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA PROC		; `std::ctype_base::~ctype_base'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1ctype_base@std@@UEAA@XZ@4HA ENDP		; `std::ctype_base::~ctype_base'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??0ctype_base@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Refs$ = 56
??0ctype_base@std@@QEAA@_K@Z PROC			; std::ctype_base::ctype_base, COMDAT

; 2444 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) noexcept // strengthened

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2445 :         : locale::facet(_Refs) {}

	mov	rdx, QWORD PTR _Refs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0facet@locale@std@@IEAA@_K@Z		; std::locale::facet::facet
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7ctype_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ctype_base@std@@QEAA@_K@Z ENDP			; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Refs$ = 56
?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA PROC	; `std::ctype_base::ctype_base'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0ctype_base@std@@QEAA@_K@Z@4HA ENDP	; `std::ctype_base::ctype_base'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Glocale@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Glocale@std@@QEAAPEAXI@Z PROC			; std::locale::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Glocale@std@@QEAAPEAXI@Z ENDP			; std::locale::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
tv71 = 32
_Facptr$ = 40
_Ptr0$ = 48
this$ = 80
_Id$ = 88
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 374  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 375  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Id$[rsp], rax
	jae	SHORT $LN6@Getfacet
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR _Id$[rsp]
	mov	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN7@Getfacet
$LN6@Getfacet:
	mov	QWORD PTR tv71[rsp], 0
$LN7@Getfacet:
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR _Facptr$[rsp], rax

; 376  :         if (_Facptr || !_Ptr->_Xparent) {

	cmp	QWORD PTR _Facptr$[rsp], 0
	jne	SHORT $LN3@Getfacet
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	jne	SHORT $LN2@Getfacet
$LN3@Getfacet:

; 377  :             return _Facptr; // found facet or not transparent

	mov	rax, QWORD PTR _Facptr$[rsp]
	jmp	SHORT $LN1@Getfacet
$LN2@Getfacet:

; 378  :         }
; 379  : 
; 380  :         // look in current locale
; 381  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	mov	QWORD PTR _Ptr0$[rsp], rax

; 382  :         if (_Id < _Ptr0->_Facetcount) {

	mov	rax, QWORD PTR _Ptr0$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Id$[rsp], rax
	jae	SHORT $LN4@Getfacet

; 383  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

	mov	rax, QWORD PTR _Ptr0$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR _Id$[rsp]
	mov	rax, QWORD PTR [rax+rcx*8]
	jmp	SHORT $LN1@Getfacet
$LN4@Getfacet:

; 384  :         }
; 385  : 
; 386  :         return nullptr; // no entry in current locale

	xor	eax, eax
$LN1@Getfacet:

; 387  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?_C_str@locale@std@@QEBAPEBDXZ
_TEXT	SEGMENT
tv70 = 32
this$ = 64
?_C_str@locale@std@@QEBAPEBDXZ PROC			; std::locale::_C_str, COMDAT

; 370  :     _Ret_z_ const char* _C_str() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 371  :         return _Ptr ? _Ptr->_Name.c_str() : "";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@C_str
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	?c_str@?$_Yarn@D@std@@QEBAPEBDXZ	; std::_Yarn<char>::c_str
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN4@C_str
$LN3@C_str:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv70[rsp], rax
$LN4@C_str:
	mov	rax, QWORD PTR tv70[rsp]

; 372  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_C_str@locale@std@@QEBAPEBDXZ ENDP			; std::locale::_C_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv85 = 40
tv86 = 48
this$ = 80
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 351  :     ~locale() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 352  :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@locale

; 353  :             delete _Ptr->_Decref();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+16]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN4@locale
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv85[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR tv85[rsp]
	mov	QWORD PTR tv86[rsp], rax
	jmp	SHORT $LN5@locale
$LN4@locale:
	mov	QWORD PTR tv86[rsp], 0
$LN5@locale:
$LN2@locale:

; 354  :         }
; 355  :     }

	add	rsp, 72					; 00000048H
	ret	0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??0locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0locale@std@@QEAA@XZ PROC				; std::locale::locale, COMDAT

; 270  :     locale() noexcept : _Ptr(_Init(true)) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	cl, 1
	call	?_Init@locale@std@@CAPEAV_Locimp@12@_N@Z ; std::locale::_Init
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0locale@std@@QEAA@XZ ENDP				; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??0locale@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0locale@std@@QEAA@AEBV01@@Z PROC			; std::locale::locale, COMDAT

; 266  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 267  :         _Ptr->_Incref();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+8]
	npad	1

; 268  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0locale@std@@QEAA@AEBV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfacet@locale@std@@MEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gfacet@locale@std@@MEAAPEAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gfacet@locale@std@@MEAAPEAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??1facet@locale@std@@MEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1facet@locale@std@@MEAA@XZ PROC			; std::locale::facet::~facet, COMDAT

; 144  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7facet@locale@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Facet_base@std@@UEAA@XZ		; std::_Facet_base::~_Facet_base
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1facet@locale@std@@MEAA@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA PROC	; `std::locale::facet::~facet'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Facet_base@std@@UEAA@XZ		; std::_Facet_base::~_Facet_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1facet@locale@std@@MEAA@XZ@4HA ENDP	; `std::locale::facet::~facet'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??0facet@locale@std@@IEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Initrefs$ = 56
??0facet@locale@std@@IEAA@_K@Z PROC			; std::locale::facet::facet, COMDAT

; 142  :         {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_Facet_base@std@@QEAA@XZ
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7facet@locale@std@@6B@
	mov	QWORD PTR [rax], rcx

; 141  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _Initrefs$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 142  :         {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0facet@locale@std@@IEAA@_K@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Initrefs$ = 56
?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA PROC	; `std::locale::facet::facet'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Facet_base@std@@UEAA@XZ		; std::_Facet_base::~_Facet_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0facet@locale@std@@IEAA@_K@Z@4HA ENDP	; `std::locale::facet::facet'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
_TEXT	SEGMENT
this$ = 8
?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ PROC ; std::locale::facet::_Decref, COMDAT

; 128  :         _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count

	mov	QWORD PTR [rsp+8], rcx

; 129  :             if (_MT_DECR(_Myrefs) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decref

; 130  :                 return this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@Decref
$LN2@Decref:

; 131  :             }
; 132  : 
; 133  :             return nullptr;

	xor	eax, eax
$LN1@Decref:

; 134  :         }

	ret	0
?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ ENDP ; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Incref@facet@locale@std@@UEAAXXZ PROC			; std::locale::facet::_Incref, COMDAT

; 124  :         void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count

	mov	QWORD PTR [rsp+8], rcx

; 125  :             _MT_INCR(_Myrefs);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lock inc DWORD PTR [rax]

; 126  :         }

	ret	0
?_Incref@facet@locale@std@@UEAAXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$_Yarn@_W@std@@AEAAXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT

; 202  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 203  :         if (_Myptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
	npad	1
$LN2@Tidy:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 212  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Tidy@?$_Yarn@_W@std@@AEAAXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Yarn@_W@std@@QEAA@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 182  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Yarn@_W@std@@AEAAXXZ		; std::_Yarn<wchar_t>::_Tidy
	npad	1

; 183  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Yarn@_W@std@@QEAA@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ??0?$_Yarn@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Yarn@_W@std@@QEAA@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT

; 140  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+8], ax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Yarn@_W@std@@QEAA@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$_Yarn@D@std@@AEAAXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT

; 202  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 203  :         if (_Myptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
	npad	1
$LN2@Tidy:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 212  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Tidy@?$_Yarn@D@std@@AEAAXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ?c_str@?$_Yarn@D@std@@QEBAPEBDXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?c_str@?$_Yarn@D@std@@QEBAPEBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT

; 189  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 190  :         return _Myptr ? _Myptr : &_Nul;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@c_str
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN4@c_str
$LN3@c_str:
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv68[rsp], rax
$LN4@c_str:
	mov	rax, QWORD PTR tv68[rsp]

; 191  :     }

	add	rsp, 24
	ret	0
?c_str@?$_Yarn@D@std@@QEBAPEBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Yarn@D@std@@QEAA@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 182  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Yarn@D@std@@AEAAXXZ		; std::_Yarn<char>::_Tidy
	npad	1

; 183  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Yarn@D@std@@QEAA@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ??0?$_Yarn@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Yarn@D@std@@QEAA@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT

; 140  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Yarn@D@std@@QEAA@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 96
__$ReturnUdt$ = 104
?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT

; 276  :     _Ctypevec __CLR_OR_THIS_CALL _Getctype() const {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 277  :         return ::_Getctype();

	lea	rcx, QWORD PTR $T1[rsp]
	call	_Getctype
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 278  :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Locinfo@std@@QEAA@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT

; 256  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 257  :         _Locinfo_dtor(this);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPEAV12@@Z ; std::_Locinfo::_Locinfo_dtor
	npad	1

; 258  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1_Locinfo@std@@QEAA@XZ ENDP				; std::_Locinfo::~_Locinfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA PROC		; `std::_Locinfo::~_Locinfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1_Locinfo@std@@QEAA@XZ@4HA ENDP		; `std::_Locinfo::~_Locinfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA PROC		; `std::_Locinfo::~_Locinfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1_Locinfo@std@@QEAA@XZ@4HA ENDP		; `std::_Locinfo::~_Locinfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA PROC		; `std::_Locinfo::~_Locinfo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1_Locinfo@std@@QEAA@XZ@4HA ENDP		; `std::_Locinfo::~_Locinfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA PROC		; `std::_Locinfo::~_Locinfo'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???1_Locinfo@std@@QEAA@XZ@4HA ENDP		; `std::_Locinfo::~_Locinfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA PROC		; `std::_Locinfo::~_Locinfo'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???1_Locinfo@std@@QEAA@XZ@4HA ENDP		; `std::_Locinfo::~_Locinfo'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA PROC		; `std::_Locinfo::~_Locinfo'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 72					; 00000048H
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???1_Locinfo@std@@QEAA@XZ@4HA ENDP		; `std::_Locinfo::~_Locinfo'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA PROC		; `std::_Locinfo::~_Locinfo'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 88					; 00000058H
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???1_Locinfo@std@@QEAA@XZ@4HA ENDP		; `std::_Locinfo::~_Locinfo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QEAA@PEBD@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
??0_Locinfo@std@@QEAA@PEBD@Z PROC			; std::_Locinfo::_Locinfo, COMDAT

; 234  :     {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  :         : _Lock(_LOCK_LOCALE)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 234  :     {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??0?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1

; 235  :         if (_Pch) {

	cmp	QWORD PTR _Pch$[rsp], 0
	je	SHORT $LN2@Locinfo

; 236  :             _Locinfo_ctor(this, _Pch);

	mov	rdx, QWORD PTR _Pch$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPEAV12@PEBD@Z ; std::_Locinfo::_Locinfo_ctor
	npad	1

; 237  :             return;

	jmp	SHORT $LN1@Locinfo
$LN2@Locinfo:

; 238  :         }
; 239  : 
; 240  :         _Xruntime_error("bad locale name");

	lea	rcx, OFFSET FLAT:??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	?_Xruntime_error@std@@YAXPEBD@Z		; std::_Xruntime_error
	npad	1
$LN1@Locinfo:

; 241  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
$LN11@Locinfo:
??0_Locinfo@std@@QEAA@PEBD@Z ENDP			; std::_Locinfo::_Locinfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 72					; 00000048H
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
this$ = 64
_Pch$ = 72
?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 88					; 00000058H
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Facet_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Facet_base@std@@UEAAPEAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Facet_base@std@@UEAA@XZ		; std::_Facet_base::~_Facet_base
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G_Facet_base@std@@UEAAPEAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_Facet_base@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Facet_base@std@@QEAA@XZ PROC			; std::_Facet_base::_Facet_base, COMDAT
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_Facet_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Facet_base@std@@QEAA@XZ ENDP			; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xfacet
;	COMDAT ??1_Facet_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Facet_base@std@@UEAA@XZ PROC			; std::_Facet_base::~_Facet_base, COMDAT

; 25   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_Facet_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	ret	0
??1_Facet_base@std@@UEAA@XZ ENDP			; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 669  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 670  :     return _Static._Storage;

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 671  : }

	ret	0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category2@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Iostream_error_category2@std@@UEAAPEAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Iostream_error_category2@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G_Iostream_error_category2@std@@UEAAPEAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category2@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Iostream_error_category2@std@@UEAA@XZ PROC		; std::_Iostream_error_category2::~_Iostream_error_category2, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1error_category@std@@UEAA@XZ		; std::error_category::~error_category
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1_Iostream_error_category2@std@@UEAA@XZ ENDP		; std::_Iostream_error_category2::~_Iostream_error_category2
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA PROC ; `std::_Iostream_error_category2::~_Iostream_error_category2'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1error_category@std@@UEAA@XZ		; std::error_category::~error_category
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1_Iostream_error_category2@std@@UEAA@XZ@4HA ENDP ; `std::_Iostream_error_category2::~_Iostream_error_category2'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = 32
_Iostream_error_length$2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT

; 555  :     _NODISCARD string message(int _Errcode) const override {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 556  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

	cmp	DWORD PTR _Errcode$[rsp], 1
	jne	SHORT $LN2@message

; 557  :             static constexpr char _Iostream_error[] = "iostream stream error";
; 558  :             constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; // TRANSITION, DevCom-906503

	mov	QWORD PTR _Iostream_error_length$2[rsp], 21

; 559  :             return string{_Iostream_error, _Iostream_error_length};

	mov	r8d, 21
	lea	rdx, OFFSET FLAT:?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@message

; 560  :         } else {

	jmp	SHORT $LN1@message
$LN2@message:

; 561  :             return _Syserror_map(_Errcode);

	mov	ecx, DWORD PTR _Errcode$[rsp]
	call	?_Syserror_map@std@@YAPEBDH@Z		; std::_Syserror_map
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@message:

; 562  :         }
; 563  :     }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Iostream_error_length$2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA PROC ; `std::_Iostream_error_category2::message'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA ENDP ; `std::_Iostream_error_category2::message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_Iostream_error_category2@std@@UEBAPEBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT

; 551  :     _NODISCARD const char* name() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx

; 552  :         return "iostream";

	lea	rax, OFFSET FLAT:??_C@_08LLGCOLLL@iostream@

; 553  :     }

	ret	0
?name@_Iostream_error_category2@std@@UEBAPEBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gsystem_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gsystem_error@std@@UEAAPEAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1system_error@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gsystem_error@std@@UEAAPEAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0system_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0system_error@std@@QEAA@AEBV01@@Z PROC		; std::system_error::system_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_System_error@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0system_error@std@@QEAA@AEBV01@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::system_error::system_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_System_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0system_error@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::system_error::system_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1system_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1system_error@std@@UEAA@XZ PROC			; std::system_error::~system_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_System_error@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1system_error@std@@UEAA@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA PROC	; `std::system_error::~system_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_System_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1system_error@std@@UEAA@XZ@4HA ENDP	; `std::system_error::~system_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
__$ArrayPad$ = 80
this$ = 128
_Errcode$ = 136
_Message$ = 144
??0system_error@std@@QEAA@Verror_code@1@PEBD@Z PROC	; std::system_error::system_error, COMDAT

; 490  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdx, QWORD PTR _Message$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
??0system_error@std@@QEAA@Verror_code@1@PEBD@Z ENDP	; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
__$ArrayPad$ = 80
this$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA PROC ; `std::system_error::system_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA ENDP ; `std::system_error::system_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
__$ArrayPad$ = 80
this$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA PROC ; `std::system_error::system_error'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_System_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA ENDP ; `std::system_error::system_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error@std@@UEAAPEAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_System_error@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G_System_error@std@@UEAAPEAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_System_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
__that$ = 72
??0_System_error@std@@QEAA@AEBV01@@Z PROC		; std::_System_error::_System_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0runtime_error@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	lea	rdi, QWORD PTR [rax+24]
	lea	rsi, QWORD PTR [rcx+24]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??0_System_error@std@@QEAA@AEBV01@@Z ENDP		; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
__that$ = 72
?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1runtime_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0_System_error@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_System_error@std@@UEAA@XZ PROC			; std::_System_error::~_System_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1runtime_error@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1_System_error@std@@UEAA@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA PROC	; `std::_System_error::~_System_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1runtime_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1_System_error@std@@UEAA@XZ@4HA ENDP	; `std::_System_error::~_System_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv138 = 40
tv134 = 48
tv84 = 56
tv139 = 64
tv136 = 72
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 144
__$ArrayPad$ = 176
this$ = 224
_Errcode$ = 232
_Message$ = 240
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT

; 475  :     _System_error(error_code _Errcode, const string& _Message)

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 476  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR tv138[rsp]
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR tv134[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	mov	r8, QWORD PTR tv84[rsp]
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
	mov	QWORD PTR tv139[rsp], rax
	mov	rax, QWORD PTR tv139[rsp]
	mov	QWORD PTR tv136[rsp], rax
	mov	rdx, QWORD PTR tv136[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	npad	1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rax+24]
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv138 = 40
tv134 = 48
tv84 = 56
tv139 = 64
tv136 = 72
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 144
__$ArrayPad$ = 176
this$ = 224
_Errcode$ = 232
_Message$ = 240
?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T1[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv138 = 40
tv134 = 48
tv84 = 56
tv139 = 64
tv136 = 72
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 144
__$ArrayPad$ = 176
this$ = 224
_Errcode$ = 232
_Message$ = 240
?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv138 = 40
tv134 = 48
tv84 = 56
tv139 = 64
tv136 = 72
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 144
__$ArrayPad$ = 176
this$ = 224
_Errcode$ = 232
_Message$ = 240
?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1runtime_error@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T1 = 32
tv92 = 40
tv86 = 48
tv80 = 56
$T2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 463  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 464  :         if (!_Message.empty()) {

	mov	rcx, QWORD PTR _Message$[rsp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Makestr

; 465  :             _Message.append(": ");

	lea	rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
	mov	rcx, QWORD PTR _Message$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
$LN2@Makestr:

; 466  :         }
; 467  : 
; 468  :         _Message.append(_Errcode.message());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR _Errcode$[rsp]
	call	?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
	mov	QWORD PTR tv92[rsp], rax
	mov	rax, QWORD PTR tv92[rsp]
	mov	QWORD PTR tv86[rsp], rax
	mov	rax, QWORD PTR tv86[rsp]
	mov	QWORD PTR tv80[rsp], rax
	mov	rdx, QWORD PTR tv80[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 469  :         return _Message;

	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rcx, QWORD PTR _Message$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 470  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
	int	3
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv92 = 40
tv86 = 48
tv80 = 56
$T2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR _Message$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv92 = 40
tv86 = 48
tv80 = 56
$T2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv92 = 40
tv86 = 48
tv80 = 56
$T2 = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@dtor$2
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN7@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Ec$ = 56
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 429  : _EXPORT_STD _NODISCARD inline error_code make_error_code(io_errc _Ec) noexcept {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 430  :     return error_code(static_cast<int>(_Ec), _STD iostream_category());

	call	?iostream_category@std@@YAAEBVerror_category@1@XZ ; std::iostream_category
	mov	r8, rax
	mov	edx, DWORD PTR _Ec$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_code::error_code
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 431  : }

	add	rsp, 40					; 00000028H
	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??8std@@YA_NAEBVerror_condition@0@0@Z
_TEXT	SEGMENT
tv82 = 32
tv76 = 36
tv72 = 40
tv74 = 48
_Left$ = 80
_Right$ = 88
??8std@@YA_NAEBVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 304  :     _NODISCARD friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	mov	rcx, QWORD PTR _Left$[rsp]
	call	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
	mov	QWORD PTR tv74[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??8error_category@std@@QEBA_NAEBV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	rcx, QWORD PTR _Left$[rsp]
	call	?value@error_condition@std@@QEBAHXZ	; std::error_condition::value
	mov	DWORD PTR tv76[rsp], eax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?value@error_condition@std@@QEBAHXZ	; std::error_condition::value
	mov	ecx, DWORD PTR tv76[rsp]
	cmp	ecx, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv82[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv82[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv82[rsp]

; 306  :     }

	add	rsp, 72					; 00000048H
	ret	0
??8std@@YA_NAEBVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?category@error_condition@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT

; 291  :     _NODISCARD const error_category& category() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 292  :         return *_Mycat;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 293  :     }

	ret	0
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?value@error_condition@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_condition@std@@QEBAHXZ PROC		; std::error_condition::value, COMDAT

; 287  :     _NODISCARD int value() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 288  :         return _Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]

; 289  :     }

	ret	0
?value@error_condition@std@@QEBAHXZ ENDP		; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _Val$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Cat$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
tv76 = 36
tv67 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT

; 206  :     _NODISCARD string message() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T1[rsp], 0

; 207  :         return category().message(value());

	mov	rcx, QWORD PTR this$[rsp]
	call	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
	mov	QWORD PTR tv67[rsp], rax
	mov	rax, QWORD PTR tv67[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?value@error_code@std@@QEBAHXZ		; std::error_code::value
	mov	DWORD PTR tv76[rsp], eax
	mov	r8d, DWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv67[rsp]
	call	QWORD PTR tv78[rsp]
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 208  :     }

	add	rsp, 72					; 00000048H
	ret	0
	int	3
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv76 = 36
tv67 = 40
tv78 = 48
this$ = 80
__$ReturnUdt$ = 88
?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA PROC ; `std::error_code::message'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ@4HA ENDP ; `std::error_code::message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?category@error_code@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_code@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_code::category, COMDAT

; 200  :     _NODISCARD const error_category& category() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 201  :         return *_Mycat;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 202  :     }

	ret	0
?category@error_code@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?value@error_code@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_code@std@@QEBAHXZ PROC			; std::error_code::value, COMDAT

; 196  :     _NODISCARD int value() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 197  :         return _Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]

; 198  :     }

	ret	0
?value@error_code@std@@QEBAHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??0error_code@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT

; 171  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _Val$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Cat$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z
_TEXT	SEGMENT
$T1 = 0
_Val$ = 32
??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z PROC ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>, COMDAT

; 2488 : _NODISCARD constexpr _To _Bit_cast(const _From& _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2489 :     return __builtin_bit_cast(_To, _Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 2490 : }

	add	rsp, 24
	ret	0
??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ENDP ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??8error_category@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv71 = 32
tv64 = 40
this$ = 64
_Right$ = 72
??8error_category@std@@QEBA_NAEBV01@@Z PROC		; std::error_category::operator==, COMDAT

; 99   :     _NODISCARD bool operator==(const error_category& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 100  : #ifdef _M_CEE_PURE
; 101  :         return _Addr == _Right._Addr;
; 102  : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
	mov	QWORD PTR tv64[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	add	rcx, 8
	call	??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
	mov	rcx, QWORD PTR tv64[rsp]
	cmp	rcx, rax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv71[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv71[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv71[rsp]

; 104  : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 105  :     }

	add	rsp, 56					; 00000038H
	ret	0
??8error_category@std@@QEBA_NAEBV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = 32
this$ = 64
_Code$ = 72
_Errval$ = 80
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT

; 416  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 417  :     return *this == _Code.category() && _Code.value() == _Errval;

	mov	rcx, QWORD PTR _Code$[rsp]
	call	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??8error_category@std@@QEBA_NAEBV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	rcx, QWORD PTR _Code$[rsp]
	call	?value@error_code@std@@QEBAHXZ		; std::error_code::value
	cmp	eax, DWORD PTR _Errval$[rsp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[rsp], 0
$LN4@equivalent:
	movzx	eax, BYTE PTR tv74[rsp]

; 418  : }

	add	rsp, 56					; 00000038H
	ret	0
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
_TEXT	SEGMENT
tv73 = 32
$T1 = 40
this$ = 80
_Errval$ = 88
_Cond$ = 96
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT

; 412  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 413  :     return default_error_condition(_Errval) == _Cond;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv73[rsp], rax
	mov	r8d, DWORD PTR _Errval$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR tv73[rsp]
	mov	rdx, QWORD PTR _Cond$[rsp]
	mov	rcx, rax
	call	??8std@@YA_NAEBVerror_condition@0@0@Z	; std::operator==

; 414  : }

	add	rsp, 72					; 00000048H
	ret	0
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Errval$ = 64
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT

; 407  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 408  :     // make error_condition for error code
; 409  :     return error_condition(_Errval, *this);

	mov	r8, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR _Errval$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 410  : }

	add	rsp, 40					; 00000028H
	ret	0
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ??1error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1error_category@std@@UEAA@XZ PROC			; std::error_category::~error_category, COMDAT

; 87   :     _CONSTEXPR20 virtual ~error_category() noexcept = default;

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1error_category@std@@UEAA@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\system_error
;	COMDAT ?iostream_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAAEBVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 697  : _EXPORT_STD _NODISCARD inline const error_category& iostream_category() noexcept {

$LN3:
	sub	rsp, 40					; 00000028H

; 698  :     return _Immortalize_memcpy_image<_Iostream_error_category2>();

	call	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>

; 699  : }

	add	rsp, 40					; 00000028H
	ret	0
?iostream_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gruntime_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gruntime_error@std@@UEAAPEAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1runtime_error@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gruntime_error@std@@UEAAPEAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runtime_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0runtime_error@std@@QEAA@AEBV01@@Z PROC		; std::runtime_error::runtime_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0runtime_error@std@@QEAA@AEBV01@@Z ENDP		; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::runtime_error::runtime_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0runtime_error@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::runtime_error::runtime_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1runtime_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1runtime_error@std@@UEAA@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1runtime_error@std@@UEAA@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA PROC	; `std::runtime_error::~runtime_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1runtime_error@std@@UEAA@XZ@4HA ENDP	; `std::runtime_error::~runtime_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\stdexcept
;	COMDAT ??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Message$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBD@Z		; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::runtime_error::runtime_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::runtime_error::runtime_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\Macro.hpp
;	COMDAT ?hash_@@YA?B_KPEBD@Z
_TEXT	SEGMENT
ret$ = 0
str$ = 32
?hash_@@YA?B_KPEBD@Z PROC				; hash_, COMDAT

; 203  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 204  : 	hash_t ret{ basis };

	mov	rax, -3750763034361777355		; cbf29ce484333335H
	mov	QWORD PTR ret$[rsp], rax
$LN2@hash_:

; 205  : 
; 206  : 	while (*str) {

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@hash_

; 207  : 		ret ^= *str;

	mov	rax, QWORD PTR str$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR ret$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 208  : 		ret *= prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR ret$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret$[rsp], rax

; 209  : 		str++;

	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax

; 210  : 	}

	jmp	SHORT $LN2@hash_
$LN3@hash_:

; 211  : 
; 212  : 	return ret;

	mov	rax, QWORD PTR ret$[rsp]

; 213  : }

	add	rsp, 24
	ret	0
?hash_@@YA?B_KPEBD@Z ENDP				; hash_
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winnt.h
;	COMDAT RtlSecureZeroMemory
_TEXT	SEGMENT
vptr$ = 0
ptr$ = 32
cnt$ = 40
RtlSecureZeroMemory PROC				; COMDAT

; 22907: {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16

; 22908:     volatile char *vptr = (volatile char *)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR vptr$[rsp], rax

; 22909: 
; 22910: #if defined(_M_AMD64) && !defined(_M_ARM64EC)
; 22911: 
; 22912:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

	mov	rdi, QWORD PTR vptr$[rsp]
	xor	eax, eax
	mov	rcx, QWORD PTR cnt$[rsp]
	rep stosb

; 22913: 
; 22914: #else
; 22915: 
; 22916:     while (cnt) {
; 22917: 
; 22918: #if !defined(_M_CEE) && (defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC))
; 22919: 
; 22920:         __iso_volatile_store8(vptr, 0);
; 22921: 
; 22922: #else
; 22923: 
; 22924:         *vptr = 0;
; 22925: 
; 22926: #endif
; 22927: 
; 22928:         vptr++;
; 22929:         cnt--;
; 22930:     }
; 22931: 
; 22932: #endif // _M_AMD64 && !defined(_M_ARM64EC)
; 22933: 
; 22934:     return ptr;

	mov	rax, QWORD PTR ptr$[rsp]

; 22935: }

	add	rsp, 16
	pop	rdi
	ret	0
RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 62   : [[noreturn]] inline void _Throw_bad_cast() {

$LN3:
	sub	rsp, 72					; 00000048H

; 63   :     _THROW(bad_cast{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_cast@std@@QEAA@XZ		; std::bad_cast::bad_cast
	lea	rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 64   : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_cast@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_cast::bad_cast'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_cast@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_cast::bad_cast'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA PROC		; `std::bad_cast::~bad_cast'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_cast@std@@UEAA@XZ@4HA ENDP		; `std::bad_cast::~bad_cast'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT

; 153  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 152  :         : exception("bad cast", 1)

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 153  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
	mov	QWORD PTR [rax], rcx

; 154  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA PROC		; `std::bad_cast::bad_cast'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_cast@std@@QEAA@XZ@4HA ENDP		; `std::bad_cast::bad_cast'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3074 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3075 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3076 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 32
this$ = 64
_Right$ = 72
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 3066 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3067 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv79[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 3068 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_size$ = 72
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 3038 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3039 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 3040 :         _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3041 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _New_size$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3042 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2954 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2955 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 2956 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2941 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2944 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2948 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2952 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT

; 2935 :     _NODISCARD _CONSTEXPR20 allocator_type get_allocator() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2936 :         return static_cast<allocator_type>(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2937 :     }

	add	rsp, 40					; 00000028H
	ret	0
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 2457 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2458 :         return _Mypair._Myval2._Mysize == 0;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv68[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv68[rsp]

; 2459 :     }

	add	rsp, 24
	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2349 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2350 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2351 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2352 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2353 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2354 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2355 :         );
; 2356 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 2345 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 2346 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 2347 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT

; 1891 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1892 :         _Eos(0);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	npad	1

; 1893 :     }

	add	rsp, 40					; 00000028H
	ret	0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1509 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1510 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1511 :     }

	add	rsp, 40					; 00000028H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Ptr$ = 104
_Count$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1486 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 1487 :         // append [_Ptr, _Ptr + _Count)
; 1488 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1489 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 1490 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1492 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1493 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 1494 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1495 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1496 :         }
; 1497 : 
; 1498 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
$LN1@append:

; 1499 :             _Count,
; 1500 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1501 :                 const size_type _Count) _STATIC_CALL_OPERATOR {
; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1505 :             },
; 1506 :             _Ptr, _Count);
; 1507 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
_Right$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1458 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1459 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1460 :     }

	add	rsp, 56					; 00000038H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Right_data$ = 40
_My_data$ = 48
_Right_data_mem$3 = 56
_My_data_mem$4 = 64
tv148 = 72
this$ = 96
_Right$ = 104
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 1234 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1235 :         // assign by stealing _Right's buffer
; 1236 :         // pre: this != &_Right
; 1237 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1238 :         // pre: *this owns no memory, iterators orphaned
; 1239 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1240 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1241 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1242 : 
; 1243 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1244 :         if constexpr (_Can_memcpy_val) {
; 1245 : #if _HAS_CXX20
; 1246 :             if (!_STD is_constant_evaluated())
; 1247 : #endif // _HAS_CXX20
; 1248 :             {
; 1249 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1250 :                 if (_Right_data._Large_mode_engaged()) {
; 1251 :                     // take ownership of _Right's iterators along with its buffer
; 1252 :                     _Swap_proxy_and_iterators(_Right);
; 1253 :                 } else {
; 1254 :                     _Right_data._Orphan_all();
; 1255 :                 }
; 1256 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1257 : 
; 1258 :                 const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _My_data_mem$4[rsp], rax

; 1259 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1260 :                 const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _Right_data_mem$3[rsp], rax

; 1261 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$3[rsp]
	mov	rcx, QWORD PTR _My_data_mem$4[rsp]
	call	memcpy

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1266 :                 _Right_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1268 :                 return;

	jmp	$LN1@Take_conte

; 1269 :             }
; 1270 :         }
; 1271 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1272 : 
; 1273 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 1274 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 1275 : 
; 1276 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 1277 :             _Right_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 1278 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1279 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1280 : 
; 1281 :             _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 1282 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv148[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv148[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1
$LN3@Take_conte:

; 1283 :         }
; 1284 : 
; 1285 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 1286 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 1287 : 
; 1288 :         _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1289 :         _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1290 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1
$LN1@Take_conte:

; 1291 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1004 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	mov	QWORD PTR tv75[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv75[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 1005 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv89[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1006 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1007 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 746  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 731  :         : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 732  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 733  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 693  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	mov	QWORD PTR tv76[rsp], rax
	movzx	eax, BYTE PTR $T3[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv76[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv94[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv92[rsp], rax
	mov	r8, QWORD PTR tv94[rsp]
	mov	rdx, QWORD PTR tv92[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
	npad	1

; 695  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 416  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 417  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 422  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 750  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 751  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 511  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 512  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 513  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1181 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
_InitData$ = 32
this$ = 64
_Message$ = 72
??0exception@std@@QEAA@QEBD@Z PROC			; std::exception::exception, COMDAT

; 60   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 59   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 61   :         __std_exception_data _InitData = { _Message, true };

	mov	rax, QWORD PTR _Message$[rsp]
	mov	QWORD PTR _InitData$[rsp], rax
	mov	BYTE PTR _InitData$[rsp+8], 1

; 62   :         __std_exception_copy(&_InitData, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR _InitData$[rsp]
	call	__std_exception_copy
	npad	1

; 63   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 504  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 505  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z
_TEXT	SEGMENT
tv68 = 32
tv69 = 36
_Meta$ = 64
?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z PROC	; std::_Narrow_char_traits<char,int>::not_eof, COMDAT

; 499  :     _NODISCARD static constexpr int_type not_eof(const int_type _Meta) noexcept {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 500  :         return _Meta != eof() ? _Meta : !eof();

	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	cmp	DWORD PTR _Meta$[rsp], eax
	je	SHORT $LN5@not_eof
	mov	eax, DWORD PTR _Meta$[rsp]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@not_eof
$LN5@not_eof:
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	test	eax, eax
	jne	SHORT $LN3@not_eof
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@not_eof
$LN3@not_eof:
	mov	DWORD PTR tv68[rsp], 0
$LN4@not_eof:
	mov	eax, DWORD PTR tv68[rsp]
	mov	DWORD PTR tv69[rsp], eax
$LN6@not_eof:
	mov	eax, DWORD PTR tv69[rsp]

; 501  :     }

	add	rsp, 56					; 00000038H
	ret	0
?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z ENDP	; std::_Narrow_char_traits<char,int>::not_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = 0
_Left$ = 32
_Right$ = 40
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 495  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 496  :         return _Left == _Right;

	mov	eax, DWORD PTR _Right$[rsp]
	cmp	DWORD PTR _Left$[rsp], eax
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[rsp], 0
$LN4@eq_int_typ:
	movzx	eax, BYTE PTR tv65[rsp]

; 497  :     }

	add	rsp, 24
	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z PROC	; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 491  :     _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {

	mov	BYTE PTR [rsp+8], cl

; 492  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR _Ch$[rsp]

; 493  :     }

	ret	0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ENDP	; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z PROC	; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 487  :     _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {

	mov	DWORD PTR [rsp+8], ecx

; 488  :         return static_cast<_Elem>(_Meta);

	movzx	eax, BYTE PTR _Meta$[rsp]

; 489  :     }

	ret	0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ENDP	; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z PROC		; std::_Narrow_char_traits<char,int>::eq, COMDAT

; 479  :     _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 480  :         return _Left == _Right;

	movsx	eax, BYTE PTR _Left$[rsp]
	movsx	ecx, BYTE PTR _Right$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN3@eq
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@eq
$LN3@eq:
	mov	DWORD PTR tv67[rsp], 0
$LN4@eq:
	movzx	eax, BYTE PTR tv67[rsp]

; 481  :     }

	add	rsp, 24
	ret	0
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ENDP		; std::_Narrow_char_traits<char,int>::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 417  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 418  :         // find length of null-terminated string
; 419  : #if _HAS_CXX17
; 420  : #ifdef __cpp_char8_t
; 421  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 422  : #if _HAS_U8_INTRINSICS
; 423  :             return __builtin_u8strlen(_First);
; 424  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 425  :             return _Primary_char_traits::length(_First);
; 426  : #endif // ^^^ no u8 intrinsics ^^^
; 427  :         } else
; 428  : #endif // defined(__cpp_char8_t)
; 429  :         {
; 430  :             return __builtin_strlen(_First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	mov	QWORD PTR tv68[rsp], -1
$LL3@length:
	inc	QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR tv67[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL3@length
	mov	rax, QWORD PTR tv68[rsp]

; 431  :         }
; 432  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 434  : #endif // ^^^ !_HAS_CXX17 ^^^
; 435  :     }

	add	rsp, 24
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 110  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 111  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 112  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 113  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 114  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 115  : #if _HAS_CXX20
; 116  :         if (_STD is_constant_evaluated()) {
; 117  :             // dest: [_First1, _First1 + _Count)
; 118  :             // src: [_First2, _First2 + _Count)
; 119  :             // We need to handle overlapping ranges.
; 120  :             // If _First1 is in the src range, we need a backward loop.
; 121  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 122  : 
; 123  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 124  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 125  :             bool _Loop_forward = true;
; 126  : 
; 127  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 128  :                 if (_First1 == _Src) {
; 129  :                     _Loop_forward = false;
; 130  :                     break;
; 131  :                 }
; 132  :             }
; 133  : 
; 134  :             if (_Loop_forward) {
; 135  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 136  :                     _First1[_Idx] = _First2[_Idx];
; 137  :                 }
; 138  :             } else {
; 139  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 140  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 141  :                 }
; 142  :             }
; 143  : 
; 144  :             return _First1;
; 145  :         }
; 146  : #endif // _HAS_CXX20
; 147  : 
; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memmove

; 149  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 150  : 
; 151  :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 152  :     }

	add	rsp, 40					; 00000028H
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 87   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 88   :                 _First1[_Idx] = _First2[_Idx];
; 89   :             }
; 90   : 
; 91   :             return _First1;
; 92   :         }
; 93   : #endif // _HAS_CXX20
; 94   : 
; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 96   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 97   : 
; 98   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 99   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
