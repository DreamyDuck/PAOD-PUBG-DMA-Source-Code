; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_Avx2WmemEnabledWeakValue
PUBLIC	?sockMonitorfd@IronMan@@3_KA			; IronMan::sockMonitorfd
PUBLIC	?tx@IronMan@@3Uclient_tx@1@A			; IronMan::tx
PUBLIC	?rx@IronMan@@3Uclient_tx@1@A			; IronMan::rx
PUBLIC	?addrSrv@IronMan@@3Usockaddr_in@@A		; IronMan::addrSrv
PUBLIC	?softmouse@IronMan@@3Usoft_mouse_t@1@A		; IronMan::softmouse
PUBLIC	?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A	; IronMan::softkeyboard
PUBLIC	?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A ; IronMan::hw_mouse
PUBLIC	?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A ; IronMan::hw_keyboard
PUBLIC	?sockClientfd@IronMan@@3_KA			; IronMan::sockClientfd
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
_BSS	SEGMENT
?sockMonitorfd@IronMan@@3_KA DQ 01H DUP (?)		; IronMan::sockMonitorfd
?tx@IronMan@@3Uclient_tx@1@A DB 0410H DUP (?)		; IronMan::tx
?rx@IronMan@@3Uclient_tx@1@A DB 0410H DUP (?)		; IronMan::rx
?addrSrv@IronMan@@3Usockaddr_in@@A DB 010H DUP (?)	; IronMan::addrSrv
?softmouse@IronMan@@3Usoft_mouse_t@1@A DB 038H DUP (?)	; IronMan::softmouse
?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A DB 0cH DUP (?) ; IronMan::softkeyboard
	ALIGN	8

?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A DQ 01H DUP (?) ; IronMan::hw_mouse
?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A DB 0cH DUP (?) ; IronMan::hw_keyboard
	ALIGN	8

?sockClientfd@IronMan@@3_KA DQ 01H DUP (?)		; IronMan::sockClientfd
_BSS	ENDS
PUBLIC	?kmNet_init@IronMan@@YAHPEAD00@Z		; IronMan::kmNet_init
PUBLIC	?kmNet_mouse_move@IronMan@@YAHFF@Z		; IronMan::kmNet_mouse_move
PUBLIC	?kmNet_mouse_left@IronMan@@YAHH@Z		; IronMan::kmNet_mouse_left
PUBLIC	?kmNet_mouse_right@IronMan@@YAHH@Z		; IronMan::kmNet_mouse_right
PUBLIC	?kmNet_mouse_middle@IronMan@@YAHH@Z		; IronMan::kmNet_mouse_middle
PUBLIC	?kmNet_mouse_wheel@IronMan@@YAHH@Z		; IronMan::kmNet_mouse_wheel
PUBLIC	?kmNet_mouse_all@IronMan@@YAHHHHH@Z		; IronMan::kmNet_mouse_all
PUBLIC	?kmNet_mouse_move_auto@IronMan@@YAHHHH@Z	; IronMan::kmNet_mouse_move_auto
PUBLIC	?kmNet_mouse_move_beizer@IronMan@@YAHHHHHHHH@Z	; IronMan::kmNet_mouse_move_beizer
PUBLIC	?kmNet_keydown@IronMan@@YAHH@Z			; IronMan::kmNet_keydown
PUBLIC	?kmNet_keyup@IronMan@@YAHH@Z			; IronMan::kmNet_keyup
PUBLIC	?kmNet_monitor@IronMan@@YAHH@Z			; IronMan::kmNet_monitor
PUBLIC	?kmNet_monitor_mouse_left@IronMan@@YAHXZ	; IronMan::kmNet_monitor_mouse_left
PUBLIC	?kmNet_monitor_mouse_middle@IronMan@@YAHXZ	; IronMan::kmNet_monitor_mouse_middle
PUBLIC	?kmNet_monitor_mouse_right@IronMan@@YAHXZ	; IronMan::kmNet_monitor_mouse_right
PUBLIC	?kmNet_monitor_mouse_side1@IronMan@@YAHXZ	; IronMan::kmNet_monitor_mouse_side1
PUBLIC	?kmNet_monitor_mouse_side2@IronMan@@YAHXZ	; IronMan::kmNet_monitor_mouse_side2
PUBLIC	?kmNet_monitor_keyboard@IronMan@@YAHF@Z		; IronMan::kmNet_monitor_keyboard
PUBLIC	?kmNet_mask_mouse_left@IronMan@@YAHH@Z		; IronMan::kmNet_mask_mouse_left
PUBLIC	?kmNet_mask_mouse_right@IronMan@@YAHH@Z		; IronMan::kmNet_mask_mouse_right
PUBLIC	?kmNet_mask_mouse_middle@IronMan@@YAHH@Z	; IronMan::kmNet_mask_mouse_middle
PUBLIC	?kmNet_mask_mouse_side1@IronMan@@YAHH@Z		; IronMan::kmNet_mask_mouse_side1
PUBLIC	?kmNet_mask_mouse_side2@IronMan@@YAHH@Z		; IronMan::kmNet_mask_mouse_side2
PUBLIC	?kmNet_mask_mouse_x@IronMan@@YAHH@Z		; IronMan::kmNet_mask_mouse_x
PUBLIC	?kmNet_mask_mouse_y@IronMan@@YAHH@Z		; IronMan::kmNet_mask_mouse_y
PUBLIC	?kmNet_mask_mouse_wheel@IronMan@@YAHH@Z		; IronMan::kmNet_mask_mouse_wheel
PUBLIC	?kmNet_mask_keyboard@IronMan@@YAHF@Z		; IronMan::kmNet_mask_keyboard
PUBLIC	?kmNet_unmask_keyboard@IronMan@@YAHF@Z		; IronMan::kmNet_unmask_keyboard
PUBLIC	?kmNet_unmask_all@IronMan@@YAHXZ		; IronMan::kmNet_unmask_all
PUBLIC	?kmNet_reboot@IronMan@@YAHXZ			; IronMan::kmNet_reboot
PUBLIC	?kmNet_setconfig@IronMan@@YAHPEADG@Z		; IronMan::kmNet_setconfig
PUBLIC	?kmNet_setvidpid@IronMan@@YAHGG@Z		; IronMan::kmNet_setvidpid
PUBLIC	?kmNet_debug@IronMan@@YAHFD@Z			; IronMan::kmNet_debug
PUBLIC	?kmNet_lcd_color@IronMan@@YAHG@Z		; IronMan::kmNet_lcd_color
PUBLIC	?kmNet_lcd_picture_bottom@IronMan@@YAHPEAE@Z	; IronMan::kmNet_lcd_picture_bottom
PUBLIC	?kmNet_lcd_picture@IronMan@@YAHPEAE@Z		; IronMan::kmNet_lcd_picture
PUBLIC	?myrand@IronMan@@YAHHH@Z			; IronMan::myrand
PUBLIC	?StrToHex@IronMan@@YAIPEADH@Z			; IronMan::StrToHex
PUBLIC	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
PUBLIC	?ThreadListenProcess@IronMan@@YAKPEAX@Z		; IronMan::ThreadListenProcess
EXTRN	toupper:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_CreateThread:PROC
EXTRN	srand:PROC
EXTRN	rand:PROC
EXTRN	atoi:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_closesocket:PROC
EXTRN	__imp_htonl:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_inet_addr:PROC
EXTRN	__imp_recvfrom:PROC
EXTRN	__imp_sendto:PROC
EXTRN	__imp_socket:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	_time64:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
?monitor_run@IronMan@@3HA DD 01H DUP (?)		; IronMan::monitor_run
?mask_keyboard_mouse_flag@IronMan@@3HA DD 01H DUP (?)	; IronMan::mask_keyboard_mouse_flag
?handle_listen@IronMan@@3PEAXEA DQ 01H DUP (?)		; IronMan::handle_listen
_BSS	ENDS
pdata	SEGMENT
$pdata$?kmNet_init@IronMan@@YAHPEAD00@Z DD imagerel $LN7
	DD	imagerel $LN7+536
	DD	imagerel $unwind$?kmNet_init@IronMan@@YAHPEAD00@Z
$pdata$?kmNet_mouse_move@IronMan@@YAHFF@Z DD imagerel $LN5
	DD	imagerel $LN5+319
	DD	imagerel $unwind$?kmNet_mouse_move@IronMan@@YAHFF@Z
$pdata$?kmNet_mouse_left@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+316
	DD	imagerel $unwind$?kmNet_mouse_left@IronMan@@YAHH@Z
$pdata$?kmNet_mouse_right@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+316
	DD	imagerel $unwind$?kmNet_mouse_right@IronMan@@YAHH@Z
$pdata$?kmNet_mouse_middle@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+316
	DD	imagerel $unwind$?kmNet_mouse_middle@IronMan@@YAHH@Z
$pdata$?kmNet_mouse_wheel@IronMan@@YAHH@Z DD imagerel $LN5
	DD	imagerel $LN5+291
	DD	imagerel $unwind$?kmNet_mouse_wheel@IronMan@@YAHH@Z
$pdata$?kmNet_mouse_all@IronMan@@YAHHHHH@Z DD imagerel $LN5
	DD	imagerel $LN5+361
	DD	imagerel $unwind$?kmNet_mouse_all@IronMan@@YAHHHHH@Z
$pdata$?kmNet_mouse_move_auto@IronMan@@YAHHHH@Z DD imagerel $LN5
	DD	imagerel $LN5+322
	DD	imagerel $unwind$?kmNet_mouse_move_auto@IronMan@@YAHHHH@Z
$pdata$?kmNet_mouse_move_beizer@IronMan@@YAHHHHHHHH@Z DD imagerel $LN5
	DD	imagerel $LN5+431
	DD	imagerel $unwind$?kmNet_mouse_move_beizer@IronMan@@YAHHHHHHHH@Z
$pdata$?kmNet_keydown@IronMan@@YAHH@Z DD imagerel $LN28
	DD	imagerel $LN28+752
	DD	imagerel $unwind$?kmNet_keydown@IronMan@@YAHH@Z
$pdata$?kmNet_keyup@IronMan@@YAHH@Z DD imagerel $LN23
	DD	imagerel $LN23+704
	DD	imagerel $unwind$?kmNet_keyup@IronMan@@YAHH@Z
$pdata$?kmNet_monitor@IronMan@@YAHH@Z DD imagerel $LN13
	DD	imagerel $LN13+390
	DD	imagerel $unwind$?kmNet_monitor@IronMan@@YAHH@Z
$pdata$?kmNet_monitor_mouse_left@IronMan@@YAHXZ DD imagerel $LN6
	DD	imagerel $LN6+58
	DD	imagerel $unwind$?kmNet_monitor_mouse_left@IronMan@@YAHXZ
$pdata$?kmNet_monitor_mouse_middle@IronMan@@YAHXZ DD imagerel $LN6
	DD	imagerel $LN6+58
	DD	imagerel $unwind$?kmNet_monitor_mouse_middle@IronMan@@YAHXZ
$pdata$?kmNet_monitor_mouse_right@IronMan@@YAHXZ DD imagerel $LN6
	DD	imagerel $LN6+58
	DD	imagerel $unwind$?kmNet_monitor_mouse_right@IronMan@@YAHXZ
$pdata$?kmNet_monitor_mouse_side1@IronMan@@YAHXZ DD imagerel $LN6
	DD	imagerel $LN6+58
	DD	imagerel $unwind$?kmNet_monitor_mouse_side1@IronMan@@YAHXZ
$pdata$?kmNet_monitor_mouse_side2@IronMan@@YAHXZ DD imagerel $LN6
	DD	imagerel $LN6+58
	DD	imagerel $unwind$?kmNet_monitor_mouse_side2@IronMan@@YAHXZ
$pdata$?kmNet_monitor_keyboard@IronMan@@YAHF@Z DD imagerel $LN37
	DD	imagerel $LN37+552
	DD	imagerel $unwind$?kmNet_monitor_keyboard@IronMan@@YAHF@Z
$pdata$?kmNet_mask_mouse_left@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?kmNet_mask_mouse_left@IronMan@@YAHH@Z
$pdata$?kmNet_mask_mouse_right@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?kmNet_mask_mouse_right@IronMan@@YAHH@Z
$pdata$?kmNet_mask_mouse_middle@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?kmNet_mask_mouse_middle@IronMan@@YAHH@Z
$pdata$?kmNet_mask_mouse_side1@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?kmNet_mask_mouse_side1@IronMan@@YAHH@Z
$pdata$?kmNet_mask_mouse_side2@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?kmNet_mask_mouse_side2@IronMan@@YAHH@Z
$pdata$?kmNet_mask_mouse_x@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?kmNet_mask_mouse_x@IronMan@@YAHH@Z
$pdata$?kmNet_mask_mouse_y@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+304
	DD	imagerel $unwind$?kmNet_mask_mouse_y@IronMan@@YAHH@Z
$pdata$?kmNet_mask_mouse_wheel@IronMan@@YAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+306
	DD	imagerel $unwind$?kmNet_mask_mouse_wheel@IronMan@@YAHH@Z
$pdata$?kmNet_mask_keyboard@IronMan@@YAHF@Z DD imagerel $LN5
	DD	imagerel $LN5+277
	DD	imagerel $unwind$?kmNet_mask_keyboard@IronMan@@YAHF@Z
$pdata$?kmNet_unmask_keyboard@IronMan@@YAHF@Z DD imagerel $LN5
	DD	imagerel $LN5+277
	DD	imagerel $unwind$?kmNet_unmask_keyboard@IronMan@@YAHF@Z
$pdata$?kmNet_unmask_all@IronMan@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+253
	DD	imagerel $unwind$?kmNet_unmask_all@IronMan@@YAHXZ
$pdata$?kmNet_reboot@IronMan@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+259
	DD	imagerel $unwind$?kmNet_reboot@IronMan@@YAHXZ
$pdata$?kmNet_setconfig@IronMan@@YAHPEADG@Z DD imagerel $LN5
	DD	imagerel $LN5+309
	DD	imagerel $unwind$?kmNet_setconfig@IronMan@@YAHPEADG@Z
$pdata$?kmNet_setvidpid@IronMan@@YAHGG@Z DD imagerel $LN5
	DD	imagerel $LN5+262
	DD	imagerel $unwind$?kmNet_setvidpid@IronMan@@YAHGG@Z
$pdata$?kmNet_debug@IronMan@@YAHFD@Z DD imagerel $LN5
	DD	imagerel $LN5+261
	DD	imagerel $unwind$?kmNet_debug@IronMan@@YAHFD@Z
$pdata$?kmNet_lcd_color@IronMan@@YAHG@Z DD imagerel $LN11
	DD	imagerel $LN11+337
	DD	imagerel $unwind$?kmNet_lcd_color@IronMan@@YAHG@Z
$pdata$?kmNet_lcd_picture_bottom@IronMan@@YAHPEAE@Z DD imagerel $LN8
	DD	imagerel $LN8+330
	DD	imagerel $unwind$?kmNet_lcd_picture_bottom@IronMan@@YAHPEAE@Z
$pdata$?kmNet_lcd_picture@IronMan@@YAHPEAE@Z DD imagerel $LN8
	DD	imagerel $LN8+326
	DD	imagerel $unwind$?kmNet_lcd_picture@IronMan@@YAHPEAE@Z
$pdata$time DD	imagerel time
	DD	imagerel time+24
	DD	imagerel $unwind$time
$pdata$?myrand@IronMan@@YAHHH@Z DD imagerel $LN7
	DD	imagerel $LN7+115
	DD	imagerel $unwind$?myrand@IronMan@@YAHHH@Z
$pdata$?StrToHex@IronMan@@YAIPEADH@Z DD imagerel $LN8
	DD	imagerel $LN8+334
	DD	imagerel $unwind$?StrToHex@IronMan@@YAIPEADH@Z
$pdata$?ThreadListenProcess@IronMan@@YAKPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+337
	DD	imagerel $unwind$?ThreadListenProcess@IronMan@@YAKPEAX@Z
pdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ThreadListenProcess@IronMan@@YAKPEAX@Z
	DD	016H
	DD	0139H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?StrToHex@IronMan@@YAIPEADH@Z
	DD	01bH
	DD	0138H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_lcd_picture@IronMan@@YAHPEAE@Z
	DD	013H
	DD	0134H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_lcd_picture_bottom@IronMan@@YAHPEAE@Z
	DD	013H
	DD	0138H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_lcd_color@IronMan@@YAHG@Z
	DD	013H
	DD	013fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_debug@IronMan@@YAHFD@Z
	DD	017H
	DD	0f3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_setvidpid@IronMan@@YAHGG@Z
	DD	018H
	DD	0f4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_setconfig@IronMan@@YAHPEADG@Z
	DD	018H
	DD	0123H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_reboot@IronMan@@YAHXZ
	DD	0eH
	DD	0f1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_unmask_all@IronMan@@YAHXZ
	DD	0eH
	DD	0ebH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_unmask_keyboard@IronMan@@YAHF@Z
	DD	013H
	DD	0103H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_keyboard@IronMan@@YAHF@Z
	DD	013H
	DD	0103H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_wheel@IronMan@@YAHH@Z
	DD	012H
	DD	0120H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_y@IronMan@@YAHH@Z
	DD	012H
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_x@IronMan@@YAHH@Z
	DD	012H
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_side2@IronMan@@YAHH@Z
	DD	012H
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_side1@IronMan@@YAHH@Z
	DD	012H
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_middle@IronMan@@YAHH@Z
	DD	012H
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_right@IronMan@@YAHH@Z
	DD	012H
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mask_mouse_left@IronMan@@YAHH@Z
	DD	012H
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_monitor@IronMan@@YAHH@Z
	DD	012H
	DD	0174H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_keyup@IronMan@@YAHH@Z
	DD	012H
	DD	028eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_keydown@IronMan@@YAHH@Z
	DD	012H
	DD	02bdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_move_beizer@IronMan@@YAHHHHHHHH@Z
	DD	020H
	DD	019dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_move_auto@IronMan@@YAHHHH@Z
	DD	01bH
	DD	0130H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_all@IronMan@@YAHHHHH@Z
	DD	020H
	DD	0157H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_wheel@IronMan@@YAHH@Z
	DD	012H
	DD	0111H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_middle@IronMan@@YAHH@Z
	DD	012H
	DD	012aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_right@IronMan@@YAHH@Z
	DD	012H
	DD	012aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_left@IronMan@@YAHH@Z
	DD	012H
	DD	012aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_mouse_move@IronMan@@YAHFF@Z
	DD	018H
	DD	012dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?kmNet_init@IronMan@@YAHPEAD00@Z
	DD	020H
	DD	0200H
voltbl	ENDS
xdata	SEGMENT
$unwind$?kmNet_init@IronMan@@YAHPEAD00@Z DD 022819H
	DD	03f0116H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$?kmNet_mouse_move@IronMan@@YAHFF@Z DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mouse_left@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mouse_right@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mouse_middle@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mouse_wheel@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mouse_all@IronMan@@YAHHHHH@Z DD 012519H
	DD	0c216H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mouse_move_auto@IronMan@@YAHHHH@Z DD 012019H
	DD	0c211H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mouse_move_beizer@IronMan@@YAHHHHHHHH@Z DD 012519H
	DD	0c216H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_keydown@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$?kmNet_keyup@IronMan@@YAHH@Z DD 011719H
	DD	0e208H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$?kmNet_monitor@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_monitor_mouse_left@IronMan@@YAHXZ DD 010401H
	DD	02204H
$unwind$?kmNet_monitor_mouse_middle@IronMan@@YAHXZ DD 010401H
	DD	02204H
$unwind$?kmNet_monitor_mouse_right@IronMan@@YAHXZ DD 010401H
	DD	02204H
$unwind$?kmNet_monitor_mouse_side1@IronMan@@YAHXZ DD 010401H
	DD	02204H
$unwind$?kmNet_monitor_mouse_side2@IronMan@@YAHXZ DD 010401H
	DD	02204H
$unwind$?kmNet_monitor_keyboard@IronMan@@YAHF@Z DD 010901H
	DD	06209H
$unwind$?kmNet_mask_mouse_left@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_mouse_right@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_mouse_middle@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_mouse_side1@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_mouse_side2@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_mouse_x@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_mouse_y@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_mouse_wheel@IronMan@@YAHH@Z DD 011719H
	DD	0c208H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_mask_keyboard@IronMan@@YAHF@Z DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_unmask_keyboard@IronMan@@YAHF@Z DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_unmask_all@IronMan@@YAHXZ DD 011319H
	DD	0c204H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_reboot@IronMan@@YAHXZ DD 011319H
	DD	0c204H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_setconfig@IronMan@@YAHPEADG@Z DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_setvidpid@IronMan@@YAHGG@Z DD 011d19H
	DD	0c20eH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_debug@IronMan@@YAHFD@Z DD 011c19H
	DD	0c20dH
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_lcd_color@IronMan@@YAHG@Z DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$?kmNet_lcd_picture_bottom@IronMan@@YAHPEAE@Z DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$?kmNet_lcd_picture@IronMan@@YAHPEAE@Z DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$time DD	010901H
	DD	04209H
$unwind$?myrand@IronMan@@YAHHH@Z DD 010c01H
	DD	0620cH
$unwind$?StrToHex@IronMan@@YAIPEADH@Z DD 022019H
	DD	0700af211H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?ThreadListenProcess@IronMan@@YAKPEAX@Z DD 021e19H
	DD	0c5010cH
	DD	imagerel __GSHandlerCheck
	DD	0610H
xdata	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
nSize$ = 48
sock$ = 56
strLen$1 = 64
servAddr$ = 72
cliAddr$ = 88
wsaData$ = 112
buff$ = 528
__$ArrayPad$ = 1552
lpParameter$ = 1584
?ThreadListenProcess@IronMan@@YAKPEAX@Z PROC		; IronMan::ThreadListenProcess

; 468  : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1576				; 00000628H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 469  : 		WSADATA wsaData;
; 470  : 		WSAStartup(MAKEWORD(2, 2), &wsaData);			//创建套接字，SOCK_DGRAM指明使用 UDP 协议

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 514					; 00000202H
	call	QWORD PTR __imp_WSAStartup

; 471  : 		SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);	//绑定套接字

	xor	r8d, r8d
	mov	edx, 2
	mov	ecx, 2
	call	QWORD PTR __imp_socket
	mov	QWORD PTR sock$[rsp], rax

; 472  : 		sockaddr_in servAddr;
; 473  : 		memset(&servAddr, 0, sizeof(servAddr));			 //每个字节都用0填充

	mov	r8d, 16
	xor	edx, edx
	lea	rcx, QWORD PTR servAddr$[rsp]
	call	memset

; 474  : 		servAddr.sin_family = PF_INET;					//使用IPv4地址

	mov	eax, 2
	mov	WORD PTR servAddr$[rsp], ax

; 475  : 		servAddr.sin_addr.s_addr = htonl(INADDR_ANY);	 //自动获取IP地址

	xor	ecx, ecx
	call	QWORD PTR __imp_htonl
	mov	DWORD PTR servAddr$[rsp+4], eax

; 476  : 		servAddr.sin_port = htons(addrSrv.sin_port + 1);  //端口

	movzx	eax, WORD PTR ?addrSrv@IronMan@@3Usockaddr_in@@A+2
	inc	eax
	movzx	ecx, ax
	call	QWORD PTR __imp_htons
	mov	WORD PTR servAddr$[rsp+2], ax

; 477  : 		bind(sock, (SOCKADDR*)&servAddr, sizeof(SOCKADDR));

	mov	r8d, 16
	lea	rdx, QWORD PTR servAddr$[rsp]
	mov	rcx, QWORD PTR sock$[rsp]
	call	QWORD PTR __imp_bind

; 478  : 		SOCKADDR cliAddr;  //客户端地址信息
; 479  : 		int nSize = sizeof(SOCKADDR);

	mov	DWORD PTR nSize$[rsp], 16

; 480  : 		char buff[1024];  //缓冲区
; 481  : 		monitor_run = monitor_ok;

	mov	DWORD PTR ?monitor_run@IronMan@@3HA, 2
$LN2@ThreadList:

; 482  : 		while (monitor_run) {

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 0
	je	SHORT $LN3@ThreadList

; 483  : 			int strLen = recvfrom(sock, buff, 1024, 0, &cliAddr, &nSize);

	lea	rax, QWORD PTR nSize$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR cliAddr$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, QWORD PTR buff$[rsp]
	mov	rcx, QWORD PTR sock$[rsp]
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR strLen$1[rsp], eax

; 484  : 			memcpy(&hw_mouse, buff, sizeof(hw_mouse));							//物理鼠标状态

	mov	r8d, 8
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A ; IronMan::hw_mouse
	call	memcpy

; 485  : 			memcpy(&hw_keyboard, &buff[sizeof(hw_mouse)], sizeof(hw_keyboard));	//物理键盘状态

	mov	eax, 1
	imul	rax, rax, 8
	lea	rax, QWORD PTR buff$[rsp+rax]
	mov	r8d, 12
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A ; IronMan::hw_keyboard
	call	memcpy
	npad	1

; 486  : 		}

	jmp	SHORT $LN2@ThreadList
$LN3@ThreadList:

; 487  : 		closesocket(sock);

	mov	rcx, QWORD PTR sock$[rsp]
	call	QWORD PTR __imp_closesocket

; 488  : 		return 0;

	xor	eax, eax

; 489  : 
; 490  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1576				; 00000628H
	ret	0
?ThreadListenProcess@IronMan@@YAKPEAX@Z ENDP		; IronMan::ThreadListenProcess
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
rx$ = 8
tx$ = 16
?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z PROC	; IronMan::NetRxReturnHandle

; 72   : 	{

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 73   : 		if (rx->head.cmd != tx->head.cmd)

	mov	rax, QWORD PTR rx$[rsp]
	mov	rcx, QWORD PTR tx$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	cmp	DWORD PTR [rax+12], ecx
	je	SHORT $LN2@NetRxRetur

; 74   : 			return  err_net_cmd;//命令码错误

	mov	eax, -8996				; ffffffffffffdcdcH
	jmp	SHORT $LN1@NetRxRetur
$LN2@NetRxRetur:

; 75   : 		if (rx->head.indexpts != tx->head.indexpts)

	mov	rax, QWORD PTR rx$[rsp]
	mov	rcx, QWORD PTR tx$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+8], ecx
	je	SHORT $LN3@NetRxRetur

; 76   : 			return  err_net_pts;//时间戳错误

	mov	eax, -8995				; ffffffffffffdcddH
	jmp	SHORT $LN1@NetRxRetur
$LN3@NetRxRetur:

; 77   : 		return 0;				//没有错误返回0

	xor	eax, eax
$LN1@NetRxRetur:

; 78   : 		//return  rx->head.rand;//真正的返回值
; 79   : 
; 80   : 
; 81   : 	}

	ret	0
?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ENDP	; IronMan::NetRxReturnHandle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
s1$ = 32
s2$ = 33
h1$ = 34
h2$ = 35
i$ = 36
pbDest$ = 48
__$ArrayPad$ = 112
pbSrc$ = 144
nLen$ = 152
?StrToHex@IronMan@@YAIPEADH@Z PROC			; IronMan::StrToHex

; 52   : 	{

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 53   : 		char h1, h2;
; 54   : 		unsigned char s1, s2;
; 55   : 		int i;
; 56   : 		unsigned int pbDest[16] = { 0 };

	lea	rax, QWORD PTR pbDest$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 64					; 00000040H
	rep stosb

; 57   : 		for (i = 0; i < nLen; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@StrToHex
$LN2@StrToHex:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@StrToHex:
	mov	eax, DWORD PTR nLen$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN3@StrToHex

; 58   : 			h1 = pbSrc[2 * i];

	mov	eax, DWORD PTR i$[rsp]
	add	eax, eax
	cdqe
	mov	rcx, QWORD PTR pbSrc$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR h1$[rsp], al

; 59   : 			h2 = pbSrc[2 * i + 1];

	mov	eax, DWORD PTR i$[rsp]
	lea	eax, DWORD PTR [rax+rax+1]
	cdqe
	mov	rcx, QWORD PTR pbSrc$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR h2$[rsp], al

; 60   : 			s1 = toupper(h1) - 0x30;

	movsx	eax, BYTE PTR h1$[rsp]
	mov	ecx, eax
	call	toupper
	sub	eax, 48					; 00000030H
	mov	BYTE PTR s1$[rsp], al

; 61   : 			if (s1 > 9)

	movzx	eax, BYTE PTR s1$[rsp]
	cmp	eax, 9
	jle	SHORT $LN5@StrToHex

; 62   : 				s1 -= 7;

	movzx	eax, BYTE PTR s1$[rsp]
	sub	eax, 7
	mov	BYTE PTR s1$[rsp], al
$LN5@StrToHex:

; 63   : 			s2 = toupper(h2) - 0x30;

	movsx	eax, BYTE PTR h2$[rsp]
	mov	ecx, eax
	call	toupper
	sub	eax, 48					; 00000030H
	mov	BYTE PTR s2$[rsp], al

; 64   : 			if (s2 > 9)

	movzx	eax, BYTE PTR s2$[rsp]
	cmp	eax, 9
	jle	SHORT $LN6@StrToHex

; 65   : 				s2 -= 7;

	movzx	eax, BYTE PTR s2$[rsp]
	sub	eax, 7
	mov	BYTE PTR s2$[rsp], al
$LN6@StrToHex:

; 66   : 			pbDest[i] = s1 * 16 + s2;

	movzx	eax, BYTE PTR s1$[rsp]
	imul	eax, eax, 16
	movzx	ecx, BYTE PTR s2$[rsp]
	add	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	DWORD PTR pbDest$[rsp+rcx*4], eax

; 67   : 		}

	jmp	$LN2@StrToHex
$LN3@StrToHex:

; 68   : 		return pbDest[0] << 24 | pbDest[1] << 16 | pbDest[2] << 8 | pbDest[3];

	mov	eax, 4
	imul	rax, rax, 0
	mov	eax, DWORD PTR pbDest$[rsp+rax]
	shl	eax, 24
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	ecx, DWORD PTR pbDest$[rsp+rcx]
	shl	ecx, 16
	or	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	ecx, DWORD PTR pbDest$[rsp+rcx]
	shl	ecx, 8
	or	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 3
	or	eax, DWORD PTR pbDest$[rsp+rcx]

; 69   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
?StrToHex@IronMan@@YAIPEADH@Z ENDP			; IronMan::StrToHex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv65 = 32
tv67 = 36
min$ = 40
max$ = 44
a$ = 64
b$ = 72
?myrand@IronMan@@YAHHH@Z PROC				; IronMan::myrand

; 45   : 	{

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 46   : 		int min = a < b ? a : b;

	mov	eax, DWORD PTR b$[rsp]
	cmp	DWORD PTR a$[rsp], eax
	jge	SHORT $LN3@myrand
	mov	eax, DWORD PTR a$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN4@myrand
$LN3@myrand:
	mov	eax, DWORD PTR b$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN4@myrand:
	mov	eax, DWORD PTR tv65[rsp]
	mov	DWORD PTR min$[rsp], eax

; 47   : 		int max = a > b ? a : b;

	mov	eax, DWORD PTR b$[rsp]
	cmp	DWORD PTR a$[rsp], eax
	jle	SHORT $LN5@myrand
	mov	eax, DWORD PTR a$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN6@myrand
$LN5@myrand:
	mov	eax, DWORD PTR b$[rsp]
	mov	DWORD PTR tv67[rsp], eax
$LN6@myrand:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR max$[rsp], eax

; 48   : 		return ((rand() % (max - min)) + min);

	call	rand
	mov	ecx, DWORD PTR min$[rsp]
	mov	edx, DWORD PTR max$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, DWORD PTR min$[rsp]

; 49   : 	}

	add	rsp, 56					; 00000038H
	ret	0
?myrand@IronMan@@YAHHH@Z ENDP				; IronMan::myrand
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 551  :         {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 552  :             return _time64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	_time64

; 553  :         }

	add	rsp, 40					; 00000028H
	ret	0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
y$1 = 48
length$2 = 52
clen$3 = 56
err$ = 60
sclient$4 = 64
__$ArrayPad$ = 80
buff_128_160$ = 112
?kmNet_lcd_picture@IronMan@@YAHPEAE@Z PROC		; IronMan::kmNet_lcd_picture

; 948  : 	{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 949  : 		int err;
; 950  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN5@kmNet_lcd_
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_lcd_
$LN5@kmNet_lcd_:

; 951  : 		for (int y = 0; y < 40; y++)

	mov	DWORD PTR y$1[rsp], 0
	jmp	SHORT $LN4@kmNet_lcd_
$LN2@kmNet_lcd_:
	mov	eax, DWORD PTR y$1[rsp]
	inc	eax
	mov	DWORD PTR y$1[rsp], eax
$LN4@kmNet_lcd_:
	cmp	DWORD PTR y$1[rsp], 40			; 00000028H
	jge	$LN3@kmNet_lcd_

; 952  : 		{
; 953  : 			tx.head.indexpts++;		    //指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 954  : 			tx.head.cmd = cmd_showpic;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 305350787 ; 12334883H

; 955  : 			tx.head.rand = y * 4;

	mov	eax, DWORD PTR y$1[rsp]
	shl	eax, 2
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 956  : 			memcpy(tx.u8buff.buff, &buff_128_160[y * 1024], 1024);

	imul	eax, DWORD PTR y$1[rsp], 1024		; 00000400H
	cdqe
	mov	rcx, QWORD PTR buff_128_160$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 1024				; 00000400H
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 957  : 			int length = sizeof(cmd_head_t) + 1024;

	mov	DWORD PTR length$2[rsp], 1040		; 00000410H

; 958  : 			sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$2[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 959  : 			SOCKADDR_IN sclient;
; 960  : 			int clen = sizeof(sclient);

	mov	DWORD PTR clen$3[rsp], 16

; 961  : 			err = recvfrom(sockClientfd, (char*)&rx, length, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$3[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$4[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$2[rsp]
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 962  : 			if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN6@kmNet_lcd_

; 963  : 				return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_lcd_
$LN6@kmNet_lcd_:

; 964  : 		}

	jmp	$LN2@kmNet_lcd_
$LN3@kmNet_lcd_:

; 965  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_lcd_:

; 966  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_lcd_picture@IronMan@@YAHPEAE@Z ENDP		; IronMan::kmNet_lcd_picture
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
y$1 = 48
length$2 = 52
clen$3 = 56
err$ = 60
sclient$4 = 64
__$ArrayPad$ = 80
buff_128_80$ = 112
?kmNet_lcd_picture_bottom@IronMan@@YAHPEAE@Z PROC	; IronMan::kmNet_lcd_picture_bottom

; 926  : 	{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 927  : 		int err;
; 928  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN5@kmNet_lcd_
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_lcd_
$LN5@kmNet_lcd_:

; 929  : 		for (int y = 0; y < 20; y++)

	mov	DWORD PTR y$1[rsp], 0
	jmp	SHORT $LN4@kmNet_lcd_
$LN2@kmNet_lcd_:
	mov	eax, DWORD PTR y$1[rsp]
	inc	eax
	mov	DWORD PTR y$1[rsp], eax
$LN4@kmNet_lcd_:
	cmp	DWORD PTR y$1[rsp], 20
	jge	$LN3@kmNet_lcd_

; 930  : 		{
; 931  : 			tx.head.indexpts++;		    //指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 932  : 			tx.head.cmd = cmd_showpic;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 305350787 ; 12334883H

; 933  : 			tx.head.rand = 80 + y * 4;

	mov	eax, DWORD PTR y$1[rsp]
	lea	eax, DWORD PTR [rax*4+80]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 934  : 			memcpy(tx.u8buff.buff, &buff_128_80[y * 1024], 1024);

	imul	eax, DWORD PTR y$1[rsp], 1024		; 00000400H
	cdqe
	mov	rcx, QWORD PTR buff_128_80$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 1024				; 00000400H
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 935  : 			int length = sizeof(cmd_head_t) + 1024;

	mov	DWORD PTR length$2[rsp], 1040		; 00000410H

; 936  : 			sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$2[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 937  : 			SOCKADDR_IN sclient;
; 938  : 			int clen = sizeof(sclient);

	mov	DWORD PTR clen$3[rsp], 16

; 939  : 			err = recvfrom(sockClientfd, (char*)&rx, length, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$3[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$4[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$2[rsp]
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 940  : 			if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN6@kmNet_lcd_

; 941  : 				return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_lcd_
$LN6@kmNet_lcd_:

; 942  : 		}

	jmp	$LN2@kmNet_lcd_
$LN3@kmNet_lcd_:

; 943  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_lcd_:

; 944  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_lcd_picture_bottom@IronMan@@YAHPEAE@Z ENDP	; IronMan::kmNet_lcd_picture_bottom
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
y$1 = 48
c$2 = 52
length$3 = 56
clen$4 = 60
err$ = 64
sclient$5 = 72
__$ArrayPad$ = 88
rgb565$ = 112
?kmNet_lcd_color@IronMan@@YAHG@Z PROC			; IronMan::kmNet_lcd_color

; 902  : 	{

$LN11:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 903  : 		int err;
; 904  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN8@kmNet_lcd_
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_lcd_
$LN8@kmNet_lcd_:

; 905  : 		for (int y = 0; y < 40; y++)

	mov	DWORD PTR y$1[rsp], 0
	jmp	SHORT $LN4@kmNet_lcd_
$LN2@kmNet_lcd_:
	mov	eax, DWORD PTR y$1[rsp]
	inc	eax
	mov	DWORD PTR y$1[rsp], eax
$LN4@kmNet_lcd_:
	cmp	DWORD PTR y$1[rsp], 40			; 00000028H
	jge	$LN3@kmNet_lcd_

; 906  : 		{
; 907  : 			tx.head.indexpts++;		    //指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 908  : 			tx.head.cmd = cmd_showpic;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 305350787 ; 12334883H

; 909  : 			tx.head.rand = 0 | y * 4;

	mov	eax, DWORD PTR y$1[rsp]
	shl	eax, 2
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 910  : 			for (int c = 0; c < 512; c++)

	mov	DWORD PTR c$2[rsp], 0
	jmp	SHORT $LN7@kmNet_lcd_
$LN5@kmNet_lcd_:
	mov	eax, DWORD PTR c$2[rsp]
	inc	eax
	mov	DWORD PTR c$2[rsp], eax
$LN7@kmNet_lcd_:
	cmp	DWORD PTR c$2[rsp], 512			; 00000200H
	jge	SHORT $LN6@kmNet_lcd_

; 911  : 				tx.u16buff.buff[c] = rgb565;

	movsxd	rax, DWORD PTR c$2[rsp]
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	movzx	edx, WORD PTR rgb565$[rsp]
	mov	WORD PTR [rcx+rax*2], dx
	jmp	SHORT $LN5@kmNet_lcd_
$LN6@kmNet_lcd_:

; 912  : 			int length = sizeof(cmd_head_t) + 1024;

	mov	DWORD PTR length$3[rsp], 1040		; 00000410H

; 913  : 			sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$3[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 914  : 			SOCKADDR_IN sclient;
; 915  : 			int clen = sizeof(sclient);

	mov	DWORD PTR clen$4[rsp], 16

; 916  : 			err = recvfrom(sockClientfd, (char*)&rx, length, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$4[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$5[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$3[rsp]
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 917  : 			if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN9@kmNet_lcd_

; 918  : 				return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_lcd_
$LN9@kmNet_lcd_:

; 919  : 		}

	jmp	$LN2@kmNet_lcd_
$LN3@kmNet_lcd_:

; 920  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_lcd_:

; 921  : 
; 922  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_lcd_color@IronMan@@YAHG@Z ENDP			; IronMan::kmNet_lcd_color
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
port$ = 112
enable$ = 120
?kmNet_debug@IronMan@@YAHFD@Z PROC			; IronMan::kmNet_debug

; 632  : 	{

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 633  : 		int err;
; 634  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_debu
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_debu
$LN2@kmNet_debu:

; 635  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 636  : 		tx.head.cmd = cmd_debug;			//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 657989665 ; 27382021H

; 637  : 		tx.head.rand = port | enable << 16;	// 随机混淆值

	movsx	eax, WORD PTR port$[rsp]
	movsx	ecx, BYTE PTR enable$[rsp]
	shl	ecx, 16
	or	eax, ecx
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 638  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 639  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 640  : 		SOCKADDR_IN sclient;
; 641  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 642  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 643  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_debu

; 644  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_debu
$LN3@kmNet_debu:

; 645  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_debu:

; 646  : 
; 647  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_debug@IronMan@@YAHFD@Z ENDP			; IronMan::kmNet_debug
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
vid$ = 112
pid$ = 120
?kmNet_setvidpid@IronMan@@YAHGG@Z PROC			; IronMan::kmNet_setvidpid

; 883  : 	{

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 884  : 		int err;
; 885  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_setv
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_setv
$LN2@kmNet_setv:

; 886  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 887  : 		tx.head.cmd = cmd_setvidpid;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1232334 ; ffed3232H

; 888  : 		tx.head.rand = vid | pid << 16;

	movzx	eax, WORD PTR vid$[rsp]
	movzx	ecx, WORD PTR pid$[rsp]
	shl	ecx, 16
	or	eax, ecx
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 889  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 890  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 891  : 		SOCKADDR_IN sclient;
; 892  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 893  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 894  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_setv

; 895  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_setv
$LN3@kmNet_setv:

; 896  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_setv:

; 897  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_setvidpid@IronMan@@YAHGG@Z ENDP			; IronMan::kmNet_setvidpid
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
ip$ = 112
port$ = 120
?kmNet_setconfig@IronMan@@YAHPEADG@Z PROC		; IronMan::kmNet_setconfig

; 863  : 	{

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 864  : 		int err;
; 865  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_setc
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_setc
$LN2@kmNet_setc:

; 866  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 867  : 		tx.head.cmd = cmd_setconfig;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 490550051 ; 1d3d3323H

; 868  : 		tx.head.rand = inet_addr(ip); ;

	mov	rcx, QWORD PTR ip$[rsp]
	call	QWORD PTR __imp_inet_addr
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 869  : 		tx.u8buff.buff[0] = port >> 8;

	movzx	eax, WORD PTR port$[rsp]
	sar	eax, 8
	mov	ecx, 1
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	mov	BYTE PTR [rdx+rcx], al

; 870  : 		tx.u8buff.buff[1] = port >> 0;

	mov	eax, 1
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	movzx	edx, BYTE PTR port$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 871  : 		int length = sizeof(cmd_head_t) + 2;

	mov	DWORD PTR length$[rsp], 18

; 872  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 873  : 		SOCKADDR_IN sclient;
; 874  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 875  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 876  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_setc

; 877  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_setc
$LN3@kmNet_setc:

; 878  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_setc:

; 879  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_setconfig@IronMan@@YAHPEADG@Z ENDP		; IronMan::kmNet_setconfig
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
?kmNet_reboot@IronMan@@YAHXZ PROC			; IronMan::kmNet_reboot

; 444  : 	{

$LN5:
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 445  : 		int err;
; 446  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_rebo
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_rebo
$LN2@kmNet_rebo:

; 447  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 448  : 		tx.head.cmd = cmd_reboot;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1433905750 ; aa8855aaH

; 449  : 		tx.head.rand = rand();			// 随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 450  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 451  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 452  : 		SOCKADDR_IN sclient;
; 453  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 454  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 455  : 		WSACleanup();

	call	QWORD PTR __imp_WSACleanup

; 456  : 		sockClientfd = -1;

	mov	QWORD PTR ?sockClientfd@IronMan@@3_KA, -1 ; IronMan::sockClientfd

; 457  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_rebo

; 458  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_rebo
$LN3@kmNet_rebo:

; 459  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_rebo:

; 460  : 
; 461  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_reboot@IronMan@@YAHXZ ENDP			; IronMan::kmNet_reboot
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
?kmNet_unmask_all@IronMan@@YAHXZ PROC			; IronMan::kmNet_unmask_all

; 842  : 	{

$LN5:
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 843  : 		int err;
; 844  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_unma
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_unma
$LN2@kmNet_unma:

; 845  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 846  : 		tx.head.cmd = cmd_unmask_all;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 590627651 ; 23344343H

; 847  : 		mask_keyboard_mouse_flag = 0;

	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, 0

; 848  : 		tx.head.rand = mask_keyboard_mouse_flag;

	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 849  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 850  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 851  : 		SOCKADDR_IN sclient;
; 852  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 853  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 854  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_unma

; 855  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_unma
$LN3@kmNet_unma:

; 856  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_unma:

; 857  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_unmask_all@IronMan@@YAHXZ ENDP			; IronMan::kmNet_unmask_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
v_key$ = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
vkey$ = 112
?kmNet_unmask_keyboard@IronMan@@YAHF@Z PROC		; IronMan::kmNet_unmask_keyboard

; 822  : 	{

$LN5:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 823  : 		int err;
; 824  : 		BYTE v_key = vkey & 0xff;

	movsx	eax, WORD PTR vkey$[rsp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR v_key$[rsp], al

; 825  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_unma
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_unma
$LN2@kmNet_unma:

; 826  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 827  : 		tx.head.cmd = cmd_unmask_all;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 590627651 ; 23344343H

; 828  : 		tx.head.rand = (mask_keyboard_mouse_flag & 0xff) | (v_key << 8);	// 屏蔽键盘vkey

	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, 255				; 000000ffH
	movzx	ecx, BYTE PTR v_key$[rsp]
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 829  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 830  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 831  : 		SOCKADDR_IN sclient;
; 832  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 833  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 834  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_unma

; 835  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_unma
$LN3@kmNet_unma:

; 836  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_unma:

; 837  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_unmask_keyboard@IronMan@@YAHF@Z ENDP		; IronMan::kmNet_unmask_keyboard
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
v_key$ = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
vkey$ = 112
?kmNet_mask_keyboard@IronMan@@YAHF@Z PROC		; IronMan::kmNet_mask_keyboard

; 802  : 	{

$LN5:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 803  : 		int err;
; 804  : 		BYTE v_key = vkey & 0xff;

	movsx	eax, WORD PTR vkey$[rsp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR v_key$[rsp], al

; 805  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 806  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 807  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 808  : 		tx.head.rand = (mask_keyboard_mouse_flag & 0xff) | (v_key << 8);	// 屏蔽键盘vkey

	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, 255				; 000000ffH
	movzx	ecx, BYTE PTR v_key$[rsp]
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 809  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 810  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 811  : 		SOCKADDR_IN sclient;
; 812  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 813  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 814  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 815  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 816  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 817  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_keyboard@IronMan@@YAHF@Z ENDP		; IronMan::kmNet_mask_keyboard
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_wheel@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_wheel

; 783  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 784  : 		int err;
; 785  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 786  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 787  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 788  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT7) : (mask_keyboard_mouse_flag &= ~BIT7);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	bts	eax, 7
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	btr	eax, 7
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 789  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 790  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 791  : 		SOCKADDR_IN sclient;
; 792  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 793  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 794  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 795  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 796  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 797  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_wheel@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_wheel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_y@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_y

; 765  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 766  : 		int err;
; 767  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 768  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 769  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 770  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT6) : (mask_keyboard_mouse_flag &= ~BIT6);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	or	eax, 64					; 00000040H
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, -65				; ffffffffffffffbfH
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 771  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 772  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 773  : 		SOCKADDR_IN sclient;
; 774  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 775  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 776  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 777  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 778  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 779  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_y@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_y
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_x@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_x

; 746  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 747  : 		int err;
; 748  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 749  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 750  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 751  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT5) : (mask_keyboard_mouse_flag &= ~BIT5);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	or	eax, 32					; 00000020H
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, -33				; ffffffffffffffdfH
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 752  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 753  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 754  : 		SOCKADDR_IN sclient;
; 755  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 756  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 757  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 758  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 759  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 760  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_x@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_x
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_side2@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_side2

; 727  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 728  : 		int err;
; 729  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 730  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 731  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 732  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT4) : (mask_keyboard_mouse_flag &= ~BIT4);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	or	eax, 16
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, -17
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 733  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 734  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 735  : 		SOCKADDR_IN sclient;
; 736  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 737  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 738  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 739  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 740  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 741  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_side2@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_side2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_side1@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_side1

; 707  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 708  : 		int err;
; 709  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 710  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 711  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 712  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT3) : (mask_keyboard_mouse_flag &= ~BIT3);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	or	eax, 8
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, -9
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 713  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 714  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 715  : 		SOCKADDR_IN sclient;
; 716  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 717  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 718  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 719  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 720  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 721  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_side1@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_side1
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_middle@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_middle

; 688  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 689  : 		int err;
; 690  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 691  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 692  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 693  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT2) : (mask_keyboard_mouse_flag &= ~BIT2);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	or	eax, 4
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, -5
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 694  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 695  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 696  : 		SOCKADDR_IN sclient;
; 697  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 698  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 699  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 700  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 701  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 702  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_middle@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_middle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_right@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_right

; 669  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 670  : 		int err;
; 671  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 672  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 673  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 674  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT1) : (mask_keyboard_mouse_flag &= ~BIT1);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	or	eax, 2
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, -3
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 675  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 676  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 677  : 		SOCKADDR_IN sclient;
; 678  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 679  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 680  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 681  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 682  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 683  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_right@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_right
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv69 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_mask_mouse_left@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mask_mouse_left

; 651  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 652  : 		int err;
; 653  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mask
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mask
$LN2@kmNet_mask:

; 654  : 		tx.head.indexpts++;					//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 655  : 		tx.head.cmd = cmd_mask_mouse;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 589513539 ; 23234343H

; 656  : 		tx.head.rand = enable ? (mask_keyboard_mouse_flag |= BIT0) : (mask_keyboard_mouse_flag &= ~BIT0);	// 屏蔽鼠标左键

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN5@kmNet_mask
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	or	eax, 1
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN6@kmNet_mask
$LN5@kmNet_mask:
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	and	eax, -2
	mov	DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA, eax
	mov	eax, DWORD PTR ?mask_keyboard_mouse_flag@IronMan@@3HA
	mov	DWORD PTR tv69[rsp], eax
$LN6@kmNet_mask:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 657  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 658  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 659  : 		SOCKADDR_IN sclient;
; 660  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 661  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 662  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mask

; 663  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mask
$LN3@kmNet_mask:

; 664  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mask:

; 665  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mask_mouse_left@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mask_mouse_left
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
vk_key$ = 0
tv73 = 4
i$1 = 8
tv77 = 12
tv81 = 16
tv85 = 20
tv89 = 24
tv93 = 28
tv129 = 32
tv133 = 36
tv137 = 40
vkey$ = 64
?kmNet_monitor_keyboard@IronMan@@YAHF@Z PROC		; IronMan::kmNet_monitor_keyboard

; 598  : 	{

$LN37:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 599  : 		unsigned char vk_key = vkey & 0xff;

	movsx	eax, WORD PTR vkey$[rsp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR vk_key$[rsp], al

; 600  : 		if (monitor_run != monitor_ok) return -1;

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 2
	je	SHORT $LN7@kmNet_moni
	mov	eax, -1
	jmp	$LN1@kmNet_moni
$LN7@kmNet_moni:

; 601  : 		if (vk_key >= KEY_LEFTCONTROL && vk_key <= KEY_RIGHT_GUI)//控制键

	movzx	eax, BYTE PTR vk_key$[rsp]
	cmp	eax, 224				; 000000e0H
	jl	$LN8@kmNet_moni
	movzx	eax, BYTE PTR vk_key$[rsp]
	cmp	eax, 231				; 000000e7H
	jg	$LN8@kmNet_moni

; 602  : 		{
; 603  : 			switch (vk_key)

	movzx	eax, BYTE PTR vk_key$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	mov	eax, DWORD PTR tv73[rsp]
	sub	eax, 224				; 000000e0H
	mov	DWORD PTR tv73[rsp], eax
	cmp	DWORD PTR tv73[rsp], 7
	ja	$LN2@kmNet_moni
	movsxd	rax, DWORD PTR tv73[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN36@kmNet_moni[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN10@kmNet_moni:

; 604  : 			{
; 605  : 			case KEY_LEFTCONTROL: return  hw_keyboard.buttons & BIT0 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN20@kmNet_moni
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN21@kmNet_moni
$LN20@kmNet_moni:
	mov	DWORD PTR tv77[rsp], 0
$LN21@kmNet_moni:
	mov	eax, DWORD PTR tv77[rsp]
	jmp	$LN1@kmNet_moni
$LN11@kmNet_moni:

; 606  : 			case KEY_LEFTSHIFT:   return  hw_keyboard.buttons & BIT1 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 2
	test	eax, eax
	je	SHORT $LN22@kmNet_moni
	mov	DWORD PTR tv81[rsp], 1
	jmp	SHORT $LN23@kmNet_moni
$LN22@kmNet_moni:
	mov	DWORD PTR tv81[rsp], 0
$LN23@kmNet_moni:
	mov	eax, DWORD PTR tv81[rsp]
	jmp	$LN1@kmNet_moni
$LN12@kmNet_moni:

; 607  : 			case KEY_LEFTALT:     return  hw_keyboard.buttons & BIT2 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 4
	test	eax, eax
	je	SHORT $LN24@kmNet_moni
	mov	DWORD PTR tv85[rsp], 1
	jmp	SHORT $LN25@kmNet_moni
$LN24@kmNet_moni:
	mov	DWORD PTR tv85[rsp], 0
$LN25@kmNet_moni:
	mov	eax, DWORD PTR tv85[rsp]
	jmp	$LN1@kmNet_moni
$LN13@kmNet_moni:

; 608  : 			case KEY_LEFT_GUI:    return  hw_keyboard.buttons & BIT3 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 8
	test	eax, eax
	je	SHORT $LN26@kmNet_moni
	mov	DWORD PTR tv89[rsp], 1
	jmp	SHORT $LN27@kmNet_moni
$LN26@kmNet_moni:
	mov	DWORD PTR tv89[rsp], 0
$LN27@kmNet_moni:
	mov	eax, DWORD PTR tv89[rsp]
	jmp	$LN1@kmNet_moni
$LN14@kmNet_moni:

; 609  : 			case KEY_RIGHTCONTROL:return  hw_keyboard.buttons & BIT4 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 16
	test	eax, eax
	je	SHORT $LN28@kmNet_moni
	mov	DWORD PTR tv93[rsp], 1
	jmp	SHORT $LN29@kmNet_moni
$LN28@kmNet_moni:
	mov	DWORD PTR tv93[rsp], 0
$LN29@kmNet_moni:
	mov	eax, DWORD PTR tv93[rsp]
	jmp	$LN1@kmNet_moni
$LN15@kmNet_moni:

; 610  : 			case KEY_RIGHTSHIFT:  return  hw_keyboard.buttons & BIT5 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN30@kmNet_moni
	mov	DWORD PTR tv129[rsp], 1
	jmp	SHORT $LN31@kmNet_moni
$LN30@kmNet_moni:
	mov	DWORD PTR tv129[rsp], 0
$LN31@kmNet_moni:
	mov	eax, DWORD PTR tv129[rsp]
	jmp	$LN1@kmNet_moni
$LN16@kmNet_moni:

; 611  : 			case KEY_RIGHTALT:    return  hw_keyboard.buttons & BIT6 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN32@kmNet_moni
	mov	DWORD PTR tv133[rsp], 1
	jmp	SHORT $LN33@kmNet_moni
$LN32@kmNet_moni:
	mov	DWORD PTR tv133[rsp], 0
$LN33@kmNet_moni:
	mov	eax, DWORD PTR tv133[rsp]
	jmp	SHORT $LN1@kmNet_moni
$LN17@kmNet_moni:

; 612  : 			case KEY_RIGHT_GUI:   return  hw_keyboard.buttons & BIT7 ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+1
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN34@kmNet_moni
	mov	DWORD PTR tv137[rsp], 1
	jmp	SHORT $LN35@kmNet_moni
$LN34@kmNet_moni:
	mov	DWORD PTR tv137[rsp], 0
$LN35@kmNet_moni:
	mov	eax, DWORD PTR tv137[rsp]
	jmp	SHORT $LN1@kmNet_moni
$LN2@kmNet_moni:

; 613  : 			}
; 614  : 		}

	jmp	SHORT $LN9@kmNet_moni
$LN8@kmNet_moni:

; 615  : 		else//常规键
; 616  : 		{
; 617  : 			for (int i = 0; i < 10; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@kmNet_moni
$LN4@kmNet_moni:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@kmNet_moni:
	cmp	DWORD PTR i$1[rsp], 10
	jge	SHORT $LN5@kmNet_moni

; 618  : 			{
; 619  : 				if (hw_keyboard.data[i] == vk_key)

	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?hw_keyboard@IronMan@@3Ustandard_keyboard_report_t@1@A+2
	movzx	eax, BYTE PTR [rcx+rax]
	movzx	ecx, BYTE PTR vk_key$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN18@kmNet_moni

; 620  : 				{
; 621  : 					return 1;

	mov	eax, 1
	jmp	SHORT $LN1@kmNet_moni
$LN18@kmNet_moni:

; 622  : 				}
; 623  : 			}

	jmp	SHORT $LN4@kmNet_moni
$LN5@kmNet_moni:
$LN9@kmNet_moni:

; 624  : 		}
; 625  : 		return 0;

	xor	eax, eax
$LN1@kmNet_moni:

; 626  : 
; 627  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN36@kmNet_moni:
	DD	$LN10@kmNet_moni
	DD	$LN11@kmNet_moni
	DD	$LN12@kmNet_moni
	DD	$LN13@kmNet_moni
	DD	$LN14@kmNet_moni
	DD	$LN15@kmNet_moni
	DD	$LN16@kmNet_moni
	DD	$LN17@kmNet_moni
?kmNet_monitor_keyboard@IronMan@@YAHF@Z ENDP		; IronMan::kmNet_monitor_keyboard
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv68 = 0
?kmNet_monitor_mouse_side2@IronMan@@YAHXZ PROC		; IronMan::kmNet_monitor_mouse_side2

; 589  : 	{

$LN6:
	sub	rsp, 24

; 590  : 		if (monitor_run != monitor_ok) return -1;

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 2
	je	SHORT $LN2@kmNet_moni
	mov	eax, -1
	jmp	SHORT $LN1@kmNet_moni
$LN2@kmNet_moni:

; 591  : 		return (hw_mouse.buttons & 0x10) ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A+1
	and	eax, 16
	test	eax, eax
	je	SHORT $LN4@kmNet_moni
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN5@kmNet_moni
$LN4@kmNet_moni:
	mov	DWORD PTR tv68[rsp], 0
$LN5@kmNet_moni:
	mov	eax, DWORD PTR tv68[rsp]
$LN1@kmNet_moni:

; 592  : 	}

	add	rsp, 24
	ret	0
?kmNet_monitor_mouse_side2@IronMan@@YAHXZ ENDP		; IronMan::kmNet_monitor_mouse_side2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv68 = 0
?kmNet_monitor_mouse_side1@IronMan@@YAHXZ PROC		; IronMan::kmNet_monitor_mouse_side1

; 577  : 	{

$LN6:
	sub	rsp, 24

; 578  : 		if (monitor_run != monitor_ok) return -1;

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 2
	je	SHORT $LN2@kmNet_moni
	mov	eax, -1
	jmp	SHORT $LN1@kmNet_moni
$LN2@kmNet_moni:

; 579  : 		return (hw_mouse.buttons & 0x08) ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A+1
	and	eax, 8
	test	eax, eax
	je	SHORT $LN4@kmNet_moni
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN5@kmNet_moni
$LN4@kmNet_moni:
	mov	DWORD PTR tv68[rsp], 0
$LN5@kmNet_moni:
	mov	eax, DWORD PTR tv68[rsp]
$LN1@kmNet_moni:

; 580  : 	}

	add	rsp, 24
	ret	0
?kmNet_monitor_mouse_side1@IronMan@@YAHXZ ENDP		; IronMan::kmNet_monitor_mouse_side1
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv68 = 0
?kmNet_monitor_mouse_right@IronMan@@YAHXZ PROC		; IronMan::kmNet_monitor_mouse_right

; 564  : 	{

$LN6:
	sub	rsp, 24

; 565  : 		if (monitor_run != monitor_ok) return -1;

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 2
	je	SHORT $LN2@kmNet_moni
	mov	eax, -1
	jmp	SHORT $LN1@kmNet_moni
$LN2@kmNet_moni:

; 566  : 		return (hw_mouse.buttons & 0x02) ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A+1
	and	eax, 2
	test	eax, eax
	je	SHORT $LN4@kmNet_moni
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN5@kmNet_moni
$LN4@kmNet_moni:
	mov	DWORD PTR tv68[rsp], 0
$LN5@kmNet_moni:
	mov	eax, DWORD PTR tv68[rsp]
$LN1@kmNet_moni:

; 567  : 	}

	add	rsp, 24
	ret	0
?kmNet_monitor_mouse_right@IronMan@@YAHXZ ENDP		; IronMan::kmNet_monitor_mouse_right
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv68 = 0
?kmNet_monitor_mouse_middle@IronMan@@YAHXZ PROC		; IronMan::kmNet_monitor_mouse_middle

; 552  : 	{

$LN6:
	sub	rsp, 24

; 553  : 		if (monitor_run != monitor_ok) return -1;

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 2
	je	SHORT $LN2@kmNet_moni
	mov	eax, -1
	jmp	SHORT $LN1@kmNet_moni
$LN2@kmNet_moni:

; 554  : 		return (hw_mouse.buttons & 0x04) ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A+1
	and	eax, 4
	test	eax, eax
	je	SHORT $LN4@kmNet_moni
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN5@kmNet_moni
$LN4@kmNet_moni:
	mov	DWORD PTR tv68[rsp], 0
$LN5@kmNet_moni:
	mov	eax, DWORD PTR tv68[rsp]
$LN1@kmNet_moni:

; 555  : 	}

	add	rsp, 24
	ret	0
?kmNet_monitor_mouse_middle@IronMan@@YAHXZ ENDP		; IronMan::kmNet_monitor_mouse_middle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv68 = 0
?kmNet_monitor_mouse_left@IronMan@@YAHXZ PROC		; IronMan::kmNet_monitor_mouse_left

; 539  : 	{

$LN6:
	sub	rsp, 24

; 540  : 		if (monitor_run != monitor_ok) return -1;

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 2
	je	SHORT $LN2@kmNet_moni
	mov	eax, -1
	jmp	SHORT $LN1@kmNet_moni
$LN2@kmNet_moni:

; 541  : 		return (hw_mouse.buttons & 0x01) ? 1 : 0;

	movzx	eax, BYTE PTR ?hw_mouse@IronMan@@3Ustandard_mouse_report_t@1@A+1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@kmNet_moni
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN5@kmNet_moni
$LN4@kmNet_moni:
	mov	DWORD PTR tv68[rsp], 0
$LN5@kmNet_moni:
	mov	eax, DWORD PTR tv68[rsp]
$LN1@kmNet_moni:

; 542  : 	}

	add	rsp, 24
	ret	0
?kmNet_monitor_mouse_left@IronMan@@YAHXZ ENDP		; IronMan::kmNet_monitor_mouse_left
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
lpThreadID$1 = 60
sclient$ = 64
__$ArrayPad$ = 80
enable$ = 112
?kmNet_monitor@IronMan@@YAHH@Z PROC			; IronMan::kmNet_monitor

; 494  : 	{

$LN13:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 495  : 		int err;
; 496  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN5@kmNet_moni
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_moni
$LN5@kmNet_moni:

; 497  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 498  : 		tx.head.cmd = cmd_monitor;		//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 658014240 ; 27388020H

; 499  : 		if (enable)

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN6@kmNet_moni

; 500  : 			tx.head.rand = (addrSrv.sin_port + 1) | 0xaa55 << 16;	// 随机混淆值

	movzx	eax, WORD PTR ?addrSrv@IronMan@@3Usockaddr_in@@A+2
	inc	eax
	or	eax, -1437270016			; ffffffffaa550000H
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax
	jmp	SHORT $LN7@kmNet_moni
$LN6@kmNet_moni:

; 501  : 		else
; 502  : 			tx.head.rand = 0;	// 随机混淆值

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, 0
$LN7@kmNet_moni:

; 503  : 		int length = sizeof(cmd_head_t);

	mov	DWORD PTR length$[rsp], 16

; 504  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 505  : 		SOCKADDR_IN sclient;
; 506  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 507  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 508  : 		if (enable)//打开监听功能

	cmp	DWORD PTR enable$[rsp], 0
	je	SHORT $LN8@kmNet_moni
$LN4@kmNet_moni:

; 509  : 		{
; 510  : 			do
; 511  : 			{
; 512  : 				if (handle_listen == NULL)

	cmp	QWORD PTR ?handle_listen@IronMan@@3PEAXEA, 0
	jne	SHORT $LN10@kmNet_moni

; 513  : 				{
; 514  : 					DWORD lpThreadID;
; 515  : 					monitor_run = monitor_begin;

	mov	DWORD PTR ?monitor_run@IronMan@@3HA, 1

; 516  : 					handle_listen = CreateThread(NULL, 0, ThreadListenProcess, NULL, 0, &lpThreadID);

	lea	rax, QWORD PTR lpThreadID$1[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:?ThreadListenProcess@IronMan@@YAKPEAX@Z ; IronMan::ThreadListenProcess
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateThread
	mov	QWORD PTR ?handle_listen@IronMan@@3PEAXEA, rax
$LN10@kmNet_moni:

; 517  : 				}
; 518  : 				Sleep(10);

	mov	ecx, 10
	call	QWORD PTR __imp_Sleep
	npad	1

; 519  : 			} while (monitor_run != monitor_ok); //等待监听线程启动

	cmp	DWORD PTR ?monitor_run@IronMan@@3HA, 2
	jne	SHORT $LN4@kmNet_moni

; 520  : 		}

	jmp	SHORT $LN9@kmNet_moni
$LN8@kmNet_moni:

; 521  : 		else {
; 522  : 			handle_listen = NULL;

	mov	QWORD PTR ?handle_listen@IronMan@@3PEAXEA, 0

; 523  : 			monitor_run = monitor_exit;

	mov	DWORD PTR ?monitor_run@IronMan@@3HA, 0
$LN9@kmNet_moni:

; 524  : 		}
; 525  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN11@kmNet_moni

; 526  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_moni
$LN11@kmNet_moni:

; 527  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_moni:

; 528  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_monitor@IronMan@@YAHH@Z ENDP			; IronMan::kmNet_monitor
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
i$ = 48
tv66 = 52
length$ = 56
clen$ = 60
err$ = 64
tv143 = 72
sclient$ = 80
__$ArrayPad$ = 96
vk_key$ = 128
?kmNet_keyup@IronMan@@YAHH@Z PROC			; IronMan::kmNet_keyup

; 396  : 	{

$LN23:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 397  : 		int i;
; 398  : 		if (vk_key >= KEY_LEFTCONTROL && vk_key <= KEY_RIGHT_GUI)//控制键

	cmp	DWORD PTR vk_key$[rsp], 224		; 000000e0H
	jl	$LN7@kmNet_keyu
	cmp	DWORD PTR vk_key$[rsp], 231		; 000000e7H
	jg	$LN7@kmNet_keyu

; 399  : 		{
; 400  : 			switch (vk_key)

	mov	eax, DWORD PTR vk_key$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	mov	eax, DWORD PTR tv66[rsp]
	sub	eax, 224				; 000000e0H
	mov	DWORD PTR tv66[rsp], eax
	cmp	DWORD PTR tv66[rsp], 7
	ja	$LN2@kmNet_keyu
	movsxd	rax, DWORD PTR tv66[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN22@kmNet_keyu[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN9@kmNet_keyu:

; 401  : 			{
; 402  : 			case KEY_LEFTCONTROL: softkeyboard.ctrl &= ~BIT0; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	and	eax, -2
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyu
$LN10@kmNet_keyu:

; 403  : 			case KEY_LEFTSHIFT:   softkeyboard.ctrl &= ~BIT1; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	and	eax, -3
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyu
$LN11@kmNet_keyu:

; 404  : 			case KEY_LEFTALT:     softkeyboard.ctrl &= ~BIT2; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	and	eax, -5
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyu
$LN12@kmNet_keyu:

; 405  : 			case KEY_LEFT_GUI:    softkeyboard.ctrl &= ~BIT3; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	and	eax, -9
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyu
$LN13@kmNet_keyu:

; 406  : 			case KEY_RIGHTCONTROL:softkeyboard.ctrl &= ~BIT4; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	and	eax, -17
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyu
$LN14@kmNet_keyu:

; 407  : 			case KEY_RIGHTSHIFT:  softkeyboard.ctrl &= ~BIT5; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	and	eax, -33				; ffffffffffffffdfH
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyu
$LN15@kmNet_keyu:

; 408  : 			case KEY_RIGHTALT:    softkeyboard.ctrl &= ~BIT6; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyu
$LN16@kmNet_keyu:

; 409  : 			case KEY_RIGHT_GUI:   softkeyboard.ctrl &= ~BIT7; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	btr	eax, 7
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
$LN2@kmNet_keyu:

; 410  : 			}
; 411  : 		}

	jmp	$LN8@kmNet_keyu
$LN7@kmNet_keyu:

; 412  : 		else
; 413  : 		{//常规键  
; 414  : 			for (i = 0; i < 10; i++)//首先检查队列中是否存在vk_key

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN6@kmNet_keyu
$LN4@kmNet_keyu:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN6@kmNet_keyu:
	cmp	DWORD PTR i$[rsp], 10
	jge	$LN5@kmNet_keyu

; 415  : 			{
; 416  : 				if (softkeyboard.button[i] == vk_key)// 队列里面已经有vk_key 

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR vk_key$[rsp]
	jne	SHORT $LN17@kmNet_keyu

; 417  : 				{
; 418  : 					memcpy(&softkeyboard.button[i], &softkeyboard.button[i + 1], 10 - i);

	mov	eax, 10
	sub	eax, DWORD PTR i$[rsp]
	cdqe
	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	lea	rdx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	add	rdx, rcx
	mov	rcx, rdx
	movsxd	rdx, DWORD PTR i$[rsp]
	lea	r8, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv143[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv143[rsp]
	mov	rcx, rax
	call	memcpy

; 419  : 					softkeyboard.button[9] = 0;

	mov	eax, 1
	imul	rax, rax, 9
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	mov	BYTE PTR [rcx+rax], 0

; 420  : 					goto KM_up_send;

	jmp	SHORT $LN18@kmNet_keyu
	jmp	SHORT $KM_up_send$24
$LN17@kmNet_keyu:

; 421  : 				}
; 422  : 			}

	jmp	$LN4@kmNet_keyu
$LN5@kmNet_keyu:
$LN8@kmNet_keyu:
$LN18@kmNet_keyu:
$KM_up_send$24:

; 423  : 		}
; 424  : 	KM_up_send:
; 425  : 		int err;
; 426  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN19@kmNet_keyu
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_keyu
$LN19@kmNet_keyu:

; 427  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 428  : 		tx.head.cmd = cmd_keyboard_all;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 305933359 ; 123c2c2fH

; 429  : 		tx.head.rand = rand();			// 随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 430  : 		memcpy(&tx.cmd_keyboard, &softkeyboard, sizeof(soft_keyboard_t));

	mov	r8d, 12
	lea	rdx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A ; IronMan::softkeyboard
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 431  : 		int length = sizeof(cmd_head_t) + sizeof(soft_keyboard_t);

	mov	DWORD PTR length$[rsp], 28

; 432  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 433  : 		SOCKADDR_IN sclient;
; 434  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 435  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 436  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN20@kmNet_keyu

; 437  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_keyu
$LN20@kmNet_keyu:

; 438  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_keyu:

; 439  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
$LN22@kmNet_keyu:
	DD	$LN9@kmNet_keyu
	DD	$LN10@kmNet_keyu
	DD	$LN11@kmNet_keyu
	DD	$LN12@kmNet_keyu
	DD	$LN13@kmNet_keyu
	DD	$LN14@kmNet_keyu
	DD	$LN15@kmNet_keyu
	DD	$LN16@kmNet_keyu
?kmNet_keyup@IronMan@@YAHH@Z ENDP			; IronMan::kmNet_keyup
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
i$ = 48
tv66 = 52
length$ = 56
clen$ = 60
err$ = 64
sclient$ = 72
__$ArrayPad$ = 88
vk_key$ = 112
?kmNet_keydown@IronMan@@YAHH@Z PROC			; IronMan::kmNet_keydown

; 339  : 	{

$LN28:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 340  : 		int i;
; 341  : 		if (vk_key >= KEY_LEFTCONTROL && vk_key <= KEY_RIGHT_GUI)//控制键

	cmp	DWORD PTR vk_key$[rsp], 224		; 000000e0H
	jl	$LN10@kmNet_keyd
	cmp	DWORD PTR vk_key$[rsp], 231		; 000000e7H
	jg	$LN10@kmNet_keyd

; 342  : 		{
; 343  : 			switch (vk_key)

	mov	eax, DWORD PTR vk_key$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	mov	eax, DWORD PTR tv66[rsp]
	sub	eax, 224				; 000000e0H
	mov	DWORD PTR tv66[rsp], eax
	cmp	DWORD PTR tv66[rsp], 7
	ja	$LN2@kmNet_keyd
	movsxd	rax, DWORD PTR tv66[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN27@kmNet_keyd[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN12@kmNet_keyd:

; 344  : 			{
; 345  : 			case KEY_LEFTCONTROL: softkeyboard.ctrl |= BIT0; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	or	eax, 1
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyd
$LN13@kmNet_keyd:

; 346  : 			case KEY_LEFTSHIFT:   softkeyboard.ctrl |= BIT1; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	or	eax, 2
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyd
$LN14@kmNet_keyd:

; 347  : 			case KEY_LEFTALT:     softkeyboard.ctrl |= BIT2; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	or	eax, 4
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyd
$LN15@kmNet_keyd:

; 348  : 			case KEY_LEFT_GUI:    softkeyboard.ctrl |= BIT3; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	or	eax, 8
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyd
$LN16@kmNet_keyd:

; 349  : 			case KEY_RIGHTCONTROL:softkeyboard.ctrl |= BIT4; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	or	eax, 16
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyd
$LN17@kmNet_keyd:

; 350  : 			case KEY_RIGHTSHIFT:  softkeyboard.ctrl |= BIT5; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	or	eax, 32					; 00000020H
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyd
$LN18@kmNet_keyd:

; 351  : 			case KEY_RIGHTALT:    softkeyboard.ctrl |= BIT6; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	or	eax, 64					; 00000040H
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
	jmp	SHORT $LN2@kmNet_keyd
$LN19@kmNet_keyd:

; 352  : 			case KEY_RIGHT_GUI:   softkeyboard.ctrl |= BIT7; break;

	movsx	eax, BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A
	bts	eax, 7
	mov	BYTE PTR ?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A, al
$LN2@kmNet_keyd:

; 353  : 			}
; 354  : 		}

	jmp	$LN11@kmNet_keyd
$LN10@kmNet_keyd:

; 355  : 		else
; 356  : 		{//常规键  
; 357  : 			for (i = 0; i < 10; i++)//首先检查队列中是否存在vk_key

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN6@kmNet_keyd
$LN4@kmNet_keyd:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN6@kmNet_keyd:
	cmp	DWORD PTR i$[rsp], 10
	jge	SHORT $LN5@kmNet_keyd

; 358  : 			{
; 359  : 				if (softkeyboard.button[i] == vk_key)

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, DWORD PTR vk_key$[rsp]
	jne	SHORT $LN20@kmNet_keyd

; 360  : 					goto KM_down_send;// 队列里面已经有vk_key 直接发送就行

	jmp	$LN21@kmNet_keyd
	jmp	$KM_down_send$29
$LN20@kmNet_keyd:

; 361  : 			}

	jmp	SHORT $LN4@kmNet_keyd
$LN5@kmNet_keyd:

; 362  : 			//队列里面没有vk_key 
; 363  : 			for (i = 0; i < 10; i++)//遍历所有的数据，将vk_key添加到队列里

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN9@kmNet_keyd
$LN7@kmNet_keyd:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@kmNet_keyd:
	cmp	DWORD PTR i$[rsp], 10
	jge	SHORT $LN8@kmNet_keyd

; 364  : 			{
; 365  : 				if (softkeyboard.button[i] == 0)

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN22@kmNet_keyd

; 366  : 				{// 队列里面已经有vk_key 直接发送就行
; 367  : 					softkeyboard.button[i] = vk_key;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	movzx	edx, BYTE PTR vk_key$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 368  : 					goto KM_down_send;

	jmp	SHORT $LN23@kmNet_keyd
	jmp	SHORT $KM_down_send$29
$LN22@kmNet_keyd:

; 369  : 				}
; 370  : 			}

	jmp	SHORT $LN7@kmNet_keyd
$LN8@kmNet_keyd:

; 371  : 			//队列已经满了 那么就剔除最开始的那个
; 372  : 			memcpy(&softkeyboard.button[0], &softkeyboard.button[1], 10);

	mov	eax, 1
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 1
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8d, 10
	mov	rdx, rax
	call	memcpy

; 373  : 			softkeyboard.button[9] = vk_key;

	mov	eax, 1
	imul	rax, rax, 9
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A+2
	movzx	edx, BYTE PTR vk_key$[rsp]
	mov	BYTE PTR [rcx+rax], dl
$LN11@kmNet_keyd:
$LN21@kmNet_keyd:
$LN23@kmNet_keyd:
$KM_down_send$29:

; 374  : 		}
; 375  : 	KM_down_send:
; 376  : 		int err;
; 377  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN24@kmNet_keyd
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_keyd
$LN24@kmNet_keyd:

; 378  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 379  : 		tx.head.cmd = cmd_keyboard_all;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 305933359 ; 123c2c2fH

; 380  : 		tx.head.rand = rand();			// 随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 381  : 		memcpy(&tx.cmd_keyboard, &softkeyboard, sizeof(soft_keyboard_t));

	mov	r8d, 12
	lea	rdx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A ; IronMan::softkeyboard
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 382  : 		int length = sizeof(cmd_head_t) + sizeof(soft_keyboard_t);

	mov	DWORD PTR length$[rsp], 28

; 383  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 384  : 		SOCKADDR_IN sclient;
; 385  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 386  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 387  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN25@kmNet_keyd

; 388  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_keyd
$LN25@kmNet_keyd:

; 389  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_keyd:

; 390  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
	npad	1
$LN27@kmNet_keyd:
	DD	$LN12@kmNet_keyd
	DD	$LN13@kmNet_keyd
	DD	$LN14@kmNet_keyd
	DD	$LN15@kmNet_keyd
	DD	$LN16@kmNet_keyd
	DD	$LN17@kmNet_keyd
	DD	$LN18@kmNet_keyd
	DD	$LN19@kmNet_keyd
?kmNet_keydown@IronMan@@YAHH@Z ENDP			; IronMan::kmNet_keydown
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
x$ = 112
y$ = 120
ms$ = 128
x1$ = 136
y1$ = 144
x2$ = 152
y2$ = 160
?kmNet_mouse_move_beizer@IronMan@@YAHHHHHHHH@Z PROC	; IronMan::kmNet_mouse_move_beizer

; 311  : 	{

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 312  : 		int err;
; 313  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 314  : 		tx.head.indexpts++;			 //指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 315  : 		tx.head.cmd = cmd_bazerMove; //指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1573370534 ; a238455aH

; 316  : 		tx.head.rand = ms;			 //随机混淆值

	mov	eax, DWORD PTR ms$[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 317  : 		softmouse.x = x;

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, eax

; 318  : 		softmouse.y = y;

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, eax

; 319  : 		softmouse.point[0] = x1;

	mov	eax, 4
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A+16
	mov	edx, DWORD PTR x1$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 320  : 		softmouse.point[1] = y1;

	mov	eax, 4
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A+16
	mov	edx, DWORD PTR y1$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 321  : 		softmouse.point[2] = x2;

	mov	eax, 4
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A+16
	mov	edx, DWORD PTR x2$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 322  : 		softmouse.point[3] = y2;

	mov	eax, 4
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A+16
	mov	edx, DWORD PTR y2$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 323  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 324  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 325  : 		softmouse.x = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, 0

; 326  : 		softmouse.y = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, 0

; 327  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 328  : 		SOCKADDR_IN sclient;
; 329  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 330  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 331  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 332  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 333  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 334  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_move_beizer@IronMan@@YAHHHHHHHH@Z ENDP	; IronMan::kmNet_mouse_move_beizer
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
x$ = 112
y$ = 120
ms$ = 128
?kmNet_mouse_move_auto@IronMan@@YAHHHH@Z PROC		; IronMan::kmNet_mouse_move_auto

; 280  : 	{

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 281  : 		int err;
; 282  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 283  : 		tx.head.indexpts++;				 //指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 284  : 		tx.head.cmd = cmd_mouse_automove;//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1361153210 ; aede7346H

; 285  : 		tx.head.rand = ms;			     //随机混淆值

	mov	eax, DWORD PTR ms$[rsp]
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 286  : 		softmouse.x = x;

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, eax

; 287  : 		softmouse.y = y;

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, eax

; 288  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 289  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 290  : 		softmouse.x = 0;				//清零

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, 0

; 291  : 		softmouse.y = 0;				//清零

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, 0

; 292  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 293  : 		SOCKADDR_IN sclient;
; 294  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 295  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 296  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 297  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 298  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 299  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_move_auto@IronMan@@YAHHHH@Z ENDP		; IronMan::kmNet_mouse_move_auto
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
button$ = 112
x$ = 120
y$ = 128
wheel$ = 136
?kmNet_mouse_all@IronMan@@YAHHHHH@Z PROC		; IronMan::kmNet_mouse_all

; 248  : 	{

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 249  : 		int err;
; 250  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 251  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 252  : 		tx.head.cmd = cmd_mouse_wheel;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1135304 ; ffeead38H

; 253  : 		tx.head.rand = rand();			//随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 254  : 		softmouse.button = button;

	mov	eax, DWORD PTR button$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A, eax

; 255  : 		softmouse.x = x;

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, eax

; 256  : 		softmouse.y = y;

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, eax

; 257  : 		softmouse.wheel = wheel;

	mov	eax, DWORD PTR wheel$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+12, eax

; 258  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 259  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 260  : 		softmouse.x = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, 0

; 261  : 		softmouse.y = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, 0

; 262  : 		softmouse.wheel = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+12, 0

; 263  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 264  : 		SOCKADDR_IN sclient;
; 265  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 266  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 267  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 268  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 269  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 270  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_all@IronMan@@YAHHHHH@Z ENDP		; IronMan::kmNet_mouse_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
wheel$ = 112
?kmNet_mouse_wheel@IronMan@@YAHH@Z PROC			; IronMan::kmNet_mouse_wheel

; 224  : 	{

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 225  : 		int err;
; 226  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 227  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 228  : 		tx.head.cmd = cmd_mouse_wheel;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1135304 ; ffeead38H

; 229  : 		tx.head.rand = rand();			//随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 230  : 		softmouse.wheel = wheel;

	mov	eax, DWORD PTR wheel$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+12, eax

; 231  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 232  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 233  : 		softmouse.wheel = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+12, 0

; 234  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 235  : 		SOCKADDR_IN sclient;
; 236  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 237  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 238  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 239  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 240  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 241  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_wheel@IronMan@@YAHH@Z ENDP			; IronMan::kmNet_mouse_wheel
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv70 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
isdown$ = 112
?kmNet_mouse_middle@IronMan@@YAHH@Z PROC		; IronMan::kmNet_mouse_middle

; 180  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 181  : 		int err;
; 182  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 183  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 184  : 		tx.head.cmd = cmd_mouse_middle;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1750880627 ; 97a3ae8dH

; 185  : 		tx.head.rand = rand();			//随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 186  : 		softmouse.button = (isdown ? (softmouse.button | 0x04) : (softmouse.button & (~0x04)));

	cmp	DWORD PTR isdown$[rsp], 0
	je	SHORT $LN5@kmNet_mous
	mov	eax, DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A
	or	eax, 4
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN6@kmNet_mous
$LN5@kmNet_mous:
	mov	eax, DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A
	and	eax, -5
	mov	DWORD PTR tv70[rsp], eax
$LN6@kmNet_mous:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A, eax

; 187  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 188  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 189  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 190  : 		SOCKADDR_IN sclient;
; 191  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 192  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 193  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 194  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 195  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 196  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_middle@IronMan@@YAHH@Z ENDP		; IronMan::kmNet_mouse_middle
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv70 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
isdown$ = 112
?kmNet_mouse_right@IronMan@@YAHH@Z PROC			; IronMan::kmNet_mouse_right

; 204  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 205  : 		int err;
; 206  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 207  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 208  : 		tx.head.cmd = cmd_mouse_right;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, 596476434 ; 238d8212H

; 209  : 		tx.head.rand = rand();			//随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 210  : 		softmouse.button = (isdown ? (softmouse.button | 0x02) : (softmouse.button & (~0x02)));

	cmp	DWORD PTR isdown$[rsp], 0
	je	SHORT $LN5@kmNet_mous
	mov	eax, DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A
	or	eax, 2
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN6@kmNet_mous
$LN5@kmNet_mous:
	mov	eax, DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A
	and	eax, -3
	mov	DWORD PTR tv70[rsp], eax
$LN6@kmNet_mous:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A, eax

; 211  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 212  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 213  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 214  : 		SOCKADDR_IN sclient;
; 215  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 216  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 217  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 218  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 219  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 220  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_right@IronMan@@YAHH@Z ENDP			; IronMan::kmNet_mouse_right
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
tv70 = 48
length$ = 52
clen$ = 56
err$ = 60
sclient$ = 64
__$ArrayPad$ = 80
isdown$ = 112
?kmNet_mouse_left@IronMan@@YAHH@Z PROC			; IronMan::kmNet_mouse_left

; 156  : 	{

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 157  : 		int err;
; 158  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 159  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 160  : 		tx.head.cmd = cmd_mouse_left;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1742492019 ; 9823ae8dH

; 161  : 		tx.head.rand = rand();			//随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 162  : 		softmouse.button = (isdown ? (softmouse.button | 0x01) : (softmouse.button & (~0x01)));

	cmp	DWORD PTR isdown$[rsp], 0
	je	SHORT $LN5@kmNet_mous
	mov	eax, DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A
	or	eax, 1
	mov	DWORD PTR tv70[rsp], eax
	jmp	SHORT $LN6@kmNet_mous
$LN5@kmNet_mous:
	mov	eax, DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A
	and	eax, -2
	mov	DWORD PTR tv70[rsp], eax
$LN6@kmNet_mous:
	mov	eax, DWORD PTR tv70[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A, eax

; 163  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 164  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 165  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 166  : 		SOCKADDR_IN sclient;
; 167  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 168  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 169  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 170  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 171  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 172  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_left@IronMan@@YAHH@Z ENDP			; IronMan::kmNet_mouse_left
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
length$ = 48
clen$ = 52
err$ = 56
sclient$ = 64
__$ArrayPad$ = 80
x$ = 112
y$ = 120
?kmNet_mouse_move@IronMan@@YAHFF@Z PROC			; IronMan::kmNet_mouse_move

; 127  : 	{

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 128  : 		int err;
; 129  : 		if (sockClientfd <= 0)		return err_creat_socket;

	cmp	QWORD PTR ?sockClientfd@IronMan@@3_KA, 0 ; IronMan::sockClientfd
	ja	SHORT $LN2@kmNet_mous
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_mous
$LN2@kmNet_mous:

; 130  : 		tx.head.indexpts++;				//指令统计值

	mov	eax, DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8
	inc	eax
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, eax

; 131  : 		tx.head.cmd = cmd_mouse_move;	//指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1361153211 ; aede7345H

; 132  : 		tx.head.rand = rand();			//随机混淆值

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 133  : 		softmouse.x = x;

	movsx	eax, WORD PTR x$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, eax

; 134  : 		softmouse.y = y;

	movsx	eax, WORD PTR y$[rsp]
	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, eax

; 135  : 		memcpy(&tx.cmd_mouse, &softmouse, sizeof(soft_mouse_t));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	lea	rcx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A+16
	call	memcpy

; 136  : 		int length = sizeof(cmd_head_t) + sizeof(soft_mouse_t);

	mov	DWORD PTR length$[rsp], 72		; 00000048H

; 137  : 		sendto(sockClientfd, (const char*)&tx, length, 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, DWORD PTR length$[rsp]
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto

; 138  : 		softmouse.x = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+4, 0

; 139  : 		softmouse.y = 0;

	mov	DWORD PTR ?softmouse@IronMan@@3Usoft_mouse_t@1@A+8, 0

; 140  : 		SOCKADDR_IN sclient;
; 141  : 		int clen = sizeof(sclient);

	mov	DWORD PTR clen$[rsp], 16

; 142  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&sclient, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR sclient$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 143  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN3@kmNet_mous

; 144  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_mous
$LN3@kmNet_mous:

; 145  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_mous:

; 146  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?kmNet_mouse_move@IronMan@@YAHFF@Z ENDP			; IronMan::kmNet_mouse_move
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\MouseController\KMBOX\KmboxNet.cpp
_TEXT	SEGMENT
err$ = 48
wVersionRequested$ = 52
clen$ = 56
wsaData$ = 64
__$ArrayPad$ = 480
ip$ = 512
port$ = 520
mac$ = 528
?kmNet_init@IronMan@@YAHPEAD00@Z PROC			; IronMan::kmNet_init

; 92   : 	{

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 93   : 		WORD wVersionRequested; WSADATA wsaData;	int err;
; 94   : 		wVersionRequested = MAKEWORD(1, 1);

	mov	eax, 257				; 00000101H
	mov	WORD PTR wVersionRequested$[rsp], ax

; 95   : 		err = WSAStartup(wVersionRequested, &wsaData);

	lea	rdx, QWORD PTR wsaData$[rsp]
	movzx	ecx, WORD PTR wVersionRequested$[rsp]
	call	QWORD PTR __imp_WSAStartup
	mov	DWORD PTR err$[rsp], eax

; 96   : 		if (err != 0) 		return err_creat_socket;

	cmp	DWORD PTR err$[rsp], 0
	je	SHORT $LN2@kmNet_init
	mov	eax, -9000				; ffffffffffffdcd8H
	jmp	$LN1@kmNet_init
$LN2@kmNet_init:

; 97   : 		if (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1) {

	movzx	eax, WORD PTR wsaData$[rsp]
	and	rax, 255				; 000000ffH
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN4@kmNet_init
	movzx	eax, WORD PTR wsaData$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	movzx	eax, al
	cmp	eax, 1
	je	SHORT $LN3@kmNet_init
$LN4@kmNet_init:

; 98   : 			WSACleanup(); sockClientfd = -1;

	call	QWORD PTR __imp_WSACleanup
	mov	QWORD PTR ?sockClientfd@IronMan@@3_KA, -1 ; IronMan::sockClientfd

; 99   : 			return err_net_version;

	mov	eax, -8999				; ffffffffffffdcd9H
	jmp	$LN1@kmNet_init
$LN3@kmNet_init:

; 100  : 		}
; 101  : 		srand((unsigned)time(NULL));

	xor	ecx, ecx
	call	time
	mov	ecx, eax
	call	srand

; 102  : 		sockClientfd = socket(AF_INET, SOCK_DGRAM, 0);

	xor	r8d, r8d
	mov	edx, 2
	mov	ecx, 2
	call	QWORD PTR __imp_socket
	mov	QWORD PTR ?sockClientfd@IronMan@@3_KA, rax ; IronMan::sockClientfd

; 103  : 		addrSrv.sin_addr.S_un.S_addr = inet_addr(ip);

	mov	rcx, QWORD PTR ip$[rsp]
	call	QWORD PTR __imp_inet_addr
	mov	DWORD PTR ?addrSrv@IronMan@@3Usockaddr_in@@A+4, eax

; 104  : 		addrSrv.sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR ?addrSrv@IronMan@@3Usockaddr_in@@A, ax

; 105  : 		addrSrv.sin_port = htons(atoi(port));//端口UUID[1]>>16高16位

	mov	rcx, QWORD PTR port$[rsp]
	call	atoi
	movzx	ecx, ax
	call	QWORD PTR __imp_htons
	mov	WORD PTR ?addrSrv@IronMan@@3Usockaddr_in@@A+2, ax

; 106  : 		tx.head.mac = StrToHex(mac, 4);		 //盒子的mac 固定 UUID[1]

	mov	edx, 4
	mov	rcx, QWORD PTR mac$[rsp]
	call	?StrToHex@IronMan@@YAIPEADH@Z		; IronMan::StrToHex
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A, eax

; 107  : 		tx.head.rand = rand();				 //随机值。后续可用于网络数据包加密。避免特征。先预留

	call	rand
	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+4, eax

; 108  : 		tx.head.indexpts = 0;				 //指令统计值

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+8, 0

; 109  : 		tx.head.cmd = cmd_connect;			 //指令

	mov	DWORD PTR ?tx@IronMan@@3Uclient_tx@1@A+12, -1355012056 ; af3c2828H

; 110  : 		memset(&softmouse, 0, sizeof(softmouse));	//软件鼠标数据清零

	mov	r8d, 56					; 00000038H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?softmouse@IronMan@@3Usoft_mouse_t@1@A ; IronMan::softmouse
	call	memset

; 111  : 		memset(&softkeyboard, 0, sizeof(softkeyboard));//软件鼠标数据清零

	mov	r8d, 12
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?softkeyboard@IronMan@@3Usoft_keyboard_t@1@A ; IronMan::softkeyboard
	call	memset

; 112  : 		err = sendto(sockClientfd, (const char*)&tx, sizeof(cmd_head_t), 0, (struct sockaddr*)&addrSrv, sizeof(addrSrv));

	mov	DWORD PTR [rsp+40], 16
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 16
	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_sendto
	mov	DWORD PTR err$[rsp], eax

; 113  : 		Sleep(20);//第一次连接可能时间比较久

	mov	ecx, 20
	call	QWORD PTR __imp_Sleep

; 114  : 		int clen = sizeof(addrSrv);

	mov	DWORD PTR clen$[rsp], 16

; 115  : 		err = recvfrom(sockClientfd, (char*)&rx, 1024, 0, (struct sockaddr*)&addrSrv, &clen);

	lea	rax, QWORD PTR clen$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?addrSrv@IronMan@@3Usockaddr_in@@A ; IronMan::addrSrv
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1024				; 00000400H
	lea	rdx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	mov	rcx, QWORD PTR ?sockClientfd@IronMan@@3_KA ; IronMan::sockClientfd
	call	QWORD PTR __imp_recvfrom
	mov	DWORD PTR err$[rsp], eax

; 116  : 		if (err < 0)

	cmp	DWORD PTR err$[rsp], 0
	jge	SHORT $LN5@kmNet_init

; 117  : 			return err_net_rx_timeout;

	mov	eax, -8997				; ffffffffffffdcdbH
	jmp	SHORT $LN1@kmNet_init
$LN5@kmNet_init:

; 118  : 		return NetRxReturnHandle(&rx, &tx);

	lea	rdx, OFFSET FLAT:?tx@IronMan@@3Uclient_tx@1@A ; IronMan::tx
	lea	rcx, OFFSET FLAT:?rx@IronMan@@3Uclient_tx@1@A ; IronMan::rx
	call	?NetRxReturnHandle@IronMan@@YAHPEAUclient_tx@1@0@Z ; IronMan::NetRxReturnHandle
$LN1@kmNet_init:

; 119  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
?kmNet_init@IronMan@@YAHPEAD00@Z ENDP			; IronMan::kmNet_init
_TEXT	ENDS
END
