; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	fabsf
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	??0PxVec3@physx@@QEAA@XZ			; physx::PxVec3::PxVec3
PUBLIC	??0PxVec3@physx@@QEAA@AEBV01@@Z			; physx::PxVec3::PxVec3
PUBLIC	??APxVec3@physx@@QEAAAEAMI@Z			; physx::PxVec3::operator[]
PUBLIC	??0PxMat33@physx@@QEAA@XZ			; physx::PxMat33::PxMat33
PUBLIC	??0PxMat33@physx@@QEAA@AEBV01@@Z		; physx::PxMat33::PxMat33
PUBLIC	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z		; physx::PxMat33::operator[]
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?ToVector3@_D3DMATRIX@Math@Core@IronMan@@QEAA?AUFVector@234@XZ ; IronMan::Core::Math::_D3DMATRIX::ToVector3
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z ; IronMan::Core::Math::VectorMatrixMultiply
PUBLIC	?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z ; IronMan::Core::Math::VectorQuaternionMultiply
PUBLIC	?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z ; IronMan::Core::Math::VectorMatrixInverse
PUBLIC	?Atan2@Math@Core@IronMan@@YAMMM@Z		; IronMan::Core::Math::Atan2
PUBLIC	??0FVector@Math@Core@IronMan@@QEAA@XZ		; IronMan::Core::Math::FVector::FVector
PUBLIC	??0FVector@Math@Core@IronMan@@QEAA@M@Z		; IronMan::Core::Math::FVector::FVector
PUBLIC	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z	; IronMan::Core::Math::FVector::FVector
PUBLIC	??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator-
PUBLIC	??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator+
PUBLIC	??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z	; IronMan::Core::Math::FVector::operator*
PUBLIC	??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator*
PUBLIC	??UFVector@Math@Core@IronMan@@QEBAMAEBU0123@@Z	; IronMan::Core::Math::FVector::operator|
PUBLIC	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^
PUBLIC	?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ; IronMan::Core::Math::FVector::GetSafeNormal
PUBLIC	?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FVector::IsNearlyZero
PUBLIC	?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FVector::GetSignVector
PUBLIC	?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z ; IronMan::Core::Math::FVector::CrossProduct
PUBLIC	??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z	; IronMan::Core::Math::FVector2D::FVector2D
PUBLIC	??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector2D::operator-
PUBLIC	??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector2D::operator+
PUBLIC	??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z	; IronMan::Core::Math::FVector2D::operator*
PUBLIC	??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z	; IronMan::Core::Math::FVector2D::operator/
PUBLIC	?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ	; IronMan::Core::Math::FVector2D::Size
PUBLIC	?SizeSquared@FVector2D@Math@Core@IronMan@@QEBAMXZ ; IronMan::Core::Math::FVector2D::SizeSquared
PUBLIC	??0FRotator@Math@Core@IronMan@@QEAA@XZ		; IronMan::Core::Math::FRotator::FRotator
PUBLIC	??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z	; IronMan::Core::Math::FRotator::FRotator
PUBLIC	??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FRotator::operator+
PUBLIC	??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FRotator::operator-
PUBLIC	??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z	; IronMan::Core::Math::FRotator::operator*
PUBLIC	??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z ; IronMan::Core::Math::FRotator::operator==
PUBLIC	?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FRotator::IsNearlyZero
PUBLIC	?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z	; IronMan::Core::Math::FRotator::ClampAxis
PUBLIC	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
PUBLIC	?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ	; IronMan::Core::Math::FRotator::Normalize
PUBLIC	?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FRotator::GetNormalized
PUBLIC	?Quaternion@FRotator@Math@Core@IronMan@@QEBA?AUFQuat@234@XZ ; IronMan::Core::Math::FRotator::Quaternion
PUBLIC	?MakeFromX@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ; IronMan::Core::Math::FRotator::MakeFromX
PUBLIC	?MakeFromY@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ; IronMan::Core::Math::FRotator::MakeFromY
PUBLIC	?MakeFromZ@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ; IronMan::Core::Math::FRotator::MakeFromZ
PUBLIC	??0FQuat@Math@Core@IronMan@@QEAA@XZ		; IronMan::Core::Math::FQuat::FQuat
PUBLIC	??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z		; IronMan::Core::Math::FQuat::FQuat
PUBLIC	??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z ; IronMan::Core::Math::FQuat::FQuat
PUBLIC	?Rotator@FQuat@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ ; IronMan::Core::Math::FQuat::Rotator
PUBLIC	?SizeSquared@FQuat@Math@Core@IronMan@@QEBAMXZ	; IronMan::Core::Math::FQuat::SizeSquared
PUBLIC	?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ	; IronMan::Core::Math::FQuat::IsNormalized
PUBLIC	?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FQuat::Inverse
PUBLIC	?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z	; IronMan::Core::Math::FQuat::Normalize
PUBLIC	?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z ; IronMan::Core::Math::FQuat::RotateVector
PUBLIC	??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FQuat::operator*
PUBLIC	??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z ; IronMan::Core::Math::FQuat::operator*
PUBLIC	??0FPlane@Math@Core@IronMan@@QEAA@XZ		; IronMan::Core::Math::FPlane::FPlane
PUBLIC	??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z	; IronMan::Core::Math::FPlane::FPlane
PUBLIC	??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z	; IronMan::Core::Math::FPlane::FPlane
PUBLIC	??0FMatrix@Math@Core@IronMan@@QEAA@XZ		; IronMan::Core::Math::FMatrix::FMatrix
PUBLIC	??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z ; IronMan::Core::Math::FMatrix::FMatrix
PUBLIC	??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z ; IronMan::Core::Math::FMatrix::FMatrix
PUBLIC	?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ	; IronMan::Core::Math::FMatrix::Determinant
PUBLIC	?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FMatrix::Inverse
PUBLIC	?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z ; IronMan::Core::Math::FMatrix::RemoveScaling
PUBLIC	?SetAxis@FMatrix@Math@Core@IronMan@@QEAAXHAEBUFVector@234@@Z ; IronMan::Core::Math::FMatrix::SetAxis
PUBLIC	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
PUBLIC	?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ ; IronMan::Core::Math::FMatrix::GetOrigin
PUBLIC	?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ ; IronMan::Core::Math::FMatrix::Rotator
PUBLIC	??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FMatrix::operator*
PUBLIC	??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z ; IronMan::Core::Math::FMatrix::FMatrix
PUBLIC	??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z ; IronMan::Core::Math::FRotationTranslationMatrix::FRotationTranslationMatrix
PUBLIC	??0FTransform@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FTransform::FTransform
PUBLIC	??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z ; IronMan::Core::Math::FTransform::FTransform
PUBLIC	?GetRelativeTransform@FTransform@Math@Core@IronMan@@QEBA?AU1234@AEBU1234@@Z ; IronMan::Core::Math::FTransform::GetRelativeTransform
PUBLIC	?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z ; IronMan::Core::Math::FTransform::AnyHasNegativeScale
PUBLIC	?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ ; IronMan::Core::Math::FTransform::GetScale3D
PUBLIC	?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z ; IronMan::Core::Math::FTransform::ConstructTransformFromMatrixWithDesiredScale
PUBLIC	?GetRelativeTransformUsingMatrixWithScale@FTransform@Math@Core@IronMan@@CAXPEAU1234@PEBU1234@1@Z ; IronMan::Core::Math::FTransform::GetRelativeTransformUsingMatrixWithScale
PUBLIC	?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z ; IronMan::Core::Math::FTransform::GetSafeScaleReciprocal
PUBLIC	?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ ; IronMan::Core::Math::FTransform::ToMatrixWithScale
PUBLIC	?FindLookAtRotation@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@0@Z ; IronMan::Core::Math::FindLookAtRotation
PUBLIC	?MakeRotFromX@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z ; IronMan::Core::Math::MakeRotFromX
PUBLIC	?MakeRotFromY@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z ; IronMan::Core::Math::MakeRotFromY
PUBLIC	?MakeRotFromZ@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z ; IronMan::Core::Math::MakeRotFromZ
PUBLIC	?RInterpTo@Math@Core@IronMan@@YA?AUFRotator@123@AEBU4123@0MM@Z ; IronMan::Core::Math::RInterpTo
PUBLIC	?Vector2DInterpConstantTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z ; IronMan::Core::Math::Vector2DInterpConstantTo
PUBLIC	?Vector2DInterpTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z ; IronMan::Core::Math::Vector2DInterpTo
PUBLIC	?QuaternionToMatrix@Math@Core@IronMan@@YA?AVPxMat33@physx@@AEBUFQuat@123@@Z ; IronMan::Core::Math::QuaternionToMatrix
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB	; `IronMan::Core::Math::Atan2'::`2'::c
PUBLIC	?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B	; IronMan::Core::Math::FVector::ZeroVector
PUBLIC	?OneVector@FVector@Math@Core@IronMan@@2U1234@B	; IronMan::Core::Math::FVector::OneVector
PUBLIC	?Identity@FQuat@Math@Core@IronMan@@2U1234@B	; IronMan::Core::Math::FQuat::Identity
PUBLIC	?Identity@FMatrix@Math@Core@IronMan@@2U1234@B	; IronMan::Core::Math::FMatrix::Identity
PUBLIC	?Identity@FTransform@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FTransform::Identity
PUBLIC	?nxt@?9???0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@234@@Z@4QBHB ; `IronMan::Core::Math::FQuat::FQuat'::`10'::nxt
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	__real@00000000
PUBLIC	__real@322bcc77
PUBLIC	__real@3638b88e
PUBLIC	__real@37cfb4c2
PUBLIC	__real@38d1b717
PUBLIC	__real@39500bf1
PUBLIC	__real@3ab609aa
PUBLIC	__real@3bda90c5
PUBLIC	__real@3c088886
PUBLIC	__real@3c0efa35
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8bfc66
PUBLIC	__real@3c8efa35
PUBLIC	__real@3cfd10f8
PUBLIC	__real@3d2aaaa3
PUBLIC	__real@3d4d8392
PUBLIC	__real@3db63a9e
PUBLIC	__real@3e22f983
PUBLIC	__real@3e2aaaab
PUBLIC	__real@3e5bbfca
PUBLIC	__real@3effffef
PUBLIC	__real@3f000000
PUBLIC	__real@3f7ff972
PUBLIC	__real@3f800000
PUBLIC	__real@3fc90fda
PUBLIC	__real@3fc90fdb
PUBLIC	__real@40000000
PUBLIC	__real@40490fda
PUBLIC	__real@40c90fda
PUBLIC	__real@42652ee2
PUBLIC	__real@42b40000
PUBLIC	__real@43340000
PUBLIC	__real@43b40000
PUBLIC	__real@b2cd365b
PUBLIC	__real@b48bdd11
PUBLIC	__real@baa57a2c
PUBLIC	__real@beffffef
PUBLIC	__real@bf800000
PUBLIC	__real@bfc90fdb
PUBLIC	__real@c0000000
PUBLIC	__real@c0490fda
PUBLIC	__real@c2b40000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	atexit:PROC
EXTRN	memcpy:PROC
EXTRN	fabs:PROC
EXTRN	sqrtf:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
	ALIGN	8

?XYZMask@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?)	; IronMan::Core::Math::XYZMask
?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?) ; IronMan::Core::Math::QINV_SIGN_MASK
?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B DB 0cH DUP (?) ; IronMan::Core::Math::FVector::ZeroVector
?OneVector@FVector@Math@Core@IronMan@@2U1234@B DB 0cH DUP (?) ; IronMan::Core::Math::FVector::OneVector
?Identity@FQuat@Math@Core@IronMan@@2U1234@B DB 010H DUP (?) ; IronMan::Core::Math::FQuat::Identity
?Identity@FMatrix@Math@Core@IronMan@@2U1234@B DB 080H DUP (?) ; IronMan::Core::Math::FMatrix::Identity
?Identity@FTransform@Math@Core@IronMan@@2U1234@B DB 030H DUP (?) ; IronMan::Core::Math::FTransform::Identity
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fabsf DD	imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fabsf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sqrt@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?sqrt@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PxMat33@physx@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0PxMat33@physx@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PxMat33@physx@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$??0PxMat33@physx@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?ToVector3@_D3DMATRIX@Math@Core@IronMan@@QEAA?AUFVector@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?ToVector3@_D3DMATRIX@Math@Core@IronMan@@QEAA?AUFVector@234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ+40
	DD	imagerel $unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ+53
	DD	imagerel $unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?TruncToFloat@Math@Core@IronMan@@YAMM@Z DD imagerel ?TruncToFloat@Math@Core@IronMan@@YAMM@Z
	DD	imagerel ?TruncToFloat@Math@Core@IronMan@@YAMM@Z+30
	DD	imagerel $unwind$?TruncToFloat@Math@Core@IronMan@@YAMM@Z
$pdata$?InvSqrt@Math@Core@IronMan@@YAMM@Z DD imagerel ?InvSqrt@Math@Core@IronMan@@YAMM@Z
	DD	imagerel ?InvSqrt@Math@Core@IronMan@@YAMM@Z+444
	DD	imagerel $unwind$?InvSqrt@Math@Core@IronMan@@YAMM@Z
$pdata$?Sqrt@Math@Core@IronMan@@YAMM@Z DD imagerel ?Sqrt@Math@Core@IronMan@@YAMM@Z
	DD	imagerel ?Sqrt@Math@Core@IronMan@@YAMM@Z+26
	DD	imagerel $unwind$?Sqrt@Math@Core@IronMan@@YAMM@Z
$pdata$?FloatSelect@Math@Core@IronMan@@YAMMMM@Z DD imagerel ?FloatSelect@Math@Core@IronMan@@YAMMMM@Z
	DD	imagerel ?FloatSelect@Math@Core@IronMan@@YAMMMM@Z+71
	DD	imagerel $unwind$?FloatSelect@Math@Core@IronMan@@YAMMMM@Z
$pdata$??$Abs@M@Math@Core@IronMan@@YAMM@Z DD imagerel ??$Abs@M@Math@Core@IronMan@@YAMM@Z
	DD	imagerel ??$Abs@M@Math@Core@IronMan@@YAMM@Z+66
	DD	imagerel $unwind$??$Abs@M@Math@Core@IronMan@@YAMM@Z
$pdata$?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z DD imagerel ?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z
	DD	imagerel ?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z+472
	DD	imagerel $unwind$?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z DD imagerel $LN3
	DD	imagerel $LN3+5229
	DD	imagerel $unwind$?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z DD imagerel $LN3
	DD	imagerel $LN3+848
	DD	imagerel $unwind$?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+9480
	DD	imagerel $unwind$?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Atan2@Math@Core@IronMan@@YAMMM@Z DD imagerel $LN16
	DD	imagerel $LN16+695
	DD	imagerel $unwind$?Atan2@Math@Core@IronMan@@YAMMM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?Fmod@Math@Core@IronMan@@YAMMM@Z DD imagerel ?Fmod@Math@Core@IronMan@@YAMMM@Z
	DD	imagerel ?Fmod@Math@Core@IronMan@@YAMMM@Z+166
	DD	imagerel $unwind$?Fmod@Math@Core@IronMan@@YAMMM@Z
$pdata$?FastAsin@Math@Core@IronMan@@YAMM@Z DD imagerel ?FastAsin@Math@Core@IronMan@@YAMM@Z
	DD	imagerel ?FastAsin@Math@Core@IronMan@@YAMM@Z+317
	DD	imagerel $unwind$?FastAsin@Math@Core@IronMan@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+118
	DD	imagerel $unwind$??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+118
	DD	imagerel $unwind$??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+118
	DD	imagerel $unwind$??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+188
	DD	imagerel $unwind$??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z DD imagerel $LN6
	DD	imagerel $LN6+289
	DD	imagerel $unwind$?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ DD imagerel $LN3
	DD	imagerel $LN3+162
	DD	imagerel $unwind$?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+118
	DD	imagerel $unwind$??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+118
	DD	imagerel $unwind$??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Quaternion@FRotator@Math@Core@IronMan@@QEBA?AUFQuat@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+384
	DD	imagerel $unwind$?Quaternion@FRotator@Math@Core@IronMan@@QEBA?AUFQuat@234@XZ
$pdata$?MakeFromX@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z DD imagerel $LN5
	DD	imagerel $LN5+266
	DD	imagerel $unwind$?MakeFromX@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z
$pdata$?MakeFromY@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z DD imagerel $LN5
	DD	imagerel $LN5+266
	DD	imagerel $unwind$?MakeFromY@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z
$pdata$?MakeFromZ@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z DD imagerel $LN5
	DD	imagerel $LN5+266
	DD	imagerel $unwind$?MakeFromZ@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z DD imagerel $LN9
	DD	imagerel $LN9+1555
	DD	imagerel $unwind$??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?Rotator@FQuat@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ DD imagerel $LN7
	DD	imagerel $LN7+889
	DD	imagerel $unwind$?Rotator@FQuat@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+80
	DD	imagerel $unwind$?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z DD imagerel $LN5
	DD	imagerel $LN5+276
	DD	imagerel $unwind$?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z DD imagerel $LN3
	DD	imagerel $LN3+279
	DD	imagerel $unwind$?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FPlane@Math@Core@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??0FPlane@Math@Core@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FMatrix@Math@Core@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??0FMatrix@Math@Core@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z DD imagerel $LN3
	DD	imagerel $LN3+802
	DD	imagerel $unwind$??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z DD imagerel $LN3
	DD	imagerel $LN3+779
	DD	imagerel $unwind$??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+2530
	DD	imagerel $unwind$?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ DD imagerel $LN7
	DD	imagerel $LN7+341
	DD	imagerel $unwind$?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z DD imagerel $LN3
	DD	imagerel $LN3+1529
	DD	imagerel $unwind$?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z DD imagerel $LN9
	DD	imagerel $LN9+475
	DD	imagerel $unwind$?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+141
	DD	imagerel $unwind$?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+415
	DD	imagerel $unwind$?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+190
	DD	imagerel $unwind$??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z DD imagerel $LN3
	DD	imagerel $LN3+934
	DD	imagerel $unwind$??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FTransform@Math@Core@IronMan@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$??0FTransform@Math@Core@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?GetRelativeTransform@FTransform@Math@Core@IronMan@@QEBA?AU1234@AEBU1234@@Z DD imagerel $LN6
	DD	imagerel $LN6+545
	DD	imagerel $unwind$?GetRelativeTransform@FTransform@Math@Core@IronMan@@QEBA?AU1234@AEBU1234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z DD imagerel $LN3
	DD	imagerel $LN3+456
	DD	imagerel $unwind$?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?GetRelativeTransformUsingMatrixWithScale@FTransform@Math@Core@IronMan@@CAXPEAU1234@PEBU1234@1@Z DD imagerel $LN3
	DD	imagerel $LN3+188
	DD	imagerel $unwind$?GetRelativeTransformUsingMatrixWithScale@FTransform@Math@Core@IronMan@@CAXPEAU1234@PEBU1234@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z DD imagerel $LN9
	DD	imagerel $LN9+246
	DD	imagerel $unwind$?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+1151
	DD	imagerel $unwind$?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?FindLookAtRotation@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@0@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?FindLookAtRotation@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@0@Z
$pdata$?MakeRotFromX@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?MakeRotFromX@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z
$pdata$?MakeRotFromY@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?MakeRotFromY@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z
$pdata$?MakeRotFromZ@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?MakeRotFromZ@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z
$pdata$?RInterpTo@Math@Core@IronMan@@YA?AUFRotator@123@AEBU4123@0MM@Z DD imagerel $LN8
	DD	imagerel $LN8+392
	DD	imagerel $unwind$?RInterpTo@Math@Core@IronMan@@YA?AUFRotator@123@AEBU4123@0MM@Z
$pdata$?Vector2DInterpConstantTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z DD imagerel $LN6
	DD	imagerel $LN6+227
	DD	imagerel $unwind$?Vector2DInterpConstantTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z
$pdata$?Vector2DInterpTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z DD imagerel $LN5
	DD	imagerel $LN5+204
	DD	imagerel $unwind$?Vector2DInterpTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z
$pdata$?QuaternionToMatrix@Math@Core@IronMan@@YA?AVPxMat33@physx@@AEBUFQuat@123@@Z DD imagerel $LN3
	DD	imagerel $LN3+1081
	DD	imagerel $unwind$?QuaternionToMatrix@Math@Core@IronMan@@YA?AVPxMat33@physx@@AEBUFQuat@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ DD imagerel ??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ
	DD	imagerel ??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ+31
	DD	imagerel $unwind$??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ DD imagerel ??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ
	DD	imagerel ??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ+46
	DD	imagerel $unwind$??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ DD imagerel ??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ
	DD	imagerel ??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ+116
	DD	imagerel $unwind$??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ DD imagerel ??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ
	DD	imagerel ??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ+45
	DD	imagerel $unwind$??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ DD imagerel ??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ
	DD	imagerel ??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ+208
	DD	imagerel $unwind$??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z DD imagerel ??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z
	DD	imagerel ??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z+108
	DD	imagerel $unwind$??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c2b40000
CONST	SEGMENT
__real@c2b40000 DD 0c2b40000r			; -90
CONST	ENDS
;	COMDAT __real@c0490fda
CONST	SEGMENT
__real@c0490fda DD 0c0490fdar			; -3.14159
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bfc90fdb
CONST	SEGMENT
__real@bfc90fdb DD 0bfc90fdbr			; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@beffffef
CONST	SEGMENT
__real@beffffef DD 0beffffefr			; -0.499999
CONST	ENDS
;	COMDAT __real@baa57a2c
CONST	SEGMENT
__real@baa57a2c DD 0baa57a2cr			; -0.00126249
CONST	ENDS
;	COMDAT __real@b48bdd11
CONST	SEGMENT
__real@b48bdd11 DD 0b48bdd11r			; -2.60516e-07
CONST	ENDS
;	COMDAT __real@b2cd365b
CONST	SEGMENT
__real@b2cd365b DD 0b2cd365br			; -2.38899e-08
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42652ee2
CONST	SEGMENT
__real@42652ee2 DD 042652ee2r			; 57.2958
CONST	ENDS
;	COMDAT __real@40c90fda
CONST	SEGMENT
__real@40c90fda DD 040c90fdar			; 6.28319
CONST	ENDS
;	COMDAT __real@40490fda
CONST	SEGMENT
__real@40490fda DD 040490fdar			; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc90fda
CONST	SEGMENT
__real@3fc90fda DD 03fc90fdar			; 1.5708
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ff972
CONST	SEGMENT
__real@3f7ff972 DD 03f7ff972r			; 0.9999
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3effffef
CONST	SEGMENT
__real@3effffef DD 03effffefr			; 0.499999
CONST	ENDS
;	COMDAT __real@3e5bbfca
CONST	SEGMENT
__real@3e5bbfca DD 03e5bbfcar			; 0.214599
CONST	ENDS
;	COMDAT __real@3e2aaaab
CONST	SEGMENT
__real@3e2aaaab DD 03e2aaaabr			; 0.166667
CONST	ENDS
;	COMDAT __real@3e22f983
CONST	SEGMENT
__real@3e22f983 DD 03e22f983r			; 0.159155
CONST	ENDS
;	COMDAT __real@3db63a9e
CONST	SEGMENT
__real@3db63a9e DD 03db63a9er			; 0.088979
CONST	ENDS
;	COMDAT __real@3d4d8392
CONST	SEGMENT
__real@3d4d8392 DD 03d4d8392r			; 0.0501743
CONST	ENDS
;	COMDAT __real@3d2aaaa3
CONST	SEGMENT
__real@3d2aaaa3 DD 03d2aaaa3r			; 0.0416666
CONST	ENDS
;	COMDAT __real@3cfd10f8
CONST	SEGMENT
__real@3cfd10f8 DD 03cfd10f8r			; 0.0308919
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c8bfc66
CONST	SEGMENT
__real@3c8bfc66 DD 03c8bfc66r			; 0.0170881
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3c0efa35
CONST	SEGMENT
__real@3c0efa35 DD 03c0efa35r			; 0.00872665
CONST	ENDS
;	COMDAT __real@3c088886
CONST	SEGMENT
__real@3c088886 DD 03c088886r			; 0.00833333
CONST	ENDS
;	COMDAT __real@3bda90c5
CONST	SEGMENT
__real@3bda90c5 DD 03bda90c5r			; 0.00667009
CONST	ENDS
;	COMDAT __real@3ab609aa
CONST	SEGMENT
__real@3ab609aa DD 03ab609aar			; 0.00138884
CONST	ENDS
;	COMDAT __real@39500bf1
CONST	SEGMENT
__real@39500bf1 DD 039500bf1r			; 0.000198409
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@37cfb4c2
CONST	SEGMENT
__real@37cfb4c2 DD 037cfb4c2r			; 2.47605e-05
CONST	ENDS
;	COMDAT __real@3638b88e
CONST	SEGMENT
__real@3638b88e DD 03638b88er			; 2.75256e-06
CONST	ENDS
;	COMDAT __real@322bcc77
CONST	SEGMENT
__real@322bcc77 DD 0322bcc77r			; 1e-08
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?nxt@?9???0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@234@@Z@4QBHB
CONST	SEGMENT
?nxt@?9???0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@234@@Z@4QBHB DD 01H ; `IronMan::Core::Math::FQuat::FQuat'::`10'::nxt
	DD	02H
	DD	00H
CONST	ENDS
;	COMDAT ?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB
CONST	SEGMENT
?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB DD 03bec5a11r ; 0.00721289 ; `IronMan::Core::Math::Atan2'::`2'::c
	DD	0bd0f9abdr			; -0.0350597
	DD	03da745afr			; 0.0816759
	DD	0be08f4ddr			; -0.133747
	DD	03e4b54car			; 0.198566
	DD	0beaa9fber			; -0.33325
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ DD 020701H
	DD	0130107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ DD 021101H
	DD	01b0111H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z DD 031601H
	DD	070126216H
	DD	06011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z DD 041d01H
	DD	027011dH
	DD	060157016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ DD 020c01H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetRelativeTransform@FTransform@Math@Core@IronMan@@QEBA?AU1234@AEBU1234@@Z
	DD	022H
	DD	0207H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z DD 021601H
	DD	060157016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FTransform@Math@Core@IronMan@@QEAA@XZ DD 030b01H
	DD	07007820bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z DD 031001H
	DD	0700c8210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ DD 041301H
	DD	0230113H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z DD 010f01H
	DD	0a20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ DD 041301H
	DD	01f0113H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ DD 010601H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FMatrix@Math@Core@IronMan@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z DD 011b01H
	DD	0421bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z DD 020c01H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FPlane@Math@Core@IronMan@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z DD 041801H
	DD	0150118H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z DD 031101H
	DD	0700d6211H
	DD	0600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	05f9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ DD 031001H
	DD	0700c6210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z DD 010f01H
	DD	0620fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z DD 011401H
	DD	06214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z DD 011401H
	DD	06214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z DD 011401H
	DD	04214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z DD 010f01H
	DD	0620fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z DD 031601H
	DD	070126216H
	DD	06011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z DD 011401H
	DD	06214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Atan2@Math@Core@IronMan@@YAMMM@Z DD 011001H
	DD	0c210H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01bH
	DW	024f0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	020H
	DW	01458H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z DD 022519H
	DD	0110116H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD 011c01H
	DD	0221cH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	062H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD 012519H
	DD	06216H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
xdata	SEGMENT
$unwind$?ToVector3@_D3DMATRIX@Math@Core@IronMan@@QEAA?AUFVector@234@XZ DD 010e01H
	DD	0420eH
$unwind$?TruncToFloat@Math@Core@IronMan@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?InvSqrt@Math@Core@IronMan@@YAMM@Z DD 020d01H
	DD	02b010dH
$unwind$?Sqrt@Math@Core@IronMan@@YAMM@Z DD 010a01H
	DD	0420aH
$unwind$?FloatSelect@Math@Core@IronMan@@YAMMMM@Z DD 011601H
	DD	02216H
$unwind$??$Abs@M@Math@Core@IronMan@@YAMM@Z DD 010a01H
	DD	0220aH
$unwind$?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z DD 011401H
	DD	04214H
$unwind$?Fmod@Math@Core@IronMan@@YAMMM@Z DD 011001H
	DD	06210H
$unwind$?FastAsin@Math@Core@IronMan@@YAMM@Z DD 010a01H
	DD	0820aH
$unwind$?Quaternion@FRotator@Math@Core@IronMan@@QEBA?AUFQuat@234@XZ DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$?MakeFromX@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z DD 021101H
	DD	0150111H
$unwind$?MakeFromY@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z DD 021101H
	DD	0150111H
$unwind$?MakeFromZ@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z DD 021101H
	DD	0150111H
$unwind$?Rotator@FQuat@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ DD 031001H
	DD	0700cc210H
	DD	0600bH
$unwind$?GetRelativeTransform@FTransform@Math@Core@IronMan@@QEBA?AU1234@AEBU1234@@Z DD 042a19H
	DD	01f0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$?GetRelativeTransformUsingMatrixWithScale@FTransform@Math@Core@IronMan@@CAXPEAU1234@PEBU1234@1@Z DD 021601H
	DD	03b0116H
$unwind$?FindLookAtRotation@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@0@Z DD 011301H
	DD	06213H
$unwind$?MakeRotFromX@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z DD 021101H
	DD	0170111H
$unwind$?MakeRotFromY@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z DD 021101H
	DD	0170111H
$unwind$?MakeRotFromZ@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z DD 021101H
	DD	0170111H
$unwind$?RInterpTo@Math@Core@IronMan@@YA?AUFRotator@123@AEBU4123@0MM@Z DD 031b01H
	DD	07017e21bH
	DD	06016H
$unwind$?Vector2DInterpConstantTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z DD 011901H
	DD	08219H
$unwind$?Vector2DInterpTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z DD 011901H
	DD	06219H
$unwind$?QuaternionToMatrix@Math@Core@IronMan@@YA?AVPxMat33@physx@@AEBUFQuat@123@@Z DD 021101H
	DD	01f0111H
$unwind$??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z DD 011601H
	DD	02216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PxMat33@physx@@QEAA@AEBV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PxMat33@physx@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?sqrt@@YAMM@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?sqrt@@YAMM@Z DB 040H
	DD	imagerel $ip2state$?sqrt@@YAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sqrt@@YAMM@Z DD 010a19H
	DD	0420aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?sqrt@@YAMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fabsf DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?XYZMask$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EXYZMask@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::XYZMask$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?QINV_SIGN_MASK$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::QINV_SIGN_MASK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??ZeroVector$initializer$@FVector@Math@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ ; IronMan::Core::Math::FVector::eroVector$initializer$::operator-=
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??OneVector$initializer$@FVector@Math@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ ; IronMan::Core::Math::FVector::neVector$initializer$::operator>
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??Identity$initializer$@FTransform@Math@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ ; IronMan::Core::Math::FTransform::dentity$initializer$::operator&
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??Identity$initializer$@FQuat@Math@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ ; IronMan::Core::Math::FQuat::dentity$initializer$::operator&
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??Identity$initializer$@FMatrix@Math@Core@IronMan@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ ; IronMan::Core::Math::FMatrix::dentity$initializer$::operator&
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.h
_TEXT	SEGMENT
tv66 = 0
tv67 = 4
X$ = 32
Min$ = 40
Max$ = 48
??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z PROC		; IronMan::Core::Math::Clamp<float>

; 30   : 	{

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 31   : 		return X < Min ? Min : X < Max ? X : Max;

	movss	xmm0, DWORD PTR Min$[rsp]
	comiss	xmm0, DWORD PTR X$[rsp]
	jbe	SHORT $LN5@Clamp
	movss	xmm0, DWORD PTR Min$[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
	jmp	SHORT $LN6@Clamp
$LN5@Clamp:
	movss	xmm0, DWORD PTR Max$[rsp]
	comiss	xmm0, DWORD PTR X$[rsp]
	jbe	SHORT $LN3@Clamp
	movss	xmm0, DWORD PTR X$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@Clamp
$LN3@Clamp:
	movss	xmm0, DWORD PTR Max$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
$LN4@Clamp:
	movss	xmm0, DWORD PTR tv66[rsp]
	movss	DWORD PTR tv67[rsp], xmm0
$LN6@Clamp:
	movss	xmm0, DWORD PTR tv67[rsp]

; 32   : 	}

	add	rsp, 24
	ret	0
??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z ENDP		; IronMan::Core::Math::Clamp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
;	COMDAT ??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ
text$di	SEGMENT
tv133 = 48
tv131 = 56
tv129 = 64
tv95 = 72
$T1 = 80
$T2 = 96
$T3 = 112
$T4 = 128
??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::Math::FMatrix::Identity'', COMDAT

; 14   : 	const FMatrix FMatrix::Identity(FPlane(1, 0, 0, 0), FPlane(0, 1, 0, 0), FPlane(0, 0, 1, 0), FPlane(0, 0, 0, 1));

	sub	rsp, 152				; 00000098H
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z ; IronMan::Core::Math::FPlane::FPlane
	mov	QWORD PTR tv133[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z ; IronMan::Core::Math::FPlane::FPlane
	mov	QWORD PTR tv131[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z ; IronMan::Core::Math::FPlane::FPlane
	mov	QWORD PTR tv129[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z ; IronMan::Core::Math::FPlane::FPlane
	mov	QWORD PTR tv95[rsp], rax
	mov	rax, QWORD PTR tv133[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv131[rsp]
	mov	r8, QWORD PTR tv129[rsp]
	mov	rdx, QWORD PTR tv95[rsp]
	lea	rcx, OFFSET FLAT:?Identity@FMatrix@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FMatrix::Identity
	call	??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z ; IronMan::Core::Math::FMatrix::FMatrix
	npad	1
	add	rsp, 152				; 00000098H
	ret	0
??__E?Identity@FMatrix@Math@Core@IronMan@@2U1234@B@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::Math::FMatrix::Identity''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
;	COMDAT ??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ
text$di	SEGMENT
??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::Math::FQuat::Identity'', COMDAT

; 13   : 	const FQuat FQuat::Identity(0, 0, 0, 1);

	sub	rsp, 56					; 00000038H
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?Identity@FQuat@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FQuat::Identity
	call	??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z	; IronMan::Core::Math::FQuat::FQuat
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??__E?Identity@FQuat@Math@Core@IronMan@@2U1234@B@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::Math::FQuat::Identity''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
;	COMDAT ??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ
text$di	SEGMENT
tv86 = 48
tv84 = 56
tv82 = 64
$T1 = 72
$T2 = 84
$T3 = 96
??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::Math::FTransform::Identity'', COMDAT

; 12   : 	const FTransform FTransform::Identity(FQuat(0.f, 0.f, 0.f, 1.f), FVector(0.f), FVector(1.f));

	sub	rsp, 120				; 00000078H
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@M@Z	; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv86[rsp], rax
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@M@Z	; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv84[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z	; IronMan::Core::Math::FQuat::FQuat
	mov	QWORD PTR tv82[rsp], rax
	mov	r9, QWORD PTR tv86[rsp]
	mov	r8, QWORD PTR tv84[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	lea	rcx, OFFSET FLAT:?Identity@FTransform@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FTransform::Identity
	call	??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z ; IronMan::Core::Math::FTransform::FTransform
	npad	1
	add	rsp, 120				; 00000078H
	ret	0
??__E?Identity@FTransform@Math@Core@IronMan@@2U1234@B@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::Math::FTransform::Identity''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
;	COMDAT ??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ
text$di	SEGMENT
??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::Math::FVector::OneVector'', COMDAT

; 11   : 	const FVector FVector::OneVector(1.0f, 1.0f, 1.0f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, OFFSET FLAT:?OneVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::OneVector
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?OneVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::Math::FVector::OneVector''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
;	COMDAT ??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ
text$di	SEGMENT
??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ PROC ; `dynamic initializer for 'IronMan::Core::Math::FVector::ZeroVector'', COMDAT

; 10   : 	const FVector FVector::ZeroVector(0.0f, 0.0f, 0.0f);

	sub	rsp, 40					; 00000028H
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, OFFSET FLAT:?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::ZeroVector
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::Core::Math::FVector::ZeroVector''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
x$ = 32
y$ = 36
z$ = 40
w$ = 44
xy$ = 48
wz$ = 52
zz$ = 56
xz$ = 60
wy$ = 64
yz$ = 68
wx$ = 72
xx$ = 76
yy$ = 80
tv88 = 84
tv130 = 88
tv140 = 92
tv150 = 96
tv161 = 100
tv171 = 104
tv181 = 108
tv191 = 112
tv202 = 116
rotMat$ = 120
tv85 = 160
tv128 = 168
tv138 = 176
tv148 = 184
tv158 = 192
tv169 = 200
tv179 = 208
tv189 = 216
tv199 = 224
__$ReturnUdt$ = 256
q$ = 264
?QuaternionToMatrix@Math@Core@IronMan@@YA?AVPxMat33@physx@@AEBUFQuat@123@@Z PROC ; IronMan::Core::Math::QuaternionToMatrix

; 315  : 	PxMat33 QuaternionToMatrix(const FQuat& q) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 248				; 000000f8H

; 316  : 		// 
; 317  : 		float w = q.W;

	mov	rax, QWORD PTR q$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR w$[rsp], xmm0

; 318  : 		float x = q.X;

	mov	rax, QWORD PTR q$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR x$[rsp], xmm0

; 319  : 		float y = q.Y;

	mov	rax, QWORD PTR q$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR y$[rsp], xmm0

; 320  : 		float z = q.Z;

	mov	rax, QWORD PTR q$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR z$[rsp], xmm0

; 321  : 
; 322  : 		// 
; 323  : 		float xx = x * x;

	movss	xmm0, DWORD PTR x$[rsp]
	mulss	xmm0, DWORD PTR x$[rsp]
	movss	DWORD PTR xx$[rsp], xmm0

; 324  : 		float yy = y * y;

	movss	xmm0, DWORD PTR y$[rsp]
	mulss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR yy$[rsp], xmm0

; 325  : 		float zz = z * z;

	movss	xmm0, DWORD PTR z$[rsp]
	mulss	xmm0, DWORD PTR z$[rsp]
	movss	DWORD PTR zz$[rsp], xmm0

; 326  : 		float xy = x * y;

	movss	xmm0, DWORD PTR x$[rsp]
	mulss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR xy$[rsp], xmm0

; 327  : 		float xz = x * z;

	movss	xmm0, DWORD PTR x$[rsp]
	mulss	xmm0, DWORD PTR z$[rsp]
	movss	DWORD PTR xz$[rsp], xmm0

; 328  : 		float yz = y * z;

	movss	xmm0, DWORD PTR y$[rsp]
	mulss	xmm0, DWORD PTR z$[rsp]
	movss	DWORD PTR yz$[rsp], xmm0

; 329  : 		float wx = w * x;

	movss	xmm0, DWORD PTR w$[rsp]
	mulss	xmm0, DWORD PTR x$[rsp]
	movss	DWORD PTR wx$[rsp], xmm0

; 330  : 		float wy = w * y;

	movss	xmm0, DWORD PTR w$[rsp]
	mulss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR wy$[rsp], xmm0

; 331  : 		float wz = w * z;

	movss	xmm0, DWORD PTR w$[rsp]
	mulss	xmm0, DWORD PTR z$[rsp]
	movss	DWORD PTR wz$[rsp], xmm0

; 332  : 
; 333  : 		// 3x3
; 334  : 		PxMat33 rotMat;

	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??0PxMat33@physx@@QEAA@XZ		; physx::PxMat33::PxMat33

; 335  : 		rotMat[0][0] = 1 - 2 * (yy + zz);

	xor	edx, edx
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv85[rsp], rax
	movss	xmm0, DWORD PTR yy$[rsp]
	addss	xmm0, DWORD PTR zz$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv88[rsp], xmm0
	xor	edx, edx
	mov	rcx, QWORD PTR tv85[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv88[rsp]
	movss	DWORD PTR [rax], xmm0

; 336  : 		rotMat[0][1] = 2 * (xy - wz);

	xor	edx, edx
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv128[rsp], rax
	movss	xmm0, DWORD PTR xy$[rsp]
	subss	xmm0, DWORD PTR wz$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv130[rsp], xmm0
	mov	edx, 1
	mov	rcx, QWORD PTR tv128[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv130[rsp]
	movss	DWORD PTR [rax], xmm0

; 337  : 		rotMat[0][2] = 2 * (xz + wy);

	xor	edx, edx
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv138[rsp], rax
	movss	xmm0, DWORD PTR xz$[rsp]
	addss	xmm0, DWORD PTR wy$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv140[rsp], xmm0
	mov	edx, 2
	mov	rcx, QWORD PTR tv138[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv140[rsp]
	movss	DWORD PTR [rax], xmm0

; 338  : 
; 339  : 		rotMat[1][0] = 2 * (xy + wz);

	mov	edx, 1
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv148[rsp], rax
	movss	xmm0, DWORD PTR xy$[rsp]
	addss	xmm0, DWORD PTR wz$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv150[rsp], xmm0
	xor	edx, edx
	mov	rcx, QWORD PTR tv148[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv150[rsp]
	movss	DWORD PTR [rax], xmm0

; 340  : 		rotMat[1][1] = 1 - 2 * (xx + zz);

	mov	edx, 1
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv158[rsp], rax
	movss	xmm0, DWORD PTR xx$[rsp]
	addss	xmm0, DWORD PTR zz$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv161[rsp], xmm0
	mov	edx, 1
	mov	rcx, QWORD PTR tv158[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv161[rsp]
	movss	DWORD PTR [rax], xmm0

; 341  : 		rotMat[1][2] = 2 * (yz - wx);

	mov	edx, 1
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv169[rsp], rax
	movss	xmm0, DWORD PTR yz$[rsp]
	subss	xmm0, DWORD PTR wx$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv171[rsp], xmm0
	mov	edx, 2
	mov	rcx, QWORD PTR tv169[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv171[rsp]
	movss	DWORD PTR [rax], xmm0

; 342  : 
; 343  : 		rotMat[2][0] = 2 * (xz - wy);

	mov	edx, 2
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv179[rsp], rax
	movss	xmm0, DWORD PTR xz$[rsp]
	subss	xmm0, DWORD PTR wy$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv181[rsp], xmm0
	xor	edx, edx
	mov	rcx, QWORD PTR tv179[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv181[rsp]
	movss	DWORD PTR [rax], xmm0

; 344  : 		rotMat[2][1] = 2 * (yz + wx);

	mov	edx, 2
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv189[rsp], rax
	movss	xmm0, DWORD PTR yz$[rsp]
	addss	xmm0, DWORD PTR wx$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv191[rsp], xmm0
	mov	edx, 1
	mov	rcx, QWORD PTR tv189[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv191[rsp]
	movss	DWORD PTR [rax], xmm0

; 345  : 		rotMat[2][2] = 1 - 2 * (xx + yy);

	mov	edx, 2
	lea	rcx, QWORD PTR rotMat$[rsp]
	call	??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z	; physx::PxMat33::operator[]
	mov	QWORD PTR tv199[rsp], rax
	movss	xmm0, DWORD PTR xx$[rsp]
	addss	xmm0, DWORD PTR yy$[rsp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv202[rsp], xmm0
	mov	edx, 2
	mov	rcx, QWORD PTR tv199[rsp]
	call	??APxVec3@physx@@QEAAAEAMI@Z		; physx::PxVec3::operator[]
	movss	xmm0, DWORD PTR tv202[rsp]
	movss	DWORD PTR [rax], xmm0

; 346  : 
; 347  : 		return rotMat;

	lea	rdx, QWORD PTR rotMat$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0PxMat33@physx@@QEAA@AEBV01@@Z	; physx::PxMat33::PxMat33
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 348  : 	}

	add	rsp, 248				; 000000f8H
	ret	0
?QuaternionToMatrix@Math@Core@IronMan@@YA?AVPxMat33@physx@@AEBUFQuat@123@@Z ENDP ; IronMan::Core::Math::QuaternionToMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
Dist$ = 32
DeltaMove$ = 40
__$ReturnUdt$ = 64
Current$ = 72
Target$ = 80
DeltaTime$ = 88
InterpSpeed$ = 96
?Vector2DInterpTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z PROC ; IronMan::Core::Math::Vector2DInterpTo

; 299  : 	{

$LN5:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 300  : 		if (InterpSpeed <= 0.f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR InterpSpeed$[rsp]
	jb	SHORT $LN2@Vector2DIn

; 301  : 		{
; 302  : 			return Target;

	mov	rax, QWORD PTR Target$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Vector2DIn
$LN2@Vector2DIn:

; 303  : 		}
; 304  : 
; 305  : 		const FVector2D Dist = Target - Current;

	mov	r8, QWORD PTR Current$[rsp]
	lea	rdx, QWORD PTR Dist$[rsp]
	mov	rcx, QWORD PTR Target$[rsp]
	call	??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector2D::operator-
	npad	1

; 306  : 		if (Dist.SizeSquared() < KINDA_SMALL_NUMBER)

	lea	rcx, QWORD PTR Dist$[rsp]
	call	?SizeSquared@FVector2D@Math@Core@IronMan@@QEBAMXZ ; IronMan::Core::Math::FVector2D::SizeSquared
	movss	xmm1, DWORD PTR __real@38d1b717
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@Vector2DIn

; 307  : 		{
; 308  : 			return Target;

	mov	rax, QWORD PTR Target$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Vector2DIn
$LN3@Vector2DIn:

; 309  : 		}
; 310  : 
; 311  : 		const FVector2D DeltaMove = Dist * Clamp<float>(DeltaTime * InterpSpeed, 0.f, 1.f);

	movss	xmm0, DWORD PTR DeltaTime$[rsp]
	mulss	xmm0, DWORD PTR InterpSpeed$[rsp]
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	call	??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z	; IronMan::Core::Math::Clamp<float>
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR DeltaMove$[rsp]
	lea	rcx, QWORD PTR Dist$[rsp]
	call	??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector2D::operator*

; 312  : 		return Current + DeltaMove;

	lea	r8, QWORD PTR DeltaMove$[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR Current$[rsp]
	call	??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector2D::operator+
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Vector2DIn:

; 313  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?Vector2DInterpTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z ENDP ; IronMan::Core::Math::Vector2DInterpTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
MaxStep$ = 32
DeltaM$ = 36
Delta$ = 40
DeltaN$1 = 48
$T2 = 56
__$ReturnUdt$ = 80
Current$ = 88
Target$ = 96
DeltaTime$ = 104
InterpSpeed$ = 112
?Vector2DInterpConstantTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z PROC ; IronMan::Core::Math::Vector2DInterpConstantTo

; 277  : 	{

$LN6:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 278  : 		const FVector2D Delta = Target - Current;

	mov	r8, QWORD PTR Current$[rsp]
	lea	rdx, QWORD PTR Delta$[rsp]
	mov	rcx, QWORD PTR Target$[rsp]
	call	??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector2D::operator-

; 279  : 		const float DeltaM = Delta.Size();

	lea	rcx, QWORD PTR Delta$[rsp]
	call	?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ ; IronMan::Core::Math::FVector2D::Size
	movss	DWORD PTR DeltaM$[rsp], xmm0

; 280  : 		const float MaxStep = InterpSpeed * DeltaTime;

	movss	xmm0, DWORD PTR InterpSpeed$[rsp]
	mulss	xmm0, DWORD PTR DeltaTime$[rsp]
	movss	DWORD PTR MaxStep$[rsp], xmm0

; 281  : 
; 282  : 		if (DeltaM > MaxStep)

	movss	xmm0, DWORD PTR DeltaM$[rsp]
	comiss	xmm0, DWORD PTR MaxStep$[rsp]
	jbe	SHORT $LN2@Vector2DIn

; 283  : 		{
; 284  : 			if (MaxStep > 0.f)

	movss	xmm0, DWORD PTR MaxStep$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Vector2DIn

; 285  : 			{
; 286  : 				const FVector2D DeltaN = Delta / DeltaM;

	movss	xmm2, DWORD PTR DeltaM$[rsp]
	lea	rdx, QWORD PTR DeltaN$1[rsp]
	lea	rcx, QWORD PTR Delta$[rsp]
	call	??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector2D::operator/
	npad	1

; 287  : 				return Current + DeltaN * MaxStep;

	movss	xmm2, DWORD PTR MaxStep$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR DeltaN$1[rsp]
	call	??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector2D::operator*
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR Current$[rsp]
	call	??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector2D::operator+
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Vector2DIn

; 288  : 			}

	jmp	SHORT $LN4@Vector2DIn
$LN3@Vector2DIn:

; 289  : 			else
; 290  : 			{
; 291  : 				return Current;

	mov	rax, QWORD PTR Current$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Vector2DIn
$LN4@Vector2DIn:
$LN2@Vector2DIn:

; 292  : 			}
; 293  : 		}
; 294  : 
; 295  : 		return Target;

	mov	rax, QWORD PTR Target$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Vector2DIn:

; 296  : 	}

	add	rsp, 72					; 00000048H
	ret	0
?Vector2DInterpConstantTo@Math@Core@IronMan@@YA?AUFVector2D@123@AEBU4123@0MM@Z ENDP ; IronMan::Core::Math::Vector2DInterpConstantTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
DeltaInterpSpeed$ = 32
tv82 = 40
tv135 = 48
Delta$ = 56
DeltaMove$ = 72
$T1 = 88
$T2 = 100
__$ReturnUdt$ = 144
Current$ = 152
Target$ = 160
DeltaTime$ = 168
InterpSpeed$ = 176
?RInterpTo@Math@Core@IronMan@@YA?AUFRotator@123@AEBU4123@0MM@Z PROC ; IronMan::Core::Math::RInterpTo

; 248  : 	{

$LN8:
	movss	DWORD PTR [rsp+32], xmm3
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H

; 249  : 		// if DeltaTime is 0, do not perform any interpolation (Location was already calculated for that frame)
; 250  : 		if (DeltaTime == 0.f || Current == Target)

	movss	xmm0, DWORD PTR DeltaTime$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN7@RInterpTo
	je	SHORT $LN3@RInterpTo
$LN7@RInterpTo:
	mov	rdx, QWORD PTR Target$[rsp]
	mov	rcx, QWORD PTR Current$[rsp]
	call	??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z ; IronMan::Core::Math::FRotator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@RInterpTo
$LN3@RInterpTo:

; 251  : 		{
; 252  : 			return Current;

	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR Current$[rsp]
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@RInterpTo
$LN2@RInterpTo:

; 253  : 		}
; 254  : 
; 255  : 		// If no interp speed, jump to target value
; 256  : 		if (InterpSpeed <= 0.f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR InterpSpeed$[rsp]
	jb	SHORT $LN4@RInterpTo

; 257  : 		{
; 258  : 			return Target;

	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR Target$[rsp]
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@RInterpTo
$LN4@RInterpTo:

; 259  : 		}
; 260  : 
; 261  : 		const float DeltaInterpSpeed = InterpSpeed * DeltaTime;

	movss	xmm0, DWORD PTR InterpSpeed$[rsp]
	mulss	xmm0, DWORD PTR DeltaTime$[rsp]
	movss	DWORD PTR DeltaInterpSpeed$[rsp], xmm0

; 262  : 
; 263  : 		const FRotator Delta = (Target - Current).GetNormalized();

	mov	r8, QWORD PTR Current$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR Target$[rsp]
	call	??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FRotator::operator-
	mov	QWORD PTR tv82[rsp], rax
	lea	rdx, QWORD PTR Delta$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FRotator::GetNormalized
	npad	1

; 264  : 
; 265  : 		// If steps are too small, just return Target and assume we have reached our destination.
; 266  : 		if (Delta.IsNearlyZero())

	movss	xmm1, DWORD PTR __real@38d1b717
	lea	rcx, QWORD PTR Delta$[rsp]
	call	?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FRotator::IsNearlyZero
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@RInterpTo

; 267  : 		{
; 268  : 			return Target;

	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR Target$[rsp]
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@RInterpTo
$LN5@RInterpTo:

; 269  : 		}
; 270  : 
; 271  : 		// Delta Move, Clamp so we do not over shoot.
; 272  : 		const FRotator DeltaMove = Delta * Math::Clamp<float>(DeltaInterpSpeed, 0.f, 1.f);

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR DeltaInterpSpeed$[rsp]
	call	??$Clamp@M@Math@Core@IronMan@@YAMMMM@Z	; IronMan::Core::Math::Clamp<float>
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR DeltaMove$[rsp]
	lea	rcx, QWORD PTR Delta$[rsp]
	call	??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FRotator::operator*
	npad	1

; 273  : 		return (Current + DeltaMove).GetNormalized();

	lea	r8, QWORD PTR DeltaMove$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR Current$[rsp]
	call	??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FRotator::operator+
	mov	QWORD PTR tv135[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FRotator::GetNormalized
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@RInterpTo:

; 274  : 	}

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?RInterpTo@Math@Core@IronMan@@YA?AUFRotator@123@AEBU4123@0MM@Z ENDP ; IronMan::Core::Math::RInterpTo
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv71 = 32
$T1 = 48
__$ReturnUdt$ = 192
Z$ = 200
?MakeRotFromZ@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z PROC ; IronMan::Core::Math::MakeRotFromZ

; 244  : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 245  : 		return FRotator::MakeFromZ(Z).Rotator();

	mov	rdx, QWORD PTR Z$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?MakeFromZ@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ; IronMan::Core::Math::FRotator::MakeFromZ
	mov	QWORD PTR tv71[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ ; IronMan::Core::Math::FMatrix::Rotator
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 246  : 	}

	add	rsp, 184				; 000000b8H
	ret	0
?MakeRotFromZ@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z ENDP ; IronMan::Core::Math::MakeRotFromZ
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv71 = 32
$T1 = 48
__$ReturnUdt$ = 192
Y$ = 200
?MakeRotFromY@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z PROC ; IronMan::Core::Math::MakeRotFromY

; 239  : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 240  : 		return FRotator::MakeFromY(Y).Rotator();

	mov	rdx, QWORD PTR Y$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?MakeFromY@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ; IronMan::Core::Math::FRotator::MakeFromY
	mov	QWORD PTR tv71[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ ; IronMan::Core::Math::FMatrix::Rotator
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 241  : 	}

	add	rsp, 184				; 000000b8H
	ret	0
?MakeRotFromY@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z ENDP ; IronMan::Core::Math::MakeRotFromY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv71 = 32
$T1 = 48
__$ReturnUdt$ = 192
X$ = 200
?MakeRotFromX@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z PROC ; IronMan::Core::Math::MakeRotFromX

; 234  : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 235  : 		return FRotator::MakeFromX(X).Rotator();

	mov	rdx, QWORD PTR X$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?MakeFromX@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ; IronMan::Core::Math::FRotator::MakeFromX
	mov	QWORD PTR tv71[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv71[rsp]
	call	?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ ; IronMan::Core::Math::FMatrix::Rotator
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 236  : 	}

	add	rsp, 184				; 000000b8H
	ret	0
?MakeRotFromX@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z ENDP ; IronMan::Core::Math::MakeRotFromX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
Start$ = 72
Target$ = 80
?FindLookAtRotation@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@0@Z PROC ; IronMan::Core::Math::FindLookAtRotation

; 229  : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 230  : 		return MakeRotFromX(Target - Start);

	mov	r8, QWORD PTR Start$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR Target$[rsp]
	call	??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator-
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	?MakeRotFromX@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@@Z ; IronMan::Core::Math::MakeRotFromX
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 231  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?FindLookAtRotation@Math@Core@IronMan@@YA?AUFRotator@123@AEBUFVector@123@0@Z ENDP ; IronMan::Core::Math::FindLookAtRotation
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ
_TEXT	SEGMENT
z2$ = 32
y2$ = 36
zz2$1 = 40
xx2$2 = 44
yy2$3 = 48
x2$ = 52
yz2$4 = 56
wx2$5 = 60
xy2$6 = 64
wz2$7 = 68
xz2$8 = 72
wy2$9 = 76
OutMatrix$ = 80
this$ = 224
__$ReturnUdt$ = 232
?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ PROC ; IronMan::Core::Math::FTransform::ToMatrixWithScale, COMDAT

; 2207 : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 2208 : 			FMatrix OutMatrix;

	lea	rcx, QWORD PTR OutMatrix$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FMatrix::FMatrix

; 2209 : 			OutMatrix.M[3][0] = Translation.X;

	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rdx+16]
	movss	DWORD PTR [rax+rcx], xmm0

; 2210 : 			OutMatrix.M[3][1] = Translation.Y;

	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rdx+20]
	movss	DWORD PTR [rax+rcx], xmm0

; 2211 : 			OutMatrix.M[3][2] = Translation.Z;

	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rdx+24]
	movss	DWORD PTR [rax+rcx], xmm0

; 2212 : 
; 2213 : 			const float x2 = Rotation.X + Rotation.X;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	addss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR x2$[rsp], xmm0

; 2214 : 			const float y2 = Rotation.Y + Rotation.Y;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR y2$[rsp], xmm0

; 2215 : 			const float z2 = Rotation.Z + Rotation.Z;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx+8]
	movss	DWORD PTR z2$[rsp], xmm0

; 2216 : 			{
; 2217 : 				const float xx2 = Rotation.X * x2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR x2$[rsp]
	movss	DWORD PTR xx2$2[rsp], xmm0

; 2218 : 				const float yy2 = Rotation.Y * y2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR y2$[rsp]
	movss	DWORD PTR yy2$3[rsp], xmm0

; 2219 : 				const float zz2 = Rotation.Z * z2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR z2$[rsp]
	movss	DWORD PTR zz2$1[rsp], xmm0

; 2220 : 
; 2221 : 				OutMatrix.M[0][0] = (1.0f - (yy2 + zz2)) * Scale3D.X;

	movss	xmm0, DWORD PTR yy2$3[rsp]
	addss	xmm0, DWORD PTR zz2$1[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+32]
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 2222 : 				OutMatrix.M[1][1] = (1.0f - (xx2 + zz2)) * Scale3D.Y;

	movss	xmm0, DWORD PTR xx2$2[rsp]
	addss	xmm0, DWORD PTR zz2$1[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 2223 : 				OutMatrix.M[2][2] = (1.0f - (xx2 + yy2)) * Scale3D.Z;

	movss	xmm0, DWORD PTR xx2$2[rsp]
	addss	xmm0, DWORD PTR yy2$3[rsp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+40]
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 2224 : 			}
; 2225 : 			{
; 2226 : 				const float yz2 = Rotation.Y * z2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR z2$[rsp]
	movss	DWORD PTR yz2$4[rsp], xmm0

; 2227 : 				const float wx2 = Rotation.W * x2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR x2$[rsp]
	movss	DWORD PTR wx2$5[rsp], xmm0

; 2228 : 
; 2229 : 				OutMatrix.M[2][1] = (yz2 - wx2) * Scale3D.Z;

	movss	xmm0, DWORD PTR yz2$4[rsp]
	subss	xmm0, DWORD PTR wx2$5[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+40]
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 2230 : 				OutMatrix.M[1][2] = (yz2 + wx2) * Scale3D.Y;

	movss	xmm0, DWORD PTR yz2$4[rsp]
	addss	xmm0, DWORD PTR wx2$5[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 2231 : 			}
; 2232 : 			{
; 2233 : 				const float xy2 = Rotation.X * y2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR y2$[rsp]
	movss	DWORD PTR xy2$6[rsp], xmm0

; 2234 : 				const float wz2 = Rotation.W * z2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR z2$[rsp]
	movss	DWORD PTR wz2$7[rsp], xmm0

; 2235 : 
; 2236 : 				OutMatrix.M[1][0] = (xy2 - wz2) * Scale3D.Y;

	movss	xmm0, DWORD PTR xy2$6[rsp]
	subss	xmm0, DWORD PTR wz2$7[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+36]
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 2237 : 				OutMatrix.M[0][1] = (xy2 + wz2) * Scale3D.X;

	movss	xmm0, DWORD PTR xy2$6[rsp]
	addss	xmm0, DWORD PTR wz2$7[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+32]
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 2238 : 			}
; 2239 : 			{
; 2240 : 				const float xz2 = Rotation.X * z2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR z2$[rsp]
	movss	DWORD PTR xz2$8[rsp], xmm0

; 2241 : 				const float wy2 = Rotation.W * y2;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR y2$[rsp]
	movss	DWORD PTR wy2$9[rsp], xmm0

; 2242 : 
; 2243 : 				OutMatrix.M[2][0] = (xz2 + wy2) * Scale3D.Z;

	movss	xmm0, DWORD PTR xz2$8[rsp]
	addss	xmm0, DWORD PTR wy2$9[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+40]
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 2244 : 				OutMatrix.M[0][2] = (xz2 - wy2) * Scale3D.X;

	movss	xmm0, DWORD PTR xz2$8[rsp]
	subss	xmm0, DWORD PTR wy2$9[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mulss	xmm0, DWORD PTR [rax+32]
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 2245 : 			}
; 2246 : 
; 2247 : 			OutMatrix.M[0][3] = 0.0f;

	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 2248 : 			OutMatrix.M[1][3] = 0.0f;

	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 2249 : 			OutMatrix.M[2][3] = 0.0f;

	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 2250 : 			OutMatrix.M[3][3] = 1.0f;

	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR OutMatrix$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+rcx], xmm0

; 2251 : 
; 2252 : 			return OutMatrix;

	lea	rdx, QWORD PTR OutMatrix$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2253 : 		}

	add	rsp, 216				; 000000d8H
	ret	0
?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ ENDP ; IronMan::Core::Math::FTransform::ToMatrixWithScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z
_TEXT	SEGMENT
SafeReciprocalScale$ = 32
__$ReturnUdt$ = 80
InScale$ = 88
Tolerance$ = 96
?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z PROC ; IronMan::Core::Math::FTransform::GetSafeScaleReciprocal, COMDAT

; 2369 : 	{

$LN9:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 2370 : 		FVector SafeReciprocalScale;

	lea	rcx, QWORD PTR SafeReciprocalScale$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FVector::FVector
	npad	1

; 2371 : 		if (Math::Abs(InScale.X) <= Tolerance)

	mov	rax, QWORD PTR InScale$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN2@GetSafeSca

; 2372 : 		{
; 2373 : 			SafeReciprocalScale.X = 0.f;

	xorps	xmm0, xmm0
	movss	DWORD PTR SafeReciprocalScale$[rsp], xmm0

; 2374 : 		}

	jmp	SHORT $LN3@GetSafeSca
$LN2@GetSafeSca:

; 2375 : 		else
; 2376 : 		{
; 2377 : 			SafeReciprocalScale.X = 1 / InScale.X;

	mov	rax, QWORD PTR InScale$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR SafeReciprocalScale$[rsp], xmm0
$LN3@GetSafeSca:

; 2378 : 		}
; 2379 : 
; 2380 : 		if (Math::Abs(InScale.Y) <= Tolerance)

	mov	rax, QWORD PTR InScale$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN4@GetSafeSca

; 2381 : 		{
; 2382 : 			SafeReciprocalScale.Y = 0.f;

	xorps	xmm0, xmm0
	movss	DWORD PTR SafeReciprocalScale$[rsp+4], xmm0

; 2383 : 		}

	jmp	SHORT $LN5@GetSafeSca
$LN4@GetSafeSca:

; 2384 : 		else
; 2385 : 		{
; 2386 : 			SafeReciprocalScale.Y = 1 / InScale.Y;

	mov	rax, QWORD PTR InScale$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [rax+4]
	movss	DWORD PTR SafeReciprocalScale$[rsp+4], xmm0
$LN5@GetSafeSca:

; 2387 : 		}
; 2388 : 
; 2389 : 		if (Math::Abs(InScale.Z) <= Tolerance)

	mov	rax, QWORD PTR InScale$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN6@GetSafeSca

; 2390 : 		{
; 2391 : 			SafeReciprocalScale.Z = 0.f;

	xorps	xmm0, xmm0
	movss	DWORD PTR SafeReciprocalScale$[rsp+8], xmm0

; 2392 : 		}

	jmp	SHORT $LN7@GetSafeSca
$LN6@GetSafeSca:

; 2393 : 		else
; 2394 : 		{
; 2395 : 			SafeReciprocalScale.Z = 1 / InScale.Z;

	mov	rax, QWORD PTR InScale$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [rax+8]
	movss	DWORD PTR SafeReciprocalScale$[rsp+8], xmm0
$LN7@GetSafeSca:

; 2396 : 		}
; 2397 : 
; 2398 : 		return SafeReciprocalScale;

	lea	rax, QWORD PTR SafeReciprocalScale$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2399 : 	}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z ENDP ; IronMan::Core::Math::FTransform::GetSafeScaleReciprocal
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv78 = 32
SafeRecipScale3D$ = 40
DesiredScale3D$ = 56
BM$ = 80
AM$ = 208
$T1 = 336
OutTransform$ = 480
Base$ = 488
Relative$ = 496
?GetRelativeTransformUsingMatrixWithScale@FTransform@Math@Core@IronMan@@CAXPEAU1234@PEBU1234@1@Z PROC ; IronMan::Core::Math::FTransform::GetRelativeTransformUsingMatrixWithScale

; 217  : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H

; 218  : 		// the goal of using M is to get the correct orientation
; 219  : 	// but for translation, we still need scale
; 220  : 		FMatrix AM = Base->ToMatrixWithScale();

	lea	rdx, QWORD PTR AM$[rsp]
	mov	rcx, QWORD PTR Base$[rsp]
	call	?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ ; IronMan::Core::Math::FTransform::ToMatrixWithScale

; 221  : 		FMatrix BM = Relative->ToMatrixWithScale();

	lea	rdx, QWORD PTR BM$[rsp]
	mov	rcx, QWORD PTR Relative$[rsp]
	call	?ToMatrixWithScale@FTransform@Math@Core@IronMan@@QEBA?AUFMatrix@234@XZ ; IronMan::Core::Math::FTransform::ToMatrixWithScale

; 222  : 		// get combined scale
; 223  : 		FVector SafeRecipScale3D = GetSafeScaleReciprocal(Relative->Scale3D, SMALL_NUMBER);

	mov	rax, QWORD PTR Relative$[rsp]
	add	rax, 32					; 00000020H
	movss	xmm2, DWORD PTR __real@322bcc77
	mov	rdx, rax
	lea	rcx, QWORD PTR SafeRecipScale3D$[rsp]
	call	?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z ; IronMan::Core::Math::FTransform::GetSafeScaleReciprocal

; 224  : 		FVector DesiredScale3D = Base->Scale3D * SafeRecipScale3D;

	mov	rax, QWORD PTR Base$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv78[rsp], rax
	lea	r8, QWORD PTR SafeRecipScale3D$[rsp]
	lea	rdx, QWORD PTR DesiredScale3D$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator*
	npad	1

; 225  : 		ConstructTransformFromMatrixWithDesiredScale(AM, BM.Inverse(), DesiredScale3D, *OutTransform);

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR BM$[rsp]
	call	?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FMatrix::Inverse
	mov	r9, QWORD PTR OutTransform$[rsp]
	lea	r8, QWORD PTR DesiredScale3D$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR AM$[rsp]
	call	?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z ; IronMan::Core::Math::FTransform::ConstructTransformFromMatrixWithDesiredScale
	npad	1

; 226  : 	}

	add	rsp, 472				; 000001d8H
	ret	0
?GetRelativeTransformUsingMatrixWithScale@FTransform@Math@Core@IronMan@@CAXPEAU1234@PEBU1234@1@Z ENDP ; IronMan::Core::Math::FTransform::GetRelativeTransformUsingMatrixWithScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z
_TEXT	SEGMENT
SignedScale$ = 32
tv81 = 48
tv94 = 56
tv139 = 64
Rotation$ = 72
$T1 = 88
$T2 = 100
$T3 = 112
$T4 = 124
$T5 = 136
$T6 = 148
$T7 = 160
M$ = 176
AMatrix$ = 336
BMatrix$ = 344
DesiredScale$ = 352
OutTransform$ = 360
?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z PROC ; IronMan::Core::Math::FTransform::ConstructTransformFromMatrixWithDesiredScale, COMDAT

; 2335 : 	{

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 312				; 00000138H

; 2336 : 		// the goal of using M is to get the correct orientation
; 2337 : 		// but for translation, we still need scale
; 2338 : 		FMatrix M = AMatrix * BMatrix;

	mov	r8, QWORD PTR BMatrix$[rsp]
	lea	rdx, QWORD PTR M$[rsp]
	mov	rcx, QWORD PTR AMatrix$[rsp]
	call	??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FMatrix::operator*

; 2339 : 		M.RemoveScaling();

	movss	xmm1, DWORD PTR __real@322bcc77
	lea	rcx, QWORD PTR M$[rsp]
	call	?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z ; IronMan::Core::Math::FMatrix::RemoveScaling

; 2340 : 
; 2341 : 		// apply negative scale back to axes
; 2342 : 		FVector SignedScale = DesiredScale.GetSignVector();

	lea	rdx, QWORD PTR SignedScale$[rsp]
	mov	rcx, QWORD PTR DesiredScale$[rsp]
	call	?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FVector::GetSignVector
	npad	1

; 2343 : 
; 2344 : 		M.SetAxis(0, M.GetScaledAxis(EAxis::X) * SignedScale.X);

	mov	r8d, 1
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR M$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv81[rsp], rax
	movss	xmm2, DWORD PTR SignedScale$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector::operator*
	mov	r8, rax
	xor	edx, edx
	lea	rcx, QWORD PTR M$[rsp]
	call	?SetAxis@FMatrix@Math@Core@IronMan@@QEAAXHAEBUFVector@234@@Z ; IronMan::Core::Math::FMatrix::SetAxis
	npad	1

; 2345 : 		M.SetAxis(1, M.GetScaledAxis(EAxis::Y) * SignedScale.Y);

	mov	r8d, 2
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR M$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv94[rsp], rax
	movss	xmm2, DWORD PTR SignedScale$[rsp+4]
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR tv94[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector::operator*
	mov	r8, rax
	mov	edx, 1
	lea	rcx, QWORD PTR M$[rsp]
	call	?SetAxis@FMatrix@Math@Core@IronMan@@QEAAXHAEBUFVector@234@@Z ; IronMan::Core::Math::FMatrix::SetAxis
	npad	1

; 2346 : 		M.SetAxis(2, M.GetScaledAxis(EAxis::Z) * SignedScale.Z);

	mov	r8d, 3
	lea	rdx, QWORD PTR $T5[rsp]
	lea	rcx, QWORD PTR M$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv139[rsp], rax
	movss	xmm2, DWORD PTR SignedScale$[rsp+8]
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR tv139[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector::operator*
	mov	r8, rax
	mov	edx, 2
	lea	rcx, QWORD PTR M$[rsp]
	call	?SetAxis@FMatrix@Math@Core@IronMan@@QEAAXHAEBUFVector@234@@Z ; IronMan::Core::Math::FMatrix::SetAxis
	npad	1

; 2347 : 
; 2348 : 		// @note: if you have negative with 0 scale, this will return rotation that is identity
; 2349 : 		// since matrix loses that axes
; 2350 : 		FQuat Rotation = FQuat(M);

	lea	rdx, QWORD PTR M$[rsp]
	lea	rcx, QWORD PTR Rotation$[rsp]
	call	??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z ; IronMan::Core::Math::FQuat::FQuat

; 2351 : 		Rotation.Normalize();

	movss	xmm1, DWORD PTR __real@322bcc77
	lea	rcx, QWORD PTR Rotation$[rsp]
	call	?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z ; IronMan::Core::Math::FQuat::Normalize

; 2352 : 
; 2353 : 		// set values back to output
; 2354 : 		OutTransform.Scale3D = DesiredScale;

	mov	rax, QWORD PTR OutTransform$[rsp]
	lea	rdi, QWORD PTR [rax+32]
	mov	rsi, QWORD PTR DesiredScale$[rsp]
	mov	ecx, 12
	rep movsb

; 2355 : 		OutTransform.Rotation = Rotation;

	lea	rax, QWORD PTR Rotation$[rsp]
	mov	rdi, QWORD PTR OutTransform$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 2356 : 
; 2357 : 		// technically I could calculate this using FTransform but then it does more quat multiplication 
; 2358 : 		// instead of using Scale in matrix multiplication
; 2359 : 		// it's a question of between RemoveScaling vs using FTransform to move translation
; 2360 : 		OutTransform.Translation = M.GetOrigin();

	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR M$[rsp]
	call	?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ ; IronMan::Core::Math::FMatrix::GetOrigin
	mov	rcx, QWORD PTR OutTransform$[rsp]
	lea	rdi, QWORD PTR [rcx+16]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb

; 2361 : 	}

	add	rsp, 312				; 00000138H
	pop	rdi
	pop	rsi
	ret	0
?ConstructTransformFromMatrixWithDesiredScale@FTransform@Math@Core@IronMan@@CAXAEBUFMatrix@234@0AEBUFVector@234@AEAU1234@@Z ENDP ; IronMan::Core::Math::FTransform::ConstructTransformFromMatrixWithDesiredScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ
_TEXT	SEGMENT
this$ = 24
__$ReturnUdt$ = 32
?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ PROC ; IronMan::Core::Math::FTransform::GetScale3D, COMDAT

; 2135 : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi

; 2136 : 			//DiagnosticCheckNaN_Scale3D();
; 2137 : 			return Scale3D;

	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	lea	rsi, QWORD PTR [rax+32]
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2138 : 		}

	pop	rdi
	pop	rsi
	ret	0
?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ ENDP ; IronMan::Core::Math::FTransform::GetScale3D
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z
_TEXT	SEGMENT
tv76 = 0
InScale3D$ = 32
InOtherScale3D$ = 40
?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z PROC ; IronMan::Core::Math::FTransform::AnyHasNegativeScale, COMDAT

; 2274 : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2275 : 		return  (InScale3D.X < 0.f || InScale3D.Y < 0.f || InScale3D.Z < 0.f

	mov	rax, QWORD PTR InScale3D$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax]
	ja	SHORT $LN3@AnyHasNega
	mov	rax, QWORD PTR InScale3D$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+4]
	ja	SHORT $LN3@AnyHasNega
	mov	rax, QWORD PTR InScale3D$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+8]
	ja	SHORT $LN3@AnyHasNega
	mov	rax, QWORD PTR InOtherScale3D$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax]
	ja	SHORT $LN3@AnyHasNega
	mov	rax, QWORD PTR InOtherScale3D$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+4]
	ja	SHORT $LN3@AnyHasNega
	mov	rax, QWORD PTR InOtherScale3D$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [rax+8]
	ja	SHORT $LN3@AnyHasNega
	mov	DWORD PTR tv76[rsp], 0
	jmp	SHORT $LN4@AnyHasNega
$LN3@AnyHasNega:
	mov	DWORD PTR tv76[rsp], 1
$LN4@AnyHasNega:
	movzx	eax, BYTE PTR tv76[rsp]

; 2276 : 			|| InOtherScale3D.X < 0.f || InOtherScale3D.Y < 0.f || InOtherScale3D.Z < 0.f);
; 2277 : 	}

	add	rsp, 24
	ret	0
?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z ENDP ; IronMan::Core::Math::FTransform::AnyHasNegativeScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv87 = 32
tv131 = 40
tv146 = 48
tv154 = 56
SafeRecipScale3D$1 = 64
Inverse$2 = 80
$T3 = 96
$T4 = 108
$T5 = 120
$T6 = 132
$T7 = 144
$T8 = 156
Result$ = 176
__$ArrayPad$ = 224
this$ = 272
__$ReturnUdt$ = 280
Other$ = 288
?GetRelativeTransform@FTransform@Math@Core@IronMan@@QEBA?AU1234@AEBU1234@@Z PROC ; IronMan::Core::Math::FTransform::GetRelativeTransform

; 176  : 	{

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 248				; 000000f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 177  : 		// A * B(-1) = VQS(B)(-1) (VQS (A))
; 178  : 		// 
; 179  : 		// Scale = S(A)/S(B)
; 180  : 		// Rotation = Q(B)(-1) * Q(A)
; 181  : 		// Translation = 1/S(B) *[Q(B)(-1)*(T(A)-T(B))*Q(B)]
; 182  : 		// where A = this, B = Other
; 183  : 		FTransform Result;

	lea	rcx, QWORD PTR Result$[rsp]
	call	??0FTransform@Math@Core@IronMan@@QEAA@XZ ; IronMan::Core::Math::FTransform::FTransform
	npad	1

; 184  : 
; 185  : 		if (AnyHasNegativeScale(Scale3D, Other.GetScale3D()))

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR Other$[rsp]
	call	?GetScale3D@FTransform@Math@Core@IronMan@@QEBA?AUFVector@234@XZ ; IronMan::Core::Math::FTransform::GetScale3D
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 32					; 00000020H
	mov	rdx, rax
	call	?AnyHasNegativeScale@FTransform@Math@Core@IronMan@@SA_NAEBUFVector@234@0@Z ; IronMan::Core::Math::FTransform::AnyHasNegativeScale
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetRelativ

; 186  : 		{
; 187  : 			// @note, if you have 0 scale with negative, you're going to lose rotation as it can't convert back to quat
; 188  : 			GetRelativeTransformUsingMatrixWithScale(&Result, this, &Other);

	mov	r8, QWORD PTR Other$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR Result$[rsp]
	call	?GetRelativeTransformUsingMatrixWithScale@FTransform@Math@Core@IronMan@@CAXPEAU1234@PEBU1234@1@Z ; IronMan::Core::Math::FTransform::GetRelativeTransformUsingMatrixWithScale
	npad	1

; 189  : 		}

	jmp	$LN3@GetRelativ
$LN2@GetRelativ:

; 190  : 		else
; 191  : 		{
; 192  : 			FVector SafeRecipScale3D = GetSafeScaleReciprocal(Other.Scale3D, SMALL_NUMBER);

	mov	rax, QWORD PTR Other$[rsp]
	add	rax, 32					; 00000020H
	movss	xmm2, DWORD PTR __real@322bcc77
	mov	rdx, rax
	lea	rcx, QWORD PTR SafeRecipScale3D$1[rsp]
	call	?GetSafeScaleReciprocal@FTransform@Math@Core@IronMan@@CA?AUFVector@234@AEBU5234@M@Z ; IronMan::Core::Math::FTransform::GetSafeScaleReciprocal
	npad	1

; 193  : 			Result.Scale3D = Scale3D * SafeRecipScale3D;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv87[rsp], rax
	lea	r8, QWORD PTR SafeRecipScale3D$1[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator*
	lea	rcx, QWORD PTR Result$[rsp+32]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 12
	rep movsb

; 194  : 
; 195  : 			if (Other.Rotation.IsNormalized() == false)

	mov	rax, QWORD PTR Other$[rsp]
	mov	rcx, rax
	call	?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ ; IronMan::Core::Math::FQuat::IsNormalized
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@GetRelativ

; 196  : 			{
; 197  : 				return FTransform::Identity;

	lea	rax, OFFSET FLAT:?Identity@FTransform@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FTransform::Identity
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 48					; 00000030H
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetRelativ
$LN4@GetRelativ:

; 198  : 			}
; 199  : 
; 200  : 			FQuat Inverse = Other.Rotation.Inverse();

	mov	rax, QWORD PTR Other$[rsp]
	mov	QWORD PTR tv131[rsp], rax
	lea	rdx, QWORD PTR Inverse$2[rsp]
	mov	rcx, QWORD PTR tv131[rsp]
	call	?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ ; IronMan::Core::Math::FQuat::Inverse
	npad	1

; 201  : 			Result.Rotation = Inverse * Rotation;

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR Inverse$2[rsp]
	call	??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FQuat::operator*
	lea	rcx, QWORD PTR Result$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 202  : 
; 203  : 			Result.Translation = (Inverse * (Translation - Other.Translation)) * (SafeRecipScale3D);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv146[rsp], rax
	mov	rax, QWORD PTR Other$[rsp]
	add	rax, 16
	mov	r8, rax
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, QWORD PTR tv146[rsp]
	call	??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator-
	mov	r8, rax
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR Inverse$2[rsp]
	call	??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z ; IronMan::Core::Math::FQuat::operator*
	mov	QWORD PTR tv154[rsp], rax
	lea	r8, QWORD PTR SafeRecipScale3D$1[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR tv154[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator*
	lea	rcx, QWORD PTR Result$[rsp+16]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
$LN3@GetRelativ:

; 204  : 
; 205  : #if DEBUG_INVERSE_TRANSFORM
; 206  : 			FMatrix AM = ToMatrixWithScale();
; 207  : 			FMatrix BM = Other.ToMatrixWithScale();
; 208  : 
; 209  : 			Result.DebugEqualMatrix(AM * BM.InverseFast());
; 210  : 
; 211  : #endif
; 212  : 		}
; 213  : 
; 214  : 		return Result;

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 48					; 00000030H
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetRelativ:

; 215  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 248				; 000000f8H
	pop	rdi
	pop	rsi
	ret	0
?GetRelativeTransform@FTransform@Math@Core@IronMan@@QEBA?AU1234@AEBU1234@@Z ENDP ; IronMan::Core::Math::FTransform::GetRelativeTransform
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z
_TEXT	SEGMENT
this$ = 24
InRotation$ = 32
InTranslation$ = 40
InScale3D$ = 48
??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z PROC ; IronMan::Core::Math::FTransform::FTransform, COMDAT

; 2086 : 		{

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi

; 2083 : 			: Rotation(InRotation),

	mov	rdi, QWORD PTR this$[rsp]
	mov	rsi, QWORD PTR InRotation$[rsp]
	mov	ecx, 16
	rep movsb

; 2084 : 			Translation(InTranslation),

	mov	rax, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rax+16]
	mov	rsi, QWORD PTR InTranslation$[rsp]
	mov	ecx, 12
	rep movsb

; 2085 : 			Scale3D(InScale3D)

	mov	rax, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rax+32]
	mov	rsi, QWORD PTR InScale3D$[rsp]
	mov	ecx, 12
	rep movsb

; 2087 : 		}

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	pop	rsi
	ret	0
??0FTransform@Math@Core@IronMan@@QEAA@AEBUFQuat@123@AEBUFVector@123@1@Z ENDP ; IronMan::Core::Math::FTransform::FTransform
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FTransform@Math@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 48
tv77 = 56
this$ = 96
??0FTransform@Math@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::Math::FTransform::FTransform, COMDAT

; 2072 : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 2069 : 			: Rotation(0.f, 0.f, 0.f, 1.f)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv72[rsp], rax
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR tv72[rsp]
	call	??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z	; IronMan::Core::Math::FQuat::FQuat

; 2070 : 			, Translation(0.f)

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	QWORD PTR tv77[rsp], rax
	xorps	xmm1, xmm1
	mov	rcx, QWORD PTR tv77[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@M@Z	; IronMan::Core::Math::FVector::FVector

; 2071 : 			, Scale3D(FVector::OneVector)

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:?OneVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::OneVector
	lea	rdi, QWORD PTR [rax+32]
	mov	rsi, rcx
	mov	ecx, 12
	rep movsb

; 2073 : 		}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
??0FTransform@Math@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::Math::FTransform::FTransform
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
A$ = 8
??$Square@M@Math@Core@IronMan@@YAMM@Z PROC		; IronMan::Core::Math::Square<float>

; 288  : 	{

	movss	DWORD PTR [rsp+8], xmm0

; 289  : 		return A * A;

	movss	xmm0, DWORD PTR A$[rsp]
	mulss	xmm0, DWORD PTR A$[rsp]

; 290  : 	}

	ret	0
??$Square@M@Math@Core@IronMan@@YAMM@Z ENDP		; IronMan::Core::Math::Square<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
;	COMDAT ??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z
_TEXT	SEGMENT
CY$ = 32
SR$ = 36
SP$ = 40
SY$ = 44
CR$ = 48
CP$ = 52
this$ = 80
Rot$ = 88
Origin$ = 96
??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z PROC ; IronMan::Core::Math::FRotationTranslationMatrix::FRotationTranslationMatrix, COMDAT

; 22   : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FMatrix::FMatrix

; 23   : #ifdef PLATFORM_ENABLE_VECTORINTRINSICS
; 24   : 
; 25   : 		const VectorRegister Angles = MakeVectorRegister(Rot.Pitch, Rot.Yaw, Rot.Roll, 0.0f);
; 26   : 		const VectorRegister HalfAngles = VectorMultiply(Angles, GlobalVectorConstants::DEG_TO_RAD);
; 27   : 
; 28   : 		union { VectorRegister v; float f[4]; } SinAngles, CosAngles;
; 29   : 		VectorSinCos(&SinAngles.v, &CosAngles.v, &HalfAngles);
; 30   : 
; 31   : 		const float	SP = SinAngles.f[0];
; 32   : 		const float	SY = SinAngles.f[1];
; 33   : 		const float	SR = SinAngles.f[2];
; 34   : 		const float	CP = CosAngles.f[0];
; 35   : 		const float	CY = CosAngles.f[1];
; 36   : 		const float	CR = CosAngles.f[2];
; 37   : 
; 38   : #else
; 39   : 
; 40   : 		float SP, SY, SR;
; 41   : 		float CP, CY, CR;
; 42   : 		Math::SinCos(&SP, &CP, Math::DegreesToRadians(Rot.Pitch));

	mov	rax, QWORD PTR Rot$[rsp]
	mov	rcx, rax
	call	??$DegreesToRadians@M@Math@Core@IronMan@@YAMAEBM@Z ; IronMan::Core::Math::DegreesToRadians<float>
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR CP$[rsp]
	lea	rcx, QWORD PTR SP$[rsp]
	call	?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z	; IronMan::Core::Math::SinCos

; 43   : 		Math::SinCos(&SY, &CY, Math::DegreesToRadians(Rot.Yaw));

	mov	rax, QWORD PTR Rot$[rsp]
	add	rax, 4
	mov	rcx, rax
	call	??$DegreesToRadians@M@Math@Core@IronMan@@YAMAEBM@Z ; IronMan::Core::Math::DegreesToRadians<float>
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR CY$[rsp]
	lea	rcx, QWORD PTR SY$[rsp]
	call	?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z	; IronMan::Core::Math::SinCos

; 44   : 		Math::SinCos(&SR, &CR, Math::DegreesToRadians(Rot.Roll));

	mov	rax, QWORD PTR Rot$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$DegreesToRadians@M@Math@Core@IronMan@@YAMAEBM@Z ; IronMan::Core::Math::DegreesToRadians<float>
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR CR$[rsp]
	lea	rcx, QWORD PTR SR$[rsp]
	call	?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z	; IronMan::Core::Math::SinCos

; 45   : 
; 46   : #endif // PLATFORM_ENABLE_VECTORINTRINSICS
; 47   : 
; 48   : 		M[0][0] = CP * CY;

	movss	xmm0, DWORD PTR CP$[rsp]
	mulss	xmm0, DWORD PTR CY$[rsp]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 49   : 		M[0][1] = CP * SY;

	movss	xmm0, DWORD PTR CP$[rsp]
	mulss	xmm0, DWORD PTR SY$[rsp]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 50   : 		M[0][2] = SP;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	xmm0, DWORD PTR SP$[rsp]
	movss	DWORD PTR [rax+rcx], xmm0

; 51   : 		M[0][3] = 0.f;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 52   : 
; 53   : 		M[1][0] = SR * SP * CY - CR * SY;

	movss	xmm0, DWORD PTR SR$[rsp]
	mulss	xmm0, DWORD PTR SP$[rsp]
	mulss	xmm0, DWORD PTR CY$[rsp]
	movss	xmm1, DWORD PTR CR$[rsp]
	mulss	xmm1, DWORD PTR SY$[rsp]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 54   : 		M[1][1] = SR * SP * SY + CR * CY;

	movss	xmm0, DWORD PTR SR$[rsp]
	mulss	xmm0, DWORD PTR SP$[rsp]
	mulss	xmm0, DWORD PTR SY$[rsp]
	movss	xmm1, DWORD PTR CR$[rsp]
	mulss	xmm1, DWORD PTR CY$[rsp]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 55   : 		M[1][2] = -SR * CP;

	movss	xmm0, DWORD PTR SR$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR CP$[rsp]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 56   : 		M[1][3] = 0.f;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 57   : 
; 58   : 		M[2][0] = -(CR * SP * CY + SR * SY);

	movss	xmm0, DWORD PTR CR$[rsp]
	mulss	xmm0, DWORD PTR SP$[rsp]
	mulss	xmm0, DWORD PTR CY$[rsp]
	movss	xmm1, DWORD PTR SR$[rsp]
	mulss	xmm1, DWORD PTR SY$[rsp]
	addss	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 59   : 		M[2][1] = CY * SR - CR * SP * SY;

	movss	xmm0, DWORD PTR CY$[rsp]
	mulss	xmm0, DWORD PTR SR$[rsp]
	movss	xmm1, DWORD PTR CR$[rsp]
	mulss	xmm1, DWORD PTR SP$[rsp]
	mulss	xmm1, DWORD PTR SY$[rsp]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 60   : 		M[2][2] = CR * CP;

	movss	xmm0, DWORD PTR CR$[rsp]
	mulss	xmm0, DWORD PTR CP$[rsp]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 61   : 		M[2][3] = 0.f;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 62   : 
; 63   : 		M[3][0] = Origin.X;

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR Origin$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0

; 64   : 		M[3][1] = Origin.Y;

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR Origin$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0

; 65   : 		M[3][2] = Origin.Z;

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR Origin$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0

; 66   : 		M[3][3] = 1.f;

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+rcx], xmm0

; 67   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z ENDP ; IronMan::Core::Math::FRotationTranslationMatrix::FRotationTranslationMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
tv90 = 48
tv128 = 56
this$ = 96
__that$ = 104
??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z PROC	; IronMan::Core::Math::FMatrix::FMatrix, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H
	mov	rdi, QWORD PTR this$[rsp]
	mov	rsi, QWORD PTR __that$[rsp]
	mov	ecx, 64					; 00000040H
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv78[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z ; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 80					; 00000050H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z ; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 96					; 00000060H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv90[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z ; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 112				; 00000070H
	mov	QWORD PTR tv128[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 112				; 00000070H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv128[rsp]
	call	??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z ; IronMan::Core::Math::FPlane::FPlane
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z ENDP	; IronMan::Core::Math::FMatrix::FMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
Result$ = 32
this$ = 176
__$ReturnUdt$ = 184
Other$ = 192
??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FMatrix::operator*, COMDAT

; 2055 : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 2056 : 		FMatrix Result;

	lea	rcx, QWORD PTR Result$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FMatrix::FMatrix

; 2057 : 		VectorMatrixMultiply(&Result, this, &Other);

	mov	r8, QWORD PTR Other$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR Result$[rsp]
	call	?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z ; IronMan::Core::Math::VectorMatrixMultiply

; 2058 : 		return Result;

	lea	rdx, QWORD PTR Result$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2059 : 	}

	add	rsp, 168				; 000000a8H
	ret	0
??DFMatrix@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FMatrix::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ
_TEXT	SEGMENT
tv86 = 32
tv130 = 36
tv128 = 40
tv155 = 44
tv153 = 48
XAxis$ = 56
Rotator$ = 72
tv143 = 88
SYAxis$ = 96
YAxis$ = 112
ZAxis$ = 128
$T1 = 144
this$ = 304
__$ReturnUdt$ = 312
?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ PROC ; IronMan::Core::Math::FMatrix::Rotator, COMDAT

; 2037 : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 280				; 00000118H

; 2038 : 		const FVector		XAxis = GetScaledAxis(EAxis::X);

	mov	r8d, 1
	lea	rdx, QWORD PTR XAxis$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis

; 2039 : 		const FVector		YAxis = GetScaledAxis(EAxis::Y);

	mov	r8d, 2
	lea	rdx, QWORD PTR YAxis$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis

; 2040 : 		const FVector		ZAxis = GetScaledAxis(EAxis::Z);

	mov	r8d, 3
	lea	rdx, QWORD PTR ZAxis$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis

; 2041 : 
; 2042 : 		FRotator	Rotator = FRotator(

	movss	xmm1, DWORD PTR XAxis$[rsp]
	movss	xmm0, DWORD PTR XAxis$[rsp+4]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	mulss	xmm0, DWORD PTR __real@43340000
	divss	xmm0, DWORD PTR __real@40490fda
	movss	DWORD PTR tv130[rsp], xmm0
	movss	xmm0, DWORD PTR XAxis$[rsp+4]
	call	??$Square@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Square<float>
	movss	DWORD PTR tv86[rsp], xmm0
	movss	xmm0, DWORD PTR XAxis$[rsp]
	call	??$Square@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Square<float>
	movss	xmm1, DWORD PTR tv86[rsp]
	addss	xmm0, xmm1
	call	?Sqrt@Math@Core@IronMan@@YAMM@Z		; IronMan::Core::Math::Sqrt
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR XAxis$[rsp+8]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	mulss	xmm0, DWORD PTR __real@43340000
	divss	xmm0, DWORD PTR __real@40490fda
	movss	DWORD PTR tv128[rsp], xmm0
	xorps	xmm3, xmm3
	movss	xmm2, DWORD PTR tv130[rsp]
	movss	xmm1, DWORD PTR tv128[rsp]
	lea	rcx, QWORD PTR Rotator$[rsp]
	call	??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FRotator::FRotator
	npad	1

; 2043 : 			Math::Atan2(XAxis.Z, Math::Sqrt(Math::Square(XAxis.X) + Math::Square(XAxis.Y))) * 180.f / PI,
; 2044 : 			Math::Atan2(XAxis.Y, XAxis.X) * 180.f / PI,
; 2045 : 			0
; 2046 : 		);
; 2047 : 
; 2048 : 		const FVector		SYAxis = FRotationTranslationMatrix(Rotator, FVector::ZeroVector).GetScaledAxis(EAxis::Y);

	lea	r8, OFFSET FLAT:?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::ZeroVector
	lea	rdx, QWORD PTR Rotator$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0FRotationTranslationMatrix@Math@Core@IronMan@@QEAA@AEBUFRotator@123@AEBUFVector@123@@Z ; IronMan::Core::Math::FRotationTranslationMatrix::FRotationTranslationMatrix
	mov	QWORD PTR tv143[rsp], rax
	mov	r8d, 2
	lea	rdx, QWORD PTR SYAxis$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	npad	1

; 2049 : 		Rotator.Roll = Math::Atan2(ZAxis | SYAxis, YAxis | SYAxis) * 180.f / PI;

	lea	rdx, QWORD PTR SYAxis$[rsp]
	lea	rcx, QWORD PTR YAxis$[rsp]
	call	??UFVector@Math@Core@IronMan@@QEBAMAEBU0123@@Z ; IronMan::Core::Math::FVector::operator|
	movss	DWORD PTR tv155[rsp], xmm0
	lea	rdx, QWORD PTR SYAxis$[rsp]
	lea	rcx, QWORD PTR ZAxis$[rsp]
	call	??UFVector@Math@Core@IronMan@@QEBAMAEBU0123@@Z ; IronMan::Core::Math::FVector::operator|
	movss	DWORD PTR tv153[rsp], xmm0
	movss	xmm1, DWORD PTR tv155[rsp]
	movss	xmm0, DWORD PTR tv153[rsp]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	mulss	xmm0, DWORD PTR __real@43340000
	divss	xmm0, DWORD PTR __real@40490fda
	movss	DWORD PTR Rotator$[rsp+8], xmm0

; 2050 : 		return Rotator;

	lea	rax, QWORD PTR Rotator$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2051 : 	}

	add	rsp, 280				; 00000118H
	pop	rdi
	pop	rsi
	ret	0
?Rotator@FMatrix@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ ENDP ; IronMan::Core::Math::FMatrix::Rotator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ PROC ; IronMan::Core::Math::FMatrix::GetOrigin, COMDAT

; 2032 : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2033 : 		return FVector(M[3][0], M[3][1], M[3][2]);

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR this$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 0
	movss	xmm3, DWORD PTR [rax+rcx]
	movss	xmm2, DWORD PTR [rdx+r8]
	movss	xmm1, DWORD PTR [r9+r10]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2034 : 	}

	add	rsp, 40					; 00000028H
	ret	0
?GetOrigin@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@XZ ENDP ; IronMan::Core::Math::FMatrix::GetOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z
_TEXT	SEGMENT
tv64 = 32
this$ = 80
__$ReturnUdt$ = 88
InAxis$ = 96
?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z PROC ; IronMan::Core::Math::FMatrix::GetScaledAxis, COMDAT

; 1955 : 	{

$LN9:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 1956 : 		switch (InAxis)

	mov	eax, DWORD PTR InAxis$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 1
	je	SHORT $LN4@GetScaledA
	cmp	DWORD PTR tv64[rsp], 2
	je	$LN5@GetScaledA
	cmp	DWORD PTR tv64[rsp], 3
	je	$LN6@GetScaledA
	jmp	$LN7@GetScaledA
$LN4@GetScaledA:

; 1957 : 		{
; 1958 : 		case EAxis::X:
; 1959 : 			return FVector(M[0][0], M[0][1], M[0][2]);

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 0
	mov	r10, QWORD PTR this$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 0
	movss	xmm3, DWORD PTR [rax+rcx]
	movss	xmm2, DWORD PTR [rdx+r8]
	movss	xmm1, DWORD PTR [r9+r10]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetScaledA
$LN5@GetScaledA:

; 1960 : 
; 1961 : 		case EAxis::Y:
; 1962 : 			return FVector(M[1][0], M[1][1], M[1][2]);

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR this$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 0
	movss	xmm3, DWORD PTR [rax+rcx]
	movss	xmm2, DWORD PTR [rdx+r8]
	movss	xmm1, DWORD PTR [r9+r10]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetScaledA
$LN6@GetScaledA:

; 1963 : 
; 1964 : 		case EAxis::Z:
; 1965 : 			return FVector(M[2][0], M[2][1], M[2][2]);

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR this$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 0
	movss	xmm3, DWORD PTR [rax+rcx]
	movss	xmm2, DWORD PTR [rdx+r8]
	movss	xmm1, DWORD PTR [r9+r10]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetScaledA
$LN7@GetScaledA:

; 1966 : 
; 1967 : 		default:
; 1968 : 			//ensure(0);
; 1969 : 			return FVector::ZeroVector;

	lea	rax, OFFSET FLAT:?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::ZeroVector
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetScaledA:

; 1970 : 		}
; 1971 : 	}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ENDP ; IronMan::Core::Math::FMatrix::GetScaledAxis
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?SetAxis@FMatrix@Math@Core@IronMan@@QEAAXHAEBUFVector@234@@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
Axis$ = 24
?SetAxis@FMatrix@Math@Core@IronMan@@QEAAXHAEBUFVector@234@@Z PROC ; IronMan::Core::Math::FMatrix::SetAxis, COMDAT

; 1947 : 	{

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 1948 : 		//checkSlow(i >= 0 && i <= 2);
; 1949 : 		M[i][0] = Axis.X;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR Axis$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0

; 1950 : 		M[i][1] = Axis.Y;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR Axis$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0

; 1951 : 		M[i][2] = Axis.Z;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR Axis$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0

; 1952 : 	}

	ret	0
?SetAxis@FMatrix@Math@Core@IronMan@@QEAAXHAEBUFVector@234@@Z ENDP ; IronMan::Core::Math::FMatrix::SetAxis
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z
_TEXT	SEGMENT
Scale0$ = 32
Scale1$ = 36
Scale2$ = 40
SquareSum0$ = 44
SquareSum1$ = 48
SquareSum2$ = 52
tv206 = 56
tv213 = 60
tv220 = 64
this$ = 96
Tolerance$ = 104
?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z PROC	; IronMan::Core::Math::FMatrix::RemoveScaling, COMDAT

; 1927 : 	{

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1928 : 		// For each row, find magnitude, and if its non-zero re-scale so its unit length.
; 1929 : 		const float SquareSum0 = (M[0][0] * M[0][0]) + (M[0][1] * M[0][1]) + (M[0][2] * M[0][2]);

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	movss	DWORD PTR SquareSum0$[rsp], xmm0

; 1930 : 		const float SquareSum1 = (M[1][0] * M[1][0]) + (M[1][1] * M[1][1]) + (M[1][2] * M[1][2]);

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	movss	DWORD PTR SquareSum1$[rsp], xmm0

; 1931 : 		const float SquareSum2 = (M[2][0] * M[2][0]) + (M[2][1] * M[2][1]) + (M[2][2] * M[2][2]);

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	movss	DWORD PTR SquareSum2$[rsp], xmm0

; 1932 : 		const float Scale0 = Math::FloatSelect(SquareSum0 - Tolerance, Math::InvSqrt(SquareSum0), 1.0f);

	movss	xmm0, DWORD PTR SquareSum0$[rsp]
	call	?InvSqrt@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::InvSqrt
	movss	xmm1, DWORD PTR SquareSum0$[rsp]
	subss	xmm1, DWORD PTR Tolerance$[rsp]
	movss	DWORD PTR tv206[rsp], xmm1
	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv206[rsp]
	call	?FloatSelect@Math@Core@IronMan@@YAMMMM@Z ; IronMan::Core::Math::FloatSelect
	movss	DWORD PTR Scale0$[rsp], xmm0

; 1933 : 		const float Scale1 = Math::FloatSelect(SquareSum1 - Tolerance, Math::InvSqrt(SquareSum1), 1.0f);

	movss	xmm0, DWORD PTR SquareSum1$[rsp]
	call	?InvSqrt@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::InvSqrt
	movss	xmm1, DWORD PTR SquareSum1$[rsp]
	subss	xmm1, DWORD PTR Tolerance$[rsp]
	movss	DWORD PTR tv213[rsp], xmm1
	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv213[rsp]
	call	?FloatSelect@Math@Core@IronMan@@YAMMMM@Z ; IronMan::Core::Math::FloatSelect
	movss	DWORD PTR Scale1$[rsp], xmm0

; 1934 : 		const float Scale2 = Math::FloatSelect(SquareSum2 - Tolerance, Math::InvSqrt(SquareSum2), 1.0f);

	movss	xmm0, DWORD PTR SquareSum2$[rsp]
	call	?InvSqrt@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::InvSqrt
	movss	xmm1, DWORD PTR SquareSum2$[rsp]
	subss	xmm1, DWORD PTR Tolerance$[rsp]
	movss	DWORD PTR tv220[rsp], xmm1
	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR tv220[rsp]
	call	?FloatSelect@Math@Core@IronMan@@YAMMMM@Z ; IronMan::Core::Math::FloatSelect
	movss	DWORD PTR Scale2$[rsp], xmm0

; 1935 : 		M[0][0] *= Scale0;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale0$[rsp]
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1936 : 		M[0][1] *= Scale0;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale0$[rsp]
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1937 : 		M[0][2] *= Scale0;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale0$[rsp]
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1938 : 		M[1][0] *= Scale1;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale1$[rsp]
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1939 : 		M[1][1] *= Scale1;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale1$[rsp]
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1940 : 		M[1][2] *= Scale1;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale1$[rsp]
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 16
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1941 : 		M[2][0] *= Scale2;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale2$[rsp]
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1942 : 		M[2][1] *= Scale2;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale2$[rsp]
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1943 : 		M[2][2] *= Scale2;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Scale2$[rsp]
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 16
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movss	DWORD PTR [rcx+rax], xmm0

; 1944 : 	}

	add	rsp, 88					; 00000058H
	ret	0
?RemoveScaling@FMatrix@Math@Core@IronMan@@QEAAXM@Z ENDP	; IronMan::Core::Math::FMatrix::RemoveScaling
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ
_TEXT	SEGMENT
Det$1 = 32
tv73 = 40
tv84 = 48
tv95 = 56
$T2 = 64
$T3 = 76
$T4 = 88
Result$ = 112
this$ = 272
__$ReturnUdt$ = 280
?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ PROC	; IronMan::Core::Math::FMatrix::Inverse, COMDAT

; 1975 : 	{

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 248				; 000000f8H

; 1976 : 		FMatrix Result;

	lea	rcx, QWORD PTR Result$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FMatrix::FMatrix
	npad	1

; 1977 : 
; 1978 : 		// Check for zero scale matrix to invert
; 1979 : 		if (GetScaledAxis(EAxis::X).IsNearlyZero(SMALL_NUMBER) &&
; 1980 : 			GetScaledAxis(EAxis::Y).IsNearlyZero(SMALL_NUMBER) &&

	mov	r8d, 1
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv73[rsp], rax
	movss	xmm1, DWORD PTR __real@322bcc77
	mov	rcx, QWORD PTR tv73[rsp]
	call	?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FVector::IsNearlyZero
	movzx	eax, al
	test	eax, eax
	je	$LN2@Inverse
	mov	r8d, 2
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv84[rsp], rax
	movss	xmm1, DWORD PTR __real@322bcc77
	mov	rcx, QWORD PTR tv84[rsp]
	call	?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FVector::IsNearlyZero
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Inverse
	mov	r8d, 3
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv95[rsp], rax
	movss	xmm1, DWORD PTR __real@322bcc77
	mov	rcx, QWORD PTR tv95[rsp]
	call	?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FVector::IsNearlyZero
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Inverse

; 1981 : 			GetScaledAxis(EAxis::Z).IsNearlyZero(SMALL_NUMBER))
; 1982 : 		{
; 1983 : 			// just set to zero - avoids unsafe inverse of zero and duplicates what QNANs were resulting in before (scaling away all children)
; 1984 : 			Result = FMatrix::Identity;

	lea	rax, QWORD PTR Result$[rsp]
	lea	rcx, OFFSET FLAT:?Identity@FMatrix@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FMatrix::Identity
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 128				; 00000080H
	rep movsb

; 1985 : 		}

	jmp	SHORT $LN3@Inverse
$LN2@Inverse:

; 1986 : 		else
; 1987 : 		{
; 1988 : 			const float	Det = Determinant();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ ; IronMan::Core::Math::FMatrix::Determinant
	movss	DWORD PTR Det$1[rsp], xmm0

; 1989 : 
; 1990 : 			if (Det == 0.0f)

	movss	xmm0, DWORD PTR Det$1[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN4@Inverse
	jne	SHORT $LN4@Inverse

; 1991 : 			{
; 1992 : 				Result = FMatrix::Identity;

	lea	rax, QWORD PTR Result$[rsp]
	lea	rcx, OFFSET FLAT:?Identity@FMatrix@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FMatrix::Identity
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 128				; 00000080H
	rep movsb

; 1993 : 			}

	jmp	SHORT $LN5@Inverse
$LN4@Inverse:

; 1994 : 			else
; 1995 : 			{
; 1996 : 				VectorMatrixInverse(&Result, this);

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR Result$[rsp]
	call	?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z ; IronMan::Core::Math::VectorMatrixInverse
	npad	1
$LN5@Inverse:
$LN3@Inverse:

; 1997 : 			}
; 1998 : 		}
; 1999 : 
; 2000 : 		return Result;

	lea	rdx, QWORD PTR Result$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@$$QEAU0123@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2001 : 	}

	add	rsp, 248				; 000000f8H
	pop	rdi
	pop	rsi
	ret	0
?Inverse@FMatrix@Math@Core@IronMan@@QEBA?AU1234@XZ ENDP	; IronMan::Core::Math::FMatrix::Inverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ
_TEXT	SEGMENT
this$ = 16
?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ PROC	; IronMan::Core::Math::FMatrix::Determinant, COMDAT

; 2006 : 	{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx

; 2007 : 		return	M[0][0] * (

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR this$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR this$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	mov	r11d, 16
	imul	r11, r11, 3
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm0, DWORD PTR [r9+r10]
	mulss	xmm0, DWORD PTR [rbx+r11]
	mov	ebx, 16
	imul	rbx, rbx, 2
	mov	r9, QWORD PTR this$[rsp]
	add	r9, rbx
	mov	rbx, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm1, DWORD PTR [rbx+r9]
	mulss	xmm1, DWORD PTR [r10+r11]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm1, DWORD PTR [r8+r9]
	mulss	xmm1, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rdx+rbx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm1, DWORD PTR [r8+r9]
	mulss	xmm1, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rdx+rbx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 2
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm1, DWORD PTR [r8+r9]
	mulss	xmm1, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 2
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rdx+rbx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm3, DWORD PTR [r8+r9]
	mulss	xmm3, DWORD PTR [r10+r11]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rdx+rbx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm3, DWORD PTR [r8+r9]
	mulss	xmm3, DWORD PTR [r10+r11]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rdx+rbx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm1, DWORD PTR [r8+r9]
	mulss	xmm1, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rdx+rbx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 3
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm3, DWORD PTR [r8+r9]
	mulss	xmm3, DWORD PTR [r10+r11]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rdx+rbx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 1
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 1
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm3, DWORD PTR [r8+r9]
	mulss	xmm3, DWORD PTR [r10+r11]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rdx+rbx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm1, DWORD PTR [r8+r9]
	mulss	xmm1, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 1
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rdx+rbx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 2
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm3, DWORD PTR [r8+r9]
	mulss	xmm3, DWORD PTR [r10+r11]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rdx+rbx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	rbx, QWORD PTR this$[rsp]
	add	rbx, rdx
	mov	rdx, rbx
	mov	ebx, 4
	imul	rbx, rbx, 1
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 2
	mov	r10d, 16
	imul	r10, r10, 1
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 3
	movss	xmm2, DWORD PTR [r8+r9]
	mulss	xmm2, DWORD PTR [r10+r11]
	mov	r8d, 16
	imul	r8, r8, 0
	mov	r9, QWORD PTR this$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 4
	imul	r9, r9, 3
	mov	r10d, 16
	imul	r10, r10, 1
	mov	r11, QWORD PTR this$[rsp]
	add	r11, r10
	mov	r10, r11
	mov	r11d, 4
	imul	r11, r11, 2
	movss	xmm3, DWORD PTR [r8+r9]
	mulss	xmm3, DWORD PTR [r10+r11]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rdx+rbx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1

; 2008 : 			M[1][1] * (M[2][2] * M[3][3] - M[2][3] * M[3][2]) -
; 2009 : 			M[2][1] * (M[1][2] * M[3][3] - M[1][3] * M[3][2]) +
; 2010 : 			M[3][1] * (M[1][2] * M[2][3] - M[1][3] * M[2][2])
; 2011 : 			) -
; 2012 : 			M[1][0] * (
; 2013 : 				M[0][1] * (M[2][2] * M[3][3] - M[2][3] * M[3][2]) -
; 2014 : 				M[2][1] * (M[0][2] * M[3][3] - M[0][3] * M[3][2]) +
; 2015 : 				M[3][1] * (M[0][2] * M[2][3] - M[0][3] * M[2][2])
; 2016 : 				) +
; 2017 : 			M[2][0] * (
; 2018 : 				M[0][1] * (M[1][2] * M[3][3] - M[1][3] * M[3][2]) -
; 2019 : 				M[1][1] * (M[0][2] * M[3][3] - M[0][3] * M[3][2]) +
; 2020 : 				M[3][1] * (M[0][2] * M[1][3] - M[0][3] * M[1][2])
; 2021 : 				) -
; 2022 : 			M[3][0] * (
; 2023 : 				M[0][1] * (M[1][2] * M[2][3] - M[1][3] * M[2][2]) -
; 2024 : 				M[1][1] * (M[0][2] * M[2][3] - M[0][3] * M[2][2]) +
; 2025 : 				M[2][1] * (M[0][2] * M[1][3] - M[0][3] * M[1][2])
; 2026 : 				);
; 2027 : 	}

	pop	rbx
	ret	0
?Determinant@FMatrix@Math@Core@IronMan@@QEBAMXZ ENDP	; IronMan::Core::Math::FMatrix::Determinant
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z
_TEXT	SEGMENT
this$ = 48
InX$ = 56
InY$ = 64
InZ$ = 72
InW$ = 80
??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z PROC ; IronMan::Core::Math::FMatrix::FMatrix, COMDAT

; 1911 : 	{

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 112				; 00000070H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane

; 1912 : 		M[0][0] = InX.X; M[0][1] = InX.Y;  M[0][2] = InX.Z;  M[0][3] = 0.0f;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InX$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InX$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InX$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 1913 : 		M[1][0] = InY.X; M[1][1] = InY.Y;  M[1][2] = InY.Z;  M[1][3] = 0.0f;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InY$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InY$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InY$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 1914 : 		M[2][0] = InZ.X; M[2][1] = InZ.Y;  M[2][2] = InZ.Z;  M[2][3] = 0.0f;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InZ$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InZ$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InZ$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+rcx], xmm0

; 1915 : 		M[3][0] = InW.X; M[3][1] = InW.Y;  M[3][2] = InW.Z;  M[3][3] = 1.0f;

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InW$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InW$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InW$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+rcx], xmm0

; 1916 : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z ENDP ; IronMan::Core::Math::FMatrix::FMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z
_TEXT	SEGMENT
this$ = 48
InX$ = 56
InY$ = 64
InZ$ = 72
InW$ = 80
??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z PROC ; IronMan::Core::Math::FMatrix::FMatrix, COMDAT

; 1903 : 	{

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 112				; 00000070H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane

; 1904 : 		M[0][0] = InX.X; M[0][1] = InX.Y;  M[0][2] = InX.Z;  M[0][3] = InX.W;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InX$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InX$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InX$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR InX$[rsp]
	movss	xmm0, DWORD PTR [rdx+12]
	movss	DWORD PTR [rax+rcx], xmm0

; 1905 : 		M[1][0] = InY.X; M[1][1] = InY.Y;  M[1][2] = InY.Z;  M[1][3] = InY.W;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InY$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InY$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InY$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR InY$[rsp]
	movss	xmm0, DWORD PTR [rdx+12]
	movss	DWORD PTR [rax+rcx], xmm0

; 1906 : 		M[2][0] = InZ.X; M[2][1] = InZ.Y;  M[2][2] = InZ.Z;  M[2][3] = InZ.W;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InZ$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InZ$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InZ$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR InZ$[rsp]
	movss	xmm0, DWORD PTR [rdx+12]
	movss	DWORD PTR [rax+rcx], xmm0

; 1907 : 		M[3][0] = InW.X; M[3][1] = InW.Y;  M[3][2] = InW.Z;  M[3][3] = InW.W;

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR InW$[rsp]
	movss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR InW$[rsp]
	movss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR InW$[rsp]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rax+rcx], xmm0
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR InW$[rsp]
	movss	xmm0, DWORD PTR [rdx+12]
	movss	DWORD PTR [rax+rcx], xmm0

; 1908 : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFPlane@123@000@Z ENDP ; IronMan::Core::Math::FMatrix::FMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FMatrix@Math@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0FMatrix@Math@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::Math::FMatrix::FMatrix, COMDAT

; 1921 : 	{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 80					; 00000050H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 112				; 00000070H
	mov	rcx, rax
	call	??0FPlane@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FPlane::FPlane
	npad	1

; 1922 : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0FMatrix@Math@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::Math::FMatrix::FMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 48
InX$ = 56
InY$ = 64
InZ$ = 72
InW$ = 80
??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z PROC		; IronMan::Core::Math::FPlane::FPlane, COMDAT

; 1771 : 	{}

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1769 : 		: FVector(InX, InY, InZ)

	movss	xmm3, DWORD PTR InZ$[rsp]
	movss	xmm2, DWORD PTR InY$[rsp]
	movss	xmm1, DWORD PTR InX$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector

; 1770 : 		, W(InW)

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR InW$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 1771 : 	{}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0FPlane@Math@Core@IronMan@@QEAA@MMMM@Z ENDP		; IronMan::Core::Math::FPlane::FPlane
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z
_TEXT	SEGMENT
this$ = 24
P$ = 32
??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z PROC	; IronMan::Core::Math::FPlane::FPlane, COMDAT

; 1759 : 	{}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi

; 1757 : 		: FVector(P)

	mov	rdi, QWORD PTR this$[rsp]
	mov	rsi, QWORD PTR P$[rsp]
	mov	ecx, 12
	rep movsb

; 1758 : 		, W(P.W)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR P$[rsp]
	movss	xmm0, DWORD PTR [rcx+12]
	movss	DWORD PTR [rax+12], xmm0

; 1759 : 	{}

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	pop	rsi
	ret	0
??0FPlane@Math@Core@IronMan@@QEAA@AEBU0123@@Z ENDP	; IronMan::Core::Math::FPlane::FPlane
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FPlane@Math@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0FPlane@Math@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::Math::FPlane::FPlane, COMDAT

; 1753 : 	{}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FVector::FVector
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0FPlane@Math@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::Math::FPlane::FPlane
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
__$ReturnUdt$ = 88
V$ = 96
??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z PROC ; IronMan::Core::Math::FQuat::operator*, COMDAT

; 2551 : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 2552 : 		return RotateVector(V);

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR V$[rsp]
	mov	ecx, 12
	rep movsb
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z ; IronMan::Core::Math::FQuat::RotateVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2553 : 	}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??DFQuat@Math@Core@IronMan@@QEBA?AUFVector@123@AEBU4123@@Z ENDP ; IronMan::Core::Math::FQuat::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
Result$ = 32
this$ = 80
__$ReturnUdt$ = 88
Q$ = 96
??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FQuat::operator*, COMDAT

; 2541 : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 2542 : 		FQuat Result;

	lea	rcx, QWORD PTR Result$[rsp]
	call	??0FQuat@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FQuat::FQuat

; 2543 : 		VectorQuaternionMultiply(&Result, this, &Q);

	mov	r8, QWORD PTR Q$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR Result$[rsp]
	call	?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z ; IronMan::Core::Math::VectorQuaternionMultiply

; 2544 : 
; 2545 : 		//Result.DiagnosticCheckNaN();
; 2546 : 
; 2547 : 		return Result;

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2548 : 	}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??DFQuat@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FQuat::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z
_TEXT	SEGMENT
tv80 = 32
tv90 = 40
tv132 = 48
tv134 = 56
T$ = 64
Q$ = 80
Result$ = 96
$T1 = 112
$T2 = 124
$T3 = 136
$T4 = 148
this$ = 192
__$ReturnUdt$ = 200
V$ = 208
?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z PROC ; IronMan::Core::Math::FQuat::RotateVector, COMDAT

; 2516 : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H

; 2517 : 		// http://people.csail.mit.edu/bkph/articles/Quaternions.pdf
; 2518 : 		// V' = V + 2w(Q x V) + (2Q x (Q x V))
; 2519 : 		// refactor:
; 2520 : 		// V' = V + w(2(Q x V)) + (Q x (2(Q x V)))
; 2521 : 		// T = 2(Q x V);
; 2522 : 		// V' = V + w*(T) + (Q x T)
; 2523 : 
; 2524 : 		const FVector Q(X, Y, Z);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm3, DWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	lea	rcx, QWORD PTR Q$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	npad	1

; 2525 : 		const FVector T = FVector::CrossProduct(Q, V) * 2.f;

	mov	r8, QWORD PTR V$[rsp]
	lea	rdx, QWORD PTR Q$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z ; IronMan::Core::Math::FVector::CrossProduct
	mov	QWORD PTR tv80[rsp], rax
	movss	xmm2, DWORD PTR __real@40000000
	lea	rdx, QWORD PTR T$[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector::operator*
	npad	1

; 2526 : 		const FVector Result = V + (T * W) + FVector::CrossProduct(Q, T);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+12]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR T$[rsp]
	call	??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z ; IronMan::Core::Math::FVector::operator*
	mov	QWORD PTR tv90[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	call	??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator+
	mov	QWORD PTR tv134[rsp], rax
	lea	r8, QWORD PTR T$[rsp]
	lea	rdx, QWORD PTR Q$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z ; IronMan::Core::Math::FVector::CrossProduct
	mov	QWORD PTR tv132[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	lea	rdx, QWORD PTR Result$[rsp]
	mov	rcx, QWORD PTR tv134[rsp]
	call	??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator+
	npad	1

; 2527 : 		return Result;

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2528 : 	}

	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
?RotateVector@FQuat@Math@Core@IronMan@@QEBA?AUFVector@234@U5234@@Z ENDP ; IronMan::Core::Math::FQuat::RotateVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z
_TEXT	SEGMENT
Scale$1 = 32
SquareSum$ = 36
this$ = 80
Tolerance$ = 88
?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z PROC	; IronMan::Core::Math::FQuat::Normalize, COMDAT

; 2479 : 	{

$LN5:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 2480 : 		const float SquareSum = X * X + Y * Y + Z * Z + W * W;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mulss	xmm1, DWORD PTR [rcx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR SquareSum$[rsp], xmm0

; 2481 : 
; 2482 : 		if (SquareSum >= Tolerance)

	movss	xmm0, DWORD PTR SquareSum$[rsp]
	comiss	xmm0, DWORD PTR Tolerance$[rsp]
	jb	SHORT $LN2@Normalize

; 2483 : 		{
; 2484 : 			const float Scale = Math::InvSqrt(SquareSum);

	movss	xmm0, DWORD PTR SquareSum$[rsp]
	call	?InvSqrt@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::InvSqrt
	movss	DWORD PTR Scale$1[rsp], xmm0

; 2485 : 
; 2486 : 			X *= Scale;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR Scale$1[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0

; 2487 : 			Y *= Scale;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR Scale$1[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 2488 : 			Z *= Scale;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR Scale$1[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 2489 : 			W *= Scale;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR Scale$1[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 2490 : 		}

	jmp	SHORT $LN3@Normalize
$LN2@Normalize:

; 2491 : 		else
; 2492 : 		{
; 2493 : 			*this = FQuat::Identity;

	lea	rax, OFFSET FLAT:?Identity@FQuat@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FQuat::Identity
	mov	rdi, QWORD PTR this$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN3@Normalize:

; 2494 : 		}
; 2495 : 	}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?Normalize@FQuat@Math@Core@IronMan@@QEAAXM@Z ENDP	; IronMan::Core::Math::FQuat::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ
_TEXT	SEGMENT
tv75 = 48
this$ = 80
__$ReturnUdt$ = 88
?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ PROC	; IronMan::Core::Math::FQuat::Inverse, COMDAT

; 2561 : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2562 : 		//checkSlow(IsNormalized());
; 2563 : 
; 2564 : 		return FQuat(-X, -Y, -Z, W);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv75[rsp], xmm2
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm3, DWORD PTR [rax+12]
	movss	DWORD PTR [rsp+32], xmm3
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv75[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z	; IronMan::Core::Math::FQuat::FQuat
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2565 : 	}

	add	rsp, 72					; 00000048H
	ret	0
?Inverse@FQuat@Math@Core@IronMan@@QEBA?AU1234@XZ ENDP	; IronMan::Core::Math::FQuat::Inverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ
_TEXT	SEGMENT
tv70 = 32
this$ = 64
?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ PROC	; IronMan::Core::Math::FQuat::IsNormalized, COMDAT

; 2556 : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2557 : 		return (Math::Abs(1.f - SizeSquared()) < THRESH_QUAT_NORMALIZED);

	mov	rcx, QWORD PTR this$[rsp]
	call	?SizeSquared@FQuat@Math@Core@IronMan@@QEBAMXZ ; IronMan::Core::Math::FQuat::SizeSquared
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR __real@3c23d70a
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@IsNormaliz
	mov	DWORD PTR tv70[rsp], 1
	jmp	SHORT $LN4@IsNormaliz
$LN3@IsNormaliz:
	mov	DWORD PTR tv70[rsp], 0
$LN4@IsNormaliz:
	movzx	eax, BYTE PTR tv70[rsp]

; 2558 : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsNormalized@FQuat@Math@Core@IronMan@@QEBA_NXZ ENDP	; IronMan::Core::Math::FQuat::IsNormalized
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?SizeSquared@FQuat@Math@Core@IronMan@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?SizeSquared@FQuat@Math@Core@IronMan@@QEBAMXZ PROC	; IronMan::Core::Math::FQuat::SizeSquared, COMDAT

; 2569 : 	{

	mov	QWORD PTR [rsp+8], rcx

; 2570 : 		return (X * X + Y * Y + Z * Z + W * W);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mulss	xmm1, DWORD PTR [rcx+12]
	addss	xmm0, xmm1

; 2571 : 	}

	ret	0
?SizeSquared@FQuat@Math@Core@IronMan@@QEBAMXZ ENDP	; IronMan::Core::Math::FQuat::SizeSquared
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
RotatorFromQuat$ = 32
SingularityTest$ = 48
YawX$ = 52
YawY$ = 56
tv79 = 60
tv128 = 64
tv162 = 68
tv185 = 72
tv183 = 76
SINGULARITY_THRESHOLD$ = 80
RAD_TO_DEG$ = 84
this$ = 128
__$ReturnUdt$ = 136
?Rotator@FQuat@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ PROC ; IronMan::Core::Math::FQuat::Rotator

; 70   : 	{

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 71   : 		//SCOPE_CYCLE_COUNTER(STAT_MathConvertQuatToRotator);
; 72   : 
; 73   : 		//DiagnosticCheckNaN();
; 74   : 		const float SingularityTest = Z * X - W * Y;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mulss	xmm1, DWORD PTR [rcx+4]
	subss	xmm0, xmm1
	movss	DWORD PTR SingularityTest$[rsp], xmm0

; 75   : 		const float YawY = 2.f * (W * Z + X * Y);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR YawY$[rsp], xmm0

; 76   : 		const float YawX = (1.f - 2.f * (Math::Square(Y) + Math::Square(Z)));

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$Square@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Square<float>
	movss	DWORD PTR tv79[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	??$Square@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Square<float>
	movss	xmm1, DWORD PTR tv79[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR YawX$[rsp], xmm0

; 77   : 
; 78   : 		// reference 
; 79   : 		// http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
; 80   : 		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/
; 81   : 
; 82   : 		// this value was found from experience, the above websites recommend different values
; 83   : 		// but that isn't the case for us, so I went through different testing, and finally found the case 
; 84   : 		// where both of world lives happily. 
; 85   : 		const float SINGULARITY_THRESHOLD = 0.4999995f;

	movss	xmm0, DWORD PTR __real@3effffef
	movss	DWORD PTR SINGULARITY_THRESHOLD$[rsp], xmm0

; 86   : 		const float RAD_TO_DEG = (180.f) / PI;

	movss	xmm0, DWORD PTR __real@42652ee2
	movss	DWORD PTR RAD_TO_DEG$[rsp], xmm0

; 87   : 		FRotator RotatorFromQuat;

	lea	rcx, QWORD PTR RotatorFromQuat$[rsp]
	call	??0FRotator@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FRotator::FRotator
	npad	1

; 88   : 
; 89   : 		if (SingularityTest < -SINGULARITY_THRESHOLD)

	movss	xmm0, DWORD PTR __real@beffffef
	comiss	xmm0, DWORD PTR SingularityTest$[rsp]
	jbe	$LN2@Rotator

; 90   : 		{
; 91   : 			RotatorFromQuat.Pitch = -90.f;

	movss	xmm0, DWORD PTR __real@c2b40000
	movss	DWORD PTR RotatorFromQuat$[rsp], xmm0

; 92   : 			RotatorFromQuat.Yaw = Math::Atan2(YawY, YawX) * RAD_TO_DEG;

	movss	xmm1, DWORD PTR YawX$[rsp]
	movss	xmm0, DWORD PTR YawY$[rsp]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	mulss	xmm0, DWORD PTR __real@42652ee2
	movss	DWORD PTR RotatorFromQuat$[rsp+4], xmm0

; 93   : 			RotatorFromQuat.Roll = FRotator::NormalizeAxis(-RotatorFromQuat.Yaw - (2.f * Math::Atan2(X, W) * RAD_TO_DEG));

	movss	xmm0, DWORD PTR RotatorFromQuat$[rsp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv128[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@42652ee2
	movss	xmm1, DWORD PTR tv128[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	movss	DWORD PTR RotatorFromQuat$[rsp+8], xmm0

; 94   : 		}

	jmp	$LN3@Rotator
$LN2@Rotator:

; 95   : 		else if (SingularityTest > SINGULARITY_THRESHOLD)

	movss	xmm0, DWORD PTR SingularityTest$[rsp]
	comiss	xmm0, DWORD PTR __real@3effffef
	jbe	SHORT $LN4@Rotator

; 96   : 		{
; 97   : 			RotatorFromQuat.Pitch = 90.f;

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR RotatorFromQuat$[rsp], xmm0

; 98   : 			RotatorFromQuat.Yaw = Math::Atan2(YawY, YawX) * RAD_TO_DEG;

	movss	xmm1, DWORD PTR YawX$[rsp]
	movss	xmm0, DWORD PTR YawY$[rsp]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	mulss	xmm0, DWORD PTR __real@42652ee2
	movss	DWORD PTR RotatorFromQuat$[rsp+4], xmm0

; 99   : 			RotatorFromQuat.Roll = FRotator::NormalizeAxis(RotatorFromQuat.Yaw - (2.f * Math::Atan2(X, W) * RAD_TO_DEG));

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+12]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@42652ee2
	movss	xmm1, DWORD PTR RotatorFromQuat$[rsp+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	movss	DWORD PTR RotatorFromQuat$[rsp+8], xmm0

; 100  : 		}

	jmp	$LN5@Rotator
$LN4@Rotator:

; 101  : 		else
; 102  : 		{
; 103  : 			RotatorFromQuat.Pitch = Math::FastAsin(2.f * (SingularityTest)) * RAD_TO_DEG;

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR SingularityTest$[rsp]
	call	?FastAsin@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::FastAsin
	mulss	xmm0, DWORD PTR __real@42652ee2
	movss	DWORD PTR RotatorFromQuat$[rsp], xmm0

; 104  : 			RotatorFromQuat.Yaw = Math::Atan2(YawY, YawX) * RAD_TO_DEG;

	movss	xmm1, DWORD PTR YawX$[rsp]
	movss	xmm0, DWORD PTR YawY$[rsp]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	mulss	xmm0, DWORD PTR __real@42652ee2
	movss	DWORD PTR RotatorFromQuat$[rsp+4], xmm0

; 105  : 			RotatorFromQuat.Roll = Math::Atan2(-2.f * (W * X + Y * Z), (1.f - 2.f * (Math::Square(X) + Math::Square(Y)))) * RAD_TO_DEG;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	??$Square@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Square<float>
	movss	DWORD PTR tv162[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$Square@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Square<float>
	movss	xmm1, DWORD PTR tv162[rsp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv185[rsp], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+12]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@c0000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR tv183[rsp], xmm0
	movss	xmm1, DWORD PTR tv185[rsp]
	movss	xmm0, DWORD PTR tv183[rsp]
	call	?Atan2@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Atan2
	mulss	xmm0, DWORD PTR __real@42652ee2
	movss	DWORD PTR RotatorFromQuat$[rsp+8], xmm0
$LN5@Rotator:
$LN3@Rotator:

; 106  : 		}
; 107  : 
; 108  : 
; 109  : 		return RotatorFromQuat;

	lea	rax, QWORD PTR RotatorFromQuat$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 110  : 	}

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?Rotator@FQuat@Math@Core@IronMan@@QEBA?AUFRotator@234@XZ ENDP ; IronMan::Core::Math::FQuat::Rotator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z
_TEXT	SEGMENT
i$1 = 32
s$ = 36
j$2 = 40
k$3 = 44
tr$ = 48
InvS$4 = 52
InvS$5 = 56
tv72 = 64
tv83 = 72
tv94 = 80
$T6 = 88
$T7 = 100
$T8 = 112
qt$9 = 128
__$ArrayPad$ = 144
this$ = 192
M$ = 200
??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z PROC ; IronMan::Core::Math::FQuat::FQuat, COMDAT

; 2407 : 	{

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2408 : 		// If Matrix is NULL, return Identity quaternion. If any of them is 0, you won't be able to construct rotation
; 2409 : 		// if you have two plane at least, we can reconstruct the frame using cross product, but that's a bit expensive op to do here
; 2410 : 		// for now, if you convert to matrix from 0 scale and convert back, you'll lose rotation. Don't do that. 
; 2411 : 		if (M.GetScaledAxis(EAxis::X).IsNearlyZero() || M.GetScaledAxis(EAxis::Y).IsNearlyZero() || M.GetScaledAxis(EAxis::Z).IsNearlyZero())

	mov	r8d, 1
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR M$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv72[rsp], rax
	movss	xmm1, DWORD PTR __real@38d1b717
	mov	rcx, QWORD PTR tv72[rsp]
	call	?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FVector::IsNearlyZero
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@FQuat
	mov	r8d, 2
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR M$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv83[rsp], rax
	movss	xmm1, DWORD PTR __real@38d1b717
	mov	rcx, QWORD PTR tv83[rsp]
	call	?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FVector::IsNearlyZero
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@FQuat
	mov	r8d, 3
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR M$[rsp]
	call	?GetScaledAxis@FMatrix@Math@Core@IronMan@@QEBA?AUFVector@234@W4Type@EAxis@234@@Z ; IronMan::Core::Math::FMatrix::GetScaledAxis
	mov	QWORD PTR tv94[rsp], rax
	movss	xmm1, DWORD PTR __real@38d1b717
	mov	rcx, QWORD PTR tv94[rsp]
	call	?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ; IronMan::Core::Math::FVector::IsNearlyZero
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@FQuat
$LN3@FQuat:

; 2412 : 		{
; 2413 : 			*this = FQuat::Identity;

	lea	rax, OFFSET FLAT:?Identity@FQuat@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FQuat::Identity
	mov	rdi, QWORD PTR this$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 2414 : 			return;

	jmp	$LN1@FQuat
$LN2@FQuat:

; 2415 : 		}
; 2416 : 
; 2417 : 
; 2418 : 		//const MeReal *const t = (MeReal *) tm;
; 2419 : 		float	s;
; 2420 : 
; 2421 : 		// Check diagonal (trace)
; 2422 : 		const float tr = M.M[0][0] + M.M[1][1] + M.M[2][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	mov	edi, 4
	imul	rdi, rdi, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	addss	xmm0, DWORD PTR [rdx+rdi]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	addss	xmm0, DWORD PTR [rax+rcx]
	movss	DWORD PTR tr$[rsp], xmm0

; 2423 : 
; 2424 : 		if (tr > 0.0f)

	movss	xmm0, DWORD PTR tr$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN4@FQuat

; 2425 : 		{
; 2426 : 			float InvS = Math::InvSqrt(tr + 1.f);

	movss	xmm0, DWORD PTR tr$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	call	?InvSqrt@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::InvSqrt
	movss	DWORD PTR InvS$4[rsp], xmm0

; 2427 : 			this->W = 0.5f * (1.f / InvS);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR InvS$4[rsp]
	movss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 2428 : 			s = 0.5f * InvS;

	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR InvS$4[rsp]
	movss	DWORD PTR s$[rsp], xmm0

; 2429 : 
; 2430 : 			this->X = (M.M[1][2] - M.M[2][1]) * s;

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	mov	edi, 4
	imul	rdi, rdi, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	subss	xmm0, DWORD PTR [rdx+rdi]
	mulss	xmm0, DWORD PTR s$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0

; 2431 : 			this->Y = (M.M[2][0] - M.M[0][2]) * s;

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	mov	edi, 4
	imul	rdi, rdi, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	subss	xmm0, DWORD PTR [rdx+rdi]
	mulss	xmm0, DWORD PTR s$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 2432 : 			this->Z = (M.M[0][1] - M.M[1][0]) * s;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	mov	edi, 4
	imul	rdi, rdi, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	subss	xmm0, DWORD PTR [rdx+rdi]
	mulss	xmm0, DWORD PTR s$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 2433 : 		}

	jmp	$LN5@FQuat
$LN4@FQuat:

; 2434 : 		else
; 2435 : 		{
; 2436 : 			// diagonal is negative
; 2437 : 			int32_t i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 2438 : 
; 2439 : 			if (M.M[1][1] > M.M[0][0])

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	mov	edi, 4
	imul	rdi, rdi, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	comiss	xmm0, DWORD PTR [rdx+rdi]
	jbe	SHORT $LN6@FQuat

; 2440 : 				i = 1;

	mov	DWORD PTR i$1[rsp], 1
$LN6@FQuat:

; 2441 : 
; 2442 : 			if (M.M[2][2] > M.M[i][i])

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	movsxd	rdx, DWORD PTR i$1[rsp]
	imul	rdx, rdx, 16
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	movsxd	rdi, DWORD PTR i$1[rsp]
	movss	xmm0, DWORD PTR [rax+rcx]
	comiss	xmm0, DWORD PTR [rdx+rdi*4]
	jbe	SHORT $LN7@FQuat

; 2443 : 				i = 2;

	mov	DWORD PTR i$1[rsp], 2
$LN7@FQuat:

; 2444 : 
; 2445 : 			static const int32_t nxt[3] = { 1, 2, 0 };
; 2446 : 			const int32_t j = nxt[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?nxt@?9???0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@234@@Z@4QBHB ; `IronMan::Core::Math::FQuat::FQuat'::`10'::nxt
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR j$2[rsp], eax

; 2447 : 			const int32_t k = nxt[j];

	movsxd	rax, DWORD PTR j$2[rsp]
	lea	rcx, OFFSET FLAT:?nxt@?9???0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@234@@Z@4QBHB ; `IronMan::Core::Math::FQuat::FQuat'::`10'::nxt
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR k$3[rsp], eax

; 2448 : 
; 2449 : 			s = M.M[i][i] - M.M[j][j] - M.M[k][k] + 1.0f;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$1[rsp]
	movsxd	rdx, DWORD PTR j$2[rsp]
	imul	rdx, rdx, 16
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	movsxd	rdi, DWORD PTR j$2[rsp]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	subss	xmm0, DWORD PTR [rdx+rdi*4]
	movsxd	rax, DWORD PTR k$3[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR k$3[rsp]
	subss	xmm0, DWORD PTR [rax+rcx*4]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR s$[rsp], xmm0

; 2450 : 
; 2451 : 			float InvS = Math::InvSqrt(s);

	movss	xmm0, DWORD PTR s$[rsp]
	call	?InvSqrt@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::InvSqrt
	movss	DWORD PTR InvS$5[rsp], xmm0

; 2452 : 
; 2453 : 			float qt[4];
; 2454 : 			qt[i] = 0.5f * (1.f / InvS);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR InvS$5[rsp]
	movss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movsxd	rax, DWORD PTR i$1[rsp]
	movss	DWORD PTR qt$9[rsp+rax*4], xmm0

; 2455 : 
; 2456 : 			s = 0.5f * InvS;

	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR InvS$5[rsp]
	movss	DWORD PTR s$[rsp], xmm0

; 2457 : 
; 2458 : 			qt[3] = (M.M[j][k] - M.M[k][j]) * s;

	movsxd	rax, DWORD PTR j$2[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR k$3[rsp]
	movsxd	rdx, DWORD PTR k$3[rsp]
	imul	rdx, rdx, 16
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	movsxd	rdi, DWORD PTR j$2[rsp]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	subss	xmm0, DWORD PTR [rdx+rdi*4]
	mulss	xmm0, DWORD PTR s$[rsp]
	mov	eax, 4
	imul	rax, rax, 3
	movss	DWORD PTR qt$9[rsp+rax], xmm0

; 2459 : 			qt[j] = (M.M[i][j] + M.M[j][i]) * s;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR j$2[rsp]
	movsxd	rdx, DWORD PTR j$2[rsp]
	imul	rdx, rdx, 16
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	movsxd	rdi, DWORD PTR i$1[rsp]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	addss	xmm0, DWORD PTR [rdx+rdi*4]
	mulss	xmm0, DWORD PTR s$[rsp]
	movsxd	rax, DWORD PTR j$2[rsp]
	movss	DWORD PTR qt$9[rsp+rax*4], xmm0

; 2460 : 			qt[k] = (M.M[i][k] + M.M[k][i]) * s;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR k$3[rsp]
	movsxd	rdx, DWORD PTR k$3[rsp]
	imul	rdx, rdx, 16
	mov	rdi, QWORD PTR M$[rsp]
	add	rdi, rdx
	mov	rdx, rdi
	movsxd	rdi, DWORD PTR i$1[rsp]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	addss	xmm0, DWORD PTR [rdx+rdi*4]
	mulss	xmm0, DWORD PTR s$[rsp]
	movsxd	rax, DWORD PTR k$3[rsp]
	movss	DWORD PTR qt$9[rsp+rax*4], xmm0

; 2461 : 
; 2462 : 			this->X = qt[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR qt$9[rsp+rax]
	movss	DWORD PTR [rcx], xmm0

; 2463 : 			this->Y = qt[1];

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR qt$9[rsp+rax]
	movss	DWORD PTR [rcx+4], xmm0

; 2464 : 			this->Z = qt[2];

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR qt$9[rsp+rax]
	movss	DWORD PTR [rcx+8], xmm0

; 2465 : 			this->W = qt[3];

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR qt$9[rsp+rax]
	movss	DWORD PTR [rcx+12], xmm0
$LN5@FQuat:
$LN1@FQuat:

; 2466 : 
; 2467 : 			//DiagnosticCheckNaN();
; 2468 : 		}
; 2469 : 	}

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
??0FQuat@Math@Core@IronMan@@QEAA@AEBUFMatrix@123@@Z ENDP ; IronMan::Core::Math::FQuat::FQuat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
InX$ = 16
InY$ = 24
InZ$ = 32
InW$ = 40
??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z PROC		; IronMan::Core::Math::FQuat::FQuat, COMDAT

; 1576 : 		{

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 1572 : 			: X(InX)

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR InX$[rsp]
	movss	DWORD PTR [rax], xmm0

; 1573 : 			, Y(InY)

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR InY$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 1574 : 			, Z(InZ)

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR InZ$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 1575 : 			, W(InW)

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR InW$[rsp]
	movss	DWORD PTR [rax+12], xmm0

; 1577 : 		}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FQuat@Math@Core@IronMan@@QEAA@MMMM@Z ENDP		; IronMan::Core::Math::FQuat::FQuat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FQuat@Math@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0FQuat@Math@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::Math::FQuat::FQuat, COMDAT

; 1561 : 		FORCEINLINE FQuat() { }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FQuat@Math@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::Math::FQuat::FQuat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
DegVal$ = 8
??$DegreesToRadians@M@Math@Core@IronMan@@YAMAEBM@Z PROC	; IronMan::Core::Math::DegreesToRadians<float>

; 387  : 	{

	mov	QWORD PTR [rsp+8], rcx

; 388  : 		return DegVal * (PI / 180.f);

	mov	rax, QWORD PTR DegVal$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR __real@3c8efa35

; 389  : 	}

	ret	0
??$DegreesToRadians@M@Math@Core@IronMan@@YAMAEBM@Z ENDP	; IronMan::Core::Math::DegreesToRadians<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv80 = 48
tv90 = 56
$T1 = 64
NewZ$ = 72
UpVector$ = 88
NewX$ = 104
NewY$ = 120
$T2 = 136
__$ReturnUdt$ = 176
ZAxis$ = 184
?MakeFromZ@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z PROC ; IronMan::Core::Math::FRotator::MakeFromZ

; 160  : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 161  : 		FVector const NewZ = ZAxis.GetSafeNormal();

	movss	xmm2, DWORD PTR __real@322bcc77
	lea	rdx, QWORD PTR NewZ$[rsp]
	mov	rcx, QWORD PTR ZAxis$[rsp]
	call	?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ; IronMan::Core::Math::FVector::GetSafeNormal
	npad	1

; 162  : 
; 163  : 		// try to use up if possible
; 164  : 		FVector const UpVector = (Math::Abs(NewZ.Z) < (1.f - KINDA_SMALL_NUMBER)) ? FVector(0, 0, 1.f) : FVector(1.f, 0, 0);

	movss	xmm0, DWORD PTR NewZ$[rsp+8]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR __real@3f7ff972
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@MakeFromZ
	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN4@MakeFromZ
$LN3@MakeFromZ:
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv80[rsp], rax
$LN4@MakeFromZ:
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR $T1[rsp], rax

; 165  : 
; 166  : 		const FVector NewX = (UpVector ^ NewZ).GetSafeNormal();

	lea	r8, QWORD PTR NewZ$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^
	mov	QWORD PTR tv90[rsp], rax
	movss	xmm2, DWORD PTR __real@322bcc77
	lea	rdx, QWORD PTR NewX$[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ; IronMan::Core::Math::FVector::GetSafeNormal
	npad	1

; 167  : 		const FVector NewY = NewZ ^ NewX;

	lea	r8, QWORD PTR NewX$[rsp]
	lea	rdx, QWORD PTR NewY$[rsp]
	lea	rcx, QWORD PTR NewZ$[rsp]
	call	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^

; 168  : 
; 169  : 		return FMatrix(NewX, NewY, NewZ, FVector::ZeroVector);

	lea	rax, OFFSET FLAT:?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::ZeroVector
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR NewZ$[rsp]
	lea	r8, QWORD PTR NewY$[rsp]
	lea	rdx, QWORD PTR NewX$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z ; IronMan::Core::Math::FMatrix::FMatrix
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 170  : 	}

	add	rsp, 168				; 000000a8H
	ret	0
?MakeFromZ@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ENDP ; IronMan::Core::Math::FRotator::MakeFromZ
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv80 = 48
tv90 = 56
$T1 = 64
NewY$ = 72
UpVector$ = 88
NewZ$ = 104
NewX$ = 120
$T2 = 136
__$ReturnUdt$ = 176
YAxis$ = 184
?MakeFromY@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z PROC ; IronMan::Core::Math::FRotator::MakeFromY

; 147  : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 148  : 		FVector const NewY = YAxis.GetSafeNormal();

	movss	xmm2, DWORD PTR __real@322bcc77
	lea	rdx, QWORD PTR NewY$[rsp]
	mov	rcx, QWORD PTR YAxis$[rsp]
	call	?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ; IronMan::Core::Math::FVector::GetSafeNormal
	npad	1

; 149  : 
; 150  : 		// try to use up if possible
; 151  : 		FVector const UpVector = (Math::Abs(NewY.Z) < (1.f - KINDA_SMALL_NUMBER)) ? FVector(0, 0, 1.f) : FVector(1.f, 0, 0);

	movss	xmm0, DWORD PTR NewY$[rsp+8]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR __real@3f7ff972
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@MakeFromY
	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN4@MakeFromY
$LN3@MakeFromY:
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv80[rsp], rax
$LN4@MakeFromY:
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR $T1[rsp], rax

; 152  : 
; 153  : 		const FVector NewZ = (UpVector ^ NewY).GetSafeNormal();

	lea	r8, QWORD PTR NewY$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^
	mov	QWORD PTR tv90[rsp], rax
	movss	xmm2, DWORD PTR __real@322bcc77
	lea	rdx, QWORD PTR NewZ$[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ; IronMan::Core::Math::FVector::GetSafeNormal
	npad	1

; 154  : 		const FVector NewX = NewY ^ NewZ;

	lea	r8, QWORD PTR NewZ$[rsp]
	lea	rdx, QWORD PTR NewX$[rsp]
	lea	rcx, QWORD PTR NewY$[rsp]
	call	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^

; 155  : 
; 156  : 		return FMatrix(NewX, NewY, NewZ, FVector::ZeroVector);

	lea	rax, OFFSET FLAT:?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::ZeroVector
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR NewZ$[rsp]
	lea	r8, QWORD PTR NewY$[rsp]
	lea	rdx, QWORD PTR NewX$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z ; IronMan::Core::Math::FMatrix::FMatrix
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 157  : 	}

	add	rsp, 168				; 000000a8H
	ret	0
?MakeFromY@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ENDP ; IronMan::Core::Math::FRotator::MakeFromY
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
tv80 = 48
tv90 = 56
$T1 = 64
NewX$ = 72
UpVector$ = 88
NewY$ = 104
NewZ$ = 120
$T2 = 136
__$ReturnUdt$ = 176
XAxis$ = 184
?MakeFromX@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z PROC ; IronMan::Core::Math::FRotator::MakeFromX

; 134  : 	{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 135  : 		FVector const NewX = XAxis.GetSafeNormal();

	movss	xmm2, DWORD PTR __real@322bcc77
	lea	rdx, QWORD PTR NewX$[rsp]
	mov	rcx, QWORD PTR XAxis$[rsp]
	call	?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ; IronMan::Core::Math::FVector::GetSafeNormal
	npad	1

; 136  : 
; 137  : 		// try to use up if possible
; 138  : 		FVector const UpVector = (Math::Abs(NewX.Z) < (1.f - KINDA_SMALL_NUMBER)) ? FVector(0, 0, 1.f) : FVector(1.f, 0, 0);

	movss	xmm0, DWORD PTR NewX$[rsp+8]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR __real@3f7ff972
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@MakeFromX
	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv80[rsp], rax
	jmp	SHORT $LN4@MakeFromX
$LN3@MakeFromX:
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	QWORD PTR tv80[rsp], rax
$LN4@MakeFromX:
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR $T1[rsp], rax

; 139  : 
; 140  : 		const FVector NewY = (UpVector ^ NewX).GetSafeNormal();

	lea	r8, QWORD PTR NewX$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR UpVector$[rsp]
	call	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^
	mov	QWORD PTR tv90[rsp], rax
	movss	xmm2, DWORD PTR __real@322bcc77
	lea	rdx, QWORD PTR NewY$[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ; IronMan::Core::Math::FVector::GetSafeNormal
	npad	1

; 141  : 		const FVector NewZ = NewX ^ NewY;

	lea	r8, QWORD PTR NewY$[rsp]
	lea	rdx, QWORD PTR NewZ$[rsp]
	lea	rcx, QWORD PTR NewX$[rsp]
	call	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^

; 142  : 
; 143  : 		return FMatrix(NewX, NewY, NewZ, FVector::ZeroVector);

	lea	rax, OFFSET FLAT:?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::ZeroVector
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR NewZ$[rsp]
	lea	r8, QWORD PTR NewY$[rsp]
	lea	rdx, QWORD PTR NewX$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FMatrix@Math@Core@IronMan@@QEAA@AEBUFVector@123@000@Z ; IronMan::Core::Math::FMatrix::FMatrix
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 144  : 	}

	add	rsp, 168				; 000000a8H
	ret	0
?MakeFromX@FRotator@Math@Core@IronMan@@SA?AUFMatrix@234@AEBUFVector@234@@Z ENDP ; IronMan::Core::Math::FRotator::MakeFromX
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
CR$ = 32
CP$ = 36
CY$ = 40
SR$ = 44
SP$ = 48
SY$ = 52
RotationQuat$ = 56
DEG_TO_RAD$ = 72
DIVIDE_BY_2$ = 76
this$ = 112
__$ReturnUdt$ = 120
?Quaternion@FRotator@Math@Core@IronMan@@QEBA?AUFQuat@234@XZ PROC ; IronMan::Core::Math::FRotator::Quaternion

; 114  : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 115  : 		const float DEG_TO_RAD = PI / (180.f);

	movss	xmm0, DWORD PTR __real@3c8efa35
	movss	DWORD PTR DEG_TO_RAD$[rsp], xmm0

; 116  : 		const float DIVIDE_BY_2 = DEG_TO_RAD / 2.f;

	movss	xmm0, DWORD PTR __real@3c0efa35
	movss	DWORD PTR DIVIDE_BY_2$[rsp], xmm0

; 117  : 		float SP, SY, SR;
; 118  : 		float CP, CY, CR;
; 119  : 
; 120  : 		Math::SinCos(&SP, &CP, Pitch * DIVIDE_BY_2);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR __real@3c0efa35
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR CP$[rsp]
	lea	rcx, QWORD PTR SP$[rsp]
	call	?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z	; IronMan::Core::Math::SinCos

; 121  : 		Math::SinCos(&SY, &CY, Yaw * DIVIDE_BY_2);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR __real@3c0efa35
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR CY$[rsp]
	lea	rcx, QWORD PTR SY$[rsp]
	call	?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z	; IronMan::Core::Math::SinCos

; 122  : 		Math::SinCos(&SR, &CR, Roll * DIVIDE_BY_2);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR __real@3c0efa35
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR CR$[rsp]
	lea	rcx, QWORD PTR SR$[rsp]
	call	?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z	; IronMan::Core::Math::SinCos

; 123  : 
; 124  : 		struct FQuat RotationQuat;

	lea	rcx, QWORD PTR RotationQuat$[rsp]
	call	??0FQuat@Math@Core@IronMan@@QEAA@XZ	; IronMan::Core::Math::FQuat::FQuat

; 125  : 		RotationQuat.X = CR * SP * SY - SR * CP * CY;

	movss	xmm0, DWORD PTR CR$[rsp]
	mulss	xmm0, DWORD PTR SP$[rsp]
	mulss	xmm0, DWORD PTR SY$[rsp]
	movss	xmm1, DWORD PTR SR$[rsp]
	mulss	xmm1, DWORD PTR CP$[rsp]
	mulss	xmm1, DWORD PTR CY$[rsp]
	subss	xmm0, xmm1
	movss	DWORD PTR RotationQuat$[rsp], xmm0

; 126  : 		RotationQuat.Y = -CR * SP * CY - SR * CP * SY;

	movss	xmm0, DWORD PTR CR$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR SP$[rsp]
	mulss	xmm0, DWORD PTR CY$[rsp]
	movss	xmm1, DWORD PTR SR$[rsp]
	mulss	xmm1, DWORD PTR CP$[rsp]
	mulss	xmm1, DWORD PTR SY$[rsp]
	subss	xmm0, xmm1
	movss	DWORD PTR RotationQuat$[rsp+4], xmm0

; 127  : 		RotationQuat.Z = CR * CP * SY - SR * SP * CY;

	movss	xmm0, DWORD PTR CR$[rsp]
	mulss	xmm0, DWORD PTR CP$[rsp]
	mulss	xmm0, DWORD PTR SY$[rsp]
	movss	xmm1, DWORD PTR SR$[rsp]
	mulss	xmm1, DWORD PTR SP$[rsp]
	mulss	xmm1, DWORD PTR CY$[rsp]
	subss	xmm0, xmm1
	movss	DWORD PTR RotationQuat$[rsp+8], xmm0

; 128  : 		RotationQuat.W = CR * CP * CY + SR * SP * SY;

	movss	xmm0, DWORD PTR CR$[rsp]
	mulss	xmm0, DWORD PTR CP$[rsp]
	mulss	xmm0, DWORD PTR CY$[rsp]
	movss	xmm1, DWORD PTR SR$[rsp]
	mulss	xmm1, DWORD PTR SP$[rsp]
	mulss	xmm1, DWORD PTR SY$[rsp]
	addss	xmm0, xmm1
	movss	DWORD PTR RotationQuat$[rsp+12], xmm0

; 129  : 
; 130  : 		return RotationQuat;

	lea	rax, QWORD PTR RotationQuat$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 131  : 	}

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?Quaternion@FRotator@Math@Core@IronMan@@QEBA?AUFQuat@234@XZ ENDP ; IronMan::Core::Math::FRotator::Quaternion
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ
_TEXT	SEGMENT
Rot$ = 32
this$ = 80
__$ReturnUdt$ = 88
?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ PROC ; IronMan::Core::Math::FRotator::GetNormalized, COMDAT

; 1421 : 		__forceinline FRotator FRotator::GetNormalized() const {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 1422 : 			FRotator Rot = *this;

	lea	rax, QWORD PTR Rot$[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR this$[rsp]
	mov	ecx, 12
	rep movsb

; 1423 : 			Rot.Normalize();

	lea	rcx, QWORD PTR Rot$[rsp]
	call	?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ ; IronMan::Core::Math::FRotator::Normalize

; 1424 : 			return Rot;

	lea	rax, QWORD PTR Rot$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1425 : 		}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?GetNormalized@FRotator@Math@Core@IronMan@@QEBA?AU1234@XZ ENDP ; IronMan::Core::Math::FRotator::GetNormalized
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ PROC	; IronMan::Core::Math::FRotator::Normalize, COMDAT

; 1415 : 		__forceinline void FRotator::Normalize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1416 : 			Pitch = NormalizeAxis(Pitch);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax], xmm0

; 1417 : 			Yaw = NormalizeAxis(Yaw);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 1418 : 			Roll = NormalizeAxis(Roll);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 1419 : 		}

	add	rsp, 40					; 00000028H
	ret	0
?Normalize@FRotator@Math@Core@IronMan@@QEAAXXZ ENDP	; IronMan::Core::Math::FRotator::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z
_TEXT	SEGMENT
Angle$ = 48
?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z PROC	; IronMan::Core::Math::FRotator::NormalizeAxis, COMDAT

; 1524 : 	{

$LN4:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 1525 : 		// returns Angle in the range [0,360)
; 1526 : 		Angle = ClampAxis(Angle);

	movss	xmm0, DWORD PTR Angle$[rsp]
	call	?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::ClampAxis
	movss	DWORD PTR Angle$[rsp], xmm0

; 1527 : 
; 1528 : 		if (Angle > 180.f)

	movss	xmm0, DWORD PTR Angle$[rsp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN2@NormalizeA

; 1529 : 		{
; 1530 : 			// shift to (-180,180]
; 1531 : 			Angle -= 360.f;

	movss	xmm0, DWORD PTR Angle$[rsp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR Angle$[rsp], xmm0
$LN2@NormalizeA:

; 1532 : 		}
; 1533 : 
; 1534 : 		return Angle;

	movss	xmm0, DWORD PTR Angle$[rsp]

; 1535 : 	}

	add	rsp, 40					; 00000028H
	ret	0
?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ENDP	; IronMan::Core::Math::FRotator::NormalizeAxis
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z
_TEXT	SEGMENT
Angle$ = 48
?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z PROC	; IronMan::Core::Math::FRotator::ClampAxis, COMDAT

; 1510 : 	{

$LN4:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 1511 : 		// returns Angle in the range (-360,360)
; 1512 : 		Angle = Math::Fmod(Angle, 360.f);

	movss	xmm1, DWORD PTR __real@43b40000
	movss	xmm0, DWORD PTR Angle$[rsp]
	call	?Fmod@Math@Core@IronMan@@YAMMM@Z	; IronMan::Core::Math::Fmod
	movss	DWORD PTR Angle$[rsp], xmm0

; 1513 : 
; 1514 : 		if (Angle < 0.f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR Angle$[rsp]
	jbe	SHORT $LN2@ClampAxis

; 1515 : 		{
; 1516 : 			// shift to [0,360) range
; 1517 : 			Angle += 360.f;

	movss	xmm0, DWORD PTR Angle$[rsp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR Angle$[rsp], xmm0
$LN2@ClampAxis:

; 1518 : 		}
; 1519 : 
; 1520 : 		return Angle;

	movss	xmm0, DWORD PTR Angle$[rsp]

; 1521 : 	}

	add	rsp, 40					; 00000028H
	ret	0
?ClampAxis@FRotator@Math@Core@IronMan@@SAMM@Z ENDP	; IronMan::Core::Math::FRotator::ClampAxis
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z
_TEXT	SEGMENT
tv82 = 32
this$ = 64
Tolerance$ = 72
?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z PROC ; IronMan::Core::Math::FRotator::IsNearlyZero, COMDAT

; 1496 : 	{

$LN5:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1497 : 		return

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@IsNearlyZe
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@IsNearlyZe
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	?NormalizeAxis@FRotator@Math@Core@IronMan@@SAMM@Z ; IronMan::Core::Math::FRotator::NormalizeAxis
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@IsNearlyZe
	mov	DWORD PTR tv82[rsp], 1
	jmp	SHORT $LN4@IsNearlyZe
$LN3@IsNearlyZe:
	mov	DWORD PTR tv82[rsp], 0
$LN4@IsNearlyZe:
	movzx	eax, BYTE PTR tv82[rsp]

; 1498 : 			Math::Abs(NormalizeAxis(Pitch)) <= Tolerance
; 1499 : 			&& Math::Abs(NormalizeAxis(Yaw)) <= Tolerance
; 1500 : 			&& Math::Abs(NormalizeAxis(Roll)) <= Tolerance;
; 1501 : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsNearlyZero@FRotator@Math@Core@IronMan@@QEBA_NM@Z ENDP ; IronMan::Core::Math::FRotator::IsNearlyZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z
_TEXT	SEGMENT
tv73 = 0
this$ = 32
src$ = 40
??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z PROC	; IronMan::Core::Math::FRotator::operator==, COMDAT

; 1359 : 		__forceinline bool FRotator::operator==(const FRotator& src) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1360 : 			return (src.Pitch == Pitch) && (src.Yaw == Yaw) && (src.Roll == Roll);

	mov	rax, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	ucomiss	xmm0, DWORD PTR [rcx]
	jp	SHORT $LN3@operator
	jne	SHORT $LN3@operator
	mov	rax, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	ucomiss	xmm0, DWORD PTR [rcx+4]
	jp	SHORT $LN3@operator
	jne	SHORT $LN3@operator
	mov	rax, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	ucomiss	xmm0, DWORD PTR [rcx+8]
	jp	SHORT $LN3@operator
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv73[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv73[rsp]

; 1361 : 		}

	add	rsp, 24
	ret	0
??8FRotator@Math@Core@IronMan@@QEBA_NAEBU0123@@Z ENDP	; IronMan::Core::Math::FRotator::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z
_TEXT	SEGMENT
tv73 = 32
this$ = 64
__$ReturnUdt$ = 72
Scale$ = 80
??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z PROC	; IronMan::Core::Math::FRotator::operator*, COMDAT

; 1298 : 		__forceinline FRotator FRotator::operator*(float Scale) const {

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1299 : 			return FRotator(Pitch * Scale, Yaw * Scale, Roll * Scale);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR Scale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR Scale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mulss	xmm2, DWORD PTR Scale$[rsp]
	movss	DWORD PTR tv73[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv73[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FRotator::FRotator
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1300 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??DFRotator@Math@Core@IronMan@@QEBA?AU0123@M@Z ENDP	; IronMan::Core::Math::FRotator::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
__$ReturnUdt$ = 72
V$ = 80
??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FRotator::operator-, COMDAT

; 1294 : 		__forceinline FRotator FRotator::operator-(const FRotator& V) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1295 : 			return FRotator(Pitch - V.Pitch, Yaw - V.Yaw, Roll - V.Roll);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR [rax]
	subss	xmm2, DWORD PTR [rcx]
	movss	DWORD PTR tv76[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv76[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FRotator::FRotator
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1296 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??GFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FRotator::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
__$ReturnUdt$ = 72
V$ = 80
??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FRotator::operator+, COMDAT

; 1286 : 		__forceinline FRotator FRotator::operator+(const FRotator& V) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1287 : 			return FRotator(Pitch + V.Pitch, Yaw + V.Yaw, Roll + V.Roll);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	movss	DWORD PTR tv76[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv76[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FRotator::FRotator
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1288 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??HFRotator@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FRotator::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z PROC		; IronMan::Core::Math::FRotator::FRotator, COMDAT

; 1275 : 			Roll(z) {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 1273 : 			: Pitch(x),

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR x$[rsp]
	movss	DWORD PTR [rax], xmm0

; 1274 : 			Yaw(y),

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 1275 : 			Roll(z) {

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR z$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 1276 : 		}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FRotator@Math@Core@IronMan@@QEAA@MMM@Z ENDP		; IronMan::Core::Math::FRotator::FRotator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FRotator@Math@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0FRotator@Math@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::Math::FRotator::FRotator, COMDAT

; 1268 : 		inline FRotator()

	mov	QWORD PTR [rsp+8], rcx

; 1269 : 			: Pitch(0), Yaw(0), Roll(0) {

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0

; 1270 : 		}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FRotator@Math@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::Math::FRotator::FRotator
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?SizeSquared@FVector2D@Math@Core@IronMan@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?SizeSquared@FVector2D@Math@Core@IronMan@@QEBAMXZ PROC	; IronMan::Core::Math::FVector2D::SizeSquared, COMDAT

; 1216 : 		__forceinline float FVector2D::SizeSquared() const {

	mov	QWORD PTR [rsp+8], rcx

; 1217 : 			return X * X + Y * Y;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1

; 1218 : 		}

	ret	0
?SizeSquared@FVector2D@Math@Core@IronMan@@QEBAMXZ ENDP	; IronMan::Core::Math::FVector2D::SizeSquared
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ
_TEXT	SEGMENT
this$ = 48
?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ PROC		; IronMan::Core::Math::FVector2D::Size, COMDAT

; 1212 : 		__forceinline float FVector2D::Size() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1213 : 			return sqrt(X * X + Y * Y);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	call	?sqrt@@YAMM@Z				; sqrt

; 1214 : 		}

	add	rsp, 40					; 00000028H
	ret	0
?Size@FVector2D@Math@Core@IronMan@@QEBAMXZ ENDP		; IronMan::Core::Math::FVector2D::Size
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z
_TEXT	SEGMENT
RScale$ = 32
this$ = 64
__$ReturnUdt$ = 72
Scale$ = 80
??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z PROC	; IronMan::Core::Math::FVector2D::operator/, COMDAT

; 1135 : 		__forceinline FVector2D FVector2D::operator/(float Scale) const {

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1136 : 			const float RScale = 1.f / Scale;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR Scale$[rsp]
	movss	DWORD PTR RScale$[rsp], xmm0

; 1137 : 			return FVector2D(X * RScale, Y * RScale);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR RScale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR RScale$[rsp]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z ; IronMan::Core::Math::FVector2D::FVector2D
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1138 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??KFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z ENDP	; IronMan::Core::Math::FVector2D::operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
Scale$ = 64
??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z PROC	; IronMan::Core::Math::FVector2D::operator*, COMDAT

; 1131 : 		__forceinline FVector2D FVector2D::operator*(float Scale) const {

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1132 : 			return FVector2D(X * Scale, Y * Scale);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	mulss	xmm0, DWORD PTR Scale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax]
	mulss	xmm1, DWORD PTR Scale$[rsp]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z ; IronMan::Core::Math::FVector2D::FVector2D
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1133 : 		}

	add	rsp, 40					; 00000028H
	ret	0
??DFVector2D@Math@Core@IronMan@@QEBA?AU0123@M@Z ENDP	; IronMan::Core::Math::FVector2D::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
V$ = 64
??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FVector2D::operator+, COMDAT

; 1125 : 		__forceinline FVector2D FVector2D::operator+(const FVector2D& V) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1126 : 			return FVector2D(X + V.X, Y + V.Y);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	addss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax]
	addss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z ; IronMan::Core::Math::FVector2D::FVector2D
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1127 : 		}

	add	rsp, 40					; 00000028H
	ret	0
??HFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FVector2D::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
V$ = 64
??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FVector2D::operator-, COMDAT

; 1121 : 		__forceinline FVector2D FVector2D::operator-(const FVector2D& V) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1122 : 			return FVector2D(X - V.X, Y - V.Y);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	subss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm1, DWORD PTR [rcx]
	movaps	xmm2, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z ; IronMan::Core::Math::FVector2D::FVector2D
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1123 : 		}

	add	rsp, 40					; 00000028H
	ret	0
??GFVector2D@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FVector2D::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z PROC		; IronMan::Core::Math::FVector2D::FVector2D, COMDAT

; 1106 : 			Y(y) {

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 1105 : 			: X(x),

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR x$[rsp]
	movss	DWORD PTR [rax], xmm0

; 1106 : 			Y(y) {

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 1107 : 		}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FVector2D@Math@Core@IronMan@@QEAA@MM@Z ENDP		; IronMan::Core::Math::FVector2D::FVector2D
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
A$ = 56
B$ = 64
?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z PROC ; IronMan::Core::Math::FVector::CrossProduct, COMDAT

; 1023 : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1024 : 		return A ^ B;

	mov	r8, QWORD PTR B$[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR A$[rsp]
	call	??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ; IronMan::Core::Math::FVector::operator^
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1025 : 	}

	add	rsp, 40					; 00000028H
	ret	0
?CrossProduct@FVector@Math@Core@IronMan@@SA?AU1234@AEBU1234@0@Z ENDP ; IronMan::Core::Math::FVector::CrossProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ
_TEXT	SEGMENT
tv89 = 32
tv87 = 36
tv85 = 40
this$ = 64
__$ReturnUdt$ = 72
?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ PROC ; IronMan::Core::Math::FVector::GetSignVector, COMDAT

; 1013 : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1014 : 		return FVector

	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	?FloatSelect@Math@Core@IronMan@@YAMMMM@Z ; IronMan::Core::Math::FloatSelect
	movss	DWORD PTR tv89[rsp], xmm0
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	?FloatSelect@Math@Core@IronMan@@YAMMMM@Z ; IronMan::Core::Math::FloatSelect
	movss	DWORD PTR tv87[rsp], xmm0
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@3f800000
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	?FloatSelect@Math@Core@IronMan@@YAMMMM@Z ; IronMan::Core::Math::FloatSelect
	movss	DWORD PTR tv85[rsp], xmm0
	movss	xmm3, DWORD PTR tv89[rsp]
	movss	xmm2, DWORD PTR tv87[rsp]
	movss	xmm1, DWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1015 : 		(
; 1016 : 			Math::FloatSelect(X, 1.f, -1.f),
; 1017 : 			Math::FloatSelect(Y, 1.f, -1.f),
; 1018 : 			Math::FloatSelect(Z, 1.f, -1.f)
; 1019 : 		);
; 1020 : 	}

	add	rsp, 56					; 00000038H
	ret	0
?GetSignVector@FVector@Math@Core@IronMan@@QEBA?AU1234@XZ ENDP ; IronMan::Core::Math::FVector::GetSignVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
Tolerance$ = 72
?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z PROC	; IronMan::Core::Math::FVector::IsNearlyZero, COMDAT

; 1005 : 	{

$LN5:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1006 : 		return

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@IsNearlyZe
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+4]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@IsNearlyZe
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	xmm1, DWORD PTR Tolerance$[rsp]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@IsNearlyZe
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@IsNearlyZe
$LN3@IsNearlyZe:
	mov	DWORD PTR tv76[rsp], 0
$LN4@IsNearlyZe:
	movzx	eax, BYTE PTR tv76[rsp]

; 1007 : 			Math::Abs(X) <= Tolerance
; 1008 : 			&& Math::Abs(Y) <= Tolerance
; 1009 : 			&& Math::Abs(Z) <= Tolerance;
; 1010 : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsNearlyZero@FVector@Math@Core@IronMan@@QEBA_NM@Z ENDP	; IronMan::Core::Math::FVector::IsNearlyZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z
_TEXT	SEGMENT
SquareSum$ = 32
Scale$ = 36
tv89 = 40
this$ = 80
__$ReturnUdt$ = 88
Tolerance$ = 96
?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z PROC ; IronMan::Core::Math::FVector::GetSafeNormal, COMDAT

; 1052 : 	{

$LN6:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 1053 : 		const float SquareSum = X * X + Y * Y + Z * Z;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR SquareSum$[rsp], xmm0

; 1054 : 
; 1055 : 		// Not sure if it's safe to add tolerance in there. Might introduce too many errors
; 1056 : 		if (SquareSum == 1.f)

	movss	xmm0, DWORD PTR SquareSum$[rsp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN2@GetSafeNor
	jne	SHORT $LN2@GetSafeNor

; 1057 : 		{
; 1058 : 			return *this;

	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR this$[rsp]
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetSafeNor

; 1059 : 		}

	jmp	SHORT $LN3@GetSafeNor
$LN2@GetSafeNor:

; 1060 : 		else if (SquareSum < Tolerance)

	movss	xmm0, DWORD PTR Tolerance$[rsp]
	comiss	xmm0, DWORD PTR SquareSum$[rsp]
	jbe	SHORT $LN4@GetSafeNor

; 1061 : 		{
; 1062 : 			return FVector::ZeroVector;

	lea	rax, OFFSET FLAT:?ZeroVector@FVector@Math@Core@IronMan@@2U1234@B ; IronMan::Core::Math::FVector::ZeroVector
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 12
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetSafeNor
$LN4@GetSafeNor:
$LN3@GetSafeNor:

; 1063 : 		}
; 1064 : 		const float Scale = Math::InvSqrt(SquareSum);

	movss	xmm0, DWORD PTR SquareSum$[rsp]
	call	?InvSqrt@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::InvSqrt
	movss	DWORD PTR Scale$[rsp], xmm0

; 1065 : 		return FVector(X * Scale, Y * Scale, Z * Scale);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR Scale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR Scale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mulss	xmm2, DWORD PTR Scale$[rsp]
	movss	DWORD PTR tv89[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv89[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetSafeNor:

; 1066 : 	}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?GetSafeNormal@FVector@Math@Core@IronMan@@QEBA?AU1234@M@Z ENDP ; IronMan::Core::Math::FVector::GetSafeNormal
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
tv88 = 32
this$ = 64
__$ReturnUdt$ = 72
V$ = 80
??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FVector::operator^, COMDAT

; 803  : 		__forceinline FVector FVector::operator^(const FVector& V) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 804  : 			return FVector

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx]
	subss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mulss	xmm2, DWORD PTR [rcx+8]
	subss	xmm1, xmm2
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR [rax+4]
	mulss	xmm2, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm3, DWORD PTR [rax+8]
	mulss	xmm3, DWORD PTR [rcx+4]
	subss	xmm2, xmm3
	movss	DWORD PTR tv88[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv88[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 805  : 			(
; 806  : 				Y * V.Z - Z * V.Y,
; 807  : 				Z * V.X - X * V.Z,
; 808  : 				X * V.Y - Y * V.X
; 809  : 			);
; 810  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??TFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FVector::operator^
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??UFVector@Math@Core@IronMan@@QEBAMAEBU0123@@Z
_TEXT	SEGMENT
this$ = 8
V$ = 16
??UFVector@Math@Core@IronMan@@QEBAMAEBU0123@@Z PROC	; IronMan::Core::Math::FVector::operator|, COMDAT

; 799  : 		__forceinline float FVector::operator|(const FVector& V) const {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 800  : 			return X * V.X + Y * V.Y + Z * V.Z;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax]
	mulss	xmm0, DWORD PTR [rcx]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+8]
	mulss	xmm1, DWORD PTR [rcx+8]
	addss	xmm0, xmm1

; 801  : 		}

	ret	0
??UFVector@Math@Core@IronMan@@QEBAMAEBU0123@@Z ENDP	; IronMan::Core::Math::FVector::operator|
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
__$ReturnUdt$ = 72
V$ = 80
??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FVector::operator*, COMDAT

; 791  : 		__forceinline FVector FVector::operator*(const FVector& V) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 792  : 			return FVector(X * V.X, Y * V.Y, Z * V.Z);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mulss	xmm2, DWORD PTR [rcx]
	movss	DWORD PTR tv76[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv76[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 793  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??DFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FVector::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z
_TEXT	SEGMENT
tv73 = 32
this$ = 64
__$ReturnUdt$ = 72
Scale$ = 80
??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z PROC	; IronMan::Core::Math::FVector::operator*, COMDAT

; 774  : 		__forceinline FVector FVector::operator*(float Scale) const {

$LN3:
	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 775  : 			return FVector(X * Scale, Y * Scale, Z * Scale);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	mulss	xmm0, DWORD PTR Scale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	mulss	xmm1, DWORD PTR Scale$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax]
	mulss	xmm2, DWORD PTR Scale$[rsp]
	movss	DWORD PTR tv73[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv73[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 776  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??DFVector@Math@Core@IronMan@@QEBA?AU0123@M@Z ENDP	; IronMan::Core::Math::FVector::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
__$ReturnUdt$ = 72
V$ = 80
??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FVector::operator+, COMDAT

; 766  : 		__forceinline FVector FVector::operator+(const FVector& V) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 767  : 			return FVector(X + V.X, Y + V.Y, Z + V.Z);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	addss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	addss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR [rax]
	addss	xmm2, DWORD PTR [rcx]
	movss	DWORD PTR tv76[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv76[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 768  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??HFVector@Math@Core@IronMan@@QEAA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FVector::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z
_TEXT	SEGMENT
tv76 = 32
this$ = 64
__$ReturnUdt$ = 72
V$ = 80
??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z PROC ; IronMan::Core::Math::FVector::operator-, COMDAT

; 762  : 		__forceinline FVector FVector::operator-(const FVector& V) const {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 763  : 			return FVector(X - V.X, Y - V.Y, Z - V.Z);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm0, DWORD PTR [rax+8]
	subss	xmm0, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm1, DWORD PTR [rax+4]
	subss	xmm1, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR V$[rsp]
	movss	xmm2, DWORD PTR [rax]
	subss	xmm2, DWORD PTR [rcx]
	movss	DWORD PTR tv76[rsp], xmm2
	movaps	xmm3, xmm0
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR tv76[rsp]
	movaps	xmm1, xmm0
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 764  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??GFVector@Math@Core@IronMan@@QEBA?AU0123@AEBU0123@@Z ENDP ; IronMan::Core::Math::FVector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FVector@Math@Core@IronMan@@QEAA@MMM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
??0FVector@Math@Core@IronMan@@QEAA@MMM@Z PROC		; IronMan::Core::Math::FVector::FVector, COMDAT

; 755  : 			Z(z) {

	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 753  : 			: X(x),

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR x$[rsp]
	movss	DWORD PTR [rax], xmm0

; 754  : 			Y(y),

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR [rax+4], xmm0

; 755  : 			Z(z) {

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR z$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 756  : 		}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ENDP		; IronMan::Core::Math::FVector::FVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FVector@Math@Core@IronMan@@QEAA@M@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
??0FVector@Math@Core@IronMan@@QEAA@M@Z PROC		; IronMan::Core::Math::FVector::FVector, COMDAT

; 748  : 		inline FVector(float f)

	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx

; 749  : 			: X(f), Y(f), Z(f) {

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR f$[rsp]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR f$[rsp]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR f$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 750  : 		}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FVector@Math@Core@IronMan@@QEAA@M@Z ENDP		; IronMan::Core::Math::FVector::FVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??0FVector@Math@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0FVector@Math@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::Math::FVector::FVector, COMDAT

; 745  : 		inline FVector()

	mov	QWORD PTR [rsp+8], rcx

; 746  : 			: X(0), Y(0), Z(0) {

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+8], xmm0

; 747  : 		}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FVector@Math@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::Math::FVector::FVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
nonnegative$ = 32
x$ = 36
result$ = 40
omx$ = 44
tv65 = 48
tv92 = 52
root$ = 56
Value$ = 80
?FastAsin@Math@Core@IronMan@@YAMM@Z PROC		; IronMan::Core::Math::FastAsin

; 709  : 	{

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 72					; 00000048H

; 710  : 		// Clamp input to [-1,1].
; 711  : 		bool nonnegative = (Value >= 0.0f);

	movss	xmm0, DWORD PTR Value$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN4@FastAsin
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN5@FastAsin
$LN4@FastAsin:
	mov	DWORD PTR tv65[rsp], 0
$LN5@FastAsin:
	movzx	eax, BYTE PTR tv65[rsp]
	mov	BYTE PTR nonnegative$[rsp], al

; 712  : 		float x = Math::Abs(Value);

	movss	xmm0, DWORD PTR Value$[rsp]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	DWORD PTR x$[rsp], xmm0

; 713  : 		float omx = 1.0f - x;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR x$[rsp]
	movss	DWORD PTR omx$[rsp], xmm0

; 714  : 		if (omx < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR omx$[rsp]
	jbe	SHORT $LN2@FastAsin

; 715  : 		{
; 716  : 			omx = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR omx$[rsp], xmm0
$LN2@FastAsin:

; 717  : 		}
; 718  : 		float root = Math::Sqrt(omx);

	movss	xmm0, DWORD PTR omx$[rsp]
	call	?Sqrt@Math@Core@IronMan@@YAMM@Z		; IronMan::Core::Math::Sqrt
	movss	DWORD PTR root$[rsp], xmm0

; 719  : 		// 7-degree minimax approximation
; 720  : 		float result = ((((((-0.0012624911f * x + 0.0066700901f) * x - 0.0170881256f) * x + 0.0308918810f) * x - 0.0501743046f) * x + 0.0889789874f) * x - 0.2145988016f) * x + FASTASIN_HALF_PI;

	movss	xmm0, DWORD PTR __real@baa57a2c
	mulss	xmm0, DWORD PTR x$[rsp]
	addss	xmm0, DWORD PTR __real@3bda90c5
	mulss	xmm0, DWORD PTR x$[rsp]
	subss	xmm0, DWORD PTR __real@3c8bfc66
	mulss	xmm0, DWORD PTR x$[rsp]
	addss	xmm0, DWORD PTR __real@3cfd10f8
	mulss	xmm0, DWORD PTR x$[rsp]
	subss	xmm0, DWORD PTR __real@3d4d8392
	mulss	xmm0, DWORD PTR x$[rsp]
	addss	xmm0, DWORD PTR __real@3db63a9e
	mulss	xmm0, DWORD PTR x$[rsp]
	subss	xmm0, DWORD PTR __real@3e5bbfca
	mulss	xmm0, DWORD PTR x$[rsp]
	addss	xmm0, DWORD PTR __real@3fc90fda
	movss	DWORD PTR result$[rsp], xmm0

; 721  : 		result *= root;  // acos(|x|)

	movss	xmm0, DWORD PTR result$[rsp]
	mulss	xmm0, DWORD PTR root$[rsp]
	movss	DWORD PTR result$[rsp], xmm0

; 722  : 		// acos(x) = pi - acos(-x) when x < 0, asin(x) = pi/2 - acos(x)
; 723  : 		return (nonnegative ? FASTASIN_HALF_PI - result : result - FASTASIN_HALF_PI);

	movzx	eax, BYTE PTR nonnegative$[rsp]
	test	eax, eax
	je	SHORT $LN6@FastAsin
	movss	xmm0, DWORD PTR __real@3fc90fda
	subss	xmm0, DWORD PTR result$[rsp]
	movss	DWORD PTR tv92[rsp], xmm0
	jmp	SHORT $LN7@FastAsin
$LN6@FastAsin:
	movss	xmm0, DWORD PTR result$[rsp]
	subss	xmm0, DWORD PTR __real@3fc90fda
	movss	DWORD PTR tv92[rsp], xmm0
$LN7@FastAsin:
	movss	xmm0, DWORD PTR tv92[rsp]

; 724  : 	}

	add	rsp, 72					; 00000048H
	ret	0
?FastAsin@Math@Core@IronMan@@YAMM@Z ENDP		; IronMan::Core::Math::FastAsin
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
IntPortion$ = 32
Quotient$ = 36
tv71 = 40
Result$ = 44
X$ = 64
Y$ = 72
?Fmod@Math@Core@IronMan@@YAMMM@Z PROC			; IronMan::Core::Math::Fmod

; 681  : 	{

	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 682  : 		if (fabsf(Y) <= 1.e-8f)

	movss	xmm0, DWORD PTR Y$[rsp]
	call	fabsf
	movss	xmm1, DWORD PTR __real@322bcc77
	comiss	xmm1, xmm0
	jb	SHORT $LN2@Fmod

; 683  : 		{
; 684  : 			//FmodReportError(X, Y);
; 685  : 			return 0.f;

	xorps	xmm0, xmm0
	jmp	SHORT $LN1@Fmod
$LN2@Fmod:

; 686  : 		}
; 687  : 		const float Quotient = TruncToFloat(X / Y);

	movss	xmm0, DWORD PTR X$[rsp]
	divss	xmm0, DWORD PTR Y$[rsp]
	call	?TruncToFloat@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::TruncToFloat
	movss	DWORD PTR Quotient$[rsp], xmm0

; 688  : 		float IntPortion = Y * Quotient;

	movss	xmm0, DWORD PTR Y$[rsp]
	mulss	xmm0, DWORD PTR Quotient$[rsp]
	movss	DWORD PTR IntPortion$[rsp], xmm0

; 689  : 
; 690  : 		// Rounding and imprecision could cause IntPortion to exceed X and cause the result to be outside the expected range.
; 691  : 		// For example Fmod(55.8, 9.3) would result in a very small negative value!
; 692  : 		if (fabsf(IntPortion) > fabsf(X))

	movss	xmm0, DWORD PTR IntPortion$[rsp]
	call	fabsf
	movss	DWORD PTR tv71[rsp], xmm0
	movss	xmm0, DWORD PTR X$[rsp]
	call	fabsf
	movss	xmm1, DWORD PTR tv71[rsp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@Fmod

; 693  : 		{
; 694  : 			IntPortion = X;

	movss	xmm0, DWORD PTR X$[rsp]
	movss	DWORD PTR IntPortion$[rsp], xmm0
$LN3@Fmod:

; 695  : 		}
; 696  : 
; 697  : 		const float Result = X - IntPortion;

	movss	xmm0, DWORD PTR X$[rsp]
	subss	xmm0, DWORD PTR IntPortion$[rsp]
	movss	DWORD PTR Result$[rsp], xmm0

; 698  : 		return Result;

	movss	xmm0, DWORD PTR Result$[rsp]
$LN1@Fmod:

; 699  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?Fmod@Math@Core@IronMan@@YAMMM@Z ENDP			; IronMan::Core::Math::Fmod
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?Atan2@Math@Core@IronMan@@YAMMM@Z
_TEXT	SEGMENT
t0$ = 32
yAbsBigger$ = 36
t3$ = 40
tv69 = 44
t4$ = 48
absX$ = 52
absY$ = 56
tv72 = 60
tv75 = 64
tv141 = 68
tv144 = 72
tv147 = 76
t1$ = 80
Y$ = 112
X$ = 120
?Atan2@Math@Core@IronMan@@YAMMM@Z PROC			; IronMan::Core::Math::Atan2, COMDAT

; 636  : 	{

$LN16:
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 104				; 00000068H

; 637  : 		//return atan2f(Y,X);
; 638  : 		// atan2f occasionally returns NaN with perfectly valid input (possibly due to a compiler or library bug).
; 639  : 		// We are replacing it with a minimax approximation with a max relative error of 7.15255737e-007 compared to the C library function.
; 640  : 		// On PC this has been measured to be 2x faster than the std C version.
; 641  : 
; 642  : 		const float absX = Math::Abs(X);

	movss	xmm0, DWORD PTR X$[rsp]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	DWORD PTR absX$[rsp], xmm0

; 643  : 		const float absY = Math::Abs(Y);

	movss	xmm0, DWORD PTR Y$[rsp]
	call	??$Abs@M@Math@Core@IronMan@@YAMM@Z	; IronMan::Core::Math::Abs<float>
	movss	DWORD PTR absY$[rsp], xmm0

; 644  : 		const bool yAbsBigger = (absY > absX);

	movss	xmm0, DWORD PTR absY$[rsp]
	comiss	xmm0, DWORD PTR absX$[rsp]
	jbe	SHORT $LN4@Atan2
	mov	BYTE PTR tv69[rsp], 1
	jmp	SHORT $LN5@Atan2
$LN4@Atan2:
	mov	BYTE PTR tv69[rsp], 0
$LN5@Atan2:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR yAbsBigger$[rsp], al

; 645  : 		float t0 = yAbsBigger ? absY : absX; // Max(absY, absX)

	movzx	eax, BYTE PTR yAbsBigger$[rsp]
	test	eax, eax
	je	SHORT $LN6@Atan2
	movss	xmm0, DWORD PTR absY$[rsp]
	movss	DWORD PTR tv72[rsp], xmm0
	jmp	SHORT $LN7@Atan2
$LN6@Atan2:
	movss	xmm0, DWORD PTR absX$[rsp]
	movss	DWORD PTR tv72[rsp], xmm0
$LN7@Atan2:
	movss	xmm0, DWORD PTR tv72[rsp]
	movss	DWORD PTR t0$[rsp], xmm0

; 646  : 		float t1 = yAbsBigger ? absX : absY; // Min(absX, absY)

	movzx	eax, BYTE PTR yAbsBigger$[rsp]
	test	eax, eax
	je	SHORT $LN8@Atan2
	movss	xmm0, DWORD PTR absX$[rsp]
	movss	DWORD PTR tv75[rsp], xmm0
	jmp	SHORT $LN9@Atan2
$LN8@Atan2:
	movss	xmm0, DWORD PTR absY$[rsp]
	movss	DWORD PTR tv75[rsp], xmm0
$LN9@Atan2:
	movss	xmm0, DWORD PTR tv75[rsp]
	movss	DWORD PTR t1$[rsp], xmm0

; 647  : 
; 648  : 		if (t0 == 0.f)

	movss	xmm0, DWORD PTR t0$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN2@Atan2
	jne	SHORT $LN2@Atan2

; 649  : 			return 0.f;

	xorps	xmm0, xmm0
	jmp	$LN1@Atan2
$LN2@Atan2:

; 650  : 
; 651  : 		float t3 = t1 / t0;

	movss	xmm0, DWORD PTR t1$[rsp]
	divss	xmm0, DWORD PTR t0$[rsp]
	movss	DWORD PTR t3$[rsp], xmm0

; 652  : 		float t4 = t3 * t3;

	movss	xmm0, DWORD PTR t3$[rsp]
	mulss	xmm0, DWORD PTR t3$[rsp]
	movss	DWORD PTR t4$[rsp], xmm0

; 653  : 
; 654  : 		static const float c[7] = {
; 655  : 			+7.2128853633444123e-03f,
; 656  : 			-3.5059680836411644e-02f,
; 657  : 			+8.1675882859940430e-02f,
; 658  : 			-1.3374657325451267e-01f,
; 659  : 			+1.9856563505717162e-01f,
; 660  : 			-3.3324998579202170e-01f,
; 661  : 			+1.0f
; 662  : 		};
; 663  : 
; 664  : 		t0 = c[0];

	mov	eax, 4
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB ; `IronMan::Core::Math::Atan2'::`2'::c
	movss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR t0$[rsp], xmm0

; 665  : 		t0 = t0 * t4 + c[1];

	movss	xmm0, DWORD PTR t0$[rsp]
	mulss	xmm0, DWORD PTR t4$[rsp]
	mov	eax, 4
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB ; `IronMan::Core::Math::Atan2'::`2'::c
	addss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR t0$[rsp], xmm0

; 666  : 		t0 = t0 * t4 + c[2];

	movss	xmm0, DWORD PTR t0$[rsp]
	mulss	xmm0, DWORD PTR t4$[rsp]
	mov	eax, 4
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB ; `IronMan::Core::Math::Atan2'::`2'::c
	addss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR t0$[rsp], xmm0

; 667  : 		t0 = t0 * t4 + c[3];

	movss	xmm0, DWORD PTR t0$[rsp]
	mulss	xmm0, DWORD PTR t4$[rsp]
	mov	eax, 4
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB ; `IronMan::Core::Math::Atan2'::`2'::c
	addss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR t0$[rsp], xmm0

; 668  : 		t0 = t0 * t4 + c[4];

	movss	xmm0, DWORD PTR t0$[rsp]
	mulss	xmm0, DWORD PTR t4$[rsp]
	mov	eax, 4
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB ; `IronMan::Core::Math::Atan2'::`2'::c
	addss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR t0$[rsp], xmm0

; 669  : 		t0 = t0 * t4 + c[5];

	movss	xmm0, DWORD PTR t0$[rsp]
	mulss	xmm0, DWORD PTR t4$[rsp]
	mov	eax, 4
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB ; `IronMan::Core::Math::Atan2'::`2'::c
	addss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR t0$[rsp], xmm0

; 670  : 		t0 = t0 * t4 + c[6];

	movss	xmm0, DWORD PTR t0$[rsp]
	mulss	xmm0, DWORD PTR t4$[rsp]
	mov	eax, 4
	imul	rax, rax, 6
	lea	rcx, OFFSET FLAT:?c@?1??Atan2@Math@Core@IronMan@@YAMMM@Z@4QBMB ; `IronMan::Core::Math::Atan2'::`2'::c
	addss	xmm0, DWORD PTR [rcx+rax]
	movss	DWORD PTR t0$[rsp], xmm0

; 671  : 		t3 = t0 * t3;

	movss	xmm0, DWORD PTR t0$[rsp]
	mulss	xmm0, DWORD PTR t3$[rsp]
	movss	DWORD PTR t3$[rsp], xmm0

; 672  : 
; 673  : 		t3 = yAbsBigger ? (0.5f * PI) - t3 : t3;

	movzx	eax, BYTE PTR yAbsBigger$[rsp]
	test	eax, eax
	je	SHORT $LN10@Atan2
	movss	xmm0, DWORD PTR __real@3fc90fda
	subss	xmm0, DWORD PTR t3$[rsp]
	movss	DWORD PTR tv141[rsp], xmm0
	jmp	SHORT $LN11@Atan2
$LN10@Atan2:
	movss	xmm0, DWORD PTR t3$[rsp]
	movss	DWORD PTR tv141[rsp], xmm0
$LN11@Atan2:
	movss	xmm0, DWORD PTR tv141[rsp]
	movss	DWORD PTR t3$[rsp], xmm0

; 674  : 		t3 = (X < 0.0f) ? PI - t3 : t3;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR X$[rsp]
	jbe	SHORT $LN12@Atan2
	movss	xmm0, DWORD PTR __real@40490fda
	subss	xmm0, DWORD PTR t3$[rsp]
	movss	DWORD PTR tv144[rsp], xmm0
	jmp	SHORT $LN13@Atan2
$LN12@Atan2:
	movss	xmm0, DWORD PTR t3$[rsp]
	movss	DWORD PTR tv144[rsp], xmm0
$LN13@Atan2:
	movss	xmm0, DWORD PTR tv144[rsp]
	movss	DWORD PTR t3$[rsp], xmm0

; 675  : 		t3 = (Y < 0.0f) ? -t3 : t3;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR Y$[rsp]
	jbe	SHORT $LN14@Atan2
	movss	xmm0, DWORD PTR t3$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv147[rsp], xmm0
	jmp	SHORT $LN15@Atan2
$LN14@Atan2:
	movss	xmm0, DWORD PTR t3$[rsp]
	movss	DWORD PTR tv147[rsp], xmm0
$LN15@Atan2:
	movss	xmm0, DWORD PTR tv147[rsp]
	movss	DWORD PTR t3$[rsp], xmm0

; 676  : 
; 677  : 		return t3;

	movss	xmm0, DWORD PTR t3$[rsp]
$LN1@Atan2:

; 678  : 	}

	add	rsp, 104				; 00000068H
	ret	0
?Atan2@Math@Core@IronMan@@YAMMM@Z ENDP			; IronMan::Core::Math::Atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z
_TEXT	SEGMENT
M$ = 32
RDet$ = 40
Determinant$ = 44
Det$ = 48
Tmp$ = 64
Result$ = 128
__$ArrayPad$ = 192
DstMatrix$ = 224
SrcMatrix$ = 232
?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z PROC ; IronMan::Core::Math::VectorMatrixInverse, COMDAT

; 552  : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 553  : 		typedef float Float4x4[4][4];
; 554  : 		const Float4x4& M = *((const Float4x4*)SrcMatrix);

	mov	rax, QWORD PTR SrcMatrix$[rsp]
	mov	QWORD PTR M$[rsp], rax

; 555  : 		Float4x4 Result;
; 556  : 		float Det[4];
; 557  : 		Float4x4 Tmp;
; 558  : 
; 559  : 		Tmp[0][0] = M[2][2] * M[3][3] - M[2][3] * M[3][2];

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 560  : 		Tmp[0][1] = M[1][2] * M[3][3] - M[1][3] * M[3][2];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 561  : 		Tmp[0][2] = M[1][2] * M[2][3] - M[1][3] * M[2][2];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 562  : 
; 563  : 		Tmp[1][0] = M[2][2] * M[3][3] - M[2][3] * M[3][2];

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 564  : 		Tmp[1][1] = M[0][2] * M[3][3] - M[0][3] * M[3][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 565  : 		Tmp[1][2] = M[0][2] * M[2][3] - M[0][3] * M[2][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 566  : 
; 567  : 		Tmp[2][0] = M[1][2] * M[3][3] - M[1][3] * M[3][2];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 568  : 		Tmp[2][1] = M[0][2] * M[3][3] - M[0][3] * M[3][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 569  : 		Tmp[2][2] = M[0][2] * M[1][3] - M[0][3] * M[1][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 570  : 
; 571  : 		Tmp[3][0] = M[1][2] * M[2][3] - M[1][3] * M[2][2];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 572  : 		Tmp[3][1] = M[0][2] * M[2][3] - M[0][3] * M[2][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 573  : 		Tmp[3][2] = M[0][2] * M[1][3] - M[0][3] * M[1][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Tmp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 574  : 
; 575  : 		Det[0] = M[1][1] * Tmp[0][0] - M[2][1] * Tmp[0][1] + M[3][1] * Tmp[0][2];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 0
	movss	DWORD PTR Det$[rsp+rax], xmm0

; 576  : 		Det[1] = M[0][1] * Tmp[1][0] - M[2][1] * Tmp[1][1] + M[3][1] * Tmp[1][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 1
	movss	DWORD PTR Det$[rsp+rax], xmm0

; 577  : 		Det[2] = M[0][1] * Tmp[2][0] - M[1][1] * Tmp[2][1] + M[3][1] * Tmp[2][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 2
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 2
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 2
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 2
	movss	DWORD PTR Det$[rsp+rax], xmm0

; 578  : 		Det[3] = M[0][1] * Tmp[3][0] - M[1][1] * Tmp[3][1] + M[2][1] * Tmp[3][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 3
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 3
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 3
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 3
	movss	DWORD PTR Det$[rsp+rax], xmm0

; 579  : 
; 580  : 		float Determinant = M[0][0] * Det[0] - M[1][0] * Det[1] + M[2][0] * Det[2] - M[3][0] * Det[3];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR Det$[rsp+rdx]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR Det$[rsp+rdx]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR Det$[rsp+rdx]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR Det$[rsp+rdx]
	subss	xmm0, xmm1
	movss	DWORD PTR Determinant$[rsp], xmm0

; 581  : 		const float	RDet = 1.0f / Determinant;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR Determinant$[rsp]
	movss	DWORD PTR RDet$[rsp], xmm0

; 582  : 
; 583  : 		Result[0][0] = RDet * Det[0];

	mov	eax, 4
	imul	rax, rax, 0
	movss	xmm0, DWORD PTR RDet$[rsp]
	mulss	xmm0, DWORD PTR Det$[rsp+rax]
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 584  : 		Result[0][1] = -RDet * Det[1];

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	rax, rax, 1
	mulss	xmm0, DWORD PTR Det$[rsp+rax]
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 585  : 		Result[0][2] = RDet * Det[2];

	mov	eax, 4
	imul	rax, rax, 2
	movss	xmm0, DWORD PTR RDet$[rsp]
	mulss	xmm0, DWORD PTR Det$[rsp+rax]
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 586  : 		Result[0][3] = -RDet * Det[3];

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	rax, rax, 3
	mulss	xmm0, DWORD PTR Det$[rsp+rax]
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 587  : 		Result[1][0] = -RDet * (M[1][0] * Tmp[0][0] - M[2][0] * Tmp[0][1] + M[3][0] * Tmp[0][2]);

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, DWORD PTR [rdx+r8]
	subss	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, DWORD PTR [rdx+r8]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 588  : 		Result[1][1] = RDet * (M[0][0] * Tmp[1][0] - M[2][0] * Tmp[1][1] + M[3][0] * Tmp[1][2]);

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR RDet$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 589  : 		Result[1][2] = -RDet * (M[0][0] * Tmp[2][0] - M[1][0] * Tmp[2][1] + M[3][0] * Tmp[2][2]);

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, DWORD PTR [rdx+r8]
	subss	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, DWORD PTR [rdx+r8]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 590  : 		Result[1][3] = RDet * (M[0][0] * Tmp[3][0] - M[1][0] * Tmp[3][1] + M[2][0] * Tmp[3][2]);

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 3
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 3
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 3
	lea	rdx, QWORD PTR Tmp$[rsp+rdx]
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR RDet$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 591  : 		Result[2][0] = RDet * (

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm0, DWORD PTR [rdx+r8]
	mulss	xmm0, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR RDet$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 592  : 			M[1][0] * (M[2][1] * M[3][3] - M[2][3] * M[3][1]) -
; 593  : 			M[2][0] * (M[1][1] * M[3][3] - M[1][3] * M[3][1]) +
; 594  : 			M[3][0] * (M[1][1] * M[2][3] - M[1][3] * M[2][1])
; 595  : 			);
; 596  : 		Result[2][1] = -RDet * (

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 597  : 			M[0][0] * (M[2][1] * M[3][3] - M[2][3] * M[3][1]) -
; 598  : 			M[2][0] * (M[0][1] * M[3][3] - M[0][3] * M[3][1]) +
; 599  : 			M[3][0] * (M[0][1] * M[2][3] - M[0][3] * M[2][1])
; 600  : 			);
; 601  : 		Result[2][2] = RDet * (

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm0, DWORD PTR [rdx+r8]
	mulss	xmm0, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR RDet$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 602  : 			M[0][0] * (M[1][1] * M[3][3] - M[1][3] * M[3][1]) -
; 603  : 			M[1][0] * (M[0][1] * M[3][3] - M[0][3] * M[3][1]) +
; 604  : 			M[3][0] * (M[0][1] * M[1][3] - M[0][3] * M[1][1])
; 605  : 			);
; 606  : 		Result[2][3] = -RDet * (

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 3
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 607  : 			M[0][0] * (M[1][1] * M[2][3] - M[1][3] * M[2][1]) -
; 608  : 			M[1][0] * (M[0][1] * M[2][3] - M[0][3] * M[2][1]) +
; 609  : 			M[2][0] * (M[0][1] * M[1][3] - M[0][3] * M[1][1])
; 610  : 			);
; 611  : 		Result[3][0] = -RDet * (

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 612  : 			M[1][0] * (M[2][1] * M[3][2] - M[2][2] * M[3][1]) -
; 613  : 			M[2][0] * (M[1][1] * M[3][2] - M[1][2] * M[3][1]) +
; 614  : 			M[3][0] * (M[1][1] * M[2][2] - M[1][2] * M[2][1])
; 615  : 			);
; 616  : 		Result[3][1] = RDet * (

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm0, DWORD PTR [rdx+r8]
	mulss	xmm0, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR RDet$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 617  : 			M[0][0] * (M[2][1] * M[3][2] - M[2][2] * M[3][1]) -
; 618  : 			M[2][0] * (M[0][1] * M[3][2] - M[0][2] * M[3][1]) +
; 619  : 			M[3][0] * (M[0][1] * M[2][2] - M[0][2] * M[2][1])
; 620  : 			);
; 621  : 		Result[3][2] = -RDet * (

	movss	xmm0, DWORD PTR RDet$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 3
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	subss	xmm1, xmm2
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm3, DWORD PTR [rdx+r8]
	mulss	xmm3, DWORD PTR [r9+r10]
	subss	xmm2, xmm3
	movss	xmm3, DWORD PTR [rax+rcx]
	mulss	xmm3, xmm2
	movaps	xmm2, xmm3
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 622  : 			M[0][0] * (M[1][1] * M[3][2] - M[1][2] * M[3][1]) -
; 623  : 			M[1][0] * (M[0][1] * M[3][2] - M[0][2] * M[3][1]) +
; 624  : 			M[3][0] * (M[0][1] * M[1][2] - M[0][2] * M[1][1])
; 625  : 			);
; 626  : 		Result[3][3] = RDet * (

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm0, DWORD PTR [rdx+r8]
	mulss	xmm0, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 2
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	subss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR M$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 2
	movss	xmm1, DWORD PTR [rdx+r8]
	mulss	xmm1, DWORD PTR [r9+r10]
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR M$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	mov	r9d, 16
	imul	r9, r9, 1
	mov	r10, QWORD PTR M$[rsp]
	add	r10, r9
	mov	r9, r10
	mov	r10d, 4
	imul	r10, r10, 1
	movss	xmm2, DWORD PTR [rdx+r8]
	mulss	xmm2, DWORD PTR [r9+r10]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [rax+rcx]
	mulss	xmm2, xmm1
	movaps	xmm1, xmm2
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR RDet$[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Result$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 627  : 			M[0][0] * (M[1][1] * M[2][2] - M[1][2] * M[2][1]) -
; 628  : 			M[1][0] * (M[0][1] * M[2][2] - M[0][2] * M[2][1]) +
; 629  : 			M[2][0] * (M[0][1] * M[1][2] - M[0][2] * M[1][1])
; 630  : 			);
; 631  : 
; 632  : 		memcpy(DstMatrix, &Result, 16 * sizeof(float));

	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR Result$[rsp]
	mov	rcx, QWORD PTR DstMatrix$[rsp]
	call	memcpy
	npad	1

; 633  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 216				; 000000d8H
	ret	0
?VectorMatrixInverse@Math@Core@IronMan@@YAXPEAXPEBX@Z ENDP ; IronMan::Core::Math::VectorMatrixInverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z
_TEXT	SEGMENT
TX$ = 0
TY$ = 4
TZ$ = 8
TW$ = 12
A$ = 16
B$ = 24
R$ = 32
Result$ = 64
Quat1$ = 72
Quat2$ = 80
?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z PROC ; IronMan::Core::Math::VectorQuaternionMultiply, COMDAT

; 508  : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 509  : 		typedef float Float4[4];
; 510  : 		const Float4& A = *((const Float4*)Quat1);

	mov	rax, QWORD PTR Quat1$[rsp]
	mov	QWORD PTR A$[rsp], rax

; 511  : 		const Float4& B = *((const Float4*)Quat2);

	mov	rax, QWORD PTR Quat2$[rsp]
	mov	QWORD PTR B$[rsp], rax

; 512  : 		Float4& R = *((Float4*)Result);

	mov	rax, QWORD PTR Result$[rsp]
	mov	QWORD PTR R$[rsp], rax

; 513  : 
; 514  : #if USE_FAST_QUAT_MUL
; 515  : 		const float T0 = (A[2] - A[1]) * (B[1] - B[2]);
; 516  : 		const float T1 = (A[3] + A[0]) * (B[3] + B[0]);
; 517  : 		const float T2 = (A[3] - A[0]) * (B[1] + B[2]);
; 518  : 		const float T3 = (A[1] + A[2]) * (B[3] - B[0]);
; 519  : 		const float T4 = (A[2] - A[0]) * (B[0] - B[1]);
; 520  : 		const float T5 = (A[2] + A[0]) * (B[0] + B[1]);
; 521  : 		const float T6 = (A[3] + A[1]) * (B[3] - B[2]);
; 522  : 		const float T7 = (A[3] - A[1]) * (B[3] + B[2]);
; 523  : 		const float T8 = T5 + T6 + T7;
; 524  : 		const float T9 = 0.5f * (T4 + T8);
; 525  : 
; 526  : 		R[0] = T1 + T9 - T8;
; 527  : 		R[1] = T2 + T9 - T7;
; 528  : 		R[2] = T3 + T9 - T6;
; 529  : 		R[3] = T0 + T9 - T5;
; 530  : #else
; 531  : 		// store intermediate results in temporaries
; 532  : 		const float TX = A[3] * B[0] + A[0] * B[3] + A[1] * B[2] - A[2] * B[1];

	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm0, DWORD PTR [rdx+rax]
	mulss	xmm0, DWORD PTR [r8+rcx]
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	subss	xmm0, xmm1
	movss	DWORD PTR TX$[rsp], xmm0

; 533  : 		const float TY = A[3] * B[1] - A[0] * B[2] + A[1] * B[3] + A[2] * B[0];

	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm0, DWORD PTR [rdx+rax]
	mulss	xmm0, DWORD PTR [r8+rcx]
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	subss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	addss	xmm0, xmm1
	movss	DWORD PTR TY$[rsp], xmm0

; 534  : 		const float TZ = A[3] * B[2] + A[0] * B[1] - A[1] * B[0] + A[2] * B[3];

	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm0, DWORD PTR [rdx+rax]
	mulss	xmm0, DWORD PTR [r8+rcx]
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	subss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	addss	xmm0, xmm1
	movss	DWORD PTR TZ$[rsp], xmm0

; 535  : 		const float TW = A[3] * B[3] - A[0] * B[0] - A[1] * B[1] - A[2] * B[2];

	mov	eax, 4
	imul	rax, rax, 3
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm0, DWORD PTR [rdx+rax]
	mulss	xmm0, DWORD PTR [r8+rcx]
	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	subss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 1
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	subss	xmm0, xmm1
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR A$[rsp]
	mov	r8, QWORD PTR B$[rsp]
	movss	xmm1, DWORD PTR [rdx+rax]
	mulss	xmm1, DWORD PTR [r8+rcx]
	subss	xmm0, xmm1
	movss	DWORD PTR TW$[rsp], xmm0

; 536  : 
; 537  : 		// copy intermediate result to *this
; 538  : 		R[0] = TX;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR R$[rsp]
	movss	xmm0, DWORD PTR TX$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 539  : 		R[1] = TY;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR R$[rsp]
	movss	xmm0, DWORD PTR TY$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 540  : 		R[2] = TZ;

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR R$[rsp]
	movss	xmm0, DWORD PTR TZ$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 541  : 		R[3] = TW;

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR R$[rsp]
	movss	xmm0, DWORD PTR TW$[rsp]
	movss	DWORD PTR [rcx+rax], xmm0

; 542  : #endif
; 543  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?VectorQuaternionMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z ENDP ; IronMan::Core::Math::VectorQuaternionMultiply
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z
_TEXT	SEGMENT
A$ = 32
B$ = 40
Temp$ = 48
__$ArrayPad$ = 112
Result$ = 144
Matrix1$ = 152
Matrix2$ = 160
?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z PROC ; IronMan::Core::Math::VectorMatrixMultiply, COMDAT

; 470  : 	{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 471  : 		typedef float Float4x4[4][4];
; 472  : 		const Float4x4& A = *((const Float4x4*)Matrix1);

	mov	rax, QWORD PTR Matrix1$[rsp]
	mov	QWORD PTR A$[rsp], rax

; 473  : 		const Float4x4& B = *((const Float4x4*)Matrix2);

	mov	rax, QWORD PTR Matrix2$[rsp]
	mov	QWORD PTR B$[rsp], rax

; 474  : 		Float4x4 Temp;
; 475  : 		Temp[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0] + A[0][2] * B[2][0] + A[0][3] * B[3][0];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 476  : 		Temp[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1] + A[0][2] * B[2][1] + A[0][3] * B[3][1];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 477  : 		Temp[0][2] = A[0][0] * B[0][2] + A[0][1] * B[1][2] + A[0][2] * B[2][2] + A[0][3] * B[3][2];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 478  : 		Temp[0][3] = A[0][0] * B[0][3] + A[0][1] * B[1][3] + A[0][2] * B[2][3] + A[0][3] * B[3][3];

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 0
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 479  : 
; 480  : 		Temp[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0] + A[1][2] * B[2][0] + A[1][3] * B[3][0];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 481  : 		Temp[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1] + A[1][2] * B[2][1] + A[1][3] * B[3][1];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 482  : 		Temp[1][2] = A[1][0] * B[0][2] + A[1][1] * B[1][2] + A[1][2] * B[2][2] + A[1][3] * B[3][2];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 483  : 		Temp[1][3] = A[1][0] * B[0][3] + A[1][1] * B[1][3] + A[1][2] * B[2][3] + A[1][3] * B[3][3];

	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 1
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 484  : 
; 485  : 		Temp[2][0] = A[2][0] * B[0][0] + A[2][1] * B[1][0] + A[2][2] * B[2][0] + A[2][3] * B[3][0];

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 486  : 		Temp[2][1] = A[2][0] * B[0][1] + A[2][1] * B[1][1] + A[2][2] * B[2][1] + A[2][3] * B[3][1];

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 487  : 		Temp[2][2] = A[2][0] * B[0][2] + A[2][1] * B[1][2] + A[2][2] * B[2][2] + A[2][3] * B[3][2];

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 488  : 		Temp[2][3] = A[2][0] * B[0][3] + A[2][1] * B[1][3] + A[2][2] * B[2][3] + A[2][3] * B[3][3];

	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 2
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 489  : 
; 490  : 		Temp[3][0] = A[3][0] * B[0][0] + A[3][1] * B[1][0] + A[3][2] * B[2][0] + A[3][3] * B[3][0];

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 0
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 0
	movss	DWORD PTR [rax+rcx], xmm0

; 491  : 		Temp[3][1] = A[3][0] * B[0][1] + A[3][1] * B[1][1] + A[3][2] * B[2][1] + A[3][3] * B[3][1];

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 1
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 1
	movss	DWORD PTR [rax+rcx], xmm0

; 492  : 		Temp[3][2] = A[3][0] * B[0][2] + A[3][1] * B[1][2] + A[3][2] * B[2][2] + A[3][3] * B[3][2];

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 2
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 2
	movss	DWORD PTR [rax+rcx], xmm0

; 493  : 		Temp[3][3] = A[3][0] * B[0][3] + A[3][1] * B[1][3] + A[3][2] * B[2][3] + A[3][3] * B[3][3];

	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 16
	imul	rdx, rdx, 0
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm0, DWORD PTR [rax+rcx]
	mulss	xmm0, DWORD PTR [rdx+r8]
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 16
	imul	rdx, rdx, 1
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 16
	imul	rdx, rdx, 2
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	mov	rcx, QWORD PTR A$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 16
	imul	rdx, rdx, 3
	mov	r8, QWORD PTR B$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	r8d, 4
	imul	r8, r8, 3
	movss	xmm1, DWORD PTR [rax+rcx]
	mulss	xmm1, DWORD PTR [rdx+r8]
	addss	xmm0, xmm1
	mov	eax, 16
	imul	rax, rax, 3
	lea	rax, QWORD PTR Temp$[rsp+rax]
	mov	ecx, 4
	imul	rcx, rcx, 3
	movss	DWORD PTR [rax+rcx], xmm0

; 494  : 		memcpy(Result, &Temp, 16 * sizeof(float));

	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR Temp$[rsp]
	mov	rcx, QWORD PTR Result$[rsp]
	call	memcpy
	npad	1

; 495  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
?VectorMatrixMultiply@Math@Core@IronMan@@YAXPEAXPEBX1@Z ENDP ; IronMan::Core::Math::VectorMatrixMultiply
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
y2$ = 0
y$ = 4
quotient$ = 8
sign$ = 12
p$ = 16
ScalarSin$ = 48
ScalarCos$ = 56
Value$ = 64
?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z PROC		; IronMan::Core::Math::SinCos

; 422  : 	{

	movss	DWORD PTR [rsp+24], xmm2
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 423  : 		// Map Value to y in [-pi,pi], x = 2*pi*quotient + remainder.
; 424  : 		float quotient = (INV_PI * 0.5f) * Value;

	movss	xmm0, DWORD PTR __real@3e22f983
	mulss	xmm0, DWORD PTR Value$[rsp]
	movss	DWORD PTR quotient$[rsp], xmm0

; 425  : 		if (Value >= 0.0f)

	movss	xmm0, DWORD PTR Value$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN2@SinCos

; 426  : 		{
; 427  : 			quotient = (float)((int)(quotient + 0.5f));

	movss	xmm0, DWORD PTR quotient$[rsp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR quotient$[rsp], xmm0

; 428  : 		}

	jmp	SHORT $LN3@SinCos
$LN2@SinCos:

; 429  : 		else
; 430  : 		{
; 431  : 			quotient = (float)((int)(quotient - 0.5f));

	movss	xmm0, DWORD PTR quotient$[rsp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR quotient$[rsp], xmm0
$LN3@SinCos:

; 432  : 		}
; 433  : 		float y = Value - (2.0f * PI) * quotient;

	movss	xmm0, DWORD PTR __real@40c90fda
	mulss	xmm0, DWORD PTR quotient$[rsp]
	movss	xmm1, DWORD PTR Value$[rsp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR y$[rsp], xmm0

; 434  : 
; 435  : 		// Map y to [-pi/2,pi/2] with sin(y) = sin(Value).
; 436  : 		float sign;
; 437  : 		if (y > HALF_PI)

	movss	xmm0, DWORD PTR y$[rsp]
	comiss	xmm0, DWORD PTR __real@3fc90fdb
	jbe	SHORT $LN4@SinCos

; 438  : 		{
; 439  : 			y = PI - y;

	movss	xmm0, DWORD PTR __real@40490fda
	subss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR y$[rsp], xmm0

; 440  : 			sign = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR sign$[rsp], xmm0

; 441  : 		}

	jmp	SHORT $LN5@SinCos
$LN4@SinCos:

; 442  : 		else if (y < -HALF_PI)

	movss	xmm0, DWORD PTR __real@bfc90fdb
	comiss	xmm0, DWORD PTR y$[rsp]
	jbe	SHORT $LN6@SinCos

; 443  : 		{
; 444  : 			y = -PI - y;

	movss	xmm0, DWORD PTR __real@c0490fda
	subss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR y$[rsp], xmm0

; 445  : 			sign = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR sign$[rsp], xmm0

; 446  : 		}

	jmp	SHORT $LN7@SinCos
$LN6@SinCos:

; 447  : 		else
; 448  : 		{
; 449  : 			sign = +1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR sign$[rsp], xmm0
$LN7@SinCos:
$LN5@SinCos:

; 450  : 		}
; 451  : 
; 452  : 		float y2 = y * y;

	movss	xmm0, DWORD PTR y$[rsp]
	mulss	xmm0, DWORD PTR y$[rsp]
	movss	DWORD PTR y2$[rsp], xmm0

; 453  : 
; 454  : 		// 11-degree minimax approximation
; 455  : 		*ScalarSin = (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;

	movss	xmm0, DWORD PTR __real@b2cd365b
	mulss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR __real@3638b88e
	mulss	xmm0, DWORD PTR y2$[rsp]
	subss	xmm0, DWORD PTR __real@39500bf1
	mulss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR __real@3c088886
	mulss	xmm0, DWORD PTR y2$[rsp]
	subss	xmm0, DWORD PTR __real@3e2aaaab
	mulss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR y$[rsp]
	mov	rax, QWORD PTR ScalarSin$[rsp]
	movss	DWORD PTR [rax], xmm0

; 456  : 
; 457  : 		// 10-degree minimax approximation
; 458  : 		float p = ((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f;

	movss	xmm0, DWORD PTR __real@b48bdd11
	mulss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR __real@37cfb4c2
	mulss	xmm0, DWORD PTR y2$[rsp]
	subss	xmm0, DWORD PTR __real@3ab609aa
	mulss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR __real@3d2aaaa3
	mulss	xmm0, DWORD PTR y2$[rsp]
	subss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR y2$[rsp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR p$[rsp], xmm0

; 459  : 		*ScalarCos = sign * p;

	movss	xmm0, DWORD PTR sign$[rsp]
	mulss	xmm0, DWORD PTR p$[rsp]
	mov	rax, QWORD PTR ScalarCos$[rsp]
	movss	DWORD PTR [rax], xmm0

; 460  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?SinCos@Math@Core@IronMan@@YAXPEAM0M@Z ENDP		; IronMan::Core::Math::SinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
tv66 = 0
A$ = 32
??$Abs@M@Math@Core@IronMan@@YAMM@Z PROC			; IronMan::Core::Math::Abs<float>

; 399  : 	{

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 400  : 		return (A >= (T)0) ? A : -A;

	movss	xmm0, DWORD PTR A$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN3@Abs
	movss	xmm0, DWORD PTR A$[rsp]
	movss	DWORD PTR tv66[rsp], xmm0
	jmp	SHORT $LN4@Abs
$LN3@Abs:
	movss	xmm0, DWORD PTR A$[rsp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv66[rsp], xmm0
$LN4@Abs:
	movss	xmm0, DWORD PTR tv66[rsp]

; 401  : 	}

	add	rsp, 24
	ret	0
??$Abs@M@Math@Core@IronMan@@YAMM@Z ENDP			; IronMan::Core::Math::Abs<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
tv65 = 0
Comparand$ = 32
ValueGEZero$ = 40
ValueLTZero$ = 48
?FloatSelect@Math@Core@IronMan@@YAMMMM@Z PROC		; IronMan::Core::Math::FloatSelect

; 357  : 	{

	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 358  : 		return Comparand >= 0.f ? ValueGEZero : ValueLTZero;

	movss	xmm0, DWORD PTR Comparand$[rsp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN3@FloatSelec
	movss	xmm0, DWORD PTR ValueGEZero$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN4@FloatSelec
$LN3@FloatSelec:
	movss	xmm0, DWORD PTR ValueLTZero$[rsp]
	movss	DWORD PTR tv65[rsp], xmm0
$LN4@FloatSelec:
	movss	xmm0, DWORD PTR tv65[rsp]

; 359  : 	}

	add	rsp, 24
	ret	0
?FloatSelect@Math@Core@IronMan@@YAMMMM@Z ENDP		; IronMan::Core::Math::FloatSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
Value$ = 48
?Sqrt@Math@Core@IronMan@@YAMM@Z PROC			; IronMan::Core::Math::Sqrt

; 340  : 	static FORCEINLINE float Sqrt(float Value) { return sqrtf(Value); }

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H
	movss	xmm0, DWORD PTR Value$[rsp]
	call	sqrtf
	add	rsp, 40					; 00000028H
	ret	0
?Sqrt@Math@Core@IronMan@@YAMM@Z ENDP			; IronMan::Core::Math::Sqrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
X1$ = 0
temp$ = 16
X2$ = 32
X0$ = 48
fOneHalf$ = 64
Y0$ = 80
FOver2$ = 96
$T1 = 112
$T2 = 128
$T3 = 144
$T4 = 160
$T5 = 176
$T6 = 192
$T7 = 208
$T8 = 224
$T9 = 240
$T10 = 256
$T11 = 272
$T12 = 288
$T13 = 304
$T14 = 320
F$ = 352
?InvSqrt@Math@Core@IronMan@@YAMM@Z PROC			; IronMan::Core::Math::InvSqrt

; 294  : 	{

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 344				; 00000158H

; 295  : 		/*return 1.0f / sqrtf(F);*/
; 296  : 
; 297  : 		// Performs two passes of Newton-Raphson iteration on the hardware estimate
; 298  : 		//    v^-0.5 = x
; 299  : 		// => x^2 = v^-1
; 300  : 		// => 1/(x^2) = v
; 301  : 		// => F(x) = x^-2 - v
; 302  : 		//    F'(x) = -2x^-3
; 303  : 
; 304  : 		//    x1 = x0 - F(x0)/F'(x0)
; 305  : 		// => x1 = x0 + 0.5 * (x0^-2 - Vec) * x0^3
; 306  : 		// => x1 = x0 + 0.5 * (x0 - Vec * x0^3)
; 307  : 		// => x1 = x0 + x0 * (0.5 - 0.5 * Vec * x0^2)
; 308  : 		//
; 309  : 		// This final form has one more operation than the legacy factorization (X1 = 0.5*X0*(3-(Y*X0)*X0)
; 310  : 		// but retains better accuracy (namely InvSqrt(1) = 1 exactly).
; 311  : 
; 312  : 		const __m128 fOneHalf = _mm_set_ss(0.5f);

	movss	xmm0, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
	movss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]
	movaps	XMMWORD PTR fOneHalf$[rsp], xmm0

; 313  : 		__m128 Y0, X0, X1, X2, FOver2;
; 314  : 		float temp;
; 315  : 
; 316  : 		Y0 = _mm_set_ss(F);

	movss	xmm0, DWORD PTR F$[rsp]
	xorps	xmm1, xmm1
	movss	xmm1, xmm0
	movaps	xmm0, xmm1
	movaps	XMMWORD PTR $T2[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T2[rsp]
	movaps	XMMWORD PTR Y0$[rsp], xmm0

; 317  : 		X0 = _mm_rsqrt_ss(Y0);	// 1/sqrt estimate (12 bits)

	movaps	xmm0, XMMWORD PTR Y0$[rsp]
	rsqrtss	xmm0, xmm0
	movaps	XMMWORD PTR $T3[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T3[rsp]
	movaps	XMMWORD PTR X0$[rsp], xmm0

; 318  : 		FOver2 = _mm_mul_ss(Y0, fOneHalf);

	movaps	xmm0, XMMWORD PTR Y0$[rsp]
	mulss	xmm0, DWORD PTR fOneHalf$[rsp]
	movaps	XMMWORD PTR $T4[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T4[rsp]
	movaps	XMMWORD PTR FOver2$[rsp], xmm0

; 319  : 
; 320  : 		// 1st Newton-Raphson iteration
; 321  : 		X1 = _mm_mul_ss(X0, X0);

	movaps	xmm0, XMMWORD PTR X0$[rsp]
	mulss	xmm0, DWORD PTR X0$[rsp]
	movaps	XMMWORD PTR $T5[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T5[rsp]
	movaps	XMMWORD PTR X1$[rsp], xmm0

; 322  : 		X1 = _mm_sub_ss(fOneHalf, _mm_mul_ss(FOver2, X1));

	movaps	xmm0, XMMWORD PTR FOver2$[rsp]
	mulss	xmm0, DWORD PTR X1$[rsp]
	movaps	XMMWORD PTR $T6[rsp], xmm0
	movaps	xmm0, XMMWORD PTR fOneHalf$[rsp]
	subss	xmm0, DWORD PTR $T6[rsp]
	movaps	XMMWORD PTR $T7[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T7[rsp]
	movaps	XMMWORD PTR X1$[rsp], xmm0

; 323  : 		X1 = _mm_add_ss(X0, _mm_mul_ss(X0, X1));

	movaps	xmm0, XMMWORD PTR X0$[rsp]
	mulss	xmm0, DWORD PTR X1$[rsp]
	movaps	XMMWORD PTR $T8[rsp], xmm0
	movaps	xmm0, XMMWORD PTR X0$[rsp]
	addss	xmm0, DWORD PTR $T8[rsp]
	movaps	XMMWORD PTR $T9[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T9[rsp]
	movaps	XMMWORD PTR X1$[rsp], xmm0

; 324  : 
; 325  : 		// 2nd Newton-Raphson iteration
; 326  : 		X2 = _mm_mul_ss(X1, X1);

	movaps	xmm0, XMMWORD PTR X1$[rsp]
	mulss	xmm0, DWORD PTR X1$[rsp]
	movaps	XMMWORD PTR $T10[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T10[rsp]
	movaps	XMMWORD PTR X2$[rsp], xmm0

; 327  : 		X2 = _mm_sub_ss(fOneHalf, _mm_mul_ss(FOver2, X2));

	movaps	xmm0, XMMWORD PTR FOver2$[rsp]
	mulss	xmm0, DWORD PTR X2$[rsp]
	movaps	XMMWORD PTR $T11[rsp], xmm0
	movaps	xmm0, XMMWORD PTR fOneHalf$[rsp]
	subss	xmm0, DWORD PTR $T11[rsp]
	movaps	XMMWORD PTR $T12[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T12[rsp]
	movaps	XMMWORD PTR X2$[rsp], xmm0

; 328  : 		X2 = _mm_add_ss(X1, _mm_mul_ss(X1, X2));

	movaps	xmm0, XMMWORD PTR X1$[rsp]
	mulss	xmm0, DWORD PTR X2$[rsp]
	movaps	XMMWORD PTR $T13[rsp], xmm0
	movaps	xmm0, XMMWORD PTR X1$[rsp]
	addss	xmm0, DWORD PTR $T13[rsp]
	movaps	XMMWORD PTR $T14[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T14[rsp]
	movaps	XMMWORD PTR X2$[rsp], xmm0

; 329  : 
; 330  : 		_mm_store_ss(&temp, X2);

	movaps	xmm0, XMMWORD PTR X2$[rsp]
	movss	DWORD PTR temp$[rsp], xmm0

; 331  : 		return temp;

	movss	xmm0, DWORD PTR temp$[rsp]

; 332  : 	}

	add	rsp, 344				; 00000158H
	ret	0
?InvSqrt@Math@Core@IronMan@@YAMM@Z ENDP			; IronMan::Core::Math::InvSqrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
F$ = 48
?TruncToFloat@Math@Core@IronMan@@YAMM@Z PROC		; IronMan::Core::Math::TruncToFloat

; 281  : 	{

	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 282  : 		return (float)TruncToInt(F);

	movss	xmm0, DWORD PTR F$[rsp]
	call	?TruncToInt@Math@Core@IronMan@@YAHM@Z	; IronMan::Core::Math::TruncToInt
	cvtsi2ss xmm0, eax

; 283  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?TruncToFloat@Math@Core@IronMan@@YAMM@Z ENDP		; IronMan::Core::Math::TruncToFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
_TEXT	SEGMENT
F$ = 8
?TruncToInt@Math@Core@IronMan@@YAHM@Z PROC		; IronMan::Core::Math::TruncToInt

; 271  : 	{

	movss	DWORD PTR [rsp+8], xmm0

; 272  : 		return (int32_t)F;

	cvttss2si eax, DWORD PTR F$[rsp]

; 273  : 	}

	ret	0
?TruncToInt@Math@Core@IronMan@@YAHM@Z ENDP		; IronMan::Core::Math::TruncToInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ PROC	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK'', COMDAT

; 157  : 	static const VectorRegister QINV_SIGN_MASK = MakeVectorRegister(-1.f, -1.f, -1.f, 1.f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@bf800000
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EXYZMask@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EXYZMask@Math@Core@IronMan@@YAXXZ PROC		; IronMan::Core::Math::`dynamic initializer for 'XYZMask'', COMDAT

; 155  : 	static const VectorRegister XYZMask = MakeVectorRegister((uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0x00000000);

	sub	rsp, 40					; 00000028H
	xor	r9d, r9d
	mov	r8d, -1					; ffffffffH
	mov	edx, -1					; ffffffffH
	mov	ecx, -1					; ffffffffH
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?XYZMask@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EXYZMask@Math@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::Math::`dynamic initializer for 'XYZMask''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = 0
X$ = 32
Y$ = 40
Z$ = 48
W$ = 56
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 135  : 	{

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 136  : 		return _mm_setr_ps(X, Y, Z, W);

	movss	xmm0, DWORD PTR W$[rsp]
	movss	xmm1, DWORD PTR Z$[rsp]
	movss	xmm2, DWORD PTR Y$[rsp]
	movss	xmm3, DWORD PTR X$[rsp]
	unpcklps xmm1, xmm0
	unpcklps xmm3, xmm2
	movaps	xmm0, xmm3
	movlhps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 137  : 	}

	add	rsp, 24
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
_TEXT	SEGMENT
$T1 = 0
Tmp$ = 16
__$ArrayPad$ = 32
X$ = 64
Y$ = 72
Z$ = 80
W$ = 88
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 119  : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 120  : 		union { VectorRegister v; VectorRegisterInt i; } Tmp;
; 121  : 		Tmp.i = _mm_setr_epi32(X, Y, Z, W);

	movd	xmm0, DWORD PTR W$[rsp]
	movd	xmm1, DWORD PTR Z$[rsp]
	movd	xmm2, DWORD PTR Y$[rsp]
	movd	xmm3, DWORD PTR X$[rsp]
	punpckldq xmm1, xmm0
	punpckldq xmm3, xmm2
	movdqa	xmm0, xmm3
	punpcklqdq xmm0, xmm1
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR Tmp$[rsp], xmm0

; 122  : 		return Tmp.v;

	movaps	xmm0, XMMWORD PTR Tmp$[rsp]

; 123  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Math.cpp
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?ToVector3@_D3DMATRIX@Math@Core@IronMan@@QEAA?AUFVector@234@XZ PROC ; IronMan::Core::Math::_D3DMATRIX::ToVector3

; 17   : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 18   : 		return struct FVector(_41, _42, _43);

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm3, DWORD PTR [rax+56]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm2, DWORD PTR [rax+52]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+48]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0FVector@Math@Core@IronMan@@QEAA@MMM@Z ; IronMan::Core::Math::FVector::FVector
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 19   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?ToVector3@_D3DMATRIX@Math@Core@IronMan@@QEAA?AUFVector@234@XZ ENDP ; IronMan::Core::Math::_D3DMATRIX::ToVector3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\PxShared\include\foundation\PxMat33.h
;	COMDAT ??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z
_TEXT	SEGMENT
this$ = 8
num$ = 16
??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z PROC		; physx::PxMat33::operator[], COMDAT

; 343  : 	{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 344  : 		return (&column0)[num];

	mov	eax, DWORD PTR num$[rsp]
	imul	rax, rax, 12
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 345  : 	}

	ret	0
??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z ENDP		; physx::PxMat33::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\PxShared\include\foundation\PxMat33.h
;	COMDAT ??0PxMat33@physx@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
tv70 = 32
tv76 = 40
tv82 = 48
this$ = 80
other$ = 88
??0PxMat33@physx@@QEAA@AEBV01@@Z PROC			; physx::PxMat33::PxMat33, COMDAT

; 163  : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 162  : 	: column0(other.column0), column1(other.column1), column2(other.column2)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rax, QWORD PTR other$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv70[rsp]
	call	??0PxVec3@physx@@QEAA@AEBV01@@Z		; physx::PxVec3::PxVec3
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 12
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR other$[rsp]
	add	rax, 12
	mov	rdx, rax
	mov	rcx, QWORD PTR tv76[rsp]
	call	??0PxVec3@physx@@QEAA@AEBV01@@Z		; physx::PxVec3::PxVec3
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR other$[rsp]
	add	rax, 24
	mov	rdx, rax
	mov	rcx, QWORD PTR tv82[rsp]
	call	??0PxVec3@physx@@QEAA@AEBV01@@Z		; physx::PxVec3::PxVec3
	npad	1

; 164  : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0PxMat33@physx@@QEAA@AEBV01@@Z ENDP			; physx::PxMat33::PxMat33
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\PxShared\include\foundation\PxMat33.h
;	COMDAT ??0PxMat33@physx@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0PxMat33@physx@@QEAA@XZ PROC				; physx::PxMat33::PxMat33, COMDAT

; 94   : 	PX_CUDA_CALLABLE PX_FORCE_INLINE PxMat33()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 95   : 	{

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0PxVec3@physx@@QEAA@XZ		; physx::PxVec3::PxVec3
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 12
	mov	rcx, rax
	call	??0PxVec3@physx@@QEAA@XZ		; physx::PxVec3::PxVec3
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0PxVec3@physx@@QEAA@XZ		; physx::PxVec3::PxVec3
	npad	1

; 96   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0PxMat33@physx@@QEAA@XZ ENDP				; physx::PxMat33::PxMat33
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\PxShared\include\foundation\PxVec3.h
;	COMDAT ??APxVec3@physx@@QEAAAEAMI@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??APxVec3@physx@@QEAAAEAMI@Z PROC			; physx::PxVec3::operator[], COMDAT

; 113  : 	{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 114  : 		PX_ASSERT(index <= 2);
; 115  : 
; 116  : 		return reinterpret_cast<float*>(this)[index];

	mov	eax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4]

; 117  : 	}

	ret	0
??APxVec3@physx@@QEAAAEAMI@Z ENDP			; physx::PxVec3::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\PxShared\include\foundation\PxVec3.h
;	COMDAT ??0PxVec3@physx@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
??0PxVec3@physx@@QEAA@AEBV01@@Z PROC			; physx::PxVec3::PxVec3, COMDAT

; 93   : 	{

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 92   : 	PX_CUDA_CALLABLE PX_FORCE_INLINE PxVec3(const PxVec3& v) : x(v.x), y(v.y), z(v.z)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [rax+4], xmm0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	movss	xmm0, DWORD PTR [rcx+8]
	movss	DWORD PTR [rax+8], xmm0

; 94   : 	}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0PxVec3@physx@@QEAA@AEBV01@@Z ENDP			; physx::PxVec3::PxVec3
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Include\PxShared\include\foundation\PxVec3.h
;	COMDAT ??0PxVec3@physx@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0PxVec3@physx@@QEAA@XZ PROC				; physx::PxVec3::PxVec3, COMDAT

; 55   : 	PX_CUDA_CALLABLE PX_FORCE_INLINE PxVec3()

	mov	QWORD PTR [rsp+8], rcx

; 56   : 	{
; 57   : 	}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0PxVec3@physx@@QEAA@XZ ENDP				; physx::PxVec3::PxVec3
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 265  : _NODISCARD _Check_return_ inline float sqrt(_In_ float _Xx) noexcept /* strengthened */ {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 266  :     return _CSTD sqrtf(_Xx);

	movss	xmm0, DWORD PTR _Xx$[rsp]
	call	sqrtf
	npad	1

; 267  : }

	add	rsp, 40					; 00000028H
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 48
fabsf	PROC						; COMDAT

; 719  :         {

$LN3:
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 720  :             return (float)fabs(_X);

	cvtss2sd xmm0, DWORD PTR _X$[rsp]
	call	fabs
	cvtsd2ss xmm0, xmm0

; 721  :         }

	add	rsp, 40					; 00000028H
	ret	0
fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
