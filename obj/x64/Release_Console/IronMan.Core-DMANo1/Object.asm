; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34810.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLKGGCJO@LcOpen@			; `string'
PUBLIC	??_C@_06GJPHNGFG@LcRead@			; `string'
PUBLIC	??_C@_0O@CBBNAKKC@LcReadScatter@		; `string'
PUBLIC	??_C@_07MBHEMNEL@LcWrite@			; `string'
PUBLIC	??_C@_0P@DAJMPOFM@LcWriteScatter@		; `string'
PUBLIC	??_C@_0M@HBBFEIGD@LcGetOption@			; `string'
PUBLIC	??_C@_0M@FPFAGJPB@LcSetOption@			; `string'
PUBLIC	??_C@_09DCHLEDFD@LcCommand@			; `string'
PUBLIC	??_C@_03HPADHAHE@N?1A@				; `string'
PUBLIC	??_C@_03HDGGCCPD@X86@				; `string'
PUBLIC	??_C@_06IDLKBMKC@X86PAE@			; `string'
PUBLIC	??_C@_03ELMOGNHL@X64@				; `string'
PUBLIC	??_C@_05DKFIPBAL@ARM64@				; `string'
PUBLIC	?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA	; IronMan::Core::SDK::INVALID_POINTER
PUBLIC	??_C@_04PCJGBDOP@Zero@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_07LNBDIIPN@Standby@			; `string'
PUBLIC	??_C@_07PFEKAJBJ@Modifiy@			; `string'
PUBLIC	??_C@_07DGKCKENG@ModNoWr@			; `string'
PUBLIC	??_C@_03KHCCLPOB@Bad@				; `string'
PUBLIC	??_C@_06MAFFGDO@Active@				; `string'
PUBLIC	??_C@_07KADDEKFE@Transit@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_06CGLFEPBO@Unused@			; `string'
PUBLIC	??_C@_08LBAJPEDB@ProcPriv@			; `string'
PUBLIC	??_C@_09BGPMMIPE@PageTable@			; `string'
PUBLIC	??_C@_09MFCNICMF@LargePage@			; `string'
PUBLIC	??_C@_0L@DHBAIELD@DriverLock@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_04PBAHLACE@File@				; `string'
PUBLIC	_Avx2WmemEnabledWeakValue
EXTRN	?x86RegData@asmjit@@3UX86RegData@1@B:BYTE	; asmjit::x86RegData
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
?NoInit@asmjit@@3U_NoInit@1@B	ORG $+1			; asmjit::NoInit
CONST	ENDS
;	COMDAT ??_C@_04PBAHLACE@File@
CONST	SEGMENT
??_C@_04PBAHLACE@File@ DB 'File', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBAIELD@DriverLock@
CONST	SEGMENT
??_C@_0L@DHBAIELD@DriverLock@ DB 'DriverLock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCNICMF@LargePage@
CONST	SEGMENT
??_C@_09MFCNICMF@LargePage@ DB 'LargePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGPMMIPE@PageTable@
CONST	SEGMENT
??_C@_09BGPMMIPE@PageTable@ DB 'PageTable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBAJPEDB@ProcPriv@
CONST	SEGMENT
??_C@_08LBAJPEDB@ProcPriv@ DB 'ProcPriv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGLFEPBO@Unused@
CONST	SEGMENT
??_C@_06CGLFEPBO@Unused@ DB 'Unused', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KADDEKFE@Transit@
CONST	SEGMENT
??_C@_07KADDEKFE@Transit@ DB 'Transit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAFFGDO@Active@
CONST	SEGMENT
??_C@_06MAFFGDO@Active@ DB 'Active', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHCCLPOB@Bad@
CONST	SEGMENT
??_C@_03KHCCLPOB@Bad@ DB 'Bad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGKCKENG@ModNoWr@
CONST	SEGMENT
??_C@_07DGKCKENG@ModNoWr@ DB 'ModNoWr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFEKAJBJ@Modifiy@
CONST	SEGMENT
??_C@_07PFEKAJBJ@Modifiy@ DB 'Modifiy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNBDIIPN@Standby@
CONST	SEGMENT
??_C@_07LNBDIIPN@Standby@ DB 'Standby', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJGBDOP@Zero@
CONST	SEGMENT
??_C@_04PCJGBDOP@Zero@ DB 'Zero', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA DQ ffffffffffffffffH ; IronMan::Core::SDK::INVALID_POINTER
_DATA	ENDS
;	COMDAT ??_C@_05DKFIPBAL@ARM64@
CONST	SEGMENT
??_C@_05DKFIPBAL@ARM64@ DB 'ARM64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMOGNHL@X64@
CONST	SEGMENT
??_C@_03ELMOGNHL@X64@ DB 'X64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLKBMKC@X86PAE@
CONST	SEGMENT
??_C@_06IDLKBMKC@X86PAE@ DB 'X86PAE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDGGCCPD@X86@
CONST	SEGMENT
??_C@_03HDGGCCPD@X86@ DB 'X86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPADHAHE@N?1A@
CONST	SEGMENT
??_C@_03HPADHAHE@N?1A@ DB 'N/A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCHLEDFD@LcCommand@
CONST	SEGMENT
??_C@_09DCHLEDFD@LcCommand@ DB 'LcCommand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPFAGJPB@LcSetOption@
CONST	SEGMENT
??_C@_0M@FPFAGJPB@LcSetOption@ DB 'LcSetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFEIGD@LcGetOption@
CONST	SEGMENT
??_C@_0M@HBBFEIGD@LcGetOption@ DB 'LcGetOption', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJMPOFM@LcWriteScatter@
CONST	SEGMENT
??_C@_0P@DAJMPOFM@LcWriteScatter@ DB 'LcWriteScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBHEMNEL@LcWrite@
CONST	SEGMENT
??_C@_07MBHEMNEL@LcWrite@ DB 'LcWrite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBNAKKC@LcReadScatter@
CONST	SEGMENT
??_C@_0O@CBBNAKKC@LcReadScatter@ DB 'LcReadScatter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJPHNGFG@LcRead@
CONST	SEGMENT
??_C@_06GJPHNGFG@LcRead@ DB 'LcRead', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLKGGCJO@LcOpen@
CONST	SEGMENT
??_C@_06GLKGGCJO@LcOpen@ DB 'LcOpen', 00H		; `string'
CONST	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?_Is_constant_evaluated@std@@YA_NXZ		; std::_Is_constant_evaluated
PUBLIC	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z	; std::_Fnv1a_append_bytes
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z	; std::_Narrow_char_traits<char,int>::eq
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z		; std::tuple<>::tuple<>
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?_Decref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Decwref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?_Floor_of_log_2@std@@YAK_K@Z			; std::_Floor_of_log_2
PUBLIC	?_Ceiling_of_log_2@std@@YAK_K@Z			; std::_Ceiling_of_log_2
PUBLIC	??$_Hash_representation@I@std@@YA_KAEBI@Z	; std::_Hash_representation<unsigned int>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::WSInit
PUBLIC	??1WSInit@detail@httplib@@QEAA@XZ		; httplib::detail::WSInit::~WSInit
PUBLIC	??0SSLInit@detail@httplib@@QEAA@XZ		; httplib::detail::SSLInit::SSLInit
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
PUBLIC	??1BaseProcessInfo@IronMan@@QEAA@XZ		; IronMan::BaseProcessInfo::~BaseProcessInfo
PUBLIC	?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
PUBLIC	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
PUBLIC	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ		; IronMan::GetDMA
PUBLIC	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z		; std::equal_to<unsigned __int64>::operator()
PUBLIC	??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
PUBLIC	?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z		; std::hash<unsigned __int64>::_Do_hash
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
PUBLIC	??$forward@_K@std@@YA$$QEA_KAEA_K@Z		; std::forward<unsigned __int64>
PUBLIC	?DecryptDataByCache@SDK@Core@IronMan@@YA_N_KAEA_K@Z ; IronMan::Core::SDK::DecryptDataByCache
PUBLIC	?CacheDecryptData@SDK@Core@IronMan@@YAX_K0@Z	; IronMan::Core::SDK::CacheDecryptData
PUBLIC	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
PUBLIC	??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z ; IronMan::Core::SDK::UEDecryptBuilder::`scalar deleting destructor'
PUBLIC	?GetAnsiName@FNameEntry@SDK@Core@IronMan@@QEBAPEBDXZ ; IronMan::Core::SDK::FNameEntry::GetAnsiName
PUBLIC	??0FName@SDK@Core@IronMan@@QEAA@XZ		; IronMan::Core::SDK::FName::FName
PUBLIC	??0FName@SDK@Core@IronMan@@QEAA@H@Z		; IronMan::Core::SDK::FName::FName
PUBLIC	?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Core::SDK::FName::GetName
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::STATIC_Get
PUBLIC	?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::Get
PUBLIC	??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::operator->
PUBLIC	?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetPtrById
PUBLIC	?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetById
PUBLIC	?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetItemPtr
PUBLIC	??0?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEAA@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::STATIC_Get
PUBLIC	?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
PUBLIC	?ClearObjectCache@SDK@Core@IronMan@@YAXXZ	; IronMan::Core::SDK::ClearObjectCache
PUBLIC	?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::FUObjectItem::IsUnreachable
PUBLIC	?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::FUObjectItem::IsPendingKill
PUBLIC	??0UObject@SDK@Core@IronMan@@QEAA@XZ		; IronMan::Core::SDK::UObject::UObject
PUBLIC	??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z	; IronMan::Core::SDK::UObject::UObject
PUBLIC	??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z	; IronMan::Core::SDK::UObject::UObject
PUBLIC	??1UObject@SDK@Core@IronMan@@UEAA@XZ		; IronMan::Core::SDK::UObject::~UObject
PUBLIC	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ	; IronMan::Core::SDK::UObject::IsValid
PUBLIC	?GetObjectFlags@UObject@SDK@Core@IronMan@@QEAA?AW4EObjectFlags@234@XZ ; IronMan::Core::SDK::UObject::GetObjectFlags
PUBLIC	?GetIndex@UObject@SDK@Core@IronMan@@QEAA_KXZ	; IronMan::Core::SDK::UObject::GetIndex
PUBLIC	?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ ; IronMan::Core::SDK::UObject::GetClass
PUBLIC	?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ ; IronMan::Core::SDK::UObject::GetOuter
PUBLIC	?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z ; IronMan::Core::SDK::UObject::GetName
PUBLIC	?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ	; IronMan::Core::SDK::UObject::TestName
PUBLIC	?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Core::SDK::UObject::GetSuperClassName
PUBLIC	?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Core::SDK::UObject::GetFullName
PUBLIC	?IsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z ; IronMan::Core::SDK::UObject::IsA
PUBLIC	?SetIsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z ; IronMan::Core::SDK::UObject::SetIsA
PUBLIC	?ProcessEvent@UObject@SDK@Core@IronMan@@QEAAXVUFunction@234@PEAX@Z ; IronMan::Core::SDK::UObject::ProcessEvent
PUBLIC	??CUObject@SDK@Core@IronMan@@QEAA@XZ		; IronMan::Core::SDK::UObject::operator->
PUBLIC	??BUObject@SDK@Core@IronMan@@QEAA_NXZ		; IronMan::Core::SDK::UObject::operator bool
PUBLIC	?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::UObject::StaticClass
PUBLIC	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ	; IronMan::Core::SDK::UObject::GetPtr
PUBLIC	??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z	; IronMan::Core::SDK::UObject::UObject
PUBLIC	??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z ; IronMan::Core::SDK::UObject::operator=
PUBLIC	??_GUObject@SDK@Core@IronMan@@UEAAPEAXI@Z	; IronMan::Core::SDK::UObject::`scalar deleting destructor'
PUBLIC	?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z ; IronMan::Core::SDK::FWeakObjectPtr::SerialNumbersMatch
PUBLIC	?IsValid@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::FWeakObjectPtr::IsValid
PUBLIC	?Get@FWeakObjectPtr@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::FWeakObjectPtr::Get
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
PUBLIC	??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z	; IronMan::DMAHandler::Read<unsigned __int64>
PUBLIC	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
PUBLIC	??1UField@SDK@Core@IronMan@@UEAA@XZ		; IronMan::Core::SDK::UField::~UField
PUBLIC	??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z	; IronMan::Core::SDK::UField::UField
PUBLIC	??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z	; IronMan::Core::SDK::UField::UField
PUBLIC	??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z ; IronMan::Core::SDK::UField::operator=
PUBLIC	??_GUField@SDK@Core@IronMan@@UEAAPEAXI@Z	; IronMan::Core::SDK::UField::`scalar deleting destructor'
PUBLIC	??1UStruct@SDK@Core@IronMan@@UEAA@XZ		; IronMan::Core::SDK::UStruct::~UStruct
PUBLIC	??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z	; IronMan::Core::SDK::UStruct::UStruct
PUBLIC	??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z	; IronMan::Core::SDK::UStruct::UStruct
PUBLIC	??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z ; IronMan::Core::SDK::UStruct::operator=
PUBLIC	??_GUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z	; IronMan::Core::SDK::UStruct::`scalar deleting destructor'
PUBLIC	??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z		; IronMan::Core::SDK::UClass::UClass
PUBLIC	?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ ; IronMan::Core::SDK::UClass::GetClassBaseChain
PUBLIC	?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z ; IronMan::Core::SDK::UClass::IsAUsingClassArray
PUBLIC	??CUClass@SDK@Core@IronMan@@QEAA@XZ		; IronMan::Core::SDK::UClass::operator->
PUBLIC	?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ ; IronMan::Core::SDK::UClass::StaticClass
PUBLIC	??1UClass@SDK@Core@IronMan@@UEAA@XZ		; IronMan::Core::SDK::UClass::~UClass
PUBLIC	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z	; IronMan::Core::SDK::UClass::UClass
PUBLIC	??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z	; IronMan::Core::SDK::UClass::UClass
PUBLIC	??_GUClass@SDK@Core@IronMan@@UEAAPEAXI@Z	; IronMan::Core::SDK::UClass::`scalar deleting destructor'
PUBLIC	??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::UClass::FClassBaseChain>
PUBLIC	??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z	; IronMan::DMAHandler::ReadCache<unsigned __int64>
PUBLIC	??1UFunction@SDK@Core@IronMan@@UEAA@XZ		; IronMan::Core::SDK::UFunction::~UFunction
PUBLIC	??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@I@std@@QEBA_NAEBI0@Z		; std::equal_to<unsigned int>::operator()
PUBLIC	??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z ; std::_Conditionally_enabled_hash<unsigned int,1>::operator()
PUBLIC	?_Do_hash@?$hash@I@std@@SA_KAEBI@Z		; std::hash<unsigned int>::_Do_hash
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEBAAEBU?$equal_to@I@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEBAAEBU?$hash@I@2@XZ ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Get_first
PUBLIC	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size
PUBLIC	??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
PUBLIC	?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
PUBLIC	?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size
PUBLIC	??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
PUBLIC	?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
PUBLIC	?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$allocator@U?$pair@$$CB_K_K@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >
PUBLIC	??0?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::max_size
PUBLIC	??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
PUBLIC	??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
PUBLIC	?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::end
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Make_iter
PUBLIC	?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::max_size
PUBLIC	?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
PUBLIC	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first
PUBLIC	??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::max_load_factor
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Rehash_for_1
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Assign_grow
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >
PUBLIC	??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
PUBLIC	??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::find<void>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator->
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
PUBLIC	??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::emplace<unsigned __int64 &,unsigned __int64 &>
PUBLIC	??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::ReadCache<unsigned int>
PUBLIC	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z		; IronMan::DMAHandler::Read<unsigned int>
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<enum IronMan::Core::SDK::EObjectFlags,0>::STATIC_Get
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,3>::STATIC_Get
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,4>::STATIC_Get
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,5>::STATIC_Get
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,1>::STATIC_Get
PUBLIC	?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,2>::STATIC_Get
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
PUBLIC	??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UStruct>
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
PUBLIC	??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>
PUBLIC	??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>
PUBLIC	??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>
PUBLIC	??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>
PUBLIC	??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>
PUBLIC	??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>
PUBLIC	??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>
PUBLIC	??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>
PUBLIC	??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>
PUBLIC	??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindClass<-4342903124670388529>
PUBLIC	??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindClass<3244701931984741072>
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBAAEBMXZ ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ; std::equal_to<enum IronMan::Core::SDK::DecryptFunc>::operator()
PUBLIC	??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Conditionally_enabled_hash<enum IronMan::Core::SDK::DecryptFunc,1>::operator()
PUBLIC	?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::hash<enum IronMan::Core::SDK::DecryptFunc>::_Do_hash
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@std@@QEBAAEBU?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@V?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::max_size
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_end
PUBLIC	?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::max_size
PUBLIC	?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::clear
PUBLIC	?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
PUBLIC	?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Orphan_non_end
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_splice
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket_count
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::max_load_factor
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_erase
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::clear
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Rehash_for_1
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::_Assign_grow
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first
PUBLIC	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
PUBLIC	??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z ; std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>::operator()
PUBLIC	??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::~unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >
PUBLIC	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAAAEAU?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Get_first
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,unsigned __int64> *>::pointer_to
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int>
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry>
PUBLIC	??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry>
PUBLIC	??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry *>
PUBLIC	??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry *>
PUBLIC	??$forward@_N@std@@YA$$QEA_NAEA_N@Z		; std::forward<bool>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ; std::_Traits_rfind_ch<std::char_traits<char> >
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
PUBLIC	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,unsigned __int64> >
PUBLIC	??$move@AEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::move<enum IronMan::Core::SDK::DecryptFunc &>
PUBLIC	??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Try_emplace<enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::~pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
PUBLIC	??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::`scalar deleting destructor'
PUBLIC	??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > ><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Compressed_pair<std::equal_to<unsigned int>,float,1><float>
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
PUBLIC	??$?0U?$pair@$$CB_K_K@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> ><std::pair<unsigned __int64 const ,unsigned __int64> >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
PUBLIC	??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
PUBLIC	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z		; std::_Get_size_of_n<32>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
PUBLIC	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
PUBLIC	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z		; std::_Get_size_of_n<56>
PUBLIC	??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z	; std::_Fnv1a_append_value<unsigned int>
PUBLIC	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z		; std::forward<unsigned __int64 &>
PUBLIC	??$forward@AEAH@std@@YAAEAHAEAH@Z		; std::forward<int &>
PUBLIC	??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find<unsigned __int64>
PUBLIC	?_Extract@?$_In_place_key_extract_map_impl@_K_K_K@std@@SAAEB_KAEB_K0@Z ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,unsigned __int64>::_Extract
PUBLIC	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find_last<unsigned __int64>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool,0>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
PUBLIC	??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > ><unsigned __int64 &,unsigned __int64 &>
PUBLIC	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
PUBLIC	??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned int>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
PUBLIC	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned __int64>
PUBLIC	?_Extract@?$_In_place_key_extract_map_impl@_K_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SAAEB_KAEB_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Extract
PUBLIC	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned __int64>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
PUBLIC	??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,-4342903124670388529>
PUBLIC	??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,3244701931984741072>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
PUBLIC	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
PUBLIC	??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ; std::_Find_last_vectorized<char const ,char>
PUBLIC	??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ; std::_Search_vectorized<char const ,char const >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Find_last<enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &,bool,0>
PUBLIC	??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::forward<enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::forward_as_tuple<enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >
PUBLIC	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
PUBLIC	??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool,0>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_K_K@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
PUBLIC	??$?0U?$pair@$$CB_K_K@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > ><std::pair<unsigned __int64 const ,unsigned __int64> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
PUBLIC	??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
PUBLIC	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$forward@M@std@@YA$$QEAMAEAM@Z		; std::forward<float>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > * const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
PUBLIC	??$addressof@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
PUBLIC	??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::destroy<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::nullptr_t>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>
PUBLIC	??$destroy@U?$pair@$$CB_K_K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::destroy<std::pair<unsigned __int64 const ,unsigned __int64> >
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator!=
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator++
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > const >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc,enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int,unsigned int>
PUBLIC	??$_Hash_representation@_K@std@@YA_KAEB_K@Z	; std::_Hash_representation<unsigned __int64>
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
PUBLIC	??$?0$0A@@id@locale@std@@QEAA@XZ		; std::locale::id::id<0>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
PUBLIC	??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::construct<std::pair<unsigned __int64 const ,unsigned __int64>,unsigned __int64 &,unsigned __int64 &>
PUBLIC	??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z ; IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>
PUBLIC	??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>
PUBLIC	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &>
PUBLIC	??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc,0>
PUBLIC	??$forward@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z ; std::forward<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> >
PUBLIC	??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::construct<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >
PUBLIC	??$forward@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
PUBLIC	??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z	; std::_Fnv1a_append_value<unsigned __int64>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > * const &>
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Release
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
PUBLIC	??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash_representation<enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z ; std::pair<unsigned __int64 const ,unsigned __int64>::pair<unsigned __int64 const ,unsigned __int64><unsigned __int64 &,unsigned __int64 &,0>
PUBLIC	??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
PUBLIC	??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
PUBLIC	?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::_Make_iter
PUBLIC	?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::end
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::find<void>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator->
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >
PUBLIC	??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UClass>
PUBLIC	??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><std::_Exact_args_t,enum IronMan::Core::SDK::DecryptFunc,0>
PUBLIC	??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><enum IronMan::Core::SDK::DecryptFunc &&>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
PUBLIC	??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Fnv1a_append_value<enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> *>::pointer_to
PUBLIC	??$addressof@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >
PUBLIC	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find<unsigned __int64>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&>::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc>
PUBLIC	??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<>,0>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > const >
PUBLIC	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find_last<unsigned __int64>
PUBLIC	??$move@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z ; std::move<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> &>
PUBLIC	??$_Tuple_get@$0A@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@@Z ; std::_Tuple_get<0,enum IronMan::Core::SDK::DecryptFunc &&>
PUBLIC	??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> ><std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,0>
PUBLIC	??$_Kfn@$$CB_KVUObject@SDK@Core@IronMan@@@?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0>::_Kfn<unsigned __int64 const ,IronMan::Core::SDK::UObject>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1><>
PUBLIC	?piecewise_construct@std@@3Upiecewise_construct_t@1@B ; std::piecewise_construct
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A ; IronMan::DMAHandler::UpdateStartTime
PUBLIC	?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterWriteArray
PUBLIC	?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterReadArray
PUBLIC	?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A ; IronMan::DMAHandler::processInfo
PUBLIC	??_7UObject@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UObject::`vftable'
PUBLIC	??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ ; `string'
PUBLIC	??_7UField@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UField::`vftable'
PUBLIC	??_7UStruct@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UStruct::`vftable'
PUBLIC	??_7UClass@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UClass::`vftable'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_buckets
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_buckets
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Min_buckets
PUBLIC	?DecryptCache@SDK@Core@IronMan@@3V?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@A ; IronMan::Core::SDK::DecryptCache
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ@			; `string'
PUBLIC	??_C@_0M@NALCFIBF@CoreUObject@			; `string'
PUBLIC	??_C@_04JOCPCP@1?3?$CFs@			; `string'
PUBLIC	??_C@_04EHDOFFPP@2?3?$CFs@			; `string'
PUBLIC	??_C@_0BD@EDEEELKD@Name?5Error?5To?5Find@	; `string'
PUBLIC	??_C@_04BGNDFFFM@0?3?$CFp@			; `string'
PUBLIC	??_C@_02HBOOOICD@?9?$DO@			; `string'
PUBLIC	??_C@_08LPFEODAP@1?3?$CInull?$CJ@		; `string'
PUBLIC	??_C@_08IGNJNPMK@2?3?$CInull?$CJ@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Min_buckets
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A	; std::codecvt<char,char,_Mbstatet>::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?id@?$collate@D@std@@2V0locale@2@A		; std::collate<char>::id
PUBLIC	??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4UClass@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUClass@SDK@Core@IronMan@@@8		; IronMan::Core::SDK::UClass `RTTI Type Descriptor'
PUBLIC	??_R3UClass@SDK@Core@IronMan@@8			; IronMan::Core::SDK::UClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UClass@SDK@Core@IronMan@@8			; IronMan::Core::SDK::UClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UClass@SDK@Core@IronMan@@8	; IronMan::Core::SDK::UClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@UStruct@SDK@Core@IronMan@@8	; IronMan::Core::SDK::UStruct::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVUStruct@SDK@Core@IronMan@@@8		; IronMan::Core::SDK::UStruct `RTTI Type Descriptor'
PUBLIC	??_R3UStruct@SDK@Core@IronMan@@8		; IronMan::Core::SDK::UStruct::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UStruct@SDK@Core@IronMan@@8		; IronMan::Core::SDK::UStruct::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UField@SDK@Core@IronMan@@8	; IronMan::Core::SDK::UField::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVUField@SDK@Core@IronMan@@@8		; IronMan::Core::SDK::UField `RTTI Type Descriptor'
PUBLIC	??_R3UField@SDK@Core@IronMan@@8			; IronMan::Core::SDK::UField::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UField@SDK@Core@IronMan@@8			; IronMan::Core::SDK::UField::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UObject@SDK@Core@IronMan@@8	; IronMan::Core::SDK::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVUObject@SDK@Core@IronMan@@@8		; IronMan::Core::SDK::UObject `RTTI Type Descriptor'
PUBLIC	??_R3UObject@SDK@Core@IronMan@@8		; IronMan::Core::SDK::UObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UObject@SDK@Core@IronMan@@8		; IronMan::Core::SDK::UObject::`RTTI Base Class Array'
PUBLIC	??_R4UObject@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UObject::`RTTI Complete Object Locator'
PUBLIC	??_R4UField@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UField::`RTTI Complete Object Locator'
PUBLIC	??_R4UStruct@SDK@Core@IronMan@@6B@		; IronMan::Core::SDK::UStruct::`RTTI Complete Object Locator'
PUBLIC	__real@3f800000
PUBLIC	__real@5f000000
PUBLIC	__real@bf800000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	ceilf:PROC
EXTRN	__std_find_last_trivial_1:PROC
EXTRN	__std_search_1:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_MessageBoxA:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	_Xtime_get_ticks:PROC
EXTRN	?Print@Console@IronMan@@YA_NPEBDZZ:PROC		; IronMan::Console::Print
EXTRN	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ:PROC ; IronMan::Utils::FormatString
EXTRN	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z:PROC	; IronMan::Utils::IsSafeReadPtr
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSACleanup:PROC
EXTRN	OPENSSL_init_ssl:PROC
EXTRN	?Instance@DMAHandler@IronMan@@SAAEAV12@XZ:PROC	; IronMan::DMAHandler::Instance
EXTRN	?Read@DMAHandler@IronMan@@QEBAH_K00@Z:PROC	; IronMan::DMAHandler::Read
EXTRN	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z:PROC	; IronMan::DMAHandler::ReadCache
EXTRN	??1UEDecryptBuilder@SDK@Core@IronMan@@QEAA@XZ:PROC ; IronMan::Core::SDK::UEDecryptBuilder::~UEDecryptBuilder
EXTRN	??_EUObject@SDK@Core@IronMan@@UEAAPEAXI@Z:PROC	; IronMan::Core::SDK::UObject::`vector deleting destructor'
EXTRN	??_EUField@SDK@Core@IronMan@@UEAAPEAXI@Z:PROC	; IronMan::Core::SDK::UField::`vector deleting destructor'
EXTRN	??0UStruct@SDK@Core@IronMan@@QEAA@PEAX@Z:PROC	; IronMan::Core::SDK::UStruct::UStruct
EXTRN	?GetSuperStruct@UStruct@SDK@Core@IronMan@@QEAA?AV1234@XZ:PROC ; IronMan::Core::SDK::UStruct::GetSuperStruct
EXTRN	??_EUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z:PROC	; IronMan::Core::SDK::UStruct::`vector deleting destructor'
EXTRN	??_EUClass@SDK@Core@IronMan@@UEAAPEAXI@Z:PROC	; IronMan::Core::SDK::UClass::`vector deleting destructor'
EXTRN	?StaticClass@ATslCharacter@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::ATslCharacter::StaticClass
EXTRN	?StaticClass@ATslFloatingVehicle@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::ATslFloatingVehicle::StaticClass
EXTRN	?StaticClass@ATslWheeledVehicle@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::ATslWheeledVehicle::StaticClass
EXTRN	?StaticClass@ADroppedItemGroup@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::ADroppedItemGroup::StaticClass
EXTRN	?StaticClass@ADroppedItem@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::ADroppedItem::StaticClass
EXTRN	?StaticClass@UDroppedItemInteractionComponent@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::UDroppedItemInteractionComponent::StaticClass
EXTRN	?StaticClass@ACarePackageItem@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::ACarePackageItem::StaticClass
EXTRN	?StaticClass@AFloorSnapItemPackage@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::AFloorSnapItemPackage::StaticClass
EXTRN	?StaticClass@ATslProjectile@SDK@Core@IronMan@@SA?AVUClass@234@XZ:PROC ; IronMan::Core::SDK::ATslProjectile::StaticClass
EXTRN	?GetItemById@ObjectsStore@SDK@Core@IronMan@@QEBA?AVFUObjectItem@234@_K@Z:PROC ; IronMan::Core::SDK::ObjectsStore::GetItemById
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?g_PatternData@Core@IronMan@@3UPatternData@12@A:BYTE ; IronMan::Core::g_PatternData
EXTRN	?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A:ZWORD ; IronMan::Core::SDK::g_DecryptFuncs
EXTRN	?useCache@@3_NA:BYTE				; useCache
EXTRN	?GlobalNames@SDK@Core@IronMan@@3U?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@123@A:QWORD ; IronMan::Core::SDK::GlobalNames
EXTRN	?ObjectCache@SDK@Core@IronMan@@3V?$unordered_map@_KVUObject@SDK@Core@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@6@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@@std@@A:ZWORD ; IronMan::Core::SDK::ObjectCache
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?wsinit_@detail@httplib@@3VWSInit@12@A DB 01H DUP (?)	; httplib::detail::wsinit_
	ALIGN	4

?sslinit_@detail@httplib@@3VSSLInit@12@A DB 01H DUP (?)	; httplib::detail::sslinit_
_BSS	ENDS
;	COMDAT ?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A
_BSS	SEGMENT
?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A DQ 01H DUP (?) ; IronMan::DMAHandler::UpdateStartTime
_BSS	ENDS
;	COMDAT ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A
_BSS	SEGMENT
?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A DB 038H DUP (?) ; IronMan::DMAHandler::processInfo
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	8

?NAME_None@SDK@Core@IronMan@@3UFName@123@A DQ 01H DUP (?) ; IronMan::Core::SDK::NAME_None
?XYZMask@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?)	; IronMan::Core::Math::XYZMask
?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B DB 010H DUP (?) ; IronMan::Core::Math::QINV_SIGN_MASK
?uNormal@SDK@Core@IronMan@@3HA DD 01H DUP (?)		; IronMan::Core::SDK::uNormal
	ALIGN	8

?CacheName@SDK@Core@IronMan@@3V?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A DB 040H DUP (?) ; IronMan::Core::SDK::CacheName
?CacheOuterName@SDK@Core@IronMan@@3V?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A DB 040H DUP (?) ; IronMan::Core::SDK::CacheOuterName
?DecryptCache@SDK@Core@IronMan@@3V?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@A DB 040H DUP (?) ; IronMan::Core::SDK::DecryptCache
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::codecvt<char,char,_Mbstatet>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$collate@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$collate@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::collate<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+154
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+172
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+411
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+145
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+252
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+180
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA DD imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decwref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Decwref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Floor_of_log_2@std@@YAK_K@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?_Floor_of_log_2@std@@YAK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ceiling_of_log_2@std@@YAK_K@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?_Ceiling_of_log_2@std@@YAK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Hash_representation@I@std@@YA_KAEBI@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$_Hash_representation@I@std@@YA_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN5
	DD	imagerel $LN5+86
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+86
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??0WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1WSInit@detail@httplib@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$??1WSInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ewsinit_@detail@httplib@@YAXXZ DD imagerel ??__Ewsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Ewsinit_@detail@httplib@@YAXXZ+34
	DD	imagerel $unwind$??__Ewsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fwsinit_@detail@httplib@@YAXXZ DD imagerel ??__Fwsinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Fwsinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Fwsinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SSLInit@detail@httplib@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??0SSLInit@detail@httplib@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Esslinit_@detail@httplib@@YAXXZ DD imagerel ??__Esslinit_@detail@httplib@@YAXXZ
	DD	imagerel ??__Esslinit_@detail@httplib@@YAXXZ+22
	DD	imagerel $unwind$??__Esslinit_@detail@httplib@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1BaseProcessInfo@IronMan@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1BaseProcessInfo@IronMan@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ DD imagerel ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
	DD	imagerel ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD imagerel ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
	DD	imagerel ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD imagerel ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ+78
	DD	imagerel $unwind$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD imagerel ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?DecryptDataByCache@SDK@Core@IronMan@@YA_N_KAEA_K@Z DD imagerel $LN4
	DD	imagerel $LN4+107
	DD	imagerel $unwind$?DecryptDataByCache@SDK@Core@IronMan@@YA_N_KAEA_K@Z
$pdata$?CacheDecryptData@SDK@Core@IronMan@@YAX_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?CacheDecryptData@SDK@Core@IronMan@@YAX_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN6
	DD	imagerel $LN6+218
	DD	imagerel $unwind$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z DD imagerel $LN5
	DD	imagerel $LN5+134
	DD	imagerel $unwind$?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z DD imagerel $LN5
	DD	imagerel $LN5+242
	DD	imagerel $unwind$?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z DD imagerel $LN15
	DD	imagerel $LN15+631
	DD	imagerel $unwind$?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ENAME_None@SDK@Core@IronMan@@YAXXZ DD imagerel ??__ENAME_None@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__ENAME_None@SDK@Core@IronMan@@YAXXZ+24
	DD	imagerel $unwind$??__ENAME_None@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?ClearObjectCache@SDK@Core@IronMan@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?ClearObjectCache@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ
pdata	ENDS
pdata	SEGMENT
$pdata$??0UObject@SDK@Core@IronMan@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+255
	DD	imagerel $unwind$??0UObject@SDK@Core@IronMan@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
$pdata$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
$pdata$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA DD imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z DD imagerel $LN8
	DD	imagerel $LN8+560
	DD	imagerel $unwind$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA+31
	DD	imagerel $unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
$pdata$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
	DD	imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA+31
	DD	imagerel $unwind$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
$pdata$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
	DD	imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA+34
	DD	imagerel $unwind$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
$pdata$?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD imagerel ?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
	DD	imagerel ?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA+24
	DD	imagerel $unwind$?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA DD imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$??1UObject@SDK@Core@IronMan@@UEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$??1UObject@SDK@Core@IronMan@@UEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
$pdata$?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
$pdata$?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?GetObjectFlags@UObject@SDK@Core@IronMan@@QEAA?AW4EObjectFlags@234@XZ DD imagerel $LN7
	DD	imagerel $LN7+212
	DD	imagerel $unwind$?GetObjectFlags@UObject@SDK@Core@IronMan@@QEAA?AW4EObjectFlags@234@XZ
$pdata$?GetIndex@UObject@SDK@Core@IronMan@@QEAA_KXZ DD imagerel $LN8
	DD	imagerel $LN8+216
	DD	imagerel $unwind$?GetIndex@UObject@SDK@Core@IronMan@@QEAA_KXZ
$pdata$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ DD imagerel $LN9
	DD	imagerel $LN9+266
	DD	imagerel $unwind$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA DD imagerel ?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ DD imagerel $LN9
	DD	imagerel $LN9+266
	DD	imagerel $unwind$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA DD imagerel ?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z DD imagerel $LN16
	DD	imagerel $LN16+1022
	DD	imagerel $unwind$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA DD imagerel ?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA
	DD	imagerel ?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA
$pdata$?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA DD imagerel ?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA
	DD	imagerel ?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ DD imagerel $LN17
	DD	imagerel $LN17+1281
	DD	imagerel $unwind$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD imagerel ?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DD	imagerel ?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
$pdata$?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD imagerel ?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DD	imagerel ?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
$pdata$?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD imagerel ?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DD	imagerel ?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
$pdata$?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD imagerel ?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DD	imagerel ?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
$pdata$?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD imagerel ?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DD	imagerel ?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN14
	DD	imagerel $LN14+515
	DD	imagerel $unwind$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+24
	DD	imagerel $unwind$?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN29
	DD	imagerel $LN29+1458
	DD	imagerel $unwind$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$pdata$?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+27
	DD	imagerel $unwind$?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?IsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z DD imagerel $LN26
	DD	imagerel $LN26+487
	DD	imagerel $unwind$?IsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z
$pdata$?SetIsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z DD imagerel $LN26
	DD	imagerel $LN26+328
	DD	imagerel $unwind$?SetIsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z
$pdata$?ProcessEvent@UObject@SDK@Core@IronMan@@QEAAXVUFunction@234@PEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$?ProcessEvent@UObject@SDK@Core@IronMan@@QEAAXVUFunction@234@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??BUObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??BUObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA DD imagerel ?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA
	DD	imagerel ?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA
$pdata$?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA DD imagerel ?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA
	DD	imagerel ?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD imagerel $LN6
	DD	imagerel $LN6+384
	DD	imagerel $unwind$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DD	imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DD	imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA+31
	DD	imagerel $unwind$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+337
	DD	imagerel $unwind$??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GUObject@SDK@Core@IronMan@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GUObject@SDK@Core@IronMan@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?IsValid@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+168
	DD	imagerel $unwind$?IsValid@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NXZ
$pdata$?Get@FWeakObjectPtr@SDK@Core@IronMan@@QEBAPEAXXZ DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$?Get@FWeakObjectPtr@SDK@Core@IronMan@@QEBAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EXYZMask@Math@Core@IronMan@@YAXXZ+40
	DD	imagerel $unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
	DD	imagerel ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ+53
	DD	imagerel $unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1UField@SDK@Core@IronMan@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1UField@SDK@Core@IronMan@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD imagerel ?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA DD imagerel ?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GUField@SDK@Core@IronMan@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GUField@SDK@Core@IronMan@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1UStruct@SDK@Core@IronMan@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1UStruct@SDK@Core@IronMan@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD imagerel $LN4
	DD	imagerel $LN4+125
	DD	imagerel $unwind$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD imagerel ?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DD imagerel $LN4
	DD	imagerel $LN4+125
	DD	imagerel $unwind$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA DD imagerel ?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA DD imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA
	DD	imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA DD imagerel ?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA
	DD	imagerel ?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA
$pdata$?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA DD imagerel ?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA
	DD	imagerel ?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1UClass@SDK@Core@IronMan@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1UClass@SDK@Core@IronMan@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA DD imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
	DD	imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GUClass@SDK@Core@IronMan@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_GUClass@SDK@Core@IronMan@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1UFunction@SDK@Core@IronMan@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1UFunction@SDK@Core@IronMan@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA DD imagerel ?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@I@std@@QEBA_NAEBI0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??R?$equal_to@I@std@@QEBA_NAEBI0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Do_hash@?$hash@I@std@@SA_KAEBI@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Do_hash@?$hash@I@std@@SA_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN26
	DD	imagerel $LN26+783
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+195
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z DD imagerel $LN8
	DD	imagerel $LN8+335
	DD	imagerel $unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+205
	DD	imagerel $unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+870
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ECacheName@SDK@Core@IronMan@@YAXXZ DD imagerel ??__ECacheName@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__ECacheName@SDK@Core@IronMan@@YAXXZ+34
	DD	imagerel $unwind$??__ECacheName@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FCacheName@SDK@Core@IronMan@@YAXXZ DD imagerel ??__FCacheName@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__FCacheName@SDK@Core@IronMan@@YAXXZ+22
	DD	imagerel $unwind$??__FCacheName@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN26
	DD	imagerel $LN26+783
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+195
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z DD imagerel $LN8
	DD	imagerel $LN8+335
	DD	imagerel $unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+205
	DD	imagerel $unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+870
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ DD imagerel ??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ+34
	DD	imagerel $unwind$??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ DD imagerel ??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ+22
	DD	imagerel $unwind$??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+148
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA DD imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA DD imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN26
	DD	imagerel $LN26+783
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+195
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z DD imagerel $LN8
	DD	imagerel $LN8+335
	DD	imagerel $unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+205
	DD	imagerel $unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+870
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EDecryptCache@SDK@Core@IronMan@@YAXXZ DD imagerel ??__EDecryptCache@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__EDecryptCache@SDK@Core@IronMan@@YAXXZ+34
	DD	imagerel $unwind$??__EDecryptCache@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FDecryptCache@SDK@Core@IronMan@@YAXXZ DD imagerel ??__FDecryptCache@SDK@Core@IronMan@@YAXXZ
	DD	imagerel ??__FDecryptCache@SDK@Core@IronMan@@YAXXZ+22
	DD	imagerel $unwind$??__FDecryptCache@SDK@Core@IronMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+565
	DD	imagerel $unwind$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA DD imagerel ?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA
	DD	imagerel ?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+573
	DD	imagerel $unwind$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA DD imagerel ?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA
	DD	imagerel ?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+565
	DD	imagerel $unwind$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD imagerel $LN8
	DD	imagerel $LN8+262
	DD	imagerel $unwind$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD imagerel ?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD imagerel ?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
	DD	imagerel ?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD imagerel ?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
	DD	imagerel ?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN26
	DD	imagerel $LN26+783
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+195
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z DD imagerel $LN8
	DD	imagerel $LN8+335
	DD	imagerel $unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+205
	DD	imagerel $unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+141
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+870
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA DD imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+273
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z DD imagerel $LN5
	DD	imagerel $LN5+68
	DD	imagerel $unwind$??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+166
	DD	imagerel $unwind$??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+166
	DD	imagerel $unwind$??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z DD imagerel $LN12
	DD	imagerel $LN12+286
	DD	imagerel $unwind$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN14
	DD	imagerel $LN14+385
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+266
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD imagerel $LN3
	DD	imagerel $LN3+130
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+450
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+388
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+354
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN6
	DD	imagerel $LN6+484
	DD	imagerel $unwind$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA DD imagerel ?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA DD imagerel ?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z DD imagerel $LN8
	DD	imagerel $LN8+277
	DD	imagerel $unwind$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD imagerel ?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DD	imagerel ?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD imagerel ?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DD	imagerel ?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD imagerel ?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DD	imagerel ?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD imagerel ?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DD	imagerel ?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD imagerel ?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DD	imagerel ?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA+24
	DD	imagerel $unwind$?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
	DD	imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
	DD	imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+189
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+135
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+98
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+22
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+100
	DD	imagerel $unwind$??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA DD imagerel ?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA
	DD	imagerel ?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA DD imagerel ?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA
	DD	imagerel ?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z DD imagerel $LN12
	DD	imagerel $LN12+175
	DD	imagerel $unwind$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA DD imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA DD imagerel ?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA
	DD	imagerel ?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA+27
	DD	imagerel $unwind$?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+195
	DD	imagerel $unwind$??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD imagerel ?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
	DD	imagerel ?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+105
	DD	imagerel $unwind$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z DD imagerel $LN9
	DD	imagerel $LN9+322
	DD	imagerel $unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ
pdata	ENDS
CRT$XCU	SEGMENT
?wsinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Ewsinit_@detail@httplib@@YAXXZ ; httplib::detail::wsinit_$initializer$
CRT$XCU	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@5f000000
CONST	SEGMENT
__real@5f000000 DD 05f000000r			; 9.22337e+18
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R4UStruct@SDK@Core@IronMan@@6B@
rdata$r	SEGMENT
??_R4UStruct@SDK@Core@IronMan@@6B@ DD 01H		; IronMan::Core::SDK::UStruct::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUStruct@SDK@Core@IronMan@@@8
	DD	imagerel ??_R3UStruct@SDK@Core@IronMan@@8
	DD	imagerel ??_R4UStruct@SDK@Core@IronMan@@6B@
rdata$r	ENDS
;	COMDAT ??_R4UField@SDK@Core@IronMan@@6B@
rdata$r	SEGMENT
??_R4UField@SDK@Core@IronMan@@6B@ DD 01H		; IronMan::Core::SDK::UField::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUField@SDK@Core@IronMan@@@8
	DD	imagerel ??_R3UField@SDK@Core@IronMan@@8
	DD	imagerel ??_R4UField@SDK@Core@IronMan@@6B@
rdata$r	ENDS
;	COMDAT ??_R4UObject@SDK@Core@IronMan@@6B@
rdata$r	SEGMENT
??_R4UObject@SDK@Core@IronMan@@6B@ DD 01H		; IronMan::Core::SDK::UObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUObject@SDK@Core@IronMan@@@8
	DD	imagerel ??_R3UObject@SDK@Core@IronMan@@8
	DD	imagerel ??_R4UObject@SDK@Core@IronMan@@6B@
rdata$r	ENDS
;	COMDAT ??_R2UObject@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R2UObject@SDK@Core@IronMan@@8 DD imagerel ??_R1A@?0A@EA@UObject@SDK@Core@IronMan@@8 ; IronMan::Core::SDK::UObject::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3UObject@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R3UObject@SDK@Core@IronMan@@8 DD 00H			; IronMan::Core::SDK::UObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2UObject@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUObject@SDK@Core@IronMan@@@8
data$rs	SEGMENT
??_R0?AVUObject@SDK@Core@IronMan@@@8 DQ FLAT:??_7type_info@@6B@ ; IronMan::Core::SDK::UObject `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUObject@SDK@Core@IronMan@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@UObject@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UObject@SDK@Core@IronMan@@8 DD imagerel ??_R0?AVUObject@SDK@Core@IronMan@@@8 ; IronMan::Core::SDK::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UObject@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R2UField@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R2UField@SDK@Core@IronMan@@8 DD imagerel ??_R1A@?0A@EA@UField@SDK@Core@IronMan@@8 ; IronMan::Core::SDK::UField::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@UObject@SDK@Core@IronMan@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3UField@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R3UField@SDK@Core@IronMan@@8 DD 00H			; IronMan::Core::SDK::UField::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2UField@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUField@SDK@Core@IronMan@@@8
data$rs	SEGMENT
??_R0?AVUField@SDK@Core@IronMan@@@8 DQ FLAT:??_7type_info@@6B@ ; IronMan::Core::SDK::UField `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUField@SDK@Core@IronMan@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@UField@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UField@SDK@Core@IronMan@@8 DD imagerel ??_R0?AVUField@SDK@Core@IronMan@@@8 ; IronMan::Core::SDK::UField::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UField@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R2UStruct@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R2UStruct@SDK@Core@IronMan@@8 DD imagerel ??_R1A@?0A@EA@UStruct@SDK@Core@IronMan@@8 ; IronMan::Core::SDK::UStruct::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@UField@SDK@Core@IronMan@@8
	DD	imagerel ??_R1A@?0A@EA@UObject@SDK@Core@IronMan@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3UStruct@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R3UStruct@SDK@Core@IronMan@@8 DD 00H			; IronMan::Core::SDK::UStruct::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2UStruct@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUStruct@SDK@Core@IronMan@@@8
data$rs	SEGMENT
??_R0?AVUStruct@SDK@Core@IronMan@@@8 DQ FLAT:??_7type_info@@6B@ ; IronMan::Core::SDK::UStruct `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUStruct@SDK@Core@IronMan@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@UStruct@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UStruct@SDK@Core@IronMan@@8 DD imagerel ??_R0?AVUStruct@SDK@Core@IronMan@@@8 ; IronMan::Core::SDK::UStruct::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UStruct@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@UClass@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UClass@SDK@Core@IronMan@@8 DD imagerel ??_R0?AVUClass@SDK@Core@IronMan@@@8 ; IronMan::Core::SDK::UClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UClass@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R2UClass@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R2UClass@SDK@Core@IronMan@@8 DD imagerel ??_R1A@?0A@EA@UClass@SDK@Core@IronMan@@8 ; IronMan::Core::SDK::UClass::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@UStruct@SDK@Core@IronMan@@8
	DD	imagerel ??_R1A@?0A@EA@UField@SDK@Core@IronMan@@8
	DD	imagerel ??_R1A@?0A@EA@UObject@SDK@Core@IronMan@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3UClass@SDK@Core@IronMan@@8
rdata$r	SEGMENT
??_R3UClass@SDK@Core@IronMan@@8 DD 00H			; IronMan::Core::SDK::UClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2UClass@SDK@Core@IronMan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUClass@SDK@Core@IronMan@@@8
data$rs	SEGMENT
??_R0?AVUClass@SDK@Core@IronMan@@@8 DQ FLAT:??_7type_info@@6B@ ; IronMan::Core::SDK::UClass `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUClass@SDK@Core@IronMan@@', 00H
data$rs	ENDS
;	COMDAT ??_R4UClass@SDK@Core@IronMan@@6B@
rdata$r	SEGMENT
??_R4UClass@SDK@Core@IronMan@@6B@ DD 01H		; IronMan::Core::SDK::UClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUClass@SDK@Core@IronMan@@@8
	DD	imagerel ??_R3UClass@SDK@Core@IronMan@@8
	DD	imagerel ??_R4UClass@SDK@Core@IronMan@@6B@
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ DB 'unordered_map/set t'
	DB	'oo long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IGNJNPMK@2?3?$CInull?$CJ@
CONST	SEGMENT
??_C@_08IGNJNPMK@2?3?$CInull?$CJ@ DB '2:(null)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LPFEODAP@1?3?$CInull?$CJ@
CONST	SEGMENT
??_C@_08LPFEODAP@1?3?$CInull?$CJ@ DB '1:(null)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HBOOOICD@?9?$DO@
CONST	SEGMENT
??_C@_02HBOOOICD@?9?$DO@ DB '->', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGNDFFFM@0?3?$CFp@
CONST	SEGMENT
??_C@_04BGNDFFFM@0?3?$CFp@ DB '0:%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EDEEELKD@Name?5Error?5To?5Find@
CONST	SEGMENT
??_C@_0BD@EDEEELKD@Name?5Error?5To?5Find@ DB 'Name Error To Find', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHDOFFPP@2?3?$CFs@
CONST	SEGMENT
??_C@_04EHDOFFPP@2?3?$CFs@ DB '2:%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JOCPCP@1?3?$CFs@
CONST	SEGMENT
??_C@_04JOCPCP@1?3?$CFs@ DB '1:%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NALCFIBF@CoreUObject@
CONST	SEGMENT
??_C@_0M@NALCFIBF@CoreUObject@ DB 'CoreUObject', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ@ DB '(null)', 00H		; `string'
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_7UClass@SDK@Core@IronMan@@6B@
CONST	SEGMENT
??_7UClass@SDK@Core@IronMan@@6B@ DQ FLAT:??_R4UClass@SDK@Core@IronMan@@6B@ ; IronMan::Core::SDK::UClass::`vftable'
	DQ	FLAT:??_EUClass@SDK@Core@IronMan@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7UStruct@SDK@Core@IronMan@@6B@
CONST	SEGMENT
??_7UStruct@SDK@Core@IronMan@@6B@ DQ FLAT:??_R4UStruct@SDK@Core@IronMan@@6B@ ; IronMan::Core::SDK::UStruct::`vftable'
	DQ	FLAT:??_EUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7UField@SDK@Core@IronMan@@6B@
CONST	SEGMENT
??_7UField@SDK@Core@IronMan@@6B@ DQ FLAT:??_R4UField@SDK@Core@IronMan@@6B@ ; IronMan::Core::SDK::UField::`vftable'
	DQ	FLAT:??_EUField@SDK@Core@IronMan@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
CONST	SEGMENT
??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@ DB '['
	DB	0e8H, 0beH, 093H, 0e5H, 087H, 0baH, 0e4H, 0bfH, 0a1H, 0e6H, 081H
	DB	0afH, '] %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7UObject@SDK@Core@IronMan@@6B@
CONST	SEGMENT
??_7UObject@SDK@Core@IronMan@@6B@ DQ FLAT:??_R4UObject@SDK@Core@IronMan@@6B@ ; IronMan::Core::SDK::UObject::`vftable'
	DQ	FLAT:??_EUObject@SDK@Core@IronMan@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A
_DATA	SEGMENT
?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A DQ 0000000000000000H ; IronMan::DMAHandler::ScatterReadArray
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A
_DATA	SEGMENT
?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A DQ 0000000000000000H ; IronMan::DMAHandler::ScatterWriteArray
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
	DD	imagerel $ip2state$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 011811H
	DD	04218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z DD 021811H
	DD	070147218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 08H
	DB	00H
	DB	00H
	DB	'r'
	DB	02H
	DB	'$'
	DB	00H
	DB	'0'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 08H
	DD	imagerel $stateUnwindMap$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
	DD	imagerel $ip2state$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DB 040H
	DD	imagerel $ip2state$??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z DB 08H
	DB	00H
	DB	00H
	DB	'6'
	DB	04H
	DB	0e0H
	DB	02H
	DB	'<'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z DB 02H
	DB	00H
	DD	imagerel ?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z DB 018H
	DD	imagerel $stateUnwindMap$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z
	DD	imagerel $tryMap$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z
	DD	imagerel $ip2state$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z DD 011319H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z DB 08H
	DB	00H
	DB	00H
	DB	01cH
	DB	04H
	DB	'&'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z DB 08H
	DD	imagerel $stateUnwindMap$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z
	DD	imagerel $ip2state$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Hash_representation@_K@std@@YA_KAEB_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'-', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z DD 011811H
	DD	0c218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	086H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 04H
	DB	00H
	DB	00H
	DB	'`'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 08H
	DD	imagerel $stateUnwindMap$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
	DD	imagerel $ip2state$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 04H
	DB	00H
	DB	00H
	DB	'`'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 08H
	DD	imagerel $stateUnwindMap$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
	DD	imagerel $ip2state$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	0fdH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z DB 014H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	','
	DB	04H
	DB	','
	DB	06H
	DB	'V'
	DB	08H
	DB	'p'
	DB	0aH
	DB	014H
	DB	06H
	DB	'&'
	DB	04H
	DB	01cH
	DB	02H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z
	DD	imagerel $ip2state$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z DD 022319H
	DD	0770111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z
	DD	03a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	0d2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	086H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	0d2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	086H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	0d2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z
	DD	imagerel $ip2state$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	086H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a0H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z
	DD	imagerel $ip2state$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z DD 011311H
	DD	08213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DB 040H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 040H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DB 06H
	DB	00H
	DB	00H
	DB	'Y', 04H
	DB	02H
	DB	0b9H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
	DD	imagerel $ip2state$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD 041811H
	DD	0170118H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
	DD	imagerel $ip2state$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d11H
	DD	0420dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DB 048H
	DD	imagerel $stateUnwindMap$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011211H
	DD	04212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	08cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z DD 042a19H
	DD	0190118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	08cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z DD 042a19H
	DD	0190118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z DB 06H
	DB	00H
	DB	00H
	DB	089H, 04H
	DB	02H
	DB	0c5H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z
	DD	imagerel $ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z DD 021111H
	DD	0150111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z DB 040H
	DD	imagerel $ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ DB 040H
	DD	imagerel $ip2state$?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 0eH
	DB	00H
	DB	00H
	DB	0f2H
	DB	02H
	DB	')', 04H
	DB	00H
	DB	'.'
	DB	02H
	DB	'Y', 04H
	DB	00H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 048H
	DD	imagerel $stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
	DD	imagerel $ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021611H
	DD	0170116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 04H
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 08H
	DD	imagerel $stateUnwindMap$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
	DD	imagerel $ip2state$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 04H
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DB 08H
	DD	imagerel $stateUnwindMap$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
	DD	imagerel $ip2state$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	0eeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 0aH
	DB	00H
	DB	00H
	DB	0dcH
	DB	02H
	DB	'2'
	DB	00H
	DB	'('
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DB 08H
	DD	imagerel $stateUnwindMap$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	imagerel $ip2state$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
	DD	01e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	0edH, 04H
	DB	02H
	DB	'i', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 041d11H
	DD	019011dH
	DD	060157016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ DB 08H
	DB	00H
	DB	00H
	DB	'r'
	DB	02H
	DB	'$'
	DB	00H
	DB	'0'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ DB 08H
	DD	imagerel $stateUnwindMap$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ
	DD	imagerel $ip2state$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 0aH
	DB	00H
	DB	00H
	DB	0e8H
	DB	02H
	DB	0b1H, 02H
	DB	00H
	DB	'0'
	DB	02H
	DB	0a1H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 041d11H
	DD	019011dH
	DD	060157016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z DB 06H
	DB	00H
	DB	00H
	DB	0edH, 04H
	DB	02H
	DB	'i', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z DB 08H
	DD	imagerel $stateUnwindMap$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z
	DD	imagerel $ip2state$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z DD 041d11H
	DD	019011dH
	DD	060157016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FDecryptCache@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EDecryptCache@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 06H
	DB	00H
	DB	00H
	DB	089H, 04H
	DB	02H
	DB	0c5H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
	DD	imagerel $ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021111H
	DD	0150111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 040H
	DD	imagerel $ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 040H
	DD	imagerel $ip2state$?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z DB 0eH
	DB	00H
	DB	00H
	DB	0f2H
	DB	02H
	DB	')', 04H
	DB	00H
	DB	'.'
	DB	02H
	DB	'Y', 04H
	DB	00H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z DB 048H
	DD	imagerel $stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z
	DD	imagerel $ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021611H
	DD	0170116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'<'
	DB	04H
	DB	0dcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 06H
	DB	00H
	DB	00H
	DB	089H, 04H
	DB	02H
	DB	0c5H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
	DD	imagerel $ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021111H
	DD	0150111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 040H
	DD	imagerel $ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 040H
	DD	imagerel $ip2state$?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 0eH
	DB	00H
	DB	00H
	DB	0f2H
	DB	02H
	DB	')', 04H
	DB	00H
	DB	'.'
	DB	02H
	DB	'Y', 04H
	DB	00H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 048H
	DD	imagerel $stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
	DD	imagerel $ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021611H
	DD	0170116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'<'
	DB	04H
	DB	0dcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FCacheName@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ECacheName@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010911H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 06H
	DB	00H
	DB	00H
	DB	089H, 04H
	DB	02H
	DB	0c5H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DB 08H
	DD	imagerel $stateUnwindMap$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
	DD	imagerel $ip2state$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021111H
	DD	0150111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DB 040H
	DD	imagerel $ip2state$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010e19H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DB 040H
	DD	imagerel $ip2state$?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 0eH
	DB	00H
	DB	00H
	DB	0f2H
	DB	02H
	DB	')', 04H
	DB	00H
	DB	'.'
	DB	02H
	DB	'Y', 04H
	DB	00H
	DB	'('
	DB	02H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DB 048H
	DD	imagerel $stateUnwindMap$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
	DD	imagerel $ip2state$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021611H
	DD	0170116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DB 08H
	DB	00H
	DB	00H
	DB	094H
	DB	02H
	DB	'<'
	DB	04H
	DB	0dcH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 011311H
	DD	0a213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Do_hash@?$hash@I@std@@SA_KAEBI@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@I@std@@QEBA_NAEBI0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1UFunction@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1UFunction@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1UFunction@SDK@Core@IronMan@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1UFunction@SDK@Core@IronMan@@UEAA@XZ
	DD	imagerel $ip2state$??1UFunction@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1UFunction@SDK@Core@IronMan@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1UFunction@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GUClass@SDK@Core@IronMan@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
	DD	imagerel $ip2state$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	DD	imagerel $ip2state$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1UClass@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1UClass@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1UClass@SDK@Core@IronMan@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1UClass@SDK@Core@IronMan@@UEAA@XZ
	DD	imagerel $ip2state$??1UClass@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1UClass@SDK@Core@IronMan@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1UClass@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z
	DD	imagerel $ip2state$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	0aaH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
	DD	imagerel $ip2state$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	0aaH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	DD	imagerel $ip2state$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1UStruct@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1UStruct@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1UStruct@SDK@Core@IronMan@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	DD	imagerel $ip2state$??1UStruct@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1UStruct@SDK@Core@IronMan@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1UStruct@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GUField@SDK@Core@IronMan@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	'N'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
	DD	imagerel $ip2state$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	'N'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	DD	imagerel $ip2state$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1UField@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1UField@SDK@Core@IronMan@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1UField@SDK@Core@IronMan@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1UField@SDK@Core@IronMan@@UEAA@XZ
	DD	imagerel $ip2state$??1UField@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1UField@SDK@Core@IronMan@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1UField@SDK@Core@IronMan@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EXYZMask@Math@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z DD 011c01H
	DD	0221cH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	062H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z DD 012519H
	DD	06216H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GUObject@SDK@Core@IronMan@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'1', 03H
	DB	02H
	DB	'J'
	DB	04H
	DB	'R'
	DB	06H
	DB	0b8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	DD	imagerel $ip2state$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??BUObject@SDK@Core@IronMan@@QEAA_NXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ
	DD	016H
	DD	065H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ
	DD	016H
	DD	065H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	01bH
	DD	0599H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	01bH
	DD	01eaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ
	DD	016H
	DD	04e9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z
	DD	025H
	DD	03e5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z
	DD	01bH
	DD	0218H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ENAME_None@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z DD 021001H
	DD	0130110H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	0d8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z DD 042a19H
	DD	0310118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0170H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	0c1H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DB	00H
	DB	00H
	DB	011H, 02H
	DB	02H
	DB	'*'
	DB	00H
	DB	'*'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
xdata	SEGMENT
$unwind$?DecryptDataByCache@SDK@Core@IronMan@@YA_N_KAEA_K@Z DD 010e01H
	DD	0620eH
$unwind$?CacheDecryptData@SDK@Core@IronMan@@YAX_K0@Z DD 010e01H
	DD	0620eH
$unwind$?ClearObjectCache@SDK@Core@IronMan@@YAXXZ DD 010401H
	DD	04204H
$unwind$??0UObject@SDK@Core@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@XZ
$cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@XZ DB 08H
	DD	imagerel $stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??0UObject@SDK@Core@IronMan@@QEAA@XZ
$stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA
$ip2state$??0UObject@SDK@Core@IronMan@@QEAA@XZ DB 0aH
	DB	00H
	DB	00H
	DB	'}', 02H
	DB	02H
	DB	'$'
	DB	04H
	DB	'('
	DB	06H
	DB	'`'
	DB	00H
	ORG $+3
$unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z
	DD	0d2H
$cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z
	DD	imagerel $ip2state$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z
$stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA
$ip2state$??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z DB 0eH
	DB	00H
	DB	00H
	DB	0bcH
	DB	02H
	DB	'*'
	DB	04H
	DB	'.'
	DB	06H
	DB	0d8H
	DB	08H
	DB	'=', 04H
	DB	06H
	DB	016H
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA DD 020601H
	DD	050023206H
$unwind$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z
$cppxdata$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z DB 08H
	DD	imagerel $stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z
	DD	imagerel $ip2state$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z
$stateUnwindMap$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA
$ip2state$??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z DB 06H
	DB	00H
	DB	00H
	DB	'2'
	DB	02H
	DB	':'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA DD 020601H
	DD	050023206H
$unwind$??1UObject@SDK@Core@IronMan@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1UObject@SDK@Core@IronMan@@UEAA@XZ
$cppxdata$??1UObject@SDK@Core@IronMan@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1UObject@SDK@Core@IronMan@@UEAA@XZ
	DD	imagerel $ip2state$??1UObject@SDK@Core@IronMan@@UEAA@XZ
$stateUnwindMap$??1UObject@SDK@Core@IronMan@@UEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA
$ip2state$??1UObject@SDK@Core@IronMan@@UEAA@XZ DB 08H
	DB	00H
	DB	00H
	DB	'0'
	DB	04H
	DB	'('
	DB	02H
	DB	'$'
	DB	00H
	ORG $+2
$unwind$?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetObjectFlags@UObject@SDK@Core@IronMan@@QEAA?AW4EObjectFlags@234@XZ DD 010901H
	DD	0a209H
$unwind$?GetIndex@UObject@SDK@Core@IronMan@@QEAA_KXZ DD 010901H
	DD	0a209H
$unwind$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ DD 010e11H
	DD	0c20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ
$cppxdata$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ
	DD	imagerel $ip2state$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ
$stateUnwindMap$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA
$ip2state$?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ DB 04H
	DB	00H
	DB	00H
	DB	0d1H, 03H
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ DD 010e11H
	DD	0c20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ
$cppxdata$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ
	DD	imagerel $ip2state$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ
$stateUnwindMap$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA
$ip2state$?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ DB 04H
	DB	00H
	DB	00H
	DB	0d1H, 03H
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z DD 022d19H
	DD	01d011bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z
	DD	0d2H
$cppxdata$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z DB 08H
	DD	imagerel $stateUnwindMap$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z
	DD	imagerel $ip2state$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z
$stateUnwindMap$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA
$ip2state$?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z DB 012H
	DB	00H
	DB	00H
	DB	0bcH
	DB	02H
	DB	'0'
	DB	00H
	DB	'p'
	DB	02H
	DB	'0'
	DB	00H
	DB	099H, 07H
	DB	04H
	DB	':'
	DB	02H
	DB	086H
	DB	00H
	DB	'F'
	DB	02H
$unwind$?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA DD 020601H
	DD	050023206H
$unwind$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ DD 021e19H
	DD	033010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ
	DD	018aH
$cppxdata$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ DB 08H
	DD	imagerel $stateUnwindMap$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ
	DD	imagerel $ip2state$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ
$stateUnwindMap$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ DB 0aH
	DB	0eH
	DD	imagerel ?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DB	056H
	DD	imagerel ?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DB	07eH
	DD	imagerel ?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
	DB	0aeH
	DD	imagerel ?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA
$ip2state$?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ DB 01eH
	DB	00H
	DB	00H
	DB	0adH, 04H
	DB	02H
	DB	'9', 02H
	DB	04H
	DB	'>'
	DB	02H
	DB	'@'
	DB	00H
	DB	'6'
	DB	02H
	DB	'e', 03H
	DB	06H
	DB	','
	DB	02H
	DB	0a1H, 02H
	DB	08H
	DB	'V'
	DB	02H
	DB	'@'
	DB	00H
	DB	'0'
	DB	02H
	DB	','
	DB	00H
	DB	'-', 02H
	DB	0aH
	DB	'V'
	DB	00H
	ORG $+1
$unwind$?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 022319H
	DD	0450111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	0212H
$cppxdata$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$stateUnwindMap$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	056H
	DD	imagerel ?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$ip2state$?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 016H
	DB	00H
	DB	00H
	DB	0a8H
	DB	02H
	DB	'0'
	DB	00H
	DB	'x'
	DB	02H
	DB	'0'
	DB	00H
	DB	'&'
	DB	04H
	DB	'F'
	DB	06H
	DB	' '
	DB	04H
	DB	0f8H
	DB	08H
	DB	'8'
	DB	04H
	DB	' '
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 022319H
	DD	0af0111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	0562H
$cppxdata$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 08H
	DD	imagerel $stateUnwindMap$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
$stateUnwindMap$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 018H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	056H
	DD	imagerel ?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	056H
	DD	imagerel ?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	0f6H
	DD	imagerel ?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DB	08dH
	DB	02H
	DD	imagerel ?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
$ip2state$?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB '6'
	DB	00H
	DB	00H
	DB	0c6H
	DB	04H
	DB	'~'
	DB	02H
	DB	0c1H, 02H
	DB	06H
	DB	','
	DB	08H
	DB	'm', 02H
	DB	0aH
	DB	'L'
	DB	0cH
	DB	'&'
	DB	0aH
	DB	0bcH
	DB	08H
	DB	01cH
	DB	06H
	DB	01cH
	DB	02H
	DB	'4'
	DB	0aH
	DB	'T'
	DB	0eH
	DB	'V'
	DB	010H
	DB	'j'
	DB	012H
	DB	','
	DB	010H
	DB	01cH
	DB	0eH
	DB	01cH
	DB	0aH
	DB	'&'
	DB	08H
	DB	'y', 02H
	DB	014H
	DB	086H
	DB	016H
	DB	':'
	DB	014H
	DB	01cH
	DB	08H
	DB	0f2H
	DB	018H
	DB	':'
	DB	08H
	DB	'j'
	DB	06H
	DB	01cH
	DB	02H
	ORG $+3
$unwind$?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?IsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z DD 010d01H
	DD	0620dH
$unwind$?SetIsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z DD 010d01H
	DD	0620dH
$unwind$?ProcessEvent@UObject@SDK@Core@IronMan@@QEAAXVUFunction@234@PEAX@Z DD 011301H
	DD	04213H
$unwind$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ DD 021e19H
	DD	023010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ
	DD	0102H
$cppxdata$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ DB 08H
	DD	imagerel $stateUnwindMap$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ
	DD	imagerel $ip2state$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ
$stateUnwindMap$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA
$ip2state$?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ DB 06H
	DB	00H
	DB	00H
	DB	'l'
	DB	04H
	DB	':'
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?IsValid@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NXZ DD 010901H
	DD	08209H
$unwind$?Get@FWeakObjectPtr@SDK@Core@IronMan@@QEBAPEAXXZ DD 010901H
	DD	08209H
$unwind$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ DD 021e19H
	DD	023010cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ
	DD	0102H
$cppxdata$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ DB 08H
	DD	imagerel $stateUnwindMap$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ
	DD	imagerel $ip2state$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ
$stateUnwindMap$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA
$ip2state$?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ DB 06H
	DB	00H
	DB	00H
	DB	'l'
	DB	04H
	DB	':'
	DB	02H
	ORG $+1
$unwind$?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA DD 020601H
	DD	050023206H
$unwind$?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 06H
	DB	00H
	DB	00H
	DB	':'
	DB	02H
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DB 08H
	DD	imagerel $stateUnwindMap$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
	DD	imagerel $ip2state$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ DD 020611H
	DD	070023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1BaseProcessInfo@IronMan@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1BaseProcessInfo@IronMan@@QEAA@XZ
	DD	imagerel $ip2state$??1BaseProcessInfo@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1BaseProcessInfo@IronMan@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1BaseProcessInfo@IronMan@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Esslinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SSLInit@detail@httplib@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fwsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ewsinit_@detail@httplib@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1WSInit@detail@httplib@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1WSInit@detail@httplib@@QEAA@XZ DB 040H
	DD	imagerel $ip2state$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1WSInit@detail@httplib@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1WSInit@detail@httplib@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	04fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0WSInit@detail@httplib@@QEAA@XZ DD 021e19H
	DD	03b010cH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DB 04H
	DB	00H
	DB	00H
	DB	080H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DB 04H
	DB	00H
	DB	00H
	DB	080H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DB 08H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Hash_representation@I@std@@YA_KAEBI@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ceiling_of_log_2@std@@YAK_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Floor_of_log_2@std@@YAK_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decwref@_Ref_count_base@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 04H
	DB	00H
	DB	00H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DB 08H
	DD	imagerel $stateUnwindMap$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
	DD	imagerel $ip2state$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 040H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	09aH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 010e11H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	't'
	DB	02H
	DB	0d0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	0a4H
	DB	02H
	DB	'j'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 08H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0a20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'.'
	DB	02H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@XZ DB 06H
	DB	00H
	DB	00H
	DB	'6'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@XZ
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 048H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@AEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'H'
	DB	02H
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z DB 048H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@AEAA@QEBD@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@AEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 040H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 040H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f19H
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z DD 010c01H
	DD	0220cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DB 040H
	DD	imagerel $ip2state$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 011801H
	DD	06218H
xdata	ENDS
CRT$XCU	SEGMENT
?sslinit_$initializer$@detail@httplib@@3P6AXXZEA DQ FLAT:??__Esslinit_@detail@httplib@@YAXXZ ; httplib::detail::sslinit_$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??UpdateStartTime$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ ; IronMan::DMAHandler::pdateStartTime$initializer$::operator|
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ScatterWriteArray$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; IronMan::DMAHandler::catterWriteArray$initializer$::operator~
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ScatterReadArray$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; IronMan::DMAHandler::catterReadArray$initializer$::operator~
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??processInfo$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ; ??processInfo$initializer$@DMAHandler@IronMan@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
CRT$XCU	SEGMENT
	ORG $-16
?NAME_None$initializer$@SDK@Core@IronMan@@3P6AXXZEA DQ FLAT:??__ENAME_None@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::NAME_None$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?XYZMask$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EXYZMask@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::XYZMask$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?QINV_SIGN_MASK$initializer$@Math@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ; IronMan::Core::Math::QINV_SIGN_MASK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?CacheName$initializer$@SDK@Core@IronMan@@3P6AXXZEA DQ FLAT:??__ECacheName@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::CacheName$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?CacheOuterName$initializer$@SDK@Core@IronMan@@3P6AXXZEA DQ FLAT:??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::CacheOuterName$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?DecryptCache$initializer$@SDK@Core@IronMan@@3P6AXXZEA DQ FLAT:??__EDecryptCache@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::DecryptCache$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$codecvt@DDU_Mbstatet@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$collate@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$$V@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CB_KVUObject@SDK@Core@IronMan@@@?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CB_KVUObject@SDK@Core@IronMan@@@?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0>::_Kfn<unsigned __int64 const ,IronMan::Core::SDK::UObject>, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CB_KVUObject@SDK@Core@IronMan@@@?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0>::_Kfn<unsigned __int64 const ,IronMan::Core::SDK::UObject>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> ><std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,0>, COMDAT

; 3339 :     constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1><>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> ><std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$_Tuple_get@$0A@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@@Z PROC ; std::_Tuple_get<0,enum IronMan::Core::SDK::DecryptFunc &&>, COMDAT

; 925  : _NODISCARD constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 926  :     // used by pair's piecewise constructor
; 927  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 928  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 929  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR _Tuple$[rsp]
	mov	rax, QWORD PTR [rax]

; 930  : }

	ret	0
??$_Tuple_get@$0A@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@@Z ENDP ; std::_Tuple_get<0,enum IronMan::Core::SDK::DecryptFunc &&>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z PROC ; std::move<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z ENDP ; std::move<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find_last<unsigned __int64>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_KVUObject@SDK@Core@IronMan@@@?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@@Z ; std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0>::_Kfn<unsigned __int64 const ,IronMan::Core::SDK::UObject>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find_last<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
__formal$ = 72
__formal$ = 80
??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<>,0>, COMDAT

; 478  :         : first(_STD _Tuple_get<_Indices1>(_STD move(_Val1))...),

$LN4:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$move@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z ; std::move<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> &>
	mov	rcx, rax
	call	??$_Tuple_get@$0A@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@@Z ; std::_Tuple_get<0,enum IronMan::Core::SDK::DecryptFunc &&>
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 479  :           second(_STD _Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$?0U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@$0A@@?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> ><std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
__formal$ = 72
__formal$ = 80
?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA PROC ; `std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<>,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::~unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA ENDP ; `std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
this$ = 48
_Arg$ = 56
??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&>::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 132  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Arg$[rsp]
	call	??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::forward<enum IronMan::Core::SDK::DecryptFunc>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&>::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT

; 235  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 40
this$ = 80
_Keyval$ = 88
_Hashval$ = 96
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find<unsigned __int64>, COMDAT

; 1213 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1214 :         if constexpr (_Traits::_Multi) {
; 1215 :             return _Find_first(_Keyval, _Hashval);
; 1216 :         } else {
; 1217 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1218 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find_last<unsigned __int64>
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Target$1[rsp], rax

; 1219 :             if (_Target) {

	cmp	QWORD PTR _Target$1[rsp], 0
	je	SHORT $LN2@Find

; 1220 :                 return _Target;

	mov	rax, QWORD PTR _Target$1[rsp]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1221 :             }
; 1222 : 
; 1223 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@Find:

; 1224 :         }
; 1225 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@YAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
_Val$ = 48
_Keyval$ = 56
??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::_Fnv1a_append_value<enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 2310 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2311 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2312 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	mov	r8d, 4
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	call	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ; std::_Fnv1a_append_bytes

; 2313 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::_Fnv1a_append_value<enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
this$ = 80
__formal$ = 88
_Val1$ = 96
_Val2$ = 104
??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><enum IronMan::Core::SDK::DecryptFunc &&>, COMDAT

; 331  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	eax, BYTE PTR $T1[rsp]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, BYTE PTR $T2[rsp]
	mov	r8, QWORD PTR _Val2$[rsp]
	mov	rdx, QWORD PTR _Val1$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEAA@AEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<>,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><enum IronMan::Core::SDK::DecryptFunc &&>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 49
this$ = 80
__formal$ = 88
_Val1$ = 96
_Val2$ = 104
?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA PROC ; `std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><enum IronMan::Core::SDK::DecryptFunc &&>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z@4HA ENDP ; `std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><enum IronMan::Core::SDK::DecryptFunc &&>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 32
tv77 = 40
this$ = 64
__formal$ = 72
_This_arg$ = 80
??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><std::_Exact_args_t,enum IronMan::Core::SDK::DecryptFunc,0>, COMDAT

; 301  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _This_arg$[rsp]
	call	??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::forward<enum IronMan::Core::SDK::DecryptFunc>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0W4DecryptFunc@SDK@Core@IronMan@@@?$_Tuple_val@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&>::_Tuple_val<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><std::_Exact_args_t,enum IronMan::Core::SDK::DecryptFunc,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ PROC ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UClass>, COMDAT

; 487  : 		{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 488  : 			if (Utils::IsSafeReadPtr((void*)this, 8))

	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Cast

; 489  : 				return Base(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z	; IronMan::Core::SDK::UClass::UClass
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Cast
$LN2@Cast:

; 490  : 			return Base(this->GetPtr());

	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z	; IronMan::Core::SDK::UClass::UClass
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Cast:

; 491  : 		}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ENDP ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UClass>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UClass>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UClass>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator->, COMDAT

; 241  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@SAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> *>::pointer_to

; 243  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator!=, COMDAT

; 201  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 202  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 203  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::find<void>, COMDAT

; 1229 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1230 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::_Find<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::_Make_iter
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1231 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::end, COMDAT

; 796  :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 797  :         return _List.end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 798  :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::_Make_iter, COMDAT

; 1126 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1127 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > const >
	mov	r8, rax
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1128 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Make_iter@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject>,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv74 = 32
this$ = 64
_Val1$ = 72
_Val2$ = 80
??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@_K@std@@YA$$QEA_KAEA_K@Z	; std::forward<unsigned __int64>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv74 = 32
this$ = 64
_Val1$ = 72
_Val2$ = 80
?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv74 = 32
this$ = 64
_Val1$ = 72
_Val2$ = 80
??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEAH@std@@YAAEAHAEAH@Z	; std::forward<int &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv74 = 32
this$ = 64
_Val1$ = 72
_Val2$ = 80
?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z PROC ; std::pair<unsigned __int64 const ,unsigned __int64>::pair<unsigned __int64 const ,unsigned __int64><unsigned __int64 &,unsigned __int64 &,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], rax

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z ENDP ; std::pair<unsigned __int64 const ,unsigned __int64>::pair<unsigned __int64 const ,unsigned __int64><unsigned __int64 &,unsigned __int64 &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
_Keyval$ = 48
??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::_Hash_representation<enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 2316 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2317 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, -3750763034362895579		; cbf29ce484222325H
	call	??$_Fnv1a_append_value@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_K_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Fnv1a_append_value<enum IronMan::Core::SDK::DecryptFunc>

; 2318 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::_Hash_representation<enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z
_TEXT	SEGMENT
_Val$ = 48
_Keyval$ = 56
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z PROC	; std::_Fnv1a_append_value<unsigned __int64>, COMDAT

; 2310 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2311 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2312 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	mov	r8d, 8
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	call	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ; std::_Fnv1a_append_bytes

; 2313 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ENDP	; std::_Fnv1a_append_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
$T4 = 35
$T5 = 40
$T6 = 48
tv128 = 56
tv93 = 64
$T7 = 72
$T8 = 80
__formal$ = 112
_Ptr$ = 120
<_Args_0>$ = 128
<_Args_1>$ = 136
<_Args_2>$ = 144
??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::construct<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T7[rsp], rax
	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T5[rsp], rax
	mov	rcx, QWORD PTR <_Args_2>$[rsp]
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
	mov	rdx, rax
	mov	rcx, QWORD PTR $T5[rsp]
	call	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z	; std::tuple<>::tuple<>
	mov	QWORD PTR tv128[rsp], rax
	lea	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T6[rsp], rax
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	call	??$forward@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z ; std::forward<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> >
	mov	rdx, rax
	mov	rcx, QWORD PTR $T6[rsp]
	call	??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&>
	mov	QWORD PTR tv93[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	movzx	eax, BYTE PTR $T1[rsp]
	mov	BYTE PTR $T2[rsp], al
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T3[rsp], al
	mov	r9, QWORD PTR tv128[rsp]
	mov	r8, QWORD PTR tv93[rsp]
	movzx	edx, BYTE PTR $T3[rsp]
	mov	rcx, QWORD PTR $T7[rsp]
	call	??$?0$$QEAW4DecryptFunc@SDK@Core@IronMan@@$$Z$$V@?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@Z ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > ><enum IronMan::Core::SDK::DecryptFunc &&>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 104				; 00000068H
	ret	0
??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::construct<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv72 = 40
this$ = 64
_This_arg$ = 72
??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc,0>, COMDAT

; 349  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _This_arg$[rsp]
	call	??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::forward<enum IronMan::Core::SDK::DecryptFunc>
	mov	QWORD PTR tv72[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv72[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U_Exact_args_t@std@@W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@U_Exact_args_t@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><std::_Exact_args_t,enum IronMan::Core::SDK::DecryptFunc,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\ObjectsStore.h
;	COMDAT ??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z
_TEXT	SEGMENT
$T1 = 32
cache$2 = 40
tv130 = 48
$T3 = 56
this$ = 80
__$ReturnUdt$ = 88
nameHash$ = 96
??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z PROC ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>, COMDAT

; 74   : 		{

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T1[rsp], 0

; 75   : 			try
; 76   : 			{
; 77   : 				auto cache = ObjectCache.find(nameHash);

	lea	r8, QWORD PTR nameHash$[rsp]
	lea	rdx, QWORD PTR cache$2[rsp]
	lea	rcx, OFFSET FLAT:?ObjectCache@SDK@Core@IronMan@@3V?$unordered_map@_KVUObject@SDK@Core@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@6@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@@std@@A ; IronMan::Core::SDK::ObjectCache
	call	??$find@X@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::find<void>
	npad	1

; 78   : 				if (cache != ObjectCache.end())

	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, OFFSET FLAT:?ObjectCache@SDK@Core@IronMan@@3V?$unordered_map@_KVUObject@SDK@Core@IronMan@@U?$hash@_K@std@@U?$equal_to@_K@6@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@@std@@A ; IronMan::Core::SDK::ObjectCache
	call	?end@?$_Hash@V?$_Umap_traits@_KVUObject@SDK@Core@IronMan@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,IronMan::Core::SDK::UObject,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR cache$2[rsp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@FindObject

; 79   : 				{
; 80   : 					return cache->second.Cast<T>();

	lea	rcx, QWORD PTR cache$2[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KVUObject@SDK@Core@IronMan@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,IronMan::Core::SDK::UObject> > > >::operator->
	add	rax, 8
	mov	QWORD PTR tv130[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$Cast@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UClass>
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@FindObject
$LN3@FindObject:
	jmp	SHORT $LN9@FindObject
$LN10@FindObject:
$LN9@FindObject:

; 81   : 				}
; 82   : 			}
; 83   : 			catch (...)
; 84   : 			{
; 85   : 
; 86   : 			}
; 87   : 			return T(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z	; IronMan::Core::SDK::UClass::UClass
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@FindObject:

; 88   : 		}

	add	rsp, 72					; 00000048H
	ret	0
	int	3
??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z ENDP ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
cache$2 = 40
tv130 = 48
$T3 = 56
this$ = 80
__$ReturnUdt$ = 88
nameHash$ = 96
?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA PROC ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN8@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA ENDP ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
cache$2 = 40
tv130 = 48
$T3 = 56
this$ = 80
__$ReturnUdt$ = 88
nameHash$ = 96
?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA PROC ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>'::`1'::catch$1

; 84   : 			{

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z$0:

; 85   : 
; 86   : 			}

	lea	rax, $LN10@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0???$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z@4HA ENDP ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z
_TEXT	SEGMENT
$T1 = 32
ObjClass$ = 64
TestCls$ = 72
??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z PROC ; IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>, COMDAT

; 512  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 513  : 			return ObjClass.IsAUsingClassArray(TestCls);

	mov	rdx, QWORD PTR TestCls$[rsp]
	mov	rcx, QWORD PTR ObjClass$[rsp]
	call	?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z ; IronMan::Core::SDK::UClass::IsAUsingClassArray
	mov	BYTE PTR $T1[rsp], al
	mov	rcx, QWORD PTR ObjClass$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	npad	1
	mov	rcx, QWORD PTR TestCls$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]

; 514  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z ENDP ; IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
ObjClass$ = 64
TestCls$ = 72
?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA PROC ; `IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR TestCls$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
ObjClass$ = 64
TestCls$ = 72
?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA PROC ; `IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR ObjClass$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv81 = 32
tv79 = 40
$T1 = 48
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
<_Args_1>$ = 104
??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 40					; 00000028H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@_K@std@@YA$$QEA_KAEA_K@Z	; std::forward<unsigned __int64>
	mov	QWORD PTR tv79[rsp], rax
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv81 = 32
tv79 = 40
$T1 = 48
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
<_Args_1>$ = 104
??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 40					; 00000028H
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAH@std@@YAAEAHAEAH@Z	; std::forward<int &>
	mov	QWORD PTR tv79[rsp], rax
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z
_TEXT	SEGMENT
tv81 = 32
tv79 = 40
$T1 = 48
__formal$ = 80
_Ptr$ = 88
<_Args_0>$ = 96
<_Args_1>$ = 104
??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::construct<std::pair<unsigned __int64 const ,unsigned __int64>,unsigned __int64 &,unsigned __int64 &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	QWORD PTR tv79[rsp], rax
	mov	r8, QWORD PTR tv81[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??$?0AEA_KAEA_K$0A@@?$pair@$$CB_K_K@std@@QEAA@AEA_K0@Z ; std::pair<unsigned __int64 const ,unsigned __int64>::pair<unsigned __int64 const ,unsigned __int64><unsigned __int64 &,unsigned __int64 &,0>
	npad	1

; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::construct<std::pair<unsigned __int64 const ,unsigned __int64>,unsigned __int64 &,unsigned __int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 236  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\locale
;	COMDAT ??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::collate<char>::id'', COMDAT

; 124  : __PURE_APPDOMAIN_GLOBAL locale::id collate<_Elem>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$collate@D@std@@2V0locale@2@A ; std::collate<char>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$collate@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::collate<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1646 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id'', COMDAT

; 809  : __PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<char,char,_Mbstatet>::id
	call	??$?0$0A@@id@locale@std@@QEAA@XZ	; std::locale::id::id<0>
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::codecvt<char,char,_Mbstatet>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xlocale
;	COMDAT ??$?0$0A@@id@locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0$0A@@id@locale@std@@QEAA@XZ PROC			; std::locale::id::id<0>, COMDAT

; 81   :         id() noexcept /* strengthened */ {}

	mov	QWORD PTR [rsp+8], rcx

; 82   : #endif // ^^^ !defined(_CRTBLD) ^^^
; 83   : 
; 84   :         id(const id&)            = delete;
; 85   :         id& operator=(const id&) = delete;
; 86   : 
; 87   :         template <int = 0> // TRANSITION, ABI
; 88   :         size_t _Get_index() { // get stamp, with lazy allocation
; 89   :             if (_Id == 0) { // still zero, allocate stamp
; 90   :                 _BEGIN_LOCK(_LOCK_LOCALE)
; 91   :                 if (_Id == 0) {
; 92   :                     _Id = static_cast<size_t>(++_Id_cnt);
; 93   :                 }
; 94   :                 _END_LOCK()
; 95   :             }
; 96   :             return _Id;
; 97   :         }
; 98   : 
; 99   : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 100  :         __CLR_OR_THIS_CALL operator size_t() {
; 101  :             return _Get_index();
; 102  :         }
; 103  : #endif // defined(_CRTBLD)
; 104  : 
; 105  :     private:
; 106  :         size_t _Id = 0; // the identifier stamp

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 81   :         id() noexcept /* strengthened */ {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0$0A@@id@locale@std@@QEAA@XZ ENDP			; std::locale::id::id<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::destroy<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1017 :         ~_Range_eraser() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1018 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax], rcx

; 1019 :             _Next->_Prev        = _Predecessor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 1020 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldnext$ = 32
this$ = 64
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1010 :         void _Bump_erased() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1011 :             const auto _Oldnext = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldnext$[rsp], rax

; 1012 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rcx

; 1013 :             _Node::_Freenode(_List._Getal(), _Oldnext);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
	mov	rdx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, rax
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >

; 1014 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1015 :         }

	add	rsp, 56					; 00000038H
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1008 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _List_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1017 :         ~_Range_eraser() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1018 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax], rcx

; 1019 :             _Next->_Prev        = _Predecessor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 1020 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldnext$ = 32
this$ = 64
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1010 :         void _Bump_erased() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1011 :             const auto _Oldnext = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldnext$[rsp], rax

; 1012 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rcx

; 1013 :             _Node::_Freenode(_List._Getal(), _Oldnext);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
	mov	rdx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, rax
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >

; 1014 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1015 :         }

	add	rsp, 56					; 00000038H
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1008 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _List_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Hash_representation@_K@std@@YA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 48
??$_Hash_representation@_K@std@@YA_KAEB_K@Z PROC	; std::_Hash_representation<unsigned __int64>, COMDAT

; 2316 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2317 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, -3750763034362895579		; cbf29ce484222325H
	call	??$_Fnv1a_append_value@_K@std@@YA_K_KAEB_K@Z ; std::_Fnv1a_append_value<unsigned __int64>

; 2318 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Hash_representation@_K@std@@YA_KAEB_K@Z ENDP	; std::_Hash_representation<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z
_TEXT	SEGMENT
tv76 = 32
tv73 = 40
this$ = 64
_Keyval1$ = 72
_Keyval2$ = 80
??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z PROC ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int,unsigned int>, COMDAT

; 155  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  :         // test if _Keyval1 NOT equal to _Keyval2
; 157  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEBAAEBU?$equal_to@I@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Get_first
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR _Keyval2$[rsp]
	mov	rdx, QWORD PTR _Keyval1$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??R?$equal_to@I@std@@QEBA_NAEBI0@Z	; std::equal_to<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv76[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv76[rsp]

; 158  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z ENDP ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 484  :         ~_Clear_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 485  :             if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Clear_guar

; 486  :                 _Target->clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
	npad	1
$LN2@Clear_guar:

; 487  :             }
; 488  :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 479  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Target_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 484  :         ~_Clear_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 485  :             if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Clear_guar

; 486  :                 _Target->clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
	npad	1
$LN2@Clear_guar:

; 487  :             }
; 488  :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 479  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Target_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 484  :         ~_Clear_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 485  :             if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Clear_guar

; 486  :                 _Target->clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::clear
	npad	1
$LN2@Clear_guar:

; 487  :             }
; 488  :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 479  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Target_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z
_TEXT	SEGMENT
tv76 = 32
tv73 = 40
this$ = 64
_Keyval1$ = 72
_Keyval2$ = 80
??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z PROC ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc,enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 155  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  :         // test if _Keyval1 NOT equal to _Keyval2
; 157  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@std@@QEBAAEBU?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>::_Get_first
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR _Keyval2$[rsp]
	mov	rdx, QWORD PTR _Keyval1$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ; std::equal_to<enum IronMan::Core::SDK::DecryptFunc>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv76[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv76[rsp]

; 158  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ENDP ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc,enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 484  :         ~_Clear_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 485  :             if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Clear_guar

; 486  :                 _Target->clear();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::clear
	npad	1
$LN2@Clear_guar:

; 487  :             }
; 488  :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 479  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Target_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 123  : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 107  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator++

; 108  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 109  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 99   :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator*

; 100  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator!=, COMDAT

; 76   :     _NODISCARD bool operator!=(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 77   :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 78   :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 73   :     }

	add	rsp, 24
	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator--, COMDAT

; 60   :     _List_unchecked_const_iterator& operator--() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax

; 62   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 51   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CB_K_K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@U?$pair@$$CB_K_K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::destroy<std::pair<unsigned __int64 const ,unsigned __int64> >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();
; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	ret	0
??$destroy@U?$pair@$$CB_K_K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::destroy<std::pair<unsigned __int64 const ,unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 776  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::destroy<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::destroy<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 185  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 198  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv72 = 32
tv70 = 40
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>, COMDAT

; 1622 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1623 :         // construct a new element at *_Last and increment
; 1624 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv70[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>

; 1625 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1626 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Release, COMDAT

; 1628 :     constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1629 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1630 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1631 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>, COMDAT

; 1617 :     _CONSTEXPR20 ~_Uninitialized_backout() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1618 :         _STD _Destroy_range(_First, _Last);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
	npad	1

; 1619 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>, COMDAT

; 1610 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__formal$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
	npad	1

; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,unsigned __int64> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CB_K_K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::destroy<std::pair<unsigned __int64 const ,unsigned __int64> >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_K_K@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_K_K@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > ><std::pair<unsigned __int64 const ,unsigned __int64> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_K_K@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > ><std::pair<unsigned __int64 const ,unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_K_K@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_K_K@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > ><std::pair<unsigned __int64 const ,unsigned __int64> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_K_K@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_K_K@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_K_K@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z PROC ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ENDP ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
tv146 = 48
tv144 = 56
tv142 = 64
tv140 = 72
tv138 = 80
this$ = 112
_Al_$ = 120
<_Vals_0>$ = 128
<_Vals_1>$ = 136
<_Vals_2>$ = 144
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	npad	1

; 584  :         this->_Allocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_2>$[rsp]
	call	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
	mov	QWORD PTR tv146[rsp], rax
	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@@std@@YA$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@AEAV10@@Z ; std::forward<std::tuple<enum IronMan::Core::SDK::DecryptFunc &&> >
	mov	QWORD PTR tv144[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
	mov	QWORD PTR tv140[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR tv146[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv144[rsp]
	mov	r8, QWORD PTR tv142[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	mov	rcx, QWORD PTR tv138[rsp]
	call	??$construct@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::construct<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >
	npad	1

; 586  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv146 = 48
tv144 = 56
tv142 = 64
tv140 = 72
tv138 = 80
this$ = 112
_Al_$ = 120
<_Vals_0>$ = 128
<_Vals_1>$ = 136
<_Vals_2>$ = 144
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 589  :         if (this->_Ptr != pointer{}) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@YAPEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	??$destroy@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::destroy<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >
	npad	1
$LN2@List_node_:

; 591  :         }
; 592  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >, COMDAT

; 1167 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1168 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Alloc_cons

; 1169 :             _Al.deallocate(_Ptr, 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, 1
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::deallocate
	npad	1
$LN2@Alloc_cons:

; 1170 :         }
; 1171 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 32
this$ = 64
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Allocate, COMDAT

; 1162 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1164 :         _Ptr = _Al.allocate(1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv73[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::allocate
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1165 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Release, COMDAT

; 1158 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1159 :         return _STD exchange(_Ptr, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::nullptr_t>

; 1160 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >, COMDAT

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&>, COMDAT

; 352  :     tuple(tuple&&)      = default;

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z	; std::tuple<>::tuple<>
	mov	rax, QWORD PTR __that$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
<_Args_0>$ = 56
??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::forward_as_tuple<enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 1004 : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1005 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::forward<enum IronMan::Core::SDK::DecryptFunc>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0W4DecryptFunc@SDK@Core@IronMan@@$$V$0A@@?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@std@@QEAA@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>::tuple<enum IronMan::Core::SDK::DecryptFunc &&><enum IronMan::Core::SDK::DecryptFunc,0>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1006 : }

	add	rsp, 40					; 00000028H
	ret	0
??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::forward_as_tuple<enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z PROC ; std::forward<enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ENDP ; std::forward<enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Find_last<enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc,enum IronMan::Core::SDK::DecryptFunc>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Find_last<enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
tv75 = 32
this$ = 64
_Keyval$ = 72
??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 148  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 149  :         // hash _Keyval to size_t value
; 150  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@V?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>,1>::_Get_first
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Conditionally_enabled_hash<enum IronMan::Core::SDK::DecryptFunc,1>::operator()

; 151  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 32
_Al$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 802  : 
; 803  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 804  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 805  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 806  :         } else {
; 807  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 808  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 809  :         }
; 810  : 
; 811  : #if _HAS_CXX20
; 812  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 813  :         // but likely more impactful to throughput.
; 814  :         if (_STD is_constant_evaluated()) {
; 815  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 816  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 817  :                 _STD construct_at(_Ptr + _Idx);
; 818  :             }
; 819  :         }
; 820  : #endif // _HAS_CXX20
; 821  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 822  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 823  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z
_TEXT	SEGMENT
_First1$ = 48
_Last1$ = 56
_First2$ = 64
_Count2$ = 72
??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z PROC ; std::_Search_vectorized<char const ,char const >, COMDAT

; 277  : _Ty1* _Search_vectorized(_Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, const size_t _Count2) noexcept {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 278  :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Ty1) == sizeof(_Ty2));
; 279  :     if constexpr (sizeof(_Ty1) == 1) {
; 280  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_1(_First1, _Last1, _First2, _Count2)));

	mov	r9, QWORD PTR _Count2$[rsp]
	mov	r8, QWORD PTR _First2$[rsp]
	mov	rdx, QWORD PTR _Last1$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	__std_search_1

; 281  :     } else if constexpr (sizeof(_Ty1) == 2) {
; 282  :         return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));
; 283  :     } else {
; 284  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 285  :     }
; 286  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ENDP ; std::_Search_vectorized<char const ,char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Val$ = 64
??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z PROC ; std::_Find_last_vectorized<char const ,char>, COMDAT

; 226  : _Ty* _Find_last_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 227  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 228  : #ifdef _WIN64
; 229  :         return const_cast<_Ty*>(
; 230  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 231  : #else
; 232  :         return const_cast<_Ty*>(
; 233  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 234  : #endif
; 235  :     } else if constexpr (sizeof(_Ty) == 1) {
; 236  :         return const_cast<_Ty*>(

	movzx	r8d, BYTE PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	__std_find_last_trivial_1

; 237  :             static_cast<const _Ty*>(::__std_find_last_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 238  :     } else if constexpr (sizeof(_Ty) == 2) {
; 239  :         return const_cast<_Ty*>(
; 240  :             static_cast<const _Ty*>(::__std_find_last_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 241  :     } else if constexpr (sizeof(_Ty) == 4) {
; 242  :         return const_cast<_Ty*>(
; 243  :             static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 244  :     } else if constexpr (sizeof(_Ty) == 8) {
; 245  :         return const_cast<_Ty*>(
; 246  :             static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 247  :     } else {
; 248  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 249  :     }
; 250  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ENDP ; std::_Find_last_vectorized<char const ,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 1004 : _NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple

	mov	QWORD PTR [rsp+8], rcx

; 1005 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1006 : }

	ret	0
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>, COMDAT

; 1409 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	mov	QWORD PTR [rsp+8], rcx

; 1410 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1411 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1412 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1413 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1414 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1415 :     } else {
; 1416 :         return static_cast<_Iter&&>(_It);
; 1417 :     }
; 1418 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1382 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1383 :     // check that [_First, _Last) forms an iterator range
; 1384 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1385 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1386 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1387 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1388 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1389 :         _Verify_range(_First, _Last);
; 1390 :     }
; 1391 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\ObjectsStore.h
;	COMDAT ??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ PROC ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,3244701931984741072>, COMDAT

; 91   : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 92   : 			return FindObject<T>(hash);

	mov	r8, 3244701931984741072			; 2d077f3749f962d0H
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 93   : 		}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ENDP ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,3244701931984741072>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA PROC ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,3244701931984741072>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA ENDP ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,3244701931984741072>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\ObjectsStore.h
;	COMDAT ??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ PROC ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,-4342903124670388529>, COMDAT

; 91   : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 92   : 			return FindObject<T>(hash);

	mov	r8, -4342903124670388529		; c3bae89e281666cfH
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$FindObject@VUClass@SDK@Core@IronMan@@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@_K@Z ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass>
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 93   : 		}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ENDP ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,-4342903124670388529>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA PROC ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,-4342903124670388529>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA ENDP ; `IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,-4342903124670388529>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv70 = 48
tv133 = 56
$T3 = 64
tv66 = 72
tv135 = 80
tv87 = 88
tv95 = 96
$T4 = 104
$T5 = 304
ThisClass$ = 512
SomeBaseClass$ = 720
__$ArrayPad$ = 928
this$ = 960
SomeBase$ = 968
??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>, COMDAT

; 521  : 		{

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 952				; 000003b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 522  : 			// We have a cyclic dependency between UObjectBaseUtility and UClass,
; 523  : 			// so we use a template to allow inlining of something we haven't yet seen, because it delays compilation until the function is called.
; 524  : 
; 525  : 			// 'static_assert' that this thing is actually a UClass pointer or convertible to it.
; 526  : 			const UClass SomeBaseClass = SomeBase;

	mov	rdx, QWORD PTR SomeBase$[rsp]
	lea	rcx, QWORD PTR SomeBaseClass$[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	npad	1

; 527  : 			const UClass ThisClass = GetClass();

	lea	rdx, QWORD PTR ThisClass$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ ; IronMan::Core::SDK::UObject::GetClass
	npad	1

; 528  : 
; 529  : 			return IsAWorkaround(ThisClass, SomeBaseClass);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR SomeBaseClass$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv70[rsp], rax
	mov	rax, QWORD PTR tv70[rsp]
	mov	QWORD PTR tv133[rsp], rax
	mov	rax, QWORD PTR tv133[rsp]
	mov	QWORD PTR tv87[rsp], rax
	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR ThisClass$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR tv66[rsp]
	mov	QWORD PTR tv135[rsp], rax
	mov	rax, QWORD PTR tv135[rsp]
	mov	QWORD PTR tv95[rsp], rax
	mov	rdx, QWORD PTR tv87[rsp]
	mov	rcx, QWORD PTR tv95[rsp]
	call	??$IsAWorkaround@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@CA_NVUClass@123@0@Z ; IronMan::Core::SDK::UObject::IsAWorkaround<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T1[rsp], al
	lea	rcx, QWORD PTR ThisClass$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	npad	1
	lea	rcx, QWORD PTR SomeBaseClass$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	npad	1
	mov	rcx, QWORD PTR SomeBase$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]

; 530  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 952				; 000003b8H
	ret	0
??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv70 = 48
tv133 = 56
$T3 = 64
tv66 = 72
tv135 = 80
tv87 = 88
tv95 = 96
$T4 = 104
$T5 = 304
ThisClass$ = 512
SomeBaseClass$ = 720
__$ArrayPad$ = 928
this$ = 960
SomeBase$ = 968
?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR SomeBase$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv70 = 48
tv133 = 56
$T3 = 64
tv66 = 72
tv135 = 80
tv87 = 88
tv95 = 96
$T4 = 104
$T5 = 304
ThisClass$ = 512
SomeBaseClass$ = 720
__$ArrayPad$ = 928
this$ = 960
SomeBase$ = 968
?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR SomeBaseClass$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv70 = 48
tv133 = 56
$T3 = 64
tv66 = 72
tv135 = 80
tv87 = 88
tv95 = 96
$T4 = 104
$T5 = 304
ThisClass$ = 512
SomeBaseClass$ = 720
__$ArrayPad$ = 928
this$ = 960
SomeBase$ = 968
?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR ThisClass$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv70 = 48
tv133 = 56
$T3 = 64
tv66 = 72
tv135 = 80
tv87 = 88
tv95 = 96
$T4 = 104
$T5 = 304
ThisClass$ = 512
SomeBaseClass$ = 720
__$ArrayPad$ = 928
this$ = 960
SomeBase$ = 968
?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T2[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv70 = 48
tv133 = 56
$T3 = 64
tv66 = 72
tv135 = 80
tv87 = 88
tv95 = 96
$T4 = 104
$T5 = 304
ThisClass$ = 512
SomeBaseClass$ = 720
__$ArrayPad$ = 928
this$ = 960
SomeBase$ = 968
?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 584  :         this->_Allocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@_K@std@@YA$$QEA_KAEA_K@Z	; std::forward<unsigned __int64>
	mov	QWORD PTR tv139[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv135[rsp], rax
	mov	r9, QWORD PTR tv141[rsp]
	mov	r8, QWORD PTR tv139[rsp]
	mov	rdx, QWORD PTR tv137[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	??$construct@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	npad	1

; 586  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 589  :         if (this->_Ptr != pointer{}) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
$LN2@List_node_:

; 591  :         }
; 592  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 1167 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1168 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Alloc_cons

; 1169 :             _Al.deallocate(_Ptr, 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, 1
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
	npad	1
$LN2@Alloc_cons:

; 1170 :         }
; 1171 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 32
this$ = 64
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate, COMDAT

; 1162 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1164 :         _Ptr = _Al.allocate(1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv73[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1165 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release, COMDAT

; 1158 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1159 :         return _STD exchange(_Ptr, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>

; 1160 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned __int64>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map_impl@_K_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SAAEB_KAEB_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_Val$ = 8
__formal$ = 16
?_Extract@?$_In_place_key_extract_map_impl@_K_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SAAEB_KAEB_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Extract, COMDAT

; 2128 :     static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 2129 :         return _Val;

	mov	rax, QWORD PTR _Val$[rsp]

; 2130 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map_impl@_K_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SAAEB_KAEB_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 40
this$ = 80
_Keyval$ = 88
_Hashval$ = 96
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned __int64>, COMDAT

; 1213 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1214 :         if constexpr (_Traits::_Multi) {
; 1215 :             return _Find_first(_Keyval, _Hashval);
; 1216 :         } else {
; 1217 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1218 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned __int64>
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Target$1[rsp], rax

; 1219 :             if (_Target) {

	cmp	QWORD PTR _Target$1[rsp], 0
	je	SHORT $LN2@Find

; 1220 :                 return _Target;

	mov	rax, QWORD PTR _Target$1[rsp]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1221 :             }
; 1222 : 
; 1223 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@Find:

; 1224 :         }
; 1225 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned int>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int,unsigned int>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 584  :         this->_Allocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEAH@std@@YAAEAHAEAH@Z	; std::forward<int &>
	mov	QWORD PTR tv139[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv135[rsp], rax
	mov	r9, QWORD PTR tv141[rsp]
	mov	r8, QWORD PTR tv139[rsp]
	mov	rdx, QWORD PTR tv137[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	npad	1

; 586  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 589  :         if (this->_Ptr != pointer{}) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
$LN2@List_node_:

; 591  :         }
; 592  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 1167 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1168 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Alloc_cons

; 1169 :             _Al.deallocate(_Ptr, 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, 1
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
	npad	1
$LN2@Alloc_cons:

; 1170 :         }
; 1171 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 32
this$ = 64
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate, COMDAT

; 1162 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1164 :         _Ptr = _Al.allocate(1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv73[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1165 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release, COMDAT

; 1158 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1159 :         return _STD exchange(_Ptr, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::nullptr_t>

; 1160 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 40
this$ = 80
_Keyval$ = 88
_Hashval$ = 96
??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>, COMDAT

; 1213 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1214 :         if constexpr (_Traits::_Multi) {
; 1215 :             return _Find_first(_Keyval, _Hashval);
; 1216 :         } else {
; 1217 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1218 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned int>
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Target$1[rsp], rax

; 1219 :             if (_Target) {

	cmp	QWORD PTR _Target$1[rsp], 0
	je	SHORT $LN2@Find

; 1220 :                 return _Target;

	mov	rax, QWORD PTR _Target$1[rsp]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1221 :             }
; 1222 : 
; 1223 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@Find:

; 1224 :         }
; 1225 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z PROC ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z
_TEXT	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > ><unsigned __int64 &,unsigned __int64 &>, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rdx, QWORD PTR _Al_$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	npad	1

; 584  :         this->_Allocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Allocate

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	QWORD PTR tv141[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	QWORD PTR tv139[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,unsigned __int64> >
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv135[rsp], rax
	mov	r9, QWORD PTR tv141[rsp]
	mov	r8, QWORD PTR tv139[rsp]
	mov	rdx, QWORD PTR tv137[rsp]
	mov	rcx, QWORD PTR tv135[rsp]
	call	??$construct@U?$pair@$$CB_K_K@std@@AEA_KAEA_K@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@AEA_K2@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::construct<std::pair<unsigned __int64 const ,unsigned __int64>,unsigned __int64 &,unsigned __int64 &>
	npad	1

; 586  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > ><unsigned __int64 &,unsigned __int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv141 = 32
tv139 = 40
tv137 = 48
tv135 = 56
this$ = 80
_Al_$ = 88
<_Vals_0>$ = 96
<_Vals_1>$ = 104
?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > ><unsigned __int64 &,unsigned __int64 &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > ><unsigned __int64 &,unsigned __int64 &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 589  :         if (this->_Ptr != pointer{}) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@List_node_

; 590  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,unsigned __int64> >
	mov	QWORD PTR tv93[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	rdx, QWORD PTR tv93[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	??$destroy@U?$pair@$$CB_K_K@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@QEAU?$pair@$$CB_K_K@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::destroy<std::pair<unsigned __int64 const ,unsigned __int64> >
	npad	1
$LN2@List_node_:

; 591  :         }
; 592  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv93 = 32
tv91 = 40
this$ = 64
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
this$ = 64
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >, COMDAT

; 1167 :     _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1168 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Alloc_cons

; 1169 :             _Al.deallocate(_Ptr, 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	r8d, 1
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tv72[rsp]
	call	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::deallocate
	npad	1
$LN2@Alloc_cons:

; 1170 :         }
; 1171 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv73 = 32
this$ = 64
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Allocate, COMDAT

; 1162 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1164 :         _Ptr = _Al.allocate(1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	edx, 1
	mov	rcx, QWORD PTR tv73[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocate
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1165 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Release, COMDAT

; 1158 :     _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1159 :         return _STD exchange(_Ptr, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::nullptr_t>

; 1160 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >, COMDAT

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR _Val2$[rsp]
	call	??$forward@_N@std@@YA$$QEA_NAEA_N@Z	; std::forward<bool>
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z
_TEXT	SEGMENT
_Where$ = 32
_End$ = 40
_Bucket$ = 48
tv143 = 56
_Bucket_lo$ = 64
this$ = 96
__$ReturnUdt$ = 104
_Keyval$ = 112
_Hashval$ = 120
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find_last<unsigned __int64>, COMDAT

; 1537 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN9:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1538 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1539 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1540 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1541 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1542 :         if (_Where == _End) {

	mov	rax, QWORD PTR _End$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN5@Find_last

; 1543 :             return {_End, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Find_last
$LN5@Find_last:

; 1544 :         }
; 1545 : 
; 1546 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax
$LN2@Find_last:

; 1547 :         for (;;) {
; 1548 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1549 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv143[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Find_last

; 1550 :                 if constexpr (!_Traits::_Standard) {
; 1551 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1552 :                         return {_Where->_Next, _Nodeptr{}};
; 1553 :                     }
; 1554 :                 }
; 1555 : 
; 1556 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN6@Find_last:

; 1557 :             }
; 1558 : 
; 1559 :             if (_Where == _Bucket_lo) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	cmp	QWORD PTR _Where$[rsp], rax
	jne	SHORT $LN7@Find_last

; 1560 :                 return {_Where, _Nodeptr{}};

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR _Where$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Find_last
$LN7@Find_last:

; 1561 :             }
; 1562 : 
; 1563 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR _Where$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Where$[rsp], rax

; 1564 :         }

	jmp	$LN2@Find_last
$LN1@Find_last:

; 1565 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find_last<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map_impl@_K_K_K@std@@SAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Val$ = 8
__formal$ = 16
?_Extract@?$_In_place_key_extract_map_impl@_K_K_K@std@@SAAEB_KAEB_K0@Z PROC ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,unsigned __int64>::_Extract, COMDAT

; 2128 :     static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 2129 :         return _Val;

	mov	rax, QWORD PTR _Val$[rsp]

; 2130 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map_impl@_K_K_K@std@@SAAEB_KAEB_K0@Z ENDP ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,unsigned __int64>::_Extract
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 40
this$ = 80
_Keyval$ = 88
_Hashval$ = 96
??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find<unsigned __int64>, COMDAT

; 1213 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1214 :         if constexpr (_Traits::_Multi) {
; 1215 :             return _Find_first(_Keyval, _Hashval);
; 1216 :         } else {
; 1217 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1218 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find_last<unsigned __int64>
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Target$1[rsp], rax

; 1219 :             if (_Target) {

	cmp	QWORD PTR _Target$1[rsp], 0
	je	SHORT $LN2@Find

; 1220 :                 return _Target;

	mov	rax, QWORD PTR _Target$1[rsp]
	jmp	SHORT $LN1@Find
$LN2@Find:

; 1221 :             }
; 1222 : 
; 1223 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
$LN1@Find:

; 1224 :         }
; 1225 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAH@std@@YAAEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAH@std@@YAAEAHAEAH@Z PROC			; std::forward<int &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAH@std@@YAAEAHAEAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEA_K@std@@YAAEA_KAEA_K@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEA_K@std@@YAAEA_KAEA_K@Z PROC		; std::forward<unsigned __int64 &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEA_K@std@@YAAEA_KAEA_K@Z ENDP		; std::forward<unsigned __int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z
_TEXT	SEGMENT
_Val$ = 48
_Keyval$ = 56
??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z PROC		; std::_Fnv1a_append_value<unsigned int>, COMDAT

; 2310 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2311 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2312 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	mov	r8d, 4
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	call	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ; std::_Fnv1a_append_bytes

; 2313 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z ENDP		; std::_Fnv1a_append_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<56>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 329406144173384850			; 0492492492492492H
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 56		; 00000038H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<56>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv76 = 32
tv73 = 40
this$ = 64
_Keyval1$ = 72
_Keyval2$ = 80
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>, COMDAT

; 155  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  :         // test if _Keyval1 NOT equal to _Keyval2
; 157  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR _Keyval2$[rsp]
	mov	rdx, QWORD PTR _Keyval1$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z	; std::equal_to<unsigned __int64>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv76[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv76[rsp]

; 158  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 320  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 257  :     }
; 258  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<32>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 32		; 00000020H
$LN3@Get_size_o:

; 123  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<32>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> ><std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U?$pair@$$CB_K_K@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$pair@$$CB_K_K@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> ><std::pair<unsigned __int64 const ,unsigned __int64> >, COMDAT

; 974  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0U?$pair@$$CB_K_K@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> ><std::pair<unsigned __int64 const ,unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_K_K@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$?0U?$pair@$$CB_K_K@std@@@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> ><std::pair<unsigned __int64 const ,unsigned __int64> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >, COMDAT

; 2002 : void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2003 :     // copy _Val throughout raw [_First, _Last)
; 2004 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>

; 2005 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2006 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2007 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2008 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2009 :     } else {
; 2010 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2011 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2012 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2013 :                 return;
; 2014 :             }
; 2015 :         }
; 2016 : 
; 2017 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};

	mov	rdx, QWORD PTR _UFirst$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
	npad	1
$LN2@uninitiali:

; 2018 :         while (_Backout._Last != _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _Backout$1[rsp+8], rax
	je	SHORT $LN3@uninitiali

; 2019 :             _Backout._Emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > const &>
	npad	1

; 2020 :         }

	jmp	SHORT $LN2@uninitiali
$LN3@uninitiali:

; 2021 : 
; 2022 :         _Backout._Release();

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::_Release
	npad	1

; 2023 :     }

	lea	rcx, QWORD PTR _Backout$1[rsp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
	npad	1

; 2024 : }

	add	rsp, 72					; 00000048H
	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
_Backout$1 = 48
_First$ = 80
_Last$ = 88
_Val$ = 96
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA PROC ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$1[rbp]
	call	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z@4HA ENDP ; `std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$destroy@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 319  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN2@Deallocate:

; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 290  :     }
; 291  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 499  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 500  : #if _HAS_CXX20
; 501  :     if (_STD is_constant_evaluated()) {
; 502  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 503  :     } else
; 504  : #endif // _HAS_CXX20
; 505  :     {
; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 507  :     }
; 508  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx], xmm0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv81 = 48
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
<_Val2_1>$ = 104
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv79[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$?0M@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Compressed_pair<std::equal_to<unsigned __int64>,float,1><float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Compressed_pair<std::equal_to<unsigned int>,float,1><float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	rcx, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [rcx], xmm0
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Compressed_pair<std::equal_to<unsigned int>,float,1><float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv81 = 48
this$ = 80
__formal$ = 88
<_Val2_0>$ = 96
<_Val2_1>$ = 104
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Val2_1>$[rsp]
	call	??$forward@M@std@@YA$$QEAMAEAM@Z	; std::forward<float>
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv79[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$?0M@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Compressed_pair<std::equal_to<unsigned int>,float,1><float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv73 = 40
tv75 = 48
tv84 = 56
this$ = 80
_Al$ = 88
??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>, COMDAT

; 267  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	npad	1

; 268  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 269  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1017 :         ~_Range_eraser() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1018 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax], rcx

; 1019 :             _Next->_Prev        = _Predecessor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 1020 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldnext$ = 32
this$ = 64
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1010 :         void _Bump_erased() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1011 :             const auto _Oldnext = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldnext$[rsp], rax

; 1012 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rcx

; 1013 :             _Node::_Freenode(_List._Getal(), _Oldnext);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	rdx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, rax
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1014 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1015 :         }

	add	rsp, 56					; 00000038H
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1008 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _List_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv73 = 40
tv75 = 48
tv84 = 56
this$ = 80
_Al$ = 88
??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>, COMDAT

; 267  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	npad	1

; 268  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 269  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 54   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) noexcept { // extract key from element value

	mov	QWORD PTR [rsp+8], rcx

; 55   :         return _Val.first;

	mov	rax, QWORD PTR _Val$[rsp]

; 56   :     }

	ret	0
??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1017 :         ~_Range_eraser() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1018 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax], rcx

; 1019 :             _Next->_Prev        = _Predecessor;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 1020 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldnext$ = 32
this$ = 64
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1010 :         void _Bump_erased() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1011 :             const auto _Oldnext = _Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldnext$[rsp], rax

; 1012 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rcx

; 1013 :             _Node::_Freenode(_List._Getal(), _Oldnext);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	rdx, QWORD PTR _Oldnext$[rsp]
	mov	rcx, rax
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1014 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+8]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1015 :         }

	add	rsp, 56					; 00000038H
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1008 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _List_$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _First_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *>

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::deallocate
	npad	1

; 313  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 32
_Pnext$1 = 40
_Al$ = 64
_Head$ = 72
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rsp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR _Pnode$[rsp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rsp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rsp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv73 = 40
tv75 = 48
tv84 = 56
this$ = 80
_Al$ = 88
??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > ><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &,0>, COMDAT

; 267  :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Any_alloc>(_Al)) { // construct empty vector, allocator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$forward@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CB_K_K@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
	mov	QWORD PTR tv73[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv73[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
	npad	1

; 268  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv84[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
	npad	1

; 269  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > ><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>, COMDAT

; 1105 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1106 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1107 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1108 :         for (; _First != _Last; ++_First) {
; 1109 :             _STD _Destroy_in_place(*_First);
; 1110 :         }
; 1111 :     }
; 1112 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 107  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator++

; 108  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 109  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 99   :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator*

; 100  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ PROC ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::~pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::~unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::~pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::~pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::~unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >::~pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
_Hashval$ = 56
_Keyval$ = 64
_Target$ = 72
tv73 = 88
tv136 = 96
tv134 = 104
tv132 = 112
$T4 = 120
_Newnode$ = 128
$T5 = 144
$T6 = 152
this$ = 208
__$ReturnUdt$ = 216
_Keyval_arg$ = 224
??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Try_emplace<enum IronMan::Core::SDK::DecryptFunc>, COMDAT

; 695  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H

; 696  :         const auto& _Keyval = _Keyval_arg;

	mov	rax, QWORD PTR _Keyval_arg$[rsp]
	mov	QWORD PTR _Keyval$[rsp], rax

; 697  :         const auto _Hashval = _Traitsobj(_Keyval);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc>
	mov	QWORD PTR _Hashval$[rsp], rax

; 698  :         auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, QWORD PTR _Keyval$[rsp]
	lea	rdx, QWORD PTR _Target$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Find_last<enum IronMan::Core::SDK::DecryptFunc>
	npad	1

; 699  :         if (_Target._Duplicate) {

	cmp	QWORD PTR _Target$[rsp+8], 0
	je	SHORT $LN2@Try_emplac

; 700  :             return {_Target._Duplicate, false};

	mov	BYTE PTR $T1[rsp], 0
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR _Target$[rsp+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * &,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@Try_emplac
$LN2@Try_emplac:

; 701  :         }
; 702  : 
; 703  :         _Check_max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_max_size
	npad	1

; 704  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,

	lea	rcx, QWORD PTR $T3[rsp]
	call	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
	mov	QWORD PTR tv136[rsp], rax
	mov	rcx, QWORD PTR _Keyval_arg$[rsp]
	call	??$forward@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::forward<enum IronMan::Core::SDK::DecryptFunc>
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$forward_as_tuple@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA?AV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@0@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::forward_as_tuple<enum IronMan::Core::SDK::DecryptFunc>
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR tv136[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR tv134[rsp]
	lea	r8, OFFSET FLAT:?piecewise_construct@std@@3Upiecewise_construct_t@1@B ; std::piecewise_construct
	mov	rdx, QWORD PTR tv132[rsp]
	lea	rcx, QWORD PTR _Newnode$[rsp]
	call	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<enum IronMan::Core::SDK::DecryptFunc &&>,std::tuple<> >
	npad	1

; 705  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 706  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 707  :         if (_Check_rehash_required_1()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_rehash_required_1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Try_emplac

; 708  :             _Rehash_for_1();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Rehash_for_1
	npad	1

; 709  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	rax, QWORD PTR _Newnode$[rsp+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
	mov	r9, QWORD PTR _Hashval$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@W4DecryptFunc@SDK@Core@IronMan@@@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@AEBW4DecryptFunc@SDK@Core@IronMan@@_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Find_last<enum IronMan::Core::SDK::DecryptFunc>
	lea	rcx, QWORD PTR _Target$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN3@Try_emplac:

; 710  :         }
; 711  : 
; 712  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	lea	rcx, QWORD PTR _Newnode$[rsp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::_Release
	mov	r9, rax
	mov	r8, QWORD PTR _Target$[rsp]
	mov	rdx, QWORD PTR _Hashval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Insert_new_node_before
	mov	QWORD PTR $T4[rsp], rax
	mov	BYTE PTR $T2[rsp], 1
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool>::pair<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool><std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,bool,0>
	npad	1
	lea	rcx, QWORD PTR _Newnode$[rsp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Try_emplac:

; 713  :     }

	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Try_emplace<enum IronMan::Core::SDK::DecryptFunc>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 49
$T3 = 50
_Hashval$ = 56
_Keyval$ = 64
_Target$ = 72
tv73 = 88
tv136 = 96
tv134 = 104
tv132 = 112
$T4 = 120
_Newnode$ = 128
$T5 = 144
$T6 = 152
this$ = 208
__$ReturnUdt$ = 216
_Keyval_arg$ = 224
?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Try_emplace<enum IronMan::Core::SDK::DecryptFunc>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Newnode$[rbp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Try_emplace<enum IronMan::Core::SDK::DecryptFunc>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z PROC ; std::move<enum IronMan::Core::SDK::DecryptFunc &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ENDP ; std::move<enum IronMan::Core::SDK::DecryptFunc &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z PROC ; std::addressof<std::pair<unsigned __int64 const ,unsigned __int64> >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z ENDP ; std::addressof<std::pair<unsigned __int64 const ,unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
_My_data$ = 40
_New_capacity$ = 48
_New_ptr$ = 56
_Alproxy$ = 64
_Al$ = 72
tv135 = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8d, 16
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	rax, QWORD PTR _Count$[rsp]
	inc	rax
	mov	QWORD PTR tv135[rsp], rax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR tv135[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_Proxy$ = 32
$T1 = 33
$T2 = 34
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 848  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 858  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
	npad	1

; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rsp], 15
	ja	SHORT $LN3@Construct

; 866  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 867  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 868  : 
; 869  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 870  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 871  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 872  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 873  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 884  :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 885  :         }
; 886  : 
; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 890  : 
; 891  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 892  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1
$LN1@Construct:
$LN4@Construct:

; 905  :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1532 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1078 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1079 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1080 :         _Left = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	npad	1

; 1081 :     }
; 1082 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1071 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1072 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1073 :         _Left = _Right;
; 1074 :     }
; 1075 : }

	ret	0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>, COMDAT

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2992 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 2994 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2999 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3000 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3001 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3002 : 
; 3003 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 3004 :         _ASAN_STRING_REMOVE(*this);
; 3005 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 3006 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3010 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3011 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 3013 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3014 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3016 :         }
; 3017 : 
; 3018 :         _ASAN_STRING_CREATE(*this);
; 3019 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3020 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ptr$ = 96
_Count$ = 104
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 1505 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1505 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
_TEXT	SEGMENT
_New_ptr$ = 32
_New_capacity$ = 40
_Old_capacity$ = 48
_Al$ = 56
this$ = 80
_New_size$ = 88
_Fn$ = 96
<_Args_0>$ = 104
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>, COMDAT

; 2959 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2960 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 2961 :         // _Fn(_New_ptr, _New_size, _Args...)
; 2962 :         if (_New_size > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _New_size$[rsp], rax
	jbe	SHORT $LN2@Reallocate

; 2963 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2964 :         }
; 2965 : 
; 2966 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 2967 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2968 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2969 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2970 : 
; 2971 :         _Mypair._Myval2._Orphan_all();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 2972 :         _ASAN_STRING_REMOVE(*this);
; 2973 :         _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2975 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r9, QWORD PTR <_Args_0>$[rsp]
	mov	r8, QWORD PTR _New_size$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
	npad	1

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 2977 :             _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 2978 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 2979 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 2980 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 2981 :         }
; 2982 : 
; 2983 :         _ASAN_STRING_CREATE(*this);
; 2984 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 2985 :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Count$ = 80
_Ptr$ = 88
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z PROC ; <lambda_66f57f934f28d61049862f64df852ff0>::operator(), COMDAT

; 1609 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1607 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1609 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ENDP ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN3:
	sub	rsp, 24

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 78   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1550 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1551 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1552 : }

	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_End$2 = 40
_Ptr$3 = 48
_Possible_matches_end$ = 56
_Haystack$ = 80
_Hay_size$ = 88
_Start_at$ = 96
_Needle$ = 104
_Needle_size$ = 112
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 613  :     const size_t _Needle_size) noexcept {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 614  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 615  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	rax, QWORD PTR _Hay_size$[rsp]
	cmp	QWORD PTR _Needle_size$[rsp], rax
	ja	SHORT $LN6@Traits_fin
	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Start_at$[rsp], rax
	jbe	SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 616  :         // xpos cannot exist, report failure
; 617  :         // N4950 [string.view.find]/3 says:
; 618  :         // 1. _Start_at <= xpos
; 619  :         // 2. xpos + _Needle_size <= _Hay_size;
; 620  :         // therefore:
; 621  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 622  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 623  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 624  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN5@Traits_fin:

; 625  :     }
; 626  : 
; 627  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	cmp	QWORD PTR _Needle_size$[rsp], 0
	jne	SHORT $LN7@Traits_fin

; 628  :         return _Start_at;

	mov	rax, QWORD PTR _Start_at$[rsp]
	jmp	$LN1@Traits_fin
$LN7@Traits_fin:

; 629  :     }
; 630  : 
; 631  : #if _USE_STD_VECTOR_ALGORITHMS
; 632  :     if constexpr (_Is_implementation_handled_char_traits<_Traits> && sizeof(typename _Traits::char_type) <= 2) {
; 633  :         if (!_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@Traits_fin

; 634  :             const auto _End = _Haystack + _Hay_size;

	mov	rax, QWORD PTR _Hay_size$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _End$2[rsp], rax

; 635  :             const auto _Ptr = _STD _Search_vectorized(_Haystack + _Start_at, _End, _Needle, _Needle_size);

	mov	rax, QWORD PTR _Start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR _Needle_size$[rsp]
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, QWORD PTR _End$2[rsp]
	mov	rcx, rax
	call	??$_Search_vectorized@$$CBD$$CBD@std@@YAPEBDQEBD00_K@Z ; std::_Search_vectorized<char const ,char const >
	mov	QWORD PTR _Ptr$3[rsp], rax

; 636  : 
; 637  :             if (_Ptr != _End) {

	mov	rax, QWORD PTR _End$2[rsp]
	cmp	QWORD PTR _Ptr$3[rsp], rax
	je	SHORT $LN9@Traits_fin

; 638  :                 return static_cast<size_t>(_Ptr - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	$LN1@Traits_fin

; 639  :             } else {

	jmp	SHORT $LN10@Traits_fin
$LN9@Traits_fin:

; 640  :                 return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN10@Traits_fin:
$LN8@Traits_fin:

; 641  :             }
; 642  :         }
; 643  :     }
; 644  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 645  : 
; 646  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Haystack$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR _Possible_matches_end$[rsp], rax

; 647  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	mov	rax, QWORD PTR _Start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_fin
$LN2@Traits_fin:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	inc	rax
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_fin:

; 648  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	mov	rax, QWORD PTR _Match_try$1[rsp]
	mov	rcx, QWORD PTR _Possible_matches_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
	mov	QWORD PTR _Match_try$1[rsp], rax

; 649  :         if (!_Match_try) { // didn't find first character; report failure

	cmp	QWORD PTR _Match_try$1[rsp], 0
	jne	SHORT $LN11@Traits_fin

; 650  :             return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_fin
$LN11@Traits_fin:

; 651  :         }
; 652  : 
; 653  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	mov	r8, QWORD PTR _Needle_size$[rsp]
	mov	rdx, QWORD PTR _Needle$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
	test	eax, eax
	jne	SHORT $LN12@Traits_fin

; 654  :             return static_cast<size_t>(_Match_try - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_fin
$LN12@Traits_fin:

; 655  :         }
; 656  :     }

	jmp	SHORT $LN2@Traits_fin
$LN1@Traits_fin:

; 657  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_End$2 = 40
_Ptr$3 = 48
_Actual_start_at$ = 56
$T4 = 64
_Haystack$ = 96
_Hay_size$ = 104
_Start_at$ = 112
_Ch$ = 120
??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z PROC ; std::_Traits_rfind_ch<std::char_traits<char> >, COMDAT

; 720  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {

$LN12:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 721  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 722  : 
; 723  :     if (_Hay_size == 0) { // no room for match

	cmp	QWORD PTR _Hay_size$[rsp], 0
	jne	SHORT $LN5@Traits_rfi

; 724  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_rfi
$LN5@Traits_rfi:

; 725  :     }
; 726  : 
; 727  :     const size_t _Actual_start_at = (_STD min)(_Start_at, _Hay_size - 1);

	mov	rax, QWORD PTR _Hay_size$[rsp]
	dec	rax
	mov	QWORD PTR $T4[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR _Start_at$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Actual_start_at$[rsp], rax

; 728  : 
; 729  : #if _USE_STD_VECTOR_ALGORITHMS
; 730  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 731  :         if (!_STD _Is_constant_evaluated()) {

	call	?_Is_constant_evaluated@std@@YA_NXZ	; std::_Is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@Traits_rfi

; 732  :             const auto _End = _Haystack + _Actual_start_at + 1;

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Actual_start_at$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	QWORD PTR _End$2[rsp], rax

; 733  :             const auto _Ptr = _STD _Find_last_vectorized(_Haystack, _End, _Ch);

	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _End$2[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	call	??$_Find_last_vectorized@$$CBDD@std@@YAPEBDQEBD0D@Z ; std::_Find_last_vectorized<char const ,char>
	mov	QWORD PTR _Ptr$3[rsp], rax

; 734  : 
; 735  :             if (_Ptr != _End) {

	mov	rax, QWORD PTR _End$2[rsp]
	cmp	QWORD PTR _Ptr$3[rsp], rax
	je	SHORT $LN7@Traits_rfi

; 736  :                 return static_cast<size_t>(_Ptr - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_rfi

; 737  :             } else {

	jmp	SHORT $LN8@Traits_rfi
$LN7@Traits_rfi:

; 738  :                 return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN8@Traits_rfi:
$LN6@Traits_rfi:

; 739  :             }
; 740  :         }
; 741  :     }
; 742  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 743  : 
; 744  :     for (auto _Match_try = _Haystack + _Actual_start_at;; --_Match_try) {

	mov	rax, QWORD PTR _Actual_start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_rfi
$LN2@Traits_rfi:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	dec	rax
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_rfi:

; 745  :         if (_Traits::eq(*_Match_try, _Ch)) {

	movzx	edx, BYTE PTR _Ch$[rsp]
	mov	rax, QWORD PTR _Match_try$1[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ; std::_Narrow_char_traits<char,int>::eq
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Traits_rfi

; 746  :             return static_cast<size_t>(_Match_try - _Haystack); // found a match

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_rfi
$LN9@Traits_rfi:

; 747  :         }
; 748  : 
; 749  :         if (_Match_try == _Haystack) {

	mov	rax, QWORD PTR _Haystack$[rsp]
	cmp	QWORD PTR _Match_try$1[rsp], rax
	jne	SHORT $LN10@Traits_rfi

; 750  :             return static_cast<size_t>(-1); // at beginning, no more chance for match

	mov	rax, -1
	jmp	SHORT $LN1@Traits_rfi
$LN10@Traits_rfi:

; 751  :         }
; 752  :     }

	jmp	SHORT $LN2@Traits_rfi
$LN1@Traits_rfi:

; 753  : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ENDP ; std::_Traits_rfind_ch<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1116 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	mov	QWORD PTR [rsp+8], rcx

; 1117 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1118 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1119 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1120 : 
; 1121 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1122 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1123 :             _Xlength_error("size is too long for _Size_type");
; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 1128 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 69   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2257 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2258 : #if _HAS_CXX23
; 2259 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2260 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2261 :         _Count                  = _Allocated;
; 2262 :         return _Ptr;
; 2263 :     } else
; 2264 : #endif // _HAS_CXX23
; 2265 :     {
; 2266 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2267 :     }
; 2268 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QEA_NAEA_N@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_N@std@@YA$$QEA_NAEA_N@Z PROC		; std::forward<bool>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@_N@std@@YA$$QEA_NAEA_N@Z ENDP		; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z
_TEXT	SEGMENT
buffer$ = 32
this$ = 64
address$ = 72
??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z PROC ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry *>, COMDAT

; 187  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 188  : 			T buffer{};

	mov	QWORD PTR buffer$[rsp], 0

; 189  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 8
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 190  : 			Read(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 8
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read

; 191  : 			return buffer;

	mov	rax, QWORD PTR buffer$[rsp]

; 192  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z ENDP ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z
_TEXT	SEGMENT
buffer$ = 32
this$ = 64
address$ = 72
??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z PROC ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry *>, COMDAT

; 241  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 242  : 			T buffer{};

	mov	QWORD PTR buffer$[rsp], 0

; 243  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 8
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 244  : 			ReadCache(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 8
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache

; 245  : 			return buffer;

	mov	rax, QWORD PTR buffer$[rsp]

; 246  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z ENDP ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z
_TEXT	SEGMENT
buffer$ = 32
__$ArrayPad$ = 176
this$ = 224
__$ReturnUdt$ = 232
address$ = 240
??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z PROC ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry>, COMDAT

; 187  : 		{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 188  : 			T buffer{};

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 144				; 00000090H
	rep stosb

; 189  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 144				; 00000090H
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 190  : 			Read(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 144				; 00000090H
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read

; 191  : 			return buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 144				; 00000090H
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 192  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z ENDP ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z
_TEXT	SEGMENT
buffer$ = 32
__$ArrayPad$ = 176
this$ = 224
__$ReturnUdt$ = 232
address$ = 240
??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z PROC ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry>, COMDAT

; 241  : 		{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 242  : 			T buffer{};

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 144				; 00000090H
	rep stosb

; 243  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 144				; 00000090H
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 244  : 			ReadCache(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 144				; 00000090H
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache

; 245  : 			return buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 144				; 00000090H
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 246  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z ENDP ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 107  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++

; 108  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 109  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 99   :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*

; 100  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z
_TEXT	SEGMENT
tv75 = 32
this$ = 64
_Keyval$ = 72
??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z PROC ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int>, COMDAT

; 148  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 149  :         // hash _Keyval to size_t value
; 150  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEBAAEBU?$hash@I@2@XZ ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Get_first
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z ; std::_Conditionally_enabled_hash<unsigned int,1>::operator()

; 151  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z ENDP ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_UFirst$1 = 32
_ULast$2 = 40
_First$ = 64
_Last$ = 72
_Val$ = 80
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 5302 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5303 :     // copy _Val through [_First, _Last)
; 5304 :     _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>
	npad	1

; 5305 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5306 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5307 :     } else {
; 5308 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _UFirst$1[rsp], rax

; 5309 :         const auto _ULast = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > * const &>
	mov	QWORD PTR _ULast$2[rsp], rax

; 5310 : #if _HAS_CXX20
; 5311 :         if (!_STD is_constant_evaluated())
; 5312 : #endif // _HAS_CXX20
; 5313 :         {
; 5314 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5315 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5316 :                 return;
; 5317 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5318 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5319 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5320 :                     return;
; 5321 :                 }
; 5322 :             }
; 5323 :         }
; 5324 : 
; 5325 :         for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@fill
$LN2@fill:
	mov	rax, QWORD PTR _UFirst$1[rsp]
	add	rax, 8
	mov	QWORD PTR _UFirst$1[rsp], rax
$LN4@fill:
	mov	rax, QWORD PTR _ULast$2[rsp]
	cmp	QWORD PTR _UFirst$1[rsp], rax
	je	SHORT $LN3@fill

; 5326 :             *_UFirst = _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _UFirst$1[rsp]
	mov	QWORD PTR [rcx], rax

; 5327 :         }

	jmp	SHORT $LN2@fill
$LN3@fill:

; 5328 :     }
; 5329 : }

	add	rsp, 56					; 00000038H
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++, COMDAT

; 106  :     _List_unchecked_iterator& operator++() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 107  :         _Mybase::operator++();

	mov	rcx, QWORD PTR this$[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++

; 108  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 109  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*, COMDAT

; 98   :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 99   :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*

; 100  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned __int64 const ,unsigned __int64> *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CB_K_K@std@@@std@@YAPEAU?$pair@$$CB_K_K@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,unsigned __int64> >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned __int64 const ,unsigned __int64> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAAAEAU?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAAAEAU?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAAAEAU?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ PROC ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->, COMDAT

; 3425 :     _NODISCARD _CONSTEXPR23 pointer operator->() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 3426 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]

; 3427 :     }

	ret	0
??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ENDP ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv75 = 32
tv77 = 40
this$ = 64
??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::~unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >, COMDAT

; 3407 :     _CONSTEXPR23 ~unique_ptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3408 :         if (_Mypair._Myval2) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@unique_ptr

; 3409 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@PEAVUEDecryptBuilder@SDK@Core@IronMan@@$00@std@@QEAAAEAU?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@2@XZ ; std::_Compressed_pair<std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>,IronMan::Core::SDK::UEDecryptBuilder *,1>::_Get_first
	mov	QWORD PTR tv77[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z ; std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>::operator()
	npad	1
$LN2@unique_ptr:

; 3410 :         }
; 3411 :     }

	add	rsp, 56					; 00000038H
	ret	0
??1?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::~unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 32
tv68 = 40
this$ = 64
_Ptr$ = 72
??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z PROC ; std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>::operator(), COMDAT

; 3297 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3298 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3299 :         delete _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@operator
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	QWORD PTR tv68[rsp], 0
$LN4@operator:

; 3300 :     }

	add	rsp, 56					; 00000038H
	ret	0
??R?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@QEBAXPEAVUEDecryptBuilder@SDK@Core@IronMan@@@Z ENDP ; std::default_delete<IronMan::Core::SDK::UEDecryptBuilder>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[], COMDAT

; 259  :     mapped_type& operator[](key_type&& _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 260  :         return this->_Try_emplace(_STD move(_Keyval)).first->_Myval.second;

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$move@AEAW4DecryptFunc@SDK@Core@IronMan@@@std@@YA$$QEAW4DecryptFunc@SDK@Core@IronMan@@AEAW41234@@Z ; std::move<enum IronMan::Core::SDK::DecryptFunc &>
	mov	r8, rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Try_emplace@W4DecryptFunc@SDK@Core@IronMan@@$$V@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@_N@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Try_emplace<enum IronMan::Core::SDK::DecryptFunc>
	mov	rax, QWORD PTR [rax]
	add	rax, 24

; 261  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size, COMDAT

; 278  :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 279  :         return (_STD min)(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >,1>::_Get_first
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 280  :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Aliter_traits::max_size(_Mypair._Get_first()));
; 281  :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Max_bucket_size, COMDAT

; 1776 :     const float& _Max_bucket_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1777 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBAAEBMXZ ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::_Get_max_bucket_size

; 1778 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Forced_rehash, COMDAT

; 1680 :     void _Forced_rehash(size_type _Buckets) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1681 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1682 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1683 :         // load_factor() <= max_load_factor().
; 1684 : 
; 1685 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1686 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1687 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::max_size
	shr	rax, 1
	mov	rcx, rax
	call	?_Floor_of_log_2@std@@YAK_K@Z		; std::_Floor_of_log_2
	mov	DWORD PTR _Max_storage_buckets_log2$[rsp], eax

; 1688 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, DWORD PTR _Max_storage_buckets_log2$[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv308[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv308[rsp]
	shl	rax, cl
	mov	QWORD PTR _Max_storage_buckets$[rsp], rax

; 1689 :         if (_Buckets > _Max_storage_buckets) {

	mov	rax, QWORD PTR _Max_storage_buckets$[rsp]
	cmp	QWORD PTR _Buckets$[rsp], rax
	jbe	SHORT $LN8@Forced_reh

; 1690 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN8@Forced_reh:

; 1691 :         }
; 1692 : 
; 1693 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1694 :         // 2 invariant
; 1695 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1696 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1697 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	mov	rcx, QWORD PTR _Buckets$[rsp]
	call	?_Ceiling_of_log_2@std@@YAK_K@Z		; std::_Ceiling_of_log_2
	mov	ecx, 1
	mov	QWORD PTR tv312[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv312[rsp]
	shl	rax, cl
	mov	QWORD PTR _Buckets$[rsp], rax

; 1698 :         const _Unchecked_iterator _End = _Unchecked_end();

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_end

; 1699 : 
; 1700 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Buckets$[rsp]
	shl	rax, 1
	mov	r8, QWORD PTR _End$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > > >::_Assign_grow

; 1701 :         _Mask   = _Buckets - 1;

	mov	rax, QWORD PTR _Buckets$[rsp]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1702 :         _Maxidx = _Buckets;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Buckets$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 1703 : 
; 1704 :         _Clear_guard _Guard{this};

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??0_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::_Clear_guard
	npad	1

; 1705 : 
; 1706 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

	lea	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_begin
	npad	1

; 1707 : 
; 1708 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1709 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR _Next_inserted$2[rsp], rax
	jmp	SHORT $LN4@Forced_reh
$LN2@Forced_reh:
	mov	rax, QWORD PTR _Next_inserted$2[rsp]
	mov	QWORD PTR _Inserted$[rsp], rax
$LN4@Forced_reh:
	lea	rdx, QWORD PTR _End$[rsp]
	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN3@Forced_reh

; 1710 :             ++_Next_inserted;

	lea	rcx, QWORD PTR _Next_inserted$2[rsp]
	call	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator++

; 1711 : 
; 1712 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > >::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
	mov	QWORD PTR _Inserted_key$5[rsp], rax

; 1713 :             const size_type _Bucket = bucket(_Inserted_key);

	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1714 : 
; 1715 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1716 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1717 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$3[rsp], rax

; 1718 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$4[rsp], rax

; 1719 : 
; 1720 :             if (_Bucket_lo == _End) {

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Forced_reh

; 1721 :                 // The bucket was empty, set it to the inserted element.
; 1722 :                 _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1723 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1724 :                 continue;

	jmp	$LN2@Forced_reh
$LN9@Forced_reh:

; 1725 :             }
; 1726 : 
; 1727 :             // Search the bucket for the insertion location and move element if necessary.
; 1728 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Insert_before$1[rsp], rax

; 1729 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv194[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv194[rsp]
	call	??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc,enum IronMan::Core::SDK::DecryptFunc>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Forced_reh

; 1730 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1731 :                 // new bucket inclusive end.
; 1732 :                 ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator++
	npad	1

; 1733 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	lea	rdx, QWORD PTR _Inserted$[rsp]
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Forced_reh

; 1734 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_splice
	npad	1
$LN11@Forced_reh:

; 1735 :                 }
; 1736 : 
; 1737 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1738 :                 continue;

	jmp	$LN2@Forced_reh
$LN5@Forced_reh:

; 1739 :             }
; 1740 : 
; 1741 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1742 :             // go backwards to maintain sortedness when !_Standard.
; 1743 :             for (;;) {
; 1744 :                 if (_Bucket_lo == _Insert_before) {

	lea	rdx, QWORD PTR _Insert_before$1[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Forced_reh

; 1745 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1746 :                     // Element can't be already in position here because:
; 1747 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1748 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1749 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_splice

; 1750 :                     _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1751 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1752 :                 }
; 1753 : 
; 1754 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv258[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator--
	mov	rcx, rax
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv258[rsp]
	call	??$?RW4DecryptFunc@SDK@Core@IronMan@@W40123@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc,enum IronMan::Core::SDK::DecryptFunc>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@Forced_reh

; 1755 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1756 :                     ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,std::_Iterator_base0>::operator++

; 1757 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1758 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1759 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_splice
	npad	1

; 1760 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1761 :                 }
; 1762 :             }

	jmp	$LN5@Forced_reh
$LN6@Forced_reh:

; 1763 :         }

	jmp	$LN2@Forced_reh
$LN3@Forced_reh:

; 1764 : 
; 1765 :         _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$[rsp], 0

; 1766 : 
; 1767 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1768 :         _Stl_internal_check_container_invariants();
; 1769 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1770 :     }

	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::~_Clear_guard
	npad	1
	add	rsp, 168				; 000000a8H
	ret	0
$LN16@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Forced_rehash'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Clear_guard::~_Clear_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Forced_rehash'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
_Old_buckets$ = 32
_Req_buckets$ = 40
$T1 = 48
this$ = 80
_For_size$ = 88
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Desired_grow_bucket_count, COMDAT

; 1659 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1660 :         const size_type _Old_buckets = bucket_count();

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket_count
	mov	QWORD PTR _Old_buckets$[rsp], rax

; 1661 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	rdx, QWORD PTR _For_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Min_load_factor_buckets
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?_Min_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@2_KB
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Req_buckets$[rsp], rax

; 1662 :         if (_Old_buckets >= _Req_buckets) {

	mov	rax, QWORD PTR _Req_buckets$[rsp]
	cmp	QWORD PTR _Old_buckets$[rsp], rax
	jb	SHORT $LN2@Desired_gr

; 1663 :             // we already have enough buckets so there's no need to change the count
; 1664 :             return _Old_buckets;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	jmp	SHORT $LN1@Desired_gr
$LN2@Desired_gr:

; 1665 :         }
; 1666 : 
; 1667 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	QWORD PTR _Old_buckets$[rsp], 512	; 00000200H
	jae	SHORT $LN3@Desired_gr
	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	cmp	rax, QWORD PTR _Req_buckets$[rsp]
	jb	SHORT $LN3@Desired_gr

; 1668 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1669 :             return _Old_buckets * 8;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	jmp	SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1670 :         }
; 1671 : 
; 1672 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1673 :         return _Req_buckets;

	mov	rax, QWORD PTR _Req_buckets$[rsp]
$LN1@Desired_gr:

; 1674 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
tv65 = 32
this$ = 64
_For_size$ = 72
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Min_load_factor_buckets, COMDAT

; 1654 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1655 :         // returns the minimum number of buckets necessary for the elements in _List
; 1656 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	mov	rax, QWORD PTR _For_size$[rsp]
	test	rax, rax
	jl	SHORT $LN4@Min_load_f
	cvtsi2ss xmm0, rax
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN5@Min_load_f
$LN4@Min_load_f:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR tv65[rsp], xmm0
$LN5@Min_load_f:
	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::max_load_factor
	movss	xmm1, DWORD PTR tv65[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	ceilf
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN3@Min_load_f
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN3@Min_load_f
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN3@Min_load_f:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx

; 1657 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Newsize$ = 40
this$ = 64
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Rehash_for_1, COMDAT

; 1630 :     void _Rehash_for_1() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1631 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1632 :         const auto _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1633 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Forced_rehash
	npad	1

; 1634 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv71 = 32
tv77 = 36
tv70 = 40
_Oldsize$ = 48
_Newsize$ = 56
this$ = 80
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_rehash_required_1, COMDAT

; 1624 :     bool _Check_rehash_required_1() const noexcept {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1625 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1626 :         const auto _Newsize      = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1627 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::max_load_factor
	movss	DWORD PTR tv70[rsp], xmm0
	mov	rax, QWORD PTR _Newsize$[rsp]
	test	rax, rax
	jl	SHORT $LN7@Check_reha
	cvtsi2ss xmm1, rax
	movss	DWORD PTR tv71[rsp], xmm1
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
	movss	DWORD PTR tv71[rsp], xmm1
$LN8@Check_reha:
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket_count
	test	rax, rax
	jl	SHORT $LN5@Check_reha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN6@Check_reha
$LN5@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN6@Check_reha:
	movss	xmm1, DWORD PTR tv71[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tv70[rsp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Check_reha
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN4@Check_reha
$LN3@Check_reha:
	mov	DWORD PTR tv77[rsp], 0
$LN4@Check_reha:
	movzx	eax, BYTE PTR tv77[rsp]

; 1628 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
this$ = 64
?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_max_size, COMDAT

; 1617 :     void _Check_max_size() const {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1618 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1619 :         if (_Oldsize == _List.max_size()) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Check_max_

; 1620 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Check_max_:
$LN3@Check_max_:

; 1621 :         }
; 1622 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Check_max_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
_Bucket_lo$ = 32
_Insert_after$ = 40
_Bucket_hi$ = 48
_Bucket$ = 56
_Bucket_array$ = 64
_Head$ = 72
this$ = 96
_Hashval$ = 104
_Insert_before$ = 112
_Newnode$ = 120
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Insert_new_node_before, COMDAT

; 1586 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1587 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Insert_after$[rsp], rax

; 1588 :         ++_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1589 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	rax, QWORD PTR _Newnode$[rsp]
	lea	rdx, QWORD PTR _Insert_before$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>

; 1590 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	rax, QWORD PTR _Newnode$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Insert_after$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> *,std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> * const &>

; 1591 :         _Insert_after->_Next  = _Newnode;

	mov	rax, QWORD PTR _Insert_after$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1592 :         _Insert_before->_Prev = _Newnode;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 1593 : 
; 1594 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$[rsp], rax

; 1595 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_array$[rsp], rax

; 1596 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1597 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax

; 1598 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$[rsp], rax

; 1599 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@Insert_new

; 1600 :             // bucket is empty, set both
; 1601 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1602 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1603 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Insert_before$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN4@Insert_new

; 1604 :             // new node is the lowest element in the bucket
; 1605 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN5@Insert_new
$LN4@Insert_new:

; 1606 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Insert_after$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN6@Insert_new

; 1607 :             // new node is the highest element in the bucket
; 1608 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Insert_new:
$LN5@Insert_new:
$LN3@Insert_new:

; 1609 :         }
; 1610 : 
; 1611 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1612 :         _Stl_internal_check_container_invariants();
; 1613 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1614 :         return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]

; 1615 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Head$1 = 40
tv132 = 48
tv134 = 56
tv130 = 64
$T2 = 72
this$ = 96
?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::clear, COMDAT

; 1152 :     void clear() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1153 :         // TRANSITION, ABI:
; 1154 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1155 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1156 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1157 :         //   (2) The hash function operator() may throw exceptions, and
; 1158 :         //   (3) clear() is a noexcept function.
; 1159 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1160 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1161 :         if (_Oldsize == 0) {

	cmp	QWORD PTR _Oldsize$[rsp], 0
	jne	SHORT $LN2@clear

; 1162 :             return;

	jmp	$LN1@clear
$LN2@clear:

; 1163 :         }
; 1164 : 
; 1165 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1166 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1167 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1168 :             // as many buckets as elements, remove element-by-element.
; 1169 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket_count
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	cmp	rax, QWORD PTR _Oldsize$[rsp]
	jbe	SHORT $LN3@clear

; 1170 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$1[rsp], rax

; 1171 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	r8, QWORD PTR _Head$1[rsp]
	mov	rax, QWORD PTR _Head$1[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_erase
	npad	1

; 1172 :                 return;

	jmp	SHORT $LN1@clear
$LN3@clear:

; 1173 :             }
; 1174 :         }
; 1175 : 
; 1176 :         // Bulk destroy items and reset buckets
; 1177 :         _List.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::clear
	npad	1

; 1178 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_end
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv134[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > > > >
	npad	1
$LN1@clear:

; 1179 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_erase, COMDAT

; 1028 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1029 :         if (_First == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	jne	SHORT $LN10@Unchecked_

; 1030 :             return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	jmp	$LN1@Unchecked_
$LN10@Unchecked_:

; 1031 :         }
; 1032 : 
; 1033 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1034 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_bounds$[rsp], rax

; 1035 :         _Range_eraser _Eraser{_List, _First};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	r8, QWORD PTR _First$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??0_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Range_eraser
	npad	1

; 1036 :         {
; 1037 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1038 :             const auto _Predecessor = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Predecessor$12[rsp], rax

; 1039 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1040 :             // nothrow hereafter this block
; 1041 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$4[rsp], rax

; 1042 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$5[rsp], rax

; 1043 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN19@Unchecked_
	mov	BYTE PTR tv136[rsp], 1
	jmp	SHORT $LN20@Unchecked_
$LN19@Unchecked_:
	mov	BYTE PTR tv136[rsp], 0
$LN20@Unchecked_:
	movzx	eax, BYTE PTR tv136[rsp]
	mov	BYTE PTR _Update_lo$1[rsp], al

; 1044 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$10[rsp], rax
$LN2@Unchecked_:

; 1045 :             for (;;) { // remove elements until we hit the end of the bucket
; 1046 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$10[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN21@Unchecked_
	mov	BYTE PTR tv138[rsp], 1
	jmp	SHORT $LN22@Unchecked_
$LN21@Unchecked_:
	mov	BYTE PTR tv138[rsp], 0
$LN22@Unchecked_:
	movzx	eax, BYTE PTR tv138[rsp]
	mov	BYTE PTR _At_bucket_back$2[rsp], al

; 1047 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1048 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$2[rsp]
	test	eax, eax
	je	SHORT $LN11@Unchecked_

; 1049 :                     break;

	jmp	SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1050 :                 }
; 1051 : 
; 1052 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN12@Unchecked_

; 1053 :                     if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN13@Unchecked_

; 1054 :                         // erased the bucket's prefix
; 1055 :                         _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx
$LN13@Unchecked_:

; 1056 :                     }
; 1057 : 
; 1058 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T11[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN1@Unchecked_
$LN12@Unchecked_:

; 1059 :                 }
; 1060 :             }

	jmp	$LN2@Unchecked_
$LN3@Unchecked_:

; 1061 : 
; 1062 :             if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN14@Unchecked_

; 1063 :                 // emptied the bucket
; 1064 :                 _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1065 :                 _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1066 :             } else {

	jmp	SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1067 :                 _Bucket_hi = _Predecessor;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _Predecessor$12[rsp]
	mov	QWORD PTR [rax], rcx
$LN5@Unchecked_:

; 1068 :             }
; 1069 :         }
; 1070 : 
; 1071 :         // hereafter we are always erasing buckets' prefixes
; 1072 :         while (_Eraser._Next != _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	je	$LN6@Unchecked_

; 1073 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@SAAEBW4DecryptFunc@SDK@Core@IronMan@@AEBU?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@1@@Z ; std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0>::_Kfn<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$7[rsp], rax

; 1074 :             // nothrow hereafter this block
; 1075 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$8[rsp], rax

; 1076 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$9[rsp], rax

; 1077 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$13[rsp], rax
$LN7@Unchecked_:

; 1078 :             for (;;) { // remove elements until we hit the end of the bucket
; 1079 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$13[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN23@Unchecked_
	mov	BYTE PTR tv172[rsp], 1
	jmp	SHORT $LN24@Unchecked_
$LN23@Unchecked_:
	mov	BYTE PTR tv172[rsp], 0
$LN24@Unchecked_:
	movzx	eax, BYTE PTR tv172[rsp]
	mov	BYTE PTR _At_bucket_back$3[rsp], al

; 1080 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1081 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$3[rsp]
	test	eax, eax
	je	SHORT $LN16@Unchecked_

; 1082 :                     break;

	jmp	SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1083 :                 }
; 1084 : 
; 1085 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN17@Unchecked_

; 1086 :                     // erased the bucket's prefix
; 1087 :                     _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx

; 1088 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T14[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T14[rsp]
	jmp	SHORT $LN1@Unchecked_
$LN17@Unchecked_:

; 1089 :                 }
; 1090 :             }

	jmp	SHORT $LN7@Unchecked_
$LN8@Unchecked_:

; 1091 : 
; 1092 :             // emptied the bucket
; 1093 :             _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1094 :             _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1095 :         }

	jmp	$LN5@Unchecked_
$LN6@Unchecked_:

; 1096 : 
; 1097 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T15[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T15[rsp]
$LN1@Unchecked_:

; 1098 :     }

	add	rsp, 184				; 000000b8H
	ret	0
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_erase'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Eraser$[rbp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Range_eraser::~_Range_eraser
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_erase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 48
?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::max_load_factor, COMDAT

; 912  :     _NODISCARD float max_load_factor() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         return _Max_bucket_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR [rax]

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
tv73 = 32
tv76 = 40
tv78 = 48
this$ = 80
_Keyval$ = 88
?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket, COMDAT

; 856  :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 857  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$?RW4DecryptFunc@SDK@Core@IronMan@@@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::operator()<enum IronMan::Core::SDK::DecryptFunc>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	and	rcx, rax
	mov	rax, rcx

; 858  :     }

	add	rsp, 72					; 00000048H
	ret	0
?bucket@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket_count, COMDAT

; 847  :     _NODISCARD size_type bucket_count() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 848  :         return _Maxidx;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]

; 849  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_end, COMDAT

; 812  :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 813  :         return _List._Unchecked_end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 814  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_begin, COMDAT

; 804  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 805  :         return _List._Unchecked_begin();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_begin
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 806  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@V?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Last_prev$ = 0
_First_prev$ = 8
_Before_prev$ = 16
_Before$ = 48
_First$ = 56
_Last$ = 64
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_splice, COMDAT

; 468  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _First_prev$[rsp], rax

; 475  :         _First_prev->_Next      = _Last;

	mov	rax, QWORD PTR _First_prev$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Last_prev$[rsp], rax

; 477  :         _Last_prev->_Next       = _Before;

	mov	rax, QWORD PTR _Last_prev$[rsp]
	mov	rcx, QWORD PTR _Before$[rsp]
	mov	QWORD PTR [rax], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Before_prev$[rsp], rax

; 479  :         _Before_prev->_Next     = _First;

	mov	rax, QWORD PTR _Before_prev$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rcx, QWORD PTR _Last_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 484  :         _First->_Prev  = _Before_prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Before_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 485  : 
; 486  :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 487  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	mov	QWORD PTR [rsp+8], rcx

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal, COMDAT

; 1858 :     const _Alnode& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1859 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first

; 1860 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
tv75 = 40
tv73 = 48
this$ = 80
?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::clear, COMDAT

; 1494 :     void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1495 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1496 :         _My_data._Orphan_non_end();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Orphan_non_end

; 1497 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >

; 1498 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1499 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 1500 :         _My_data._Mysize        = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1501 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::max_size, COMDAT

; 1197 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1198 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1199 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1200 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_begin, COMDAT

; 1110 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1111 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1112 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 32		; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z	; std::_Get_size_of_n<32>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 32		; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@V?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@V?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@V?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@std@@QEBAAEBU?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@std@@QEBAAEBU?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ PROC ; std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@M$00@std@@QEBAAEBU?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
_Keyval$ = 48
?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::hash<enum IronMan::Core::SDK::DecryptFunc>::_Do_hash, COMDAT

; 2355 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2356 :         return _Hash_representation(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$_Hash_representation@W4DecryptFunc@SDK@Core@IronMan@@@std@@YA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::_Hash_representation<enum IronMan::Core::SDK::DecryptFunc>

; 2357 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::hash<enum IronMan::Core::SDK::DecryptFunc>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z PROC ; std::_Conditionally_enabled_hash<enum IronMan::Core::SDK::DecryptFunc,1>::operator(), COMDAT

; 2337 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2338 :         return hash<_Kty>::_Do_hash(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	?_Do_hash@?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@SA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::hash<enum IronMan::Core::SDK::DecryptFunc>::_Do_hash

; 2339 :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$_Conditionally_enabled_hash@W4DecryptFunc@SDK@Core@IronMan@@$00@std@@QEBA_KAEBW4DecryptFunc@SDK@Core@IronMan@@@Z ENDP ; std::_Conditionally_enabled_hash<enum IronMan::Core::SDK::DecryptFunc,1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z PROC ; std::equal_to<enum IronMan::Core::SDK::DecryptFunc>::operator(), COMDAT

; 634  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 635  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 636  :     }

	add	rsp, 24
	ret	0
??R?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@std@@QEBA_NAEBW4DecryptFunc@SDK@Core@IronMan@@0@Z ENDP ; std::equal_to<enum IronMan::Core::SDK::DecryptFunc>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::_Get_max_bucket_size, COMDAT

; 164  :     _NODISCARD const float& _Get_max_bucket_size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 165  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 166  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@W4DecryptFunc@SDK@Core@IronMan@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@std@@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<enum IronMan::Core::SDK::DecryptFunc,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 48
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to, COMDAT

; 557  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 558  :         return _STD addressof(_Val);

	mov	rcx, QWORD PTR _Val$[rsp]
	call	??$addressof@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 559  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\ObjectsStore.h
;	COMDAT ??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ PROC ; IronMan::Core::SDK::ObjectsStore::FindClass<3244701931984741072>, COMDAT

; 101  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 102  : 			return FindObject<UClass, nameHash>();

	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$FindObject@VUClass@SDK@Core@IronMan@@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,3244701931984741072>
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 103  : 		}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ENDP ; IronMan::Core::SDK::ObjectsStore::FindClass<3244701931984741072>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA PROC ; `IronMan::Core::SDK::ObjectsStore::FindClass<3244701931984741072>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA ENDP ; `IronMan::Core::SDK::ObjectsStore::FindClass<3244701931984741072>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\ObjectsStore.h
;	COMDAT ??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ PROC ; IronMan::Core::SDK::ObjectsStore::FindClass<-4342903124670388529>, COMDAT

; 101  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 102  : 			return FindObject<UClass, nameHash>();

	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$FindObject@VUClass@SDK@Core@IronMan@@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindObject<IronMan::Core::SDK::UClass,-4342903124670388529>
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 103  : 		}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ENDP ; IronMan::Core::SDK::ObjectsStore::FindClass<-4342903124670388529>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA PROC ; `IronMan::Core::SDK::ObjectsStore::FindClass<-4342903124670388529>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ@4HA ENDP ; `IronMan::Core::SDK::ObjectsStore::FindClass<-4342903124670388529>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@UDroppedItemInteractionComponent@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::UDroppedItemInteractionComponent::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@ATslProjectile@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::ATslProjectile::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@ACarePackageItem@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::ACarePackageItem::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@AFloorSnapItemPackage@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::AFloorSnapItemPackage::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@ADroppedItem@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::ADroppedItem::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@ADroppedItemGroup@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::ADroppedItemGroup::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@ATslFloatingVehicle@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::ATslFloatingVehicle::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@ATslWheeledVehicle@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::ATslWheeledVehicle::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ PROC ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>, COMDAT

; 534  : 		{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 535  : 			if ((ptr_t)this < 0x10000 || Utils::IsSafeReadPtr(this, 1) || !IsValid())

	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jb	SHORT $LN3@IsA
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA
$LN3@IsA:

; 536  : 				return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 537  : 
; 538  : 			auto cmp = T::StaticClass();

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?StaticClass@ATslCharacter@SDK@Core@IronMan@@SA?AVUClass@234@XZ ; IronMan::Core::SDK::ATslCharacter::StaticClass
	npad	1

; 539  : 			if (!cmp.IsValid())

	lea	rcx, QWORD PTR cmp$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@IsA

; 540  : 			{
; 541  : 				return false;

	mov	BYTE PTR $T1[rsp], 0
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T1[rsp]
	jmp	SHORT $LN1@IsA
$LN4@IsA:

; 542  : 			}
; 543  : 
; 544  : 			return IsA(cmp);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR cmp$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	mov	QWORD PTR tv74[rsp], rax
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR tv132[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUClass@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NVUClass@123@@Z ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UClass>
	mov	BYTE PTR $T2[rsp], al
	lea	rcx, QWORD PTR cmp$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	movzx	eax, BYTE PTR $T2[rsp]
$LN1@IsA:

; 545  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	ret	0
??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ENDP ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR cmp$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 40
tv74 = 48
tv132 = 56
$T4 = 64
cmp$ = 272
__$ArrayPad$ = 480
this$ = 512
?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA PROC ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR $T3[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Target$5 = 56
tv76 = 72
tv91 = 80
tv94 = 88
tv144 = 96
tv142 = 104
tv140 = 112
tv185 = 120
tv188 = 128
_Newnode$6 = 136
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 591  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 592  :         // try to insert value_type(_Vals...)
; 593  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Valtys...>;
; 594  :         if constexpr (_Multi) {
; 595  :             _Check_max_size();
; 596  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 597  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 598  :             const auto _Hashval = _Traitsobj(_Keyval);
; 599  :             if (_Check_rehash_required_1()) {
; 600  :                 _Rehash_for_1();
; 601  :             }
; 602  : 
; 603  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 604  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 605  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 606  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

	mov	rdx, QWORD PTR <_Vals_1>$[rsp]
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	?_Extract@?$_In_place_key_extract_map_impl@_K_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SAAEB_KAEB_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Extract
	mov	QWORD PTR _Keyval$4[rsp], rax

; 607  :             const auto _Hashval = _Traitsobj(_Keyval);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR _Keyval$4[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	QWORD PTR _Hashval$3[rsp], rax

; 608  :             auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, QWORD PTR _Keyval$4[rsp]
	lea	rdx, QWORD PTR _Target$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned __int64>
	npad	1

; 609  :             if (_Target._Duplicate) {

	cmp	QWORD PTR _Target$5[rsp+8], 0
	je	SHORT $LN2@emplace

; 610  :                 return {_List._Make_iter(_Target._Duplicate), false};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv91[rsp], rax
	mov	r8, QWORD PTR _Target$5[rsp+8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
	mov	QWORD PTR tv94[rsp], rax
	mov	BYTE PTR $T1[rsp], 0
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR tv94[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@emplace
$LN2@emplace:

; 611  :             }
; 612  : 
; 613  :             _Check_max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size

; 614  :             // invalidates _Keyval:
; 615  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	QWORD PTR tv144[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@_K@std@@YA$$QEA_KAEA_K@Z	; std::forward<unsigned __int64>
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR tv140[rsp], rax
	mov	r9, QWORD PTR tv144[rsp]
	mov	r8, QWORD PTR tv142[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	??$?0_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	npad	1

; 616  :             if (_Check_rehash_required_1()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@emplace

; 617  :                 _Rehash_for_1();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1
	npad	1

; 618  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	rax, QWORD PTR _Newnode$6[rsp+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned __int64>
	lea	rcx, QWORD PTR _Target$5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN3@emplace:

; 619  :             }
; 620  : 
; 621  :             return {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv185[rsp], rax
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release
	mov	r9, rax
	mov	r8, QWORD PTR _Target$5[rsp]
	mov	rdx, QWORD PTR _Hashval$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before
	mov	r8, rax
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR tv185[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
	mov	QWORD PTR tv188[rsp], rax
	mov	BYTE PTR $T2[rsp], 1
	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, QWORD PTR tv188[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
	npad	1
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@emplace:

; 622  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 623  :         } else {
; 624  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 625  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 626  :             const auto _Hashval = _Traitsobj(_Keyval);
; 627  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 628  :             if (_Target._Duplicate) {
; 629  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 630  :             }
; 631  : 
; 632  :             _Check_max_size();
; 633  :             if (_Check_rehash_required_1()) {
; 634  :                 _Rehash_for_1();
; 635  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);
; 636  :             }
; 637  : 
; 638  :             return {
; 639  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 640  :         }
; 641  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Target$5 = 56
tv76 = 72
tv91 = 80
tv94 = 88
tv144 = 96
tv142 = 104
tv140 = 112
tv185 = 120
tv188 = 128
_Newnode$6 = 136
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Newnode$6[rbp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA PROC ; `std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->, COMDAT

; 241  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to

; 243  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=, COMDAT

; 76   :     _NODISCARD bool operator!=(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 77   :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 78   :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 73   :     }

	add	rsp, 24
	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--, COMDAT

; 60   :     _List_unchecked_const_iterator& operator--() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax

; 62   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 51   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>, COMDAT

; 1229 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1230 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@_K@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1231 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ PROC ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UStruct>, COMDAT

; 487  : 		{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 488  : 			if (Utils::IsSafeReadPtr((void*)this, 8))

	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Cast

; 489  : 				return Base(nullptr);

	xor	edx, edx
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UStruct@SDK@Core@IronMan@@QEAA@PEAX@Z ; IronMan::Core::SDK::UStruct::UStruct
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@Cast
$LN2@Cast:

; 490  : 			return Base(this->GetPtr());

	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UStruct@SDK@Core@IronMan@@QEAA@PEAX@Z ; IronMan::Core::SDK::UStruct::UStruct
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@Cast:

; 491  : 		}

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ ENDP ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UStruct>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UStruct>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UStruct>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Newnode$5 = 56
_Target$6 = 72
tv81 = 88
tv79 = 96
tv77 = 104
tv132 = 112
tv147 = 120
tv150 = 128
tv190 = 136
tv193 = 144
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 591  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 592  :         // try to insert value_type(_Vals...)
; 593  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Valtys...>;
; 594  :         if constexpr (_Multi) {
; 595  :             _Check_max_size();
; 596  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 597  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 598  :             const auto _Hashval = _Traitsobj(_Keyval);
; 599  :             if (_Check_rehash_required_1()) {
; 600  :                 _Rehash_for_1();
; 601  :             }
; 602  : 
; 603  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 604  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 605  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 606  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 607  :             const auto _Hashval = _Traitsobj(_Keyval);
; 608  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 609  :             if (_Target._Duplicate) {
; 610  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 611  :             }
; 612  : 
; 613  :             _Check_max_size();
; 614  :             // invalidates _Keyval:
; 615  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 616  :             if (_Check_rehash_required_1()) {
; 617  :                 _Rehash_for_1();
; 618  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);
; 619  :             }
; 620  : 
; 621  :             return {
; 622  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 623  :         } else {
; 624  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEAH@std@@YAAEAHAEAH@Z	; std::forward<int &>
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR tv77[rsp], rax
	mov	r9, QWORD PTR tv81[rsp]
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	lea	rcx, QWORD PTR _Newnode$5[rsp]
	call	??$?0AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	npad	1

; 625  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);

	mov	rax, QWORD PTR _Newnode$5[rsp+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR _Keyval$4[rsp], rax

; 626  :             const auto _Hashval = _Traitsobj(_Keyval);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv132[rsp], rax
	mov	rdx, QWORD PTR _Keyval$4[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int>
	mov	QWORD PTR _Hashval$3[rsp], rax

; 627  :             auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, QWORD PTR _Keyval$4[rsp]
	lea	rdx, QWORD PTR _Target$6[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned int>
	npad	1

; 628  :             if (_Target._Duplicate) {

	cmp	QWORD PTR _Target$6[rsp+8], 0
	je	SHORT $LN2@emplace

; 629  :                 return {_List._Make_iter(_Target._Duplicate), false};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv147[rsp], rax
	mov	r8, QWORD PTR _Target$6[rsp+8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR tv147[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
	mov	QWORD PTR tv150[rsp], rax
	mov	BYTE PTR $T1[rsp], 0
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR tv150[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
	npad	1
	lea	rcx, QWORD PTR _Newnode$5[rsp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@emplace
$LN2@emplace:

; 630  :             }
; 631  : 
; 632  :             _Check_max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size
	npad	1

; 633  :             if (_Check_rehash_required_1()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@emplace

; 634  :                 _Rehash_for_1();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1
	npad	1

; 635  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	rax, QWORD PTR _Newnode$5[rsp+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@AEBI_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_last<unsigned int>
	lea	rcx, QWORD PTR _Target$6[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN3@emplace:

; 636  :             }
; 637  : 
; 638  :             return {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv190[rsp], rax
	lea	rcx, QWORD PTR _Newnode$5[rsp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Release
	mov	r9, rax
	mov	r8, QWORD PTR _Target$6[rsp]
	mov	rdx, QWORD PTR _Hashval$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before
	mov	r8, rax
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR tv190[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
	mov	QWORD PTR tv193[rsp], rax
	mov	BYTE PTR $T2[rsp], 1
	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, QWORD PTR tv193[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,bool,0>
	npad	1
	lea	rcx, QWORD PTR _Newnode$5[rsp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@emplace:

; 639  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 640  :         }
; 641  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Newnode$5 = 56
_Target$6 = 72
tv81 = 88
tv79 = 96
tv77 = 104
tv132 = 112
tv147 = 120
tv150 = 128
tv190 = 136
tv193 = 144
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Newnode$5[rbp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA PROC ; `std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->, COMDAT

; 241  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>::pointer_to

; 243  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=, COMDAT

; 76   :     _NODISCARD bool operator!=(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 77   :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 78   :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 73   :     }

	add	rsp, 24
	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--, COMDAT

; 60   :     _List_unchecked_const_iterator& operator--() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax

; 62   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 51   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>, COMDAT

; 1229 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1230 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@I@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@AEBI_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1231 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,2>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 2
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,2>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,1>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 1
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,1>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,5>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 5
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,5>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,4>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 4
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,4>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,3>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 3
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,3>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<enum IronMan::Core::SDK::EObjectFlags,0>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 0
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<enum IronMan::Core::SDK::EObjectFlags,0>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z
_TEXT	SEGMENT
buffer$ = 32
this$ = 64
address$ = 72
??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z PROC		; IronMan::DMAHandler::Read<unsigned int>, COMDAT

; 187  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 188  : 			T buffer{};

	mov	DWORD PTR buffer$[rsp], 0

; 189  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 4
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 190  : 			Read(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 4
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read

; 191  : 			return buffer;

	mov	eax, DWORD PTR buffer$[rsp]

; 192  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z ENDP		; IronMan::DMAHandler::Read<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z
_TEXT	SEGMENT
buffer$ = 32
this$ = 64
address$ = 72
??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z PROC	; IronMan::DMAHandler::ReadCache<unsigned int>, COMDAT

; 241  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 242  : 			T buffer{};

	mov	DWORD PTR buffer$[rsp], 0

; 243  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 4
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 244  : 			ReadCache(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 4
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache

; 245  : 			return buffer;

	mov	eax, DWORD PTR buffer$[rsp]

; 246  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z ENDP	; IronMan::DMAHandler::ReadCache<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Target$5 = 56
tv76 = 72
tv91 = 80
tv94 = 88
tv144 = 96
tv142 = 104
tv140 = 112
tv185 = 120
tv188 = 128
_Newnode$6 = 136
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::emplace<unsigned __int64 &,unsigned __int64 &>, COMDAT

; 591  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 592  :         // try to insert value_type(_Vals...)
; 593  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Valtys...>;
; 594  :         if constexpr (_Multi) {
; 595  :             _Check_max_size();
; 596  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 597  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 598  :             const auto _Hashval = _Traitsobj(_Keyval);
; 599  :             if (_Check_rehash_required_1()) {
; 600  :                 _Rehash_for_1();
; 601  :             }
; 602  : 
; 603  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 604  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 605  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 606  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

	mov	rdx, QWORD PTR <_Vals_1>$[rsp]
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	?_Extract@?$_In_place_key_extract_map_impl@_K_K_K@std@@SAAEB_KAEB_K0@Z ; std::_In_place_key_extract_map_impl<unsigned __int64,unsigned __int64,unsigned __int64>::_Extract
	mov	QWORD PTR _Keyval$4[rsp], rax

; 607  :             const auto _Hashval = _Traitsobj(_Keyval);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR _Keyval$4[rsp]
	mov	rcx, QWORD PTR tv76[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	QWORD PTR _Hashval$3[rsp], rax

; 608  :             auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, QWORD PTR _Keyval$4[rsp]
	lea	rdx, QWORD PTR _Target$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find_last<unsigned __int64>
	npad	1

; 609  :             if (_Target._Duplicate) {

	cmp	QWORD PTR _Target$5[rsp+8], 0
	je	SHORT $LN2@emplace

; 610  :                 return {_List._Make_iter(_Target._Duplicate), false};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv91[rsp], rax
	mov	r8, QWORD PTR _Target$5[rsp+8]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, QWORD PTR tv91[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Make_iter
	mov	QWORD PTR tv94[rsp], rax
	mov	BYTE PTR $T1[rsp], 0
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR tv94[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool,0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@emplace
$LN2@emplace:

; 611  :             }
; 612  : 
; 613  :             _Check_max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_max_size

; 614  :             // invalidates _Keyval:
; 615  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_1>$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	QWORD PTR tv144[rsp], rax
	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@AEA_K@std@@YAAEA_KAEA_K@Z	; std::forward<unsigned __int64 &>
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
	mov	QWORD PTR tv140[rsp], rax
	mov	r9, QWORD PTR tv144[rsp]
	mov	r8, QWORD PTR tv142[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	??$?0AEA_KAEA_K@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEA_K1@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > ><unsigned __int64 &,unsigned __int64 &>
	npad	1

; 616  :             if (_Check_rehash_required_1()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_rehash_required_1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@emplace

; 617  :                 _Rehash_for_1();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Rehash_for_1
	npad	1

; 618  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	rax, QWORD PTR _Newnode$6[rsp+8]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
	mov	r9, QWORD PTR _Hashval$3[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find_last@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find_last<unsigned __int64>
	lea	rcx, QWORD PTR _Target$5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN3@emplace:

; 619  :             }
; 620  : 
; 621  :             return {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv185[rsp], rax
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::_Release
	mov	r9, rax
	mov	r8, QWORD PTR _Target$5[rsp]
	mov	rdx, QWORD PTR _Hashval$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Insert_new_node_before
	mov	r8, rax
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR tv185[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Make_iter
	mov	QWORD PTR tv188[rsp], rax
	mov	BYTE PTR $T2[rsp], 1
	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, QWORD PTR tv188[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >,bool,0>
	npad	1
	lea	rcx, QWORD PTR _Newnode$6[rsp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@emplace:

; 622  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 623  :         } else {
; 624  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 625  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 626  :             const auto _Hashval = _Traitsobj(_Keyval);
; 627  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 628  :             if (_Target._Duplicate) {
; 629  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 630  :             }
; 631  : 
; 632  :             _Check_max_size();
; 633  :             if (_Check_rehash_required_1()) {
; 634  :                 _Rehash_for_1();
; 635  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);
; 636  :             }
; 637  : 
; 638  :             return {
; 639  :                 _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release())), true};
; 640  :         }
; 641  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::emplace<unsigned __int64 &,unsigned __int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
_Hashval$3 = 40
_Keyval$4 = 48
_Target$5 = 56
tv76 = 72
tv91 = 80
tv94 = 88
tv144 = 96
tv142 = 104
tv140 = 112
tv185 = 120
tv188 = 128
_Newnode$6 = 136
$T7 = 152
$T8 = 160
$T9 = 168
this$ = 224
__$ReturnUdt$ = 232
<_Vals_0>$ = 240
<_Vals_1>$ = 248
?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::emplace<unsigned __int64 &,unsigned __int64 &>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Newnode$6[rbp]
	call	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::emplace<unsigned __int64 &,unsigned __int64 &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ
_TEXT	SEGMENT
this$ = 48
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator->, COMDAT

; 241  :     _NODISCARD pointer operator->() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         return pointer_traits<pointer>::pointer_to(**this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
	mov	rcx, rax
	call	?pointer_to@?$pointer_traits@PEAU?$pair@$$CB_K_K@std@@@std@@SAPEAU?$pair@$$CB_K_K@2@AEAU32@@Z ; std::pointer_traits<std::pair<unsigned __int64 const ,unsigned __int64> *>::pointer_to

; 243  :     }

	add	rsp, 40					; 00000028H
	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*, COMDAT

; 237  :     _NODISCARD reference operator*() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 238  :         return const_cast<reference>(_Mybase::operator*());

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*

; 239  :     }

	add	rsp, 40					; 00000028H
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator!=, COMDAT

; 201  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 202  :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 203  :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv75 = 0
this$ = 32
_Right$ = 40
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator==, COMDAT

; 192  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv75[rsp]

; 198  :     }

	add	rsp, 24
	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*, COMDAT

; 143  :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv69 = 32
this$ = 64
_Right$ = 72
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator!=, COMDAT

; 76   :     _NODISCARD bool operator!=(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 77   :         return !(*this == _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv69[rsp]

; 78   :     }

	add	rsp, 56					; 00000038H
	ret	0
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 73   :     }

	add	rsp, 24
	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator--, COMDAT

; 60   :     _List_unchecked_const_iterator& operator--() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax

; 62   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 51   :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
_Plist$ = 64
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Pnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z
_TEXT	SEGMENT
tv78 = 32
tv84 = 40
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::find<void>, COMDAT

; 1229 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1230 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Find@_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@AEB_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Find<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Make_iter
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1231 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FDecryptCache@SDK@Core@IronMan@@YAXXZ
text$yd	SEGMENT
??__FDecryptCache@SDK@Core@IronMan@@YAXXZ PROC		; IronMan::Core::SDK::`dynamic atexit destructor for 'DecryptCache'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?DecryptCache@SDK@Core@IronMan@@3V?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@A ; IronMan::Core::SDK::DecryptCache
	call	??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__FDecryptCache@SDK@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::SDK::`dynamic atexit destructor for 'DecryptCache''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
;	COMDAT ??__EDecryptCache@SDK@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EDecryptCache@SDK@Core@IronMan@@YAXXZ PROC		; IronMan::Core::SDK::`dynamic initializer for 'DecryptCache'', COMDAT

; 14   : 	std::unordered_map<ptr_t, ptr_t> DecryptCache;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?DecryptCache@SDK@Core@IronMan@@3V?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@A ; IronMan::Core::SDK::DecryptCache
	call	??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
	lea	rcx, OFFSET FLAT:??__FDecryptCache@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::`dynamic atexit destructor for 'DecryptCache''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__EDecryptCache@SDK@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::SDK::`dynamic initializer for 'DecryptCache''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@U?$pair@$$CB_K_K@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::unordered_map<unsigned __int64,unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >, COMDAT

; 323  :     ~_Hash_vec() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Tidy
	npad	1

; 325  : #if _ITERATOR_DEBUG_LEVEL != 0
; 326  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());
; 327  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 328  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 329  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv92 = 48
this$ = 80
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Tidy, COMDAT

; 313  :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 314  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 315  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>

; 316  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::capacity
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::deallocate

; 317  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 318  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 319  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@Tidy:

; 320  :         }
; 321  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size, COMDAT

; 278  :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 279  :         return (_STD min)(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >,1>::_Get_first
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 280  :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Aliter_traits::max_size(_Mypair._Get_first()));
; 281  :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size, COMDAT

; 1776 :     const float& _Max_bucket_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1777 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1778 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size, COMDAT

; 1772 :     float& _Max_bucket_size() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1773 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1774 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Forced_rehash, COMDAT

; 1680 :     void _Forced_rehash(size_type _Buckets) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1681 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1682 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1683 :         // load_factor() <= max_load_factor().
; 1684 : 
; 1685 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1686 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1687 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::max_size
	shr	rax, 1
	mov	rcx, rax
	call	?_Floor_of_log_2@std@@YAK_K@Z		; std::_Floor_of_log_2
	mov	DWORD PTR _Max_storage_buckets_log2$[rsp], eax

; 1688 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, DWORD PTR _Max_storage_buckets_log2$[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv308[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv308[rsp]
	shl	rax, cl
	mov	QWORD PTR _Max_storage_buckets$[rsp], rax

; 1689 :         if (_Buckets > _Max_storage_buckets) {

	mov	rax, QWORD PTR _Max_storage_buckets$[rsp]
	cmp	QWORD PTR _Buckets$[rsp], rax
	jbe	SHORT $LN8@Forced_reh

; 1690 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN8@Forced_reh:

; 1691 :         }
; 1692 : 
; 1693 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1694 :         // 2 invariant
; 1695 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1696 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1697 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	mov	rcx, QWORD PTR _Buckets$[rsp]
	call	?_Ceiling_of_log_2@std@@YAK_K@Z		; std::_Ceiling_of_log_2
	mov	ecx, 1
	mov	QWORD PTR tv312[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv312[rsp]
	shl	rax, cl
	mov	QWORD PTR _Buckets$[rsp], rax

; 1698 :         const _Unchecked_iterator _End = _Unchecked_end();

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_end

; 1699 : 
; 1700 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Buckets$[rsp]
	shl	rax, 1
	mov	r8, QWORD PTR _End$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Assign_grow

; 1701 :         _Mask   = _Buckets - 1;

	mov	rax, QWORD PTR _Buckets$[rsp]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1702 :         _Maxidx = _Buckets;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Buckets$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 1703 : 
; 1704 :         _Clear_guard _Guard{this};

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??0_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::_Clear_guard
	npad	1

; 1705 : 
; 1706 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

	lea	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_begin
	npad	1

; 1707 : 
; 1708 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1709 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR _Next_inserted$2[rsp], rax
	jmp	SHORT $LN4@Forced_reh
$LN2@Forced_reh:
	mov	rax, QWORD PTR _Next_inserted$2[rsp]
	mov	QWORD PTR _Inserted$[rsp], rax
$LN4@Forced_reh:
	lea	rdx, QWORD PTR _End$[rsp]
	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN3@Forced_reh

; 1710 :             ++_Next_inserted;

	lea	rcx, QWORD PTR _Next_inserted$2[rsp]
	call	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator++

; 1711 : 
; 1712 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_K_K@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
	mov	QWORD PTR _Inserted_key$5[rsp], rax

; 1713 :             const size_type _Bucket = bucket(_Inserted_key);

	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1714 : 
; 1715 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1716 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1717 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$3[rsp], rax

; 1718 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$4[rsp], rax

; 1719 : 
; 1720 :             if (_Bucket_lo == _End) {

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Forced_reh

; 1721 :                 // The bucket was empty, set it to the inserted element.
; 1722 :                 _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1723 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1724 :                 continue;

	jmp	$LN2@Forced_reh
$LN9@Forced_reh:

; 1725 :             }
; 1726 : 
; 1727 :             // Search the bucket for the insertion location and move element if necessary.
; 1728 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Insert_before$1[rsp], rax

; 1729 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv194[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv194[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Forced_reh

; 1730 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1731 :                 // new bucket inclusive end.
; 1732 :                 ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator++
	npad	1

; 1733 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	lea	rdx, QWORD PTR _Inserted$[rsp]
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Forced_reh

; 1734 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_splice
	npad	1
$LN11@Forced_reh:

; 1735 :                 }
; 1736 : 
; 1737 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1738 :                 continue;

	jmp	$LN2@Forced_reh
$LN5@Forced_reh:

; 1739 :             }
; 1740 : 
; 1741 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1742 :             // go backwards to maintain sortedness when !_Standard.
; 1743 :             for (;;) {
; 1744 :                 if (_Bucket_lo == _Insert_before) {

	lea	rdx, QWORD PTR _Insert_before$1[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Forced_reh

; 1745 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1746 :                     // Element can't be already in position here because:
; 1747 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1748 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1749 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_splice

; 1750 :                     _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1751 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1752 :                 }
; 1753 : 
; 1754 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv258[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator--
	mov	rcx, rax
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_K_K@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv258[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@Forced_reh

; 1755 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1756 :                     ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,std::_Iterator_base0>::operator++

; 1757 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1758 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1759 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_splice
	npad	1

; 1760 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1761 :                 }
; 1762 :             }

	jmp	$LN5@Forced_reh
$LN6@Forced_reh:

; 1763 :         }

	jmp	$LN2@Forced_reh
$LN3@Forced_reh:

; 1764 : 
; 1765 :         _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$[rsp], 0

; 1766 : 
; 1767 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1768 :         _Stl_internal_check_container_invariants();
; 1769 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1770 :     }

	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::~_Clear_guard
	npad	1
	add	rsp, 168				; 000000a8H
	ret	0
$LN16@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Forced_rehash'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Clear_guard::~_Clear_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Forced_rehash'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
_Old_buckets$ = 32
_Req_buckets$ = 40
$T1 = 48
this$ = 80
_For_size$ = 88
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Desired_grow_bucket_count, COMDAT

; 1659 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1660 :         const size_type _Old_buckets = bucket_count();

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket_count
	mov	QWORD PTR _Old_buckets$[rsp], rax

; 1661 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	rdx, QWORD PTR _For_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Min_load_factor_buckets
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?_Min_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@2_KB
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Req_buckets$[rsp], rax

; 1662 :         if (_Old_buckets >= _Req_buckets) {

	mov	rax, QWORD PTR _Req_buckets$[rsp]
	cmp	QWORD PTR _Old_buckets$[rsp], rax
	jb	SHORT $LN2@Desired_gr

; 1663 :             // we already have enough buckets so there's no need to change the count
; 1664 :             return _Old_buckets;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	jmp	SHORT $LN1@Desired_gr
$LN2@Desired_gr:

; 1665 :         }
; 1666 : 
; 1667 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	QWORD PTR _Old_buckets$[rsp], 512	; 00000200H
	jae	SHORT $LN3@Desired_gr
	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	cmp	rax, QWORD PTR _Req_buckets$[rsp]
	jb	SHORT $LN3@Desired_gr

; 1668 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1669 :             return _Old_buckets * 8;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	jmp	SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1670 :         }
; 1671 : 
; 1672 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1673 :         return _Req_buckets;

	mov	rax, QWORD PTR _Req_buckets$[rsp]
$LN1@Desired_gr:

; 1674 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
tv65 = 32
this$ = 64
_For_size$ = 72
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Min_load_factor_buckets, COMDAT

; 1654 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1655 :         // returns the minimum number of buckets necessary for the elements in _List
; 1656 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	mov	rax, QWORD PTR _For_size$[rsp]
	test	rax, rax
	jl	SHORT $LN4@Min_load_f
	cvtsi2ss xmm0, rax
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN5@Min_load_f
$LN4@Min_load_f:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR tv65[rsp], xmm0
$LN5@Min_load_f:
	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::max_load_factor
	movss	xmm1, DWORD PTR tv65[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	ceilf
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN3@Min_load_f
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN3@Min_load_f
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN3@Min_load_f:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx

; 1657 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Newsize$ = 40
this$ = 64
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Rehash_for_1, COMDAT

; 1630 :     void _Rehash_for_1() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1631 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1632 :         const auto _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1633 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Forced_rehash
	npad	1

; 1634 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv71 = 32
tv77 = 36
tv70 = 40
_Oldsize$ = 48
_Newsize$ = 56
this$ = 80
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_rehash_required_1, COMDAT

; 1624 :     bool _Check_rehash_required_1() const noexcept {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1625 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1626 :         const auto _Newsize      = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1627 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::max_load_factor
	movss	DWORD PTR tv70[rsp], xmm0
	mov	rax, QWORD PTR _Newsize$[rsp]
	test	rax, rax
	jl	SHORT $LN7@Check_reha
	cvtsi2ss xmm1, rax
	movss	DWORD PTR tv71[rsp], xmm1
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
	movss	DWORD PTR tv71[rsp], xmm1
$LN8@Check_reha:
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket_count
	test	rax, rax
	jl	SHORT $LN5@Check_reha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN6@Check_reha
$LN5@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN6@Check_reha:
	movss	xmm1, DWORD PTR tv71[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tv70[rsp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Check_reha
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN4@Check_reha
$LN3@Check_reha:
	mov	DWORD PTR tv77[rsp], 0
$LN4@Check_reha:
	movzx	eax, BYTE PTR tv77[rsp]

; 1628 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
this$ = 64
?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_max_size, COMDAT

; 1617 :     void _Check_max_size() const {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1618 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1619 :         if (_Oldsize == _List.max_size()) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Check_max_

; 1620 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Check_max_:
$LN3@Check_max_:

; 1621 :         }
; 1622 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Check_max_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
_Bucket_lo$ = 32
_Insert_after$ = 40
_Bucket_hi$ = 48
_Bucket$ = 56
_Bucket_array$ = 64
_Head$ = 72
this$ = 96
_Hashval$ = 104
_Insert_before$ = 112
_Newnode$ = 120
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Insert_new_node_before, COMDAT

; 1586 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1587 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Insert_after$[rsp], rax

; 1588 :         ++_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1589 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	rax, QWORD PTR _Newnode$[rsp]
	lea	rdx, QWORD PTR _Insert_before$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>

; 1590 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	rax, QWORD PTR _Newnode$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Insert_after$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * const &>

; 1591 :         _Insert_after->_Next  = _Newnode;

	mov	rax, QWORD PTR _Insert_after$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1592 :         _Insert_before->_Prev = _Newnode;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 1593 : 
; 1594 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$[rsp], rax

; 1595 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_array$[rsp], rax

; 1596 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1597 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax

; 1598 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$[rsp], rax

; 1599 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@Insert_new

; 1600 :             // bucket is empty, set both
; 1601 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1602 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1603 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Insert_before$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN4@Insert_new

; 1604 :             // new node is the lowest element in the bucket
; 1605 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN5@Insert_new
$LN4@Insert_new:

; 1606 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Insert_after$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN6@Insert_new

; 1607 :             // new node is the highest element in the bucket
; 1608 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Insert_new:
$LN5@Insert_new:
$LN3@Insert_new:

; 1609 :         }
; 1610 : 
; 1611 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1612 :         _Stl_internal_check_container_invariants();
; 1613 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1614 :         return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]

; 1615 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Head$1 = 40
tv132 = 48
tv134 = 56
tv130 = 64
$T2 = 72
this$ = 96
?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::clear, COMDAT

; 1152 :     void clear() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1153 :         // TRANSITION, ABI:
; 1154 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1155 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1156 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1157 :         //   (2) The hash function operator() may throw exceptions, and
; 1158 :         //   (3) clear() is a noexcept function.
; 1159 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1160 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1161 :         if (_Oldsize == 0) {

	cmp	QWORD PTR _Oldsize$[rsp], 0
	jne	SHORT $LN2@clear

; 1162 :             return;

	jmp	$LN1@clear
$LN2@clear:

; 1163 :         }
; 1164 : 
; 1165 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1166 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1167 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1168 :             // as many buckets as elements, remove element-by-element.
; 1169 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket_count
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	cmp	rax, QWORD PTR _Oldsize$[rsp]
	jbe	SHORT $LN3@clear

; 1170 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$1[rsp], rax

; 1171 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	r8, QWORD PTR _Head$1[rsp]
	mov	rax, QWORD PTR _Head$1[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_erase
	npad	1

; 1172 :                 return;

	jmp	SHORT $LN1@clear
$LN3@clear:

; 1173 :             }
; 1174 :         }
; 1175 : 
; 1176 :         // Bulk destroy items and reset buckets
; 1177 :         _List.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::clear
	npad	1

; 1178 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_end
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv134[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > >
	npad	1
$LN1@clear:

; 1179 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_erase, COMDAT

; 1028 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1029 :         if (_First == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	jne	SHORT $LN10@Unchecked_

; 1030 :             return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	jmp	$LN1@Unchecked_
$LN10@Unchecked_:

; 1031 :         }
; 1032 : 
; 1033 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1034 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_bounds$[rsp], rax

; 1035 :         _Range_eraser _Eraser{_List, _First};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	r8, QWORD PTR _First$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??0_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Range_eraser
	npad	1

; 1036 :         {
; 1037 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1038 :             const auto _Predecessor = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Predecessor$12[rsp], rax

; 1039 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1040 :             // nothrow hereafter this block
; 1041 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$4[rsp], rax

; 1042 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$5[rsp], rax

; 1043 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN19@Unchecked_
	mov	BYTE PTR tv136[rsp], 1
	jmp	SHORT $LN20@Unchecked_
$LN19@Unchecked_:
	mov	BYTE PTR tv136[rsp], 0
$LN20@Unchecked_:
	movzx	eax, BYTE PTR tv136[rsp]
	mov	BYTE PTR _Update_lo$1[rsp], al

; 1044 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$10[rsp], rax
$LN2@Unchecked_:

; 1045 :             for (;;) { // remove elements until we hit the end of the bucket
; 1046 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$10[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN21@Unchecked_
	mov	BYTE PTR tv138[rsp], 1
	jmp	SHORT $LN22@Unchecked_
$LN21@Unchecked_:
	mov	BYTE PTR tv138[rsp], 0
$LN22@Unchecked_:
	movzx	eax, BYTE PTR tv138[rsp]
	mov	BYTE PTR _At_bucket_back$2[rsp], al

; 1047 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1048 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$2[rsp]
	test	eax, eax
	je	SHORT $LN11@Unchecked_

; 1049 :                     break;

	jmp	SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1050 :                 }
; 1051 : 
; 1052 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN12@Unchecked_

; 1053 :                     if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN13@Unchecked_

; 1054 :                         // erased the bucket's prefix
; 1055 :                         _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx
$LN13@Unchecked_:

; 1056 :                     }
; 1057 : 
; 1058 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T11[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN1@Unchecked_
$LN12@Unchecked_:

; 1059 :                 }
; 1060 :             }

	jmp	$LN2@Unchecked_
$LN3@Unchecked_:

; 1061 : 
; 1062 :             if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN14@Unchecked_

; 1063 :                 // emptied the bucket
; 1064 :                 _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1065 :                 _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1066 :             } else {

	jmp	SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1067 :                 _Bucket_hi = _Predecessor;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _Predecessor$12[rsp]
	mov	QWORD PTR [rax], rcx
$LN5@Unchecked_:

; 1068 :             }
; 1069 :         }
; 1070 : 
; 1071 :         // hereafter we are always erasing buckets' prefixes
; 1072 :         while (_Eraser._Next != _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	je	$LN6@Unchecked_

; 1073 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_K_K@?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_K_K@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Kfn<unsigned __int64 const ,unsigned __int64>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket
	mov	QWORD PTR _Bucket$7[rsp], rax

; 1074 :             // nothrow hereafter this block
; 1075 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$8[rsp], rax

; 1076 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$9[rsp], rax

; 1077 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$13[rsp], rax
$LN7@Unchecked_:

; 1078 :             for (;;) { // remove elements until we hit the end of the bucket
; 1079 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$13[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN23@Unchecked_
	mov	BYTE PTR tv172[rsp], 1
	jmp	SHORT $LN24@Unchecked_
$LN23@Unchecked_:
	mov	BYTE PTR tv172[rsp], 0
$LN24@Unchecked_:
	movzx	eax, BYTE PTR tv172[rsp]
	mov	BYTE PTR _At_bucket_back$3[rsp], al

; 1080 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1081 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$3[rsp]
	test	eax, eax
	je	SHORT $LN16@Unchecked_

; 1082 :                     break;

	jmp	SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1083 :                 }
; 1084 : 
; 1085 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN17@Unchecked_

; 1086 :                     // erased the bucket's prefix
; 1087 :                     _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx

; 1088 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T14[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T14[rsp]
	jmp	SHORT $LN1@Unchecked_
$LN17@Unchecked_:

; 1089 :                 }
; 1090 :             }

	jmp	SHORT $LN7@Unchecked_
$LN8@Unchecked_:

; 1091 : 
; 1092 :             // emptied the bucket
; 1093 :             _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1094 :             _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1095 :         }

	jmp	$LN5@Unchecked_
$LN6@Unchecked_:

; 1096 : 
; 1097 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T15[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T15[rsp]
$LN1@Unchecked_:

; 1098 :     }

	add	rsp, 184				; 000000b8H
	ret	0
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_erase'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Eraser$[rbp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Range_eraser::~_Range_eraser
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_erase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 48
?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::max_load_factor, COMDAT

; 912  :     _NODISCARD float max_load_factor() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         return _Max_bucket_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR [rax]

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv73 = 32
tv76 = 40
tv78 = 48
this$ = 80
_Keyval$ = 88
?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket, COMDAT

; 856  :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 857  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	and	rcx, rax
	mov	rax, rcx

; 858  :     }

	add	rsp, 72					; 00000048H
	ret	0
?bucket@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket_count, COMDAT

; 847  :     _NODISCARD size_type bucket_count() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 848  :         return _Maxidx;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]

; 849  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_end, COMDAT

; 812  :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 813  :         return _List._Unchecked_end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 814  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_begin, COMDAT

; 804  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 805  :         return _List._Unchecked_begin();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_begin
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 806  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::end, COMDAT

; 796  :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 797  :         return _List.end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 798  :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
_TEXT	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >, COMDAT

; 378  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > ><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 7
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 8

; 379  :         // construct empty hash table
; 380  :         _Max_bucket_size() = _Bucket_size;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 381  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_end
	mov	r8, QWORD PTR [rax]
	mov	edx, 16
	mov	rcx, QWORD PTR tv132[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::_Assign_grow
	npad	1

; 382  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 383  :         _Stl_internal_check_container_invariants();
; 384  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 385  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Last_prev$ = 0
_First_prev$ = 8
_Before_prev$ = 16
_Before$ = 48
_First$ = 56
_Last$ = 64
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_splice, COMDAT

; 468  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _First_prev$[rsp], rax

; 475  :         _First_prev->_Next      = _Last;

	mov	rax, QWORD PTR _First_prev$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Last_prev$[rsp], rax

; 477  :         _Last_prev->_Next       = _Before;

	mov	rax, QWORD PTR _Last_prev$[rsp]
	mov	rcx, QWORD PTR _Before$[rsp]
	mov	QWORD PTR [rax], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Before_prev$[rsp], rax

; 479  :         _Before_prev->_Next     = _First;

	mov	rax, QWORD PTR _Before_prev$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rcx, QWORD PTR _Last_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 484  :         _First->_Prev  = _Before_prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Before_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 485  : 
; 486  :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 487  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	mov	QWORD PTR [rsp+8], rcx

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal, COMDAT

; 1858 :     const _Alnode& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1859 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first

; 1860 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> *,std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
tv75 = 40
tv73 = 48
this$ = 80
?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::clear, COMDAT

; 1494 :     void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1495 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1496 :         _My_data._Orphan_non_end();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Orphan_non_end

; 1497 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >

; 1498 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1499 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 1500 :         _My_data._Mysize        = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1501 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::max_size, COMDAT

; 1197 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1198 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1199 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1200 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Make_iter, COMDAT

; 1126 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1127 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > const >
	mov	r8, rax
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1128 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Make_iter@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_begin, COMDAT

; 1110 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1111 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1112 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::~list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Al$ = 72
??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z PROC ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >, COMDAT

; 806  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_K_K@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > >,1><std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > const &>
	npad	1

; 807  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::_Alloc_sentinel_and_proxy
	npad	1

; 808  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@U?$pair@$$CB_K_K@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_K_K@std@@@1@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >::list<std::pair<unsigned __int64 const ,unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 32		; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z	; std::_Get_size_of_n<32>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 32		; 00000020H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_K_K@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,unsigned __int64>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR _Traits$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CB_K_K@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CB_K_K@std@@@std@@QEAA@XZ PROC	; std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@$$CB_K_K@std@@@std@@QEAA@XZ ENDP	; std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ
text$yd	SEGMENT
??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ PROC	; IronMan::Core::SDK::`dynamic atexit destructor for 'CacheOuterName'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?CacheOuterName@SDK@Core@IronMan@@3V?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::SDK::`dynamic atexit destructor for 'CacheOuterName''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
;	COMDAT ??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ PROC	; IronMan::Core::SDK::`dynamic initializer for 'CacheOuterName'', COMDAT

; 13   : 	static std::unordered_map<ptr_t, std::string>CacheOuterName;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?CacheOuterName@SDK@Core@IronMan@@3V?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	lea	rcx, OFFSET FLAT:??__FCacheOuterName@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::`dynamic atexit destructor for 'CacheOuterName''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__ECacheOuterName@SDK@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::SDK::`dynamic initializer for 'CacheOuterName''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned __int64>,std::equal_to<unsigned __int64>,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >, COMDAT

; 323  :     ~_Hash_vec() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy
	npad	1

; 325  : #if _ITERATOR_DEBUG_LEVEL != 0
; 326  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());
; 327  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 328  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 329  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv92 = 48
this$ = 80
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy, COMDAT

; 313  :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 314  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 315  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>

; 316  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate

; 317  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 318  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 319  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@Tidy:

; 320  :         }
; 321  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size, COMDAT

; 278  :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 279  :         return (_STD min)(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 280  :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Aliter_traits::max_size(_Mypair._Get_first()));
; 281  :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size, COMDAT

; 1776 :     const float& _Max_bucket_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1777 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1778 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size, COMDAT

; 1772 :     float& _Max_bucket_size() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1773 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size

; 1774 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash, COMDAT

; 1680 :     void _Forced_rehash(size_type _Buckets) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1681 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1682 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1683 :         // load_factor() <= max_load_factor().
; 1684 : 
; 1685 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1686 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1687 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
	shr	rax, 1
	mov	rcx, rax
	call	?_Floor_of_log_2@std@@YAK_K@Z		; std::_Floor_of_log_2
	mov	DWORD PTR _Max_storage_buckets_log2$[rsp], eax

; 1688 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, DWORD PTR _Max_storage_buckets_log2$[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv308[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv308[rsp]
	shl	rax, cl
	mov	QWORD PTR _Max_storage_buckets$[rsp], rax

; 1689 :         if (_Buckets > _Max_storage_buckets) {

	mov	rax, QWORD PTR _Max_storage_buckets$[rsp]
	cmp	QWORD PTR _Buckets$[rsp], rax
	jbe	SHORT $LN8@Forced_reh

; 1690 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN8@Forced_reh:

; 1691 :         }
; 1692 : 
; 1693 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1694 :         // 2 invariant
; 1695 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1696 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1697 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	mov	rcx, QWORD PTR _Buckets$[rsp]
	call	?_Ceiling_of_log_2@std@@YAK_K@Z		; std::_Ceiling_of_log_2
	mov	ecx, 1
	mov	QWORD PTR tv312[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv312[rsp]
	shl	rax, cl
	mov	QWORD PTR _Buckets$[rsp], rax

; 1698 :         const _Unchecked_iterator _End = _Unchecked_end();

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end

; 1699 : 
; 1700 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Buckets$[rsp]
	shl	rax, 1
	mov	r8, QWORD PTR _End$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow

; 1701 :         _Mask   = _Buckets - 1;

	mov	rax, QWORD PTR _Buckets$[rsp]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1702 :         _Maxidx = _Buckets;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Buckets$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 1703 : 
; 1704 :         _Clear_guard _Guard{this};

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??0_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard
	npad	1

; 1705 : 
; 1706 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

	lea	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin
	npad	1

; 1707 : 
; 1708 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1709 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR _Next_inserted$2[rsp], rax
	jmp	SHORT $LN4@Forced_reh
$LN2@Forced_reh:
	mov	rax, QWORD PTR _Next_inserted$2[rsp]
	mov	QWORD PTR _Inserted$[rsp], rax
$LN4@Forced_reh:
	lea	rdx, QWORD PTR _End$[rsp]
	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN3@Forced_reh

; 1710 :             ++_Next_inserted;

	lea	rcx, QWORD PTR _Next_inserted$2[rsp]
	call	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++

; 1711 : 
; 1712 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR _Inserted_key$5[rsp], rax

; 1713 :             const size_type _Bucket = bucket(_Inserted_key);

	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1714 : 
; 1715 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1716 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1717 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$3[rsp], rax

; 1718 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$4[rsp], rax

; 1719 : 
; 1720 :             if (_Bucket_lo == _End) {

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Forced_reh

; 1721 :                 // The bucket was empty, set it to the inserted element.
; 1722 :                 _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1723 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1724 :                 continue;

	jmp	$LN2@Forced_reh
$LN9@Forced_reh:

; 1725 :             }
; 1726 : 
; 1727 :             // Search the bucket for the insertion location and move element if necessary.
; 1728 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Insert_before$1[rsp], rax

; 1729 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv194[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv194[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Forced_reh

; 1730 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1731 :                 // new bucket inclusive end.
; 1732 :                 ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++
	npad	1

; 1733 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	lea	rdx, QWORD PTR _Inserted$[rsp]
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Forced_reh

; 1734 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
	npad	1
$LN11@Forced_reh:

; 1735 :                 }
; 1736 : 
; 1737 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1738 :                 continue;

	jmp	$LN2@Forced_reh
$LN5@Forced_reh:

; 1739 :             }
; 1740 : 
; 1741 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1742 :             // go backwards to maintain sortedness when !_Standard.
; 1743 :             for (;;) {
; 1744 :                 if (_Bucket_lo == _Insert_before) {

	lea	rdx, QWORD PTR _Insert_before$1[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Forced_reh

; 1745 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1746 :                     // Element can't be already in position here because:
; 1747 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1748 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1749 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice

; 1750 :                     _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1751 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1752 :                 }
; 1753 : 
; 1754 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv258[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--
	mov	rcx, rax
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv258[rsp]
	call	??$?R_K_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_NAEB_K0@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64,unsigned __int64>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@Forced_reh

; 1755 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1756 :                     ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++

; 1757 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1758 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1759 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
	npad	1

; 1760 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1761 :                 }
; 1762 :             }

	jmp	$LN5@Forced_reh
$LN6@Forced_reh:

; 1763 :         }

	jmp	$LN2@Forced_reh
$LN3@Forced_reh:

; 1764 : 
; 1765 :         _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$[rsp], 0

; 1766 : 
; 1767 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1768 :         _Stl_internal_check_container_invariants();
; 1769 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1770 :     }

	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
	npad	1
	add	rsp, 168				; 000000a8H
	ret	0
$LN16@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
_Old_buckets$ = 32
_Req_buckets$ = 40
$T1 = 48
this$ = 80
_For_size$ = 88
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count, COMDAT

; 1659 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1660 :         const size_type _Old_buckets = bucket_count();

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
	mov	QWORD PTR _Old_buckets$[rsp], rax

; 1661 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	rdx, QWORD PTR _For_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?_Min_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Req_buckets$[rsp], rax

; 1662 :         if (_Old_buckets >= _Req_buckets) {

	mov	rax, QWORD PTR _Req_buckets$[rsp]
	cmp	QWORD PTR _Old_buckets$[rsp], rax
	jb	SHORT $LN2@Desired_gr

; 1663 :             // we already have enough buckets so there's no need to change the count
; 1664 :             return _Old_buckets;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	jmp	SHORT $LN1@Desired_gr
$LN2@Desired_gr:

; 1665 :         }
; 1666 : 
; 1667 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	QWORD PTR _Old_buckets$[rsp], 512	; 00000200H
	jae	SHORT $LN3@Desired_gr
	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	cmp	rax, QWORD PTR _Req_buckets$[rsp]
	jb	SHORT $LN3@Desired_gr

; 1668 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1669 :             return _Old_buckets * 8;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	jmp	SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1670 :         }
; 1671 : 
; 1672 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1673 :         return _Req_buckets;

	mov	rax, QWORD PTR _Req_buckets$[rsp]
$LN1@Desired_gr:

; 1674 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
tv65 = 32
this$ = 64
_For_size$ = 72
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets, COMDAT

; 1654 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1655 :         // returns the minimum number of buckets necessary for the elements in _List
; 1656 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	mov	rax, QWORD PTR _For_size$[rsp]
	test	rax, rax
	jl	SHORT $LN4@Min_load_f
	cvtsi2ss xmm0, rax
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN5@Min_load_f
$LN4@Min_load_f:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR tv65[rsp], xmm0
$LN5@Min_load_f:
	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
	movss	xmm1, DWORD PTR tv65[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	ceilf
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN3@Min_load_f
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN3@Min_load_f
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN3@Min_load_f:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx

; 1657 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Newsize$ = 40
this$ = 64
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1, COMDAT

; 1630 :     void _Rehash_for_1() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1631 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1632 :         const auto _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1633 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash
	npad	1

; 1634 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv71 = 32
tv77 = 36
tv70 = 40
_Oldsize$ = 48
_Newsize$ = 56
this$ = 80
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1, COMDAT

; 1624 :     bool _Check_rehash_required_1() const noexcept {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1625 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1626 :         const auto _Newsize      = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1627 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
	movss	DWORD PTR tv70[rsp], xmm0
	mov	rax, QWORD PTR _Newsize$[rsp]
	test	rax, rax
	jl	SHORT $LN7@Check_reha
	cvtsi2ss xmm1, rax
	movss	DWORD PTR tv71[rsp], xmm1
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
	movss	DWORD PTR tv71[rsp], xmm1
$LN8@Check_reha:
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
	test	rax, rax
	jl	SHORT $LN5@Check_reha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN6@Check_reha
$LN5@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN6@Check_reha:
	movss	xmm1, DWORD PTR tv71[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tv70[rsp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Check_reha
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN4@Check_reha
$LN3@Check_reha:
	mov	DWORD PTR tv77[rsp], 0
$LN4@Check_reha:
	movzx	eax, BYTE PTR tv77[rsp]

; 1628 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
this$ = 64
?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size, COMDAT

; 1617 :     void _Check_max_size() const {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1618 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1619 :         if (_Oldsize == _List.max_size()) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Check_max_

; 1620 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Check_max_:
$LN3@Check_max_:

; 1621 :         }
; 1622 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Check_max_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
_Bucket_lo$ = 32
_Insert_after$ = 40
_Bucket_hi$ = 48
_Bucket$ = 56
_Bucket_array$ = 64
_Head$ = 72
this$ = 96
_Hashval$ = 104
_Insert_before$ = 112
_Newnode$ = 120
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before, COMDAT

; 1586 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1587 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Insert_after$[rsp], rax

; 1588 :         ++_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1589 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	rax, QWORD PTR _Newnode$[rsp]
	lea	rdx, QWORD PTR _Insert_before$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>

; 1590 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	rax, QWORD PTR _Newnode$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Insert_after$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>

; 1591 :         _Insert_after->_Next  = _Newnode;

	mov	rax, QWORD PTR _Insert_after$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1592 :         _Insert_before->_Prev = _Newnode;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 1593 : 
; 1594 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$[rsp], rax

; 1595 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_array$[rsp], rax

; 1596 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1597 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax

; 1598 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$[rsp], rax

; 1599 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@Insert_new

; 1600 :             // bucket is empty, set both
; 1601 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1602 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1603 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Insert_before$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN4@Insert_new

; 1604 :             // new node is the lowest element in the bucket
; 1605 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN5@Insert_new
$LN4@Insert_new:

; 1606 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Insert_after$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN6@Insert_new

; 1607 :             // new node is the highest element in the bucket
; 1608 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Insert_new:
$LN5@Insert_new:
$LN3@Insert_new:

; 1609 :         }
; 1610 : 
; 1611 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1612 :         _Stl_internal_check_container_invariants();
; 1613 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1614 :         return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]

; 1615 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Head$1 = 40
tv132 = 48
tv134 = 56
tv130 = 64
$T2 = 72
this$ = 96
?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear, COMDAT

; 1152 :     void clear() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1153 :         // TRANSITION, ABI:
; 1154 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1155 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1156 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1157 :         //   (2) The hash function operator() may throw exceptions, and
; 1158 :         //   (3) clear() is a noexcept function.
; 1159 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1160 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1161 :         if (_Oldsize == 0) {

	cmp	QWORD PTR _Oldsize$[rsp], 0
	jne	SHORT $LN2@clear

; 1162 :             return;

	jmp	$LN1@clear
$LN2@clear:

; 1163 :         }
; 1164 : 
; 1165 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1166 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1167 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1168 :             // as many buckets as elements, remove element-by-element.
; 1169 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	cmp	rax, QWORD PTR _Oldsize$[rsp]
	jbe	SHORT $LN3@clear

; 1170 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$1[rsp], rax

; 1171 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	r8, QWORD PTR _Head$1[rsp]
	mov	rax, QWORD PTR _Head$1[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase
	npad	1

; 1172 :                 return;

	jmp	SHORT $LN1@clear
$LN3@clear:

; 1173 :             }
; 1174 :         }
; 1175 : 
; 1176 :         // Bulk destroy items and reset buckets
; 1177 :         _List.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear
	npad	1

; 1178 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv134[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	npad	1
$LN1@clear:

; 1179 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase, COMDAT

; 1028 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1029 :         if (_First == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	jne	SHORT $LN10@Unchecked_

; 1030 :             return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	jmp	$LN1@Unchecked_
$LN10@Unchecked_:

; 1031 :         }
; 1032 : 
; 1033 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1034 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_bounds$[rsp], rax

; 1035 :         _Range_eraser _Eraser{_List, _First};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	r8, QWORD PTR _First$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??0_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser
	npad	1

; 1036 :         {
; 1037 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1038 :             const auto _Predecessor = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Predecessor$12[rsp], rax

; 1039 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1040 :             // nothrow hereafter this block
; 1041 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$4[rsp], rax

; 1042 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$5[rsp], rax

; 1043 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN19@Unchecked_
	mov	BYTE PTR tv136[rsp], 1
	jmp	SHORT $LN20@Unchecked_
$LN19@Unchecked_:
	mov	BYTE PTR tv136[rsp], 0
$LN20@Unchecked_:
	movzx	eax, BYTE PTR tv136[rsp]
	mov	BYTE PTR _Update_lo$1[rsp], al

; 1044 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$10[rsp], rax
$LN2@Unchecked_:

; 1045 :             for (;;) { // remove elements until we hit the end of the bucket
; 1046 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$10[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN21@Unchecked_
	mov	BYTE PTR tv138[rsp], 1
	jmp	SHORT $LN22@Unchecked_
$LN21@Unchecked_:
	mov	BYTE PTR tv138[rsp], 0
$LN22@Unchecked_:
	movzx	eax, BYTE PTR tv138[rsp]
	mov	BYTE PTR _At_bucket_back$2[rsp], al

; 1047 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1048 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$2[rsp]
	test	eax, eax
	je	SHORT $LN11@Unchecked_

; 1049 :                     break;

	jmp	SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1050 :                 }
; 1051 : 
; 1052 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN12@Unchecked_

; 1053 :                     if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN13@Unchecked_

; 1054 :                         // erased the bucket's prefix
; 1055 :                         _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx
$LN13@Unchecked_:

; 1056 :                     }
; 1057 : 
; 1058 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T11[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN1@Unchecked_
$LN12@Unchecked_:

; 1059 :                 }
; 1060 :             }

	jmp	$LN2@Unchecked_
$LN3@Unchecked_:

; 1061 : 
; 1062 :             if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN14@Unchecked_

; 1063 :                 // emptied the bucket
; 1064 :                 _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1065 :                 _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1066 :             } else {

	jmp	SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1067 :                 _Bucket_hi = _Predecessor;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _Predecessor$12[rsp]
	mov	QWORD PTR [rax], rcx
$LN5@Unchecked_:

; 1068 :             }
; 1069 :         }
; 1070 : 
; 1071 :         // hereafter we are always erasing buckets' prefixes
; 1072 :         while (_Eraser._Next != _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	je	$LN6@Unchecked_

; 1073 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEB_KAEBU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$7[rsp], rax

; 1074 :             // nothrow hereafter this block
; 1075 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$8[rsp], rax

; 1076 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$9[rsp], rax

; 1077 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$13[rsp], rax
$LN7@Unchecked_:

; 1078 :             for (;;) { // remove elements until we hit the end of the bucket
; 1079 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$13[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN23@Unchecked_
	mov	BYTE PTR tv172[rsp], 1
	jmp	SHORT $LN24@Unchecked_
$LN23@Unchecked_:
	mov	BYTE PTR tv172[rsp], 0
$LN24@Unchecked_:
	movzx	eax, BYTE PTR tv172[rsp]
	mov	BYTE PTR _At_bucket_back$3[rsp], al

; 1080 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1081 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$3[rsp]
	test	eax, eax
	je	SHORT $LN16@Unchecked_

; 1082 :                     break;

	jmp	SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1083 :                 }
; 1084 : 
; 1085 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN17@Unchecked_

; 1086 :                     // erased the bucket's prefix
; 1087 :                     _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx

; 1088 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T14[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T14[rsp]
	jmp	SHORT $LN1@Unchecked_
$LN17@Unchecked_:

; 1089 :                 }
; 1090 :             }

	jmp	SHORT $LN7@Unchecked_
$LN8@Unchecked_:

; 1091 : 
; 1092 :             // emptied the bucket
; 1093 :             _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1094 :             _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1095 :         }

	jmp	$LN5@Unchecked_
$LN6@Unchecked_:

; 1096 : 
; 1097 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T15[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T15[rsp]
$LN1@Unchecked_:

; 1098 :     }

	add	rsp, 184				; 000000b8H
	ret	0
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Eraser$[rbp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 48
?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor, COMDAT

; 912  :     _NODISCARD float max_load_factor() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         return _Max_bucket_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR [rax]

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv73 = 32
tv76 = 40
tv78 = 48
this$ = 80
_Keyval$ = 88
?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket, COMDAT

; 856  :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 857  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	and	rcx, rax
	mov	rax, rcx

; 858  :     }

	add	rsp, 72					; 00000048H
	ret	0
?bucket@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEB_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count, COMDAT

; 847  :     _NODISCARD size_type bucket_count() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 848  :         return _Maxidx;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]

; 849  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end, COMDAT

; 812  :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 813  :         return _List._Unchecked_end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 814  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin, COMDAT

; 804  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 805  :         return _List._Unchecked_begin();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 806  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end, COMDAT

; 796  :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 797  :         return _List.end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 798  :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT

; 378  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 7
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 8

; 379  :         // construct empty hash table
; 380  :         _Max_bucket_size() = _Bucket_size;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 381  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
	mov	r8, QWORD PTR [rax]
	mov	edx, 16
	mov	rcx, QWORD PTR tv132[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow
	npad	1

; 382  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 383  :         _Stl_internal_check_container_invariants();
; 384  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 385  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Last_prev$ = 0
_First_prev$ = 8
_Before_prev$ = 16
_Before$ = 48
_First$ = 56
_Last$ = 64
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice, COMDAT

; 468  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _First_prev$[rsp], rax

; 475  :         _First_prev->_Next      = _Last;

	mov	rax, QWORD PTR _First_prev$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Last_prev$[rsp], rax

; 477  :         _Last_prev->_Next       = _Before;

	mov	rax, QWORD PTR _Last_prev$[rsp]
	mov	rcx, QWORD PTR _Before$[rsp]
	mov	QWORD PTR [rax], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Before_prev$[rsp], rax

; 479  :         _Before_prev->_Next     = _First;

	mov	rax, QWORD PTR _Before_prev$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rcx, QWORD PTR _Last_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 484  :         _First->_Prev  = _Before_prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Before_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 485  : 
; 486  :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 487  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	mov	QWORD PTR [rsp+8], rcx

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT

; 1858 :     const _Alnode& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1859 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first

; 1860 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
tv75 = 40
tv73 = 48
this$ = 80
?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear, COMDAT

; 1494 :     void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1495 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1496 :         _My_data._Orphan_non_end();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end

; 1497 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1498 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1499 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 1500 :         _My_data._Mysize        = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1501 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size, COMDAT

; 1197 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1198 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1199 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1200 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter, COMDAT

; 1126 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1127 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >
	mov	r8, rax
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1128 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Make_iter@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin, COMDAT

; 1110 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1111 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1112 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Al$ = 72
??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 806  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	npad	1

; 807  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy
	npad	1

; 808  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 329406144173384850			; 0492492492492492H

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 56		; 00000038H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z	; std::_Get_size_of_n<56>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 56		; 00000038H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z PROC ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR _Traits$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@1@@Z ENDP ; std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FCacheName@SDK@Core@IronMan@@YAXXZ
text$yd	SEGMENT
??__FCacheName@SDK@Core@IronMan@@YAXXZ PROC		; IronMan::Core::SDK::`dynamic atexit destructor for 'CacheName'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?CacheName@SDK@Core@IronMan@@3V?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__FCacheName@SDK@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::SDK::`dynamic atexit destructor for 'CacheName''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
;	COMDAT ??__ECacheName@SDK@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__ECacheName@SDK@Core@IronMan@@YAXXZ PROC		; IronMan::Core::SDK::`dynamic initializer for 'CacheName'', COMDAT

; 12   : 	static std::unordered_map<uint32_t, std::string>CacheName;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?CacheName@SDK@Core@IronMan@@3V?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	lea	rcx, OFFSET FLAT:??__FCacheName@SDK@Core@IronMan@@YAXXZ ; IronMan::Core::SDK::`dynamic atexit destructor for 'CacheName''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__ECacheName@SDK@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::SDK::`dynamic initializer for 'CacheName''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	QWORD PTR tv79[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv79[rsp]
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv79 = 40
tv77 = 48
this$ = 80
?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::unordered_map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >, COMDAT

; 323  :     ~_Hash_vec() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy
	npad	1

; 325  : #if _ITERATOR_DEBUG_LEVEL != 0
; 326  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Aliter, _Mypair._Get_first());
; 327  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 328  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 329  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv90 = 32
tv88 = 40
tv92 = 48
this$ = 80
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy, COMDAT

; 313  :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 314  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 315  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>

; 316  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv88[rsp], rax
	mov	r8, QWORD PTR tv90[rsp]
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate

; 317  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 318  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 319  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
$LN2@Tidy:

; 320  :         }
; 321  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Newend$1 = 32
_Newvec$2 = 40
_Oldcapacity$3 = 48
_Alvec$ = 56
_Oldsize$ = 64
this$ = 96
_Cells$ = 104
_Val$ = 112
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow, COMDAT

; 289  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 290  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 291  :         const auto _Oldsize = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size
	mov	QWORD PTR _Oldsize$[rsp], rax

; 292  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 293  :         auto& _Alvec = _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
	mov	QWORD PTR _Alvec$[rsp], rax

; 294  :         if (_Oldsize < _Cells) {

	mov	rax, QWORD PTR _Cells$[rsp]
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jae	$LN2@Assign_gro

; 295  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws

	mov	rdx, QWORD PTR _Cells$[rsp]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate
	mov	QWORD PTR _Newvec$2[rsp], rax

; 296  :             // nothrow hereafter
; 297  :             const auto _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
	mov	QWORD PTR _Oldcapacity$3[rsp], rax

; 298  :             if (_Oldcapacity != 0) {

	cmp	QWORD PTR _Oldcapacity$3[rsp], 0
	je	SHORT $LN4@Assign_gro

; 299  :                 _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *>

; 300  :                 _Alvec.deallocate(_Mypair._Myval2._Myfirst, _Oldcapacity);

	mov	r8, QWORD PTR _Oldcapacity$3[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Alvec$[rsp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate
	npad	1
$LN4@Assign_gro:

; 301  :             }
; 302  : 
; 303  :             _Mypair._Myval2._Myfirst = _Newvec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	mov	QWORD PTR [rax], rcx

; 304  :             const auto _Newend       = _Newvec + _Cells;

	mov	rax, QWORD PTR _Newvec$2[rsp]
	mov	rcx, QWORD PTR _Cells$[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR _Newend$1[rsp], rax

; 305  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+8], rcx

; 306  :             _Mypair._Myval2._Myend   = _Newend;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newend$1[rsp]
	mov	QWORD PTR [rax+16], rcx

; 307  :             _STD uninitialized_fill(_Newvec, _Newend, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rdx, QWORD PTR _Newend$1[rsp]
	mov	rcx, QWORD PTR _Newvec$2[rsp]
	call	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	npad	1

; 308  :         } else {

	jmp	SHORT $LN3@Assign_gro
$LN2@Assign_gro:

; 309  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	lea	r8, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	npad	1
$LN3@Assign_gro:

; 310  :         }
; 311  :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity, COMDAT

; 283  :     _NODISCARD size_type capacity() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 284  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 285  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 286  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 3

; 287  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size, COMDAT

; 278  :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 279  :         return (_STD min)(

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,1>::_Get_first
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 280  :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Aliter_traits::max_size(_Mypair._Get_first()));
; 281  :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size, COMDAT

; 274  :     _NODISCARD size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 275  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	sar	rax, 3

; 276  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$07@std@@YA_K_K@Z	; std::_Get_size_of_n<8>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size, COMDAT

; 1776 :     const float& _Max_bucket_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1777 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size

; 1778 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 48
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size, COMDAT

; 1772 :     float& _Max_bucket_size() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1773 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size

; 1774 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash, COMDAT

; 1680 :     void _Forced_rehash(size_type _Buckets) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 1681 :         // Force rehash of elements in _List, distrusting existing bucket assignments in _Vec.
; 1682 :         // Assumes _Buckets is greater than _Min_buckets, and that changing to that many buckets doesn't violate
; 1683 :         // load_factor() <= max_load_factor().
; 1684 : 
; 1685 :         // Don't violate power of 2, fits in half the bucket vector invariant:
; 1686 :         // (we assume because vector must use single allocations; as a result, its max_size fits in a size_t)
; 1687 :         const unsigned long _Max_storage_buckets_log2 = _Floor_of_log_2(static_cast<size_t>(_Vec.max_size() >> 1));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::max_size
	shr	rax, 1
	mov	rcx, rax
	call	?_Floor_of_log_2@std@@YAK_K@Z		; std::_Floor_of_log_2
	mov	DWORD PTR _Max_storage_buckets_log2$[rsp], eax

; 1688 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, DWORD PTR _Max_storage_buckets_log2$[rsp]
	mov	ecx, 1
	mov	QWORD PTR tv308[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv308[rsp]
	shl	rax, cl
	mov	QWORD PTR _Max_storage_buckets$[rsp], rax

; 1689 :         if (_Buckets > _Max_storage_buckets) {

	mov	rax, QWORD PTR _Max_storage_buckets$[rsp]
	cmp	QWORD PTR _Buckets$[rsp], rax
	jbe	SHORT $LN8@Forced_reh

; 1690 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN8@Forced_reh:

; 1691 :         }
; 1692 : 
; 1693 :         // The above test also means that we won't perform a forbidden full shift when restoring the power of
; 1694 :         // 2 invariant
; 1695 :         // this round up to power of 2 in addition to the _Buckets > _Maxidx above means
; 1696 :         // we'll at least double in size (the next power of 2 above _Maxidx)
; 1697 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	mov	rcx, QWORD PTR _Buckets$[rsp]
	call	?_Ceiling_of_log_2@std@@YAK_K@Z		; std::_Ceiling_of_log_2
	mov	ecx, 1
	mov	QWORD PTR tv312[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv312[rsp]
	shl	rax, cl
	mov	QWORD PTR _Buckets$[rsp], rax

; 1698 :         const _Unchecked_iterator _End = _Unchecked_end();

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end

; 1699 : 
; 1700 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR _Buckets$[rsp]
	shl	rax, 1
	mov	r8, QWORD PTR _End$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv84[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow

; 1701 :         _Mask   = _Buckets - 1;

	mov	rax, QWORD PTR _Buckets$[rsp]
	dec	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 1702 :         _Maxidx = _Buckets;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Buckets$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 1703 : 
; 1704 :         _Clear_guard _Guard{this};

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??0_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::_Clear_guard
	npad	1

; 1705 : 
; 1706 :         _Unchecked_iterator _Inserted = _Unchecked_begin();

	lea	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin
	npad	1

; 1707 : 
; 1708 :         // Remember the next _Inserted value as splices will change _Inserted's position arbitrarily.
; 1709 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR _Next_inserted$2[rsp], rax
	jmp	SHORT $LN4@Forced_reh
$LN2@Forced_reh:
	mov	rax, QWORD PTR _Next_inserted$2[rsp]
	mov	QWORD PTR _Inserted$[rsp], rax
$LN4@Forced_reh:
	lea	rdx, QWORD PTR _End$[rsp]
	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN3@Forced_reh

; 1710 :             ++_Next_inserted;

	lea	rcx, QWORD PTR _Next_inserted$2[rsp]
	call	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++

; 1711 : 
; 1712 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);

	lea	rcx, QWORD PTR _Inserted$[rsp]
	call	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR _Inserted_key$5[rsp], rax

; 1713 :             const size_type _Bucket = bucket(_Inserted_key);

	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1714 : 
; 1715 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1716 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1717 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$3[rsp], rax

; 1718 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$4[rsp], rax

; 1719 : 
; 1720 :             if (_Bucket_lo == _End) {

	lea	rdx, QWORD PTR _End$[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Forced_reh

; 1721 :                 // The bucket was empty, set it to the inserted element.
; 1722 :                 _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1723 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1724 :                 continue;

	jmp	$LN2@Forced_reh
$LN9@Forced_reh:

; 1725 :             }
; 1726 : 
; 1727 :             // Search the bucket for the insertion location and move element if necessary.
; 1728 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Insert_before$1[rsp], rax

; 1729 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv194[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv194[rsp]
	call	??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int,unsigned int>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Forced_reh

; 1730 :                 // The inserted element belongs at the end of the bucket; splice it there and set _Bucket_hi to the
; 1731 :                 // new bucket inclusive end.
; 1732 :                 ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++
	npad	1

; 1733 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	lea	rdx, QWORD PTR _Inserted$[rsp]
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Forced_reh

; 1734 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
	npad	1
$LN11@Forced_reh:

; 1735 :                 }
; 1736 : 
; 1737 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_hi$4[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1738 :                 continue;

	jmp	$LN2@Forced_reh
$LN5@Forced_reh:

; 1739 :             }
; 1740 : 
; 1741 :             // The insertion point isn't *_Bucket_hi, so search [_Bucket_lo, _Bucket_hi) for insertion point; we
; 1742 :             // go backwards to maintain sortedness when !_Standard.
; 1743 :             for (;;) {
; 1744 :                 if (_Bucket_lo == _Insert_before) {

	lea	rdx, QWORD PTR _Insert_before$1[rsp]
	mov	rcx, QWORD PTR _Bucket_lo$3[rsp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@Forced_reh

; 1745 :                     // There are no equivalent keys in the bucket, so insert it at the beginning.
; 1746 :                     // Element can't be already in position here because:
; 1747 :                     // * (for !_Standard) _Inserted_key < *_Insert_before or
; 1748 :                     // * (for _Standard) _Inserted_key != *_Insert_before
; 1749 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice

; 1750 :                     _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$3[rsp]
	mov	rcx, QWORD PTR _Inserted$[rsp]
	mov	QWORD PTR [rax], rcx

; 1751 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN12@Forced_reh:

; 1752 :                 }
; 1753 : 
; 1754 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv258[rsp], rax
	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator--
	mov	rcx, rax
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator*
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	r8, rax
	mov	rdx, QWORD PTR _Inserted_key$5[rsp]
	mov	rcx, QWORD PTR tv258[rsp]
	call	??$?RII@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_NAEBI0@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int,unsigned int>
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@Forced_reh

; 1755 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1756 :                     ++_Insert_before;

	lea	rcx, QWORD PTR _Insert_before$1[rsp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base0>::operator++

; 1757 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1758 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1759 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR _Next_inserted$2[rsp]
	mov	rdx, QWORD PTR _Inserted$[rsp]
	mov	rcx, QWORD PTR _Insert_before$1[rsp]
	call	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
	npad	1

; 1760 :                     break;

	jmp	SHORT $LN6@Forced_reh
$LN13@Forced_reh:

; 1761 :                 }
; 1762 :             }

	jmp	$LN5@Forced_reh
$LN6@Forced_reh:

; 1763 :         }

	jmp	$LN2@Forced_reh
$LN3@Forced_reh:

; 1764 : 
; 1765 :         _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$[rsp], 0

; 1766 : 
; 1767 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1768 :         _Stl_internal_check_container_invariants();
; 1769 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1770 :     }

	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
	npad	1
	add	rsp, 168				; 000000a8H
	ret	0
$LN16@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Inserted$ = 32
_Insert_before$1 = 40
_Next_inserted$2 = 48
_Bucket_lo$3 = 56
_Max_storage_buckets_log2$ = 64
_End$ = 72
_Bucket_hi$4 = 80
_Inserted_key$5 = 88
_Bucket$6 = 96
_Guard$ = 104
tv308 = 112
_Max_storage_buckets$ = 120
tv312 = 128
tv84 = 136
tv194 = 144
tv258 = 152
this$ = 176
_Buckets$ = 184
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1_Clear_guard@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Clear_guard::~_Clear_guard
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
_Old_buckets$ = 32
_Req_buckets$ = 40
$T1 = 48
this$ = 80
_For_size$ = 88
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count, COMDAT

; 1659 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1660 :         const size_type _Old_buckets = bucket_count();

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
	mov	QWORD PTR _Old_buckets$[rsp], rax

; 1661 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	rdx, QWORD PTR _For_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?_Min_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@2_KB
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Req_buckets$[rsp], rax

; 1662 :         if (_Old_buckets >= _Req_buckets) {

	mov	rax, QWORD PTR _Req_buckets$[rsp]
	cmp	QWORD PTR _Old_buckets$[rsp], rax
	jb	SHORT $LN2@Desired_gr

; 1663 :             // we already have enough buckets so there's no need to change the count
; 1664 :             return _Old_buckets;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	jmp	SHORT $LN1@Desired_gr
$LN2@Desired_gr:

; 1665 :         }
; 1666 : 
; 1667 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	QWORD PTR _Old_buckets$[rsp], 512	; 00000200H
	jae	SHORT $LN3@Desired_gr
	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	cmp	rax, QWORD PTR _Req_buckets$[rsp]
	jb	SHORT $LN3@Desired_gr

; 1668 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1669 :             return _Old_buckets * 8;

	mov	rax, QWORD PTR _Old_buckets$[rsp]
	shl	rax, 3
	jmp	SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1670 :         }
; 1671 : 
; 1672 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1673 :         return _Req_buckets;

	mov	rax, QWORD PTR _Req_buckets$[rsp]
$LN1@Desired_gr:

; 1674 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
tv65 = 32
this$ = 64
_For_size$ = 72
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets, COMDAT

; 1654 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1655 :         // returns the minimum number of buckets necessary for the elements in _List
; 1656 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	mov	rax, QWORD PTR _For_size$[rsp]
	test	rax, rax
	jl	SHORT $LN4@Min_load_f
	cvtsi2ss xmm0, rax
	movss	DWORD PTR tv65[rsp], xmm0
	jmp	SHORT $LN5@Min_load_f
$LN4@Min_load_f:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR tv65[rsp], xmm0
$LN5@Min_load_f:
	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
	movss	xmm1, DWORD PTR tv65[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	call	ceilf
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@5f000000
	jb	SHORT $LN3@Min_load_f
	subss	xmm0, DWORD PTR __real@5f000000
	comiss	xmm0, DWORD PTR __real@5f000000
	jae	SHORT $LN3@Min_load_f
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN3@Min_load_f:
	cvttss2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx

; 1657 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Newsize$ = 40
this$ = 64
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1, COMDAT

; 1630 :     void _Rehash_for_1() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1631 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1632 :         const auto _Newsize = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1633 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Desired_grow_bucket_count
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Forced_rehash
	npad	1

; 1634 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
tv71 = 32
tv77 = 36
tv70 = 40
_Oldsize$ = 48
_Newsize$ = 56
this$ = 80
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1, COMDAT

; 1624 :     bool _Check_rehash_required_1() const noexcept {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1625 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1626 :         const auto _Newsize      = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 1627 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
	movss	DWORD PTR tv70[rsp], xmm0
	mov	rax, QWORD PTR _Newsize$[rsp]
	test	rax, rax
	jl	SHORT $LN7@Check_reha
	cvtsi2ss xmm1, rax
	movss	DWORD PTR tv71[rsp], xmm1
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
	movss	DWORD PTR tv71[rsp], xmm1
$LN8@Check_reha:
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
	test	rax, rax
	jl	SHORT $LN5@Check_reha
	cvtsi2ss xmm0, rax
	jmp	SHORT $LN6@Check_reha
$LN5@Check_reha:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm1, rcx
	addss	xmm1, xmm1
	movaps	xmm0, xmm1
$LN6@Check_reha:
	movss	xmm1, DWORD PTR tv71[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR tv70[rsp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Check_reha
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN4@Check_reha
$LN3@Check_reha:
	mov	DWORD PTR tv77[rsp], 0
$LN4@Check_reha:
	movzx	eax, BYTE PTR tv77[rsp]

; 1628 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
this$ = 64
?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size, COMDAT

; 1617 :     void _Check_max_size() const {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1618 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1619 :         if (_Oldsize == _List.max_size()) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Check_max_

; 1620 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Check_max_:
$LN3@Check_max_:

; 1621 :         }
; 1622 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Check_max_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
_Bucket_lo$ = 32
_Insert_after$ = 40
_Bucket_hi$ = 48
_Bucket$ = 56
_Bucket_array$ = 64
_Head$ = 72
this$ = 96
_Hashval$ = 104
_Insert_before$ = 112
_Newnode$ = 120
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before, COMDAT

; 1586 :         const size_t _Hashval, const _Nodeptr _Insert_before, const _Nodeptr _Newnode) noexcept {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1587 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Insert_after$[rsp], rax

; 1588 :         ++_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1589 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	rax, QWORD PTR _Newnode$[rsp]
	lea	rdx, QWORD PTR _Insert_before$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>

; 1590 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	rax, QWORD PTR _Newnode$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Insert_after$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>

; 1591 :         _Insert_after->_Next  = _Newnode;

	mov	rax, QWORD PTR _Insert_after$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1592 :         _Insert_before->_Prev = _Newnode;

	mov	rax, QWORD PTR _Insert_before$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 1593 : 
; 1594 :         const auto _Head                = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$[rsp], rax

; 1595 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_array$[rsp], rax

; 1596 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR _Hashval$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bucket$[rsp], rax

; 1597 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$[rsp], rax

; 1598 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];

	mov	rax, QWORD PTR _Bucket$[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_array$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$[rsp], rax

; 1599 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Head$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@Insert_new

; 1600 :             // bucket is empty, set both
; 1601 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx

; 1602 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN3@Insert_new
$LN2@Insert_new:

; 1603 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Insert_before$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN4@Insert_new

; 1604 :             // new node is the lowest element in the bucket
; 1605 :             _Bucket_lo._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_lo$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN5@Insert_new
$LN4@Insert_new:

; 1606 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Insert_after$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN6@Insert_new

; 1607 :             // new node is the highest element in the bucket
; 1608 :             _Bucket_hi._Ptr = _Newnode;

	mov	rax, QWORD PTR _Bucket_hi$[rsp]
	mov	rcx, QWORD PTR _Newnode$[rsp]
	mov	QWORD PTR [rax], rcx
$LN6@Insert_new:
$LN5@Insert_new:
$LN3@Insert_new:

; 1609 :         }
; 1610 : 
; 1611 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1612 :         _Stl_internal_check_container_invariants();
; 1613 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1614 :         return _Newnode;

	mov	rax, QWORD PTR _Newnode$[rsp]

; 1615 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Oldsize$ = 32
_Head$1 = 40
tv132 = 48
tv134 = 56
tv130 = 64
$T2 = 72
this$ = 96
?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear, COMDAT

; 1152 :     void clear() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1153 :         // TRANSITION, ABI:
; 1154 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1155 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1156 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1157 :         //   (2) The hash function operator() may throw exceptions, and
; 1158 :         //   (3) clear() is a noexcept function.
; 1159 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1160 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Oldsize$[rsp], rax

; 1161 :         if (_Oldsize == 0) {

	cmp	QWORD PTR _Oldsize$[rsp], 0
	jne	SHORT $LN2@clear

; 1162 :             return;

	jmp	$LN1@clear
$LN2@clear:

; 1163 :         }
; 1164 : 
; 1165 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1166 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1167 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1168 :             // as many buckets as elements, remove element-by-element.
; 1169 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	cmp	rax, QWORD PTR _Oldsize$[rsp]
	jbe	SHORT $LN3@clear

; 1170 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Head$1[rsp], rax

; 1171 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	r8, QWORD PTR _Head$1[rsp]
	mov	rax, QWORD PTR _Head$1[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase
	npad	1

; 1172 :                 return;

	jmp	SHORT $LN1@clear
$LN3@clear:

; 1173 :             }
; 1174 :         }
; 1175 : 
; 1176 :         // Bulk destroy items and reset buckets
; 1177 :         _List.clear();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear
	npad	1

; 1178 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv130[rsp], rax
	mov	r8, QWORD PTR tv132[rsp]
	mov	rdx, QWORD PTR tv134[rsp]
	mov	rcx, QWORD PTR tv130[rsp]
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
	npad	1
$LN1@clear:

; 1179 :     }

	add	rsp, 88					; 00000058H
	ret	0
?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase, COMDAT

; 1028 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 1029 :         if (_First == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	jne	SHORT $LN10@Unchecked_

; 1030 :             return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	jmp	$LN1@Unchecked_
$LN10@Unchecked_:

; 1031 :         }
; 1032 : 
; 1033 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _End$[rsp], rax

; 1034 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Bucket_bounds$[rsp], rax

; 1035 :         _Range_eraser _Eraser{_List, _First};

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	r8, QWORD PTR _First$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??0_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Range_eraser
	npad	1

; 1036 :         {
; 1037 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1038 :             const auto _Predecessor = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Predecessor$12[rsp], rax

; 1039 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$6[rsp], rax

; 1040 :             // nothrow hereafter this block
; 1041 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$4[rsp], rax

; 1042 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$6[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$5[rsp], rax

; 1043 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN19@Unchecked_
	mov	BYTE PTR tv136[rsp], 1
	jmp	SHORT $LN20@Unchecked_
$LN19@Unchecked_:
	mov	BYTE PTR tv136[rsp], 0
$LN20@Unchecked_:
	movzx	eax, BYTE PTR tv136[rsp]
	mov	BYTE PTR _Update_lo$1[rsp], al

; 1044 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$10[rsp], rax
$LN2@Unchecked_:

; 1045 :             for (;;) { // remove elements until we hit the end of the bucket
; 1046 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$10[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN21@Unchecked_
	mov	BYTE PTR tv138[rsp], 1
	jmp	SHORT $LN22@Unchecked_
$LN21@Unchecked_:
	mov	BYTE PTR tv138[rsp], 0
$LN22@Unchecked_:
	movzx	eax, BYTE PTR tv138[rsp]
	mov	BYTE PTR _At_bucket_back$2[rsp], al

; 1047 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1048 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$2[rsp]
	test	eax, eax
	je	SHORT $LN11@Unchecked_

; 1049 :                     break;

	jmp	SHORT $LN3@Unchecked_
$LN11@Unchecked_:

; 1050 :                 }
; 1051 : 
; 1052 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN12@Unchecked_

; 1053 :                     if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN13@Unchecked_

; 1054 :                         // erased the bucket's prefix
; 1055 :                         _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx
$LN13@Unchecked_:

; 1056 :                     }
; 1057 : 
; 1058 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T11[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN1@Unchecked_
$LN12@Unchecked_:

; 1059 :                 }
; 1060 :             }

	jmp	$LN2@Unchecked_
$LN3@Unchecked_:

; 1061 : 
; 1062 :             if (_Update_lo) {

	movzx	eax, BYTE PTR _Update_lo$1[rsp]
	test	eax, eax
	je	SHORT $LN14@Unchecked_

; 1063 :                 // emptied the bucket
; 1064 :                 _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$4[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1065 :                 _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1066 :             } else {

	jmp	SHORT $LN5@Unchecked_
$LN14@Unchecked_:

; 1067 :                 _Bucket_hi = _Predecessor;

	mov	rax, QWORD PTR _Bucket_hi$5[rsp]
	mov	rcx, QWORD PTR _Predecessor$12[rsp]
	mov	QWORD PTR [rax], rcx
$LN5@Unchecked_:

; 1068 :             }
; 1069 :         }
; 1070 : 
; 1071 :         // hereafter we are always erasing buckets' prefixes
; 1072 :         while (_Eraser._Next != _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	je	$LN6@Unchecked_

; 1073 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	mov	rax, QWORD PTR _Eraser$[rsp+16]
	add	rax, 16
	mov	rcx, rax
	call	??$_Kfn@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAAEBIAEBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
	mov	QWORD PTR _Bucket$7[rsp], rax

; 1074 :             // nothrow hereafter this block
; 1075 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR _Bucket_lo$8[rsp], rax

; 1076 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR _Bucket$7[rsp]
	shl	rax, 1
	mov	rcx, QWORD PTR _Bucket_bounds$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8+8]
	mov	QWORD PTR _Bucket_hi$9[rsp], rax

; 1077 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_hi$13[rsp], rax
$LN7@Unchecked_:

; 1078 :             for (;;) { // remove elements until we hit the end of the bucket
; 1079 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rax, QWORD PTR _Old_hi$13[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN23@Unchecked_
	mov	BYTE PTR tv172[rsp], 1
	jmp	SHORT $LN24@Unchecked_
$LN23@Unchecked_:
	mov	BYTE PTR tv172[rsp], 0
$LN24@Unchecked_:
	movzx	eax, BYTE PTR tv172[rsp]
	mov	BYTE PTR _At_bucket_back$3[rsp], al

; 1080 :                 _Eraser._Bump_erased();

	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::_Bump_erased
	npad	1

; 1081 :                 if (_At_bucket_back) {

	movzx	eax, BYTE PTR _At_bucket_back$3[rsp]
	test	eax, eax
	je	SHORT $LN16@Unchecked_

; 1082 :                     break;

	jmp	SHORT $LN8@Unchecked_
$LN16@Unchecked_:

; 1083 :                 }
; 1084 : 
; 1085 :                 if (_Eraser._Next == _Last) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _Eraser$[rsp+16], rax
	jne	SHORT $LN17@Unchecked_

; 1086 :                     // erased the bucket's prefix
; 1087 :                     _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _Eraser$[rsp+16]
	mov	QWORD PTR [rax], rcx

; 1088 :                     return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T14[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T14[rsp]
	jmp	SHORT $LN1@Unchecked_
$LN17@Unchecked_:

; 1089 :                 }
; 1090 :             }

	jmp	SHORT $LN7@Unchecked_
$LN8@Unchecked_:

; 1091 : 
; 1092 :             // emptied the bucket
; 1093 :             _Bucket_lo = _End;

	mov	rax, QWORD PTR _Bucket_lo$8[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1094 :             _Bucket_hi = _End;

	mov	rax, QWORD PTR _Bucket_hi$9[rsp]
	mov	rcx, QWORD PTR _End$[rsp]
	mov	QWORD PTR [rax], rcx

; 1095 :         }

	jmp	$LN5@Unchecked_
$LN6@Unchecked_:

; 1096 : 
; 1097 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	QWORD PTR $T15[rsp], rax
	lea	rcx, QWORD PTR _Eraser$[rsp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	mov	rax, QWORD PTR $T15[rsp]
$LN1@Unchecked_:

; 1098 :     }

	add	rsp, 184				; 000000b8H
	ret	0
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv136 = 32
tv138 = 33
_Update_lo$1 = 34
tv172 = 35
_At_bucket_back$2 = 36
_At_bucket_back$3 = 37
_Eraser$ = 40
_Bucket_bounds$ = 64
_End$ = 72
_Bucket_lo$4 = 80
_Bucket_hi$5 = 88
_Bucket$6 = 96
_Bucket$7 = 104
_Bucket_lo$8 = 112
_Bucket_hi$9 = 120
_Old_hi$10 = 128
$T11 = 136
_Predecessor$12 = 144
_Old_hi$13 = 152
$T14 = 160
$T15 = 168
this$ = 192
_First$ = 200
_Last$ = 208
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Eraser$[rbp]
	call	??1_Range_eraser@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Range_eraser::~_Range_eraser
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Unchecked_erase@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_erase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 48
?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor, COMDAT

; 912  :     _NODISCARD float max_load_factor() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         return _Max_bucket_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR [rax]

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z
_TEXT	SEGMENT
tv73 = 32
tv76 = 40
tv78 = 48
this$ = 80
_Keyval$ = 88
?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket, COMDAT

; 856  :         noexcept(_Nothrow_hash<_Traits, key_type>) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 857  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$?RI@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBA_KAEBI@Z ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::operator()<unsigned int>
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	and	rcx, rax
	mov	rax, rcx

; 858  :     }

	add	rsp, 72					; 00000048H
	ret	0
?bucket@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBI@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count, COMDAT

; 847  :     _NODISCARD size_type bucket_count() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 848  :         return _Maxidx;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+56]

; 849  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end, COMDAT

; 812  :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 813  :         return _List._Unchecked_end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 814  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin, COMDAT

; 804  :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 805  :         return _List._Unchecked_begin();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 806  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv69 = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end, COMDAT

; 796  :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 797  :         return _List.end();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 798  :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT

; 378  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??0?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@@Z ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv74[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv82[rsp], rax
	mov	rdx, QWORD PTR _Al$[rsp]
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > ><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &,0>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+48], 7
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+56], 8

; 379  :         // construct empty hash table
; 380  :         _Max_bucket_size() = _Bucket_size;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max_bucket_size
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax], xmm0

; 381  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv128[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR tv128[rsp]
	call	?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
	mov	r8, QWORD PTR [rax]
	mov	edx, 16
	mov	rcx, QWORD PTR tv132[rsp]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::_Assign_grow
	npad	1

; 382  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 383  :         _Stl_internal_check_container_invariants();
; 384  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 385  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv69 = 32
tv74 = 40
tv82 = 48
tv128 = 56
tv132 = 64
$T1 = 72
this$ = 96
_Parg$ = 104
_Al$ = 112
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Last_prev$ = 0
_First_prev$ = 8
_Before_prev$ = 16
_Before$ = 48
_First$ = 56
_Last$ = 64
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice, COMDAT

; 468  :     static _Nodeptr _Unchecked_splice(const _Nodeptr _Before, const _Nodeptr _First, const _Nodeptr _Last) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _First_prev$[rsp], rax

; 475  :         _First_prev->_Next      = _Last;

	mov	rax, QWORD PTR _First_prev$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	mov	QWORD PTR [rax], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Last_prev$[rsp], rax

; 477  :         _Last_prev->_Next       = _Before;

	mov	rax, QWORD PTR _Last_prev$[rsp]
	mov	rcx, QWORD PTR _Before$[rsp]
	mov	QWORD PTR [rax], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Before_prev$[rsp], rax

; 479  :         _Before_prev->_Next     = _First;

	mov	rax, QWORD PTR _Before_prev$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	mov	QWORD PTR [rax], rcx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	rax, QWORD PTR _Before$[rsp]
	mov	rcx, QWORD PTR _Last_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	rax, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 484  :         _First->_Prev  = _Before_prev;

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Before_prev$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 485  : 
; 486  :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 487  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end, COMDAT

; 376  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

	mov	QWORD PTR [rsp+8], rcx

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT

; 1858 :     const _Alnode& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1859 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first

; 1860 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT

; 1854 :     _Alnode& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1855 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first

; 1856 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Proxy$ = 32
_Newhead$ = 40
_Alproxy$ = 48
_Al$ = 56
this$ = 80
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy, COMDAT

; 1839 :     void _Alloc_sentinel_and_proxy() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1840 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1841 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1842 :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1843 :         auto _Newhead = _Al.allocate(1);

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
	mov	QWORD PTR _Newhead$[rsp], rax

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	rax, QWORD PTR _Newhead$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _Newhead$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newhead$[rsp]
	mov	QWORD PTR [rax], rcx

; 1847 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
	npad	1

; 1848 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Al$ = 40
this$ = 64
?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy, COMDAT

; 1504 :     void _Tidy() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1505 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1506 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1507 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1509 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
	npad	1

; 1510 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
tv75 = 40
tv73 = 48
this$ = 80
?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear, COMDAT

; 1494 :     void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1495 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1496 :         _My_data._Orphan_non_end();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_non_end

; 1497 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	QWORD PTR tv73[rsp], rax
	mov	rdx, QWORD PTR tv75[rsp]
	mov	rcx, QWORD PTR tv73[rsp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1498 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1499 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rcx

; 1500 :         _My_data._Mysize        = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1501 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size, COMDAT

; 1197 :     _NODISCARD size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1198 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1199 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1200 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter, COMDAT

; 1126 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1127 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >
	mov	r8, rax
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1128 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Make_iter@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end, COMDAT

; 1118 :     _Unchecked_iterator _Unchecked_end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1119 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1120 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin, COMDAT

; 1110 :     _Unchecked_iterator _Unchecked_begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1111 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1112 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
__$ReturnUdt$ = 72
?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end, COMDAT

; 1102 :     _NODISCARD iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1103 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1104 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1050 :     ~list() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1051 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
	npad	1

; 1052 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1053 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1054 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1055 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1056 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
;	COMDAT ??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Al$ = 72
??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 806  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const &>
	npad	1

; 807  :         _Alloc_sentinel_and_proxy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_sentinel_and_proxy
	npad	1

; 808  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$list@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::list<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 329406144173384850			; 0492492492492492H

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 56		; 00000038H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 724  :         }
; 725  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z	; std::_Get_size_of_n<56>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 56		; 00000038H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\unordered_map
;	COMDAT ??0?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@@Z PROC ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR _Traits$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@1@@Z ENDP ; std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEBAAEBU?$hash@I@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEBAAEBU?$hash@I@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEBAAEBU?$hash@I@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEBAAEBU?$equal_to@I@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEBAAEBU?$equal_to@I@2@XZ PROC ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@I@std@@M$00@std@@QEBAAEBU?$equal_to@I@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned int>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Do_hash@?$hash@I@std@@SA_KAEBI@Z
_TEXT	SEGMENT
_Keyval$ = 48
?_Do_hash@?$hash@I@std@@SA_KAEBI@Z PROC			; std::hash<unsigned int>::_Do_hash, COMDAT

; 2355 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2356 :         return _Hash_representation(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$_Hash_representation@I@std@@YA_KAEBI@Z ; std::_Hash_representation<unsigned int>

; 2357 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_hash@?$hash@I@std@@SA_KAEBI@Z ENDP			; std::hash<unsigned int>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z PROC ; std::_Conditionally_enabled_hash<unsigned int,1>::operator(), COMDAT

; 2337 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2338 :         return hash<_Kty>::_Do_hash(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	?_Do_hash@?$hash@I@std@@SA_KAEBI@Z	; std::hash<unsigned int>::_Do_hash

; 2339 :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$_Conditionally_enabled_hash@I$00@std@@QEBA_KAEBI@Z ENDP ; std::_Conditionally_enabled_hash<unsigned int,1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??R?$equal_to@I@std@@QEBA_NAEBI0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$equal_to@I@std@@QEBA_NAEBI0@Z PROC			; std::equal_to<unsigned int>::operator(), COMDAT

; 634  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 635  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 636  :     }

	add	rsp, 24
	ret	0
??R?$equal_to@I@std@@QEBA_NAEBI0@Z ENDP			; std::equal_to<unsigned int>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size, COMDAT

; 164  :     _NODISCARD const float& _Get_max_bucket_size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 165  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 166  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size, COMDAT

; 160  :     _NODISCARD float& _Get_max_bucket_size() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 161  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 162  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
tv75 = 40
this$ = 64
??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >, COMDAT

; 137  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR $T3[rsp], xmm0
	lea	r9, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	movzx	edx, BYTE PTR $T2[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@I@std@@V?$_Compressed_pair@U?$equal_to@I@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1>::_Compressed_pair<std::hash<unsigned int>,std::_Compressed_pair<std::equal_to<unsigned int>,float,1>,1><std::_Zero_then_variadic_args_t,float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1UFunction@SDK@Core@IronMan@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1UFunction@SDK@Core@IronMan@@UEAA@XZ PROC		; IronMan::Core::SDK::UFunction::~UFunction, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1UFunction@SDK@Core@IronMan@@UEAA@XZ ENDP		; IronMan::Core::SDK::UFunction::~UFunction
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UFunction::~UFunction'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1UFunction@SDK@Core@IronMan@@UEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UFunction::~UFunction'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z
_TEXT	SEGMENT
buffer$ = 32
this$ = 64
address$ = 72
??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z PROC	; IronMan::DMAHandler::ReadCache<unsigned __int64>, COMDAT

; 241  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 242  : 			T buffer{};

	mov	QWORD PTR buffer$[rsp], 0

; 243  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 8
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 244  : 			ReadCache(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 8
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache

; 245  : 			return buffer;

	mov	rax, QWORD PTR buffer$[rsp]

; 246  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z ENDP	; IronMan::DMAHandler::ReadCache<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z
_TEXT	SEGMENT
buffer$ = 32
this$ = 80
__$ReturnUdt$ = 88
address$ = 96
??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z PROC ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::UClass::FClassBaseChain>, COMDAT

; 241  : 		{

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 242  : 			T buffer{};

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 243  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 16
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 244  : 			ReadCache(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 16
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache

; 245  : 			return buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 246  : 		}

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z ENDP ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::UClass::FClassBaseChain>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUClass@SDK@Core@IronMan@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GUClass@SDK@Core@IronMan@@UEAAPEAXI@Z PROC		; IronMan::Core::SDK::UClass::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 200				; 000000c8H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GUClass@SDK@Core@IronMan@@UEAAPEAXI@Z ENDP		; IronMan::Core::SDK::UClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z PROC	; IronMan::Core::SDK::UClass::UClass, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UClass@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z ENDP	; IronMan::Core::SDK::UClass::UClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UClass::UClass'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UClass::UClass'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z PROC	; IronMan::Core::SDK::UClass::UClass, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UClass@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z ENDP	; IronMan::Core::SDK::UClass::UClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UClass::UClass'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UClass::UClass'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1UClass@SDK@Core@IronMan@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1UClass@SDK@Core@IronMan@@UEAA@XZ PROC		; IronMan::Core::SDK::UClass::~UClass, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1UClass@SDK@Core@IronMan@@UEAA@XZ ENDP		; IronMan::Core::SDK::UClass::~UClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA PROC	; `IronMan::Core::SDK::UClass::~UClass'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1UClass@SDK@Core@IronMan@@UEAA@XZ@4HA ENDP	; `IronMan::Core::SDK::UClass::~UClass'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
c$ = 48
__$ArrayPad$ = 256
__$ReturnUdt$ = 288
?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ PROC	; IronMan::Core::SDK::UClass::StaticClass

; 379  : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T2[rsp], 0

; 380  : 		auto c = ObjectsStore().FindClass<"Class CoreUObject.Class"_hash>();

	lea	rdx, QWORD PTR c$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$FindClass@$0CNAHHPDHEJPJGCNA@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindClass<3244701931984741072>
	npad	1

; 381  : 		return c;

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	lea	rcx, QWORD PTR c$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 382  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
	int	3
?StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ ENDP	; IronMan::Core::SDK::UClass::StaticClass
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
c$ = 48
__$ArrayPad$ = 256
__$ReturnUdt$ = 288
?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA PROC ; `IronMan::Core::SDK::UClass::StaticClass'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR c$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA ENDP ; `IronMan::Core::SDK::UClass::StaticClass'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
c$ = 48
__$ArrayPad$ = 256
__$ReturnUdt$ = 288
?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA PROC ; `IronMan::Core::SDK::UClass::StaticClass'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??StaticClass@UClass@SDK@Core@IronMan@@SA?AV1234@XZ@4HA ENDP ; `IronMan::Core::SDK::UClass::StaticClass'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Class.h
;	COMDAT ??CUClass@SDK@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??CUClass@SDK@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::SDK::UClass::operator->, COMDAT

; 161  : 		auto operator->() { return this; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??CUClass@SDK@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::SDK::UClass::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Class.h
;	COMDAT ?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z
_TEXT	SEGMENT
NumParentClassBasesInChainMinusOne$ = 32
tv86 = 36
tv77 = 40
tv71 = 48
thisClassBaseChain$ = 56
parentClassBaseChain$ = 72
this$ = 112
Parent$ = 120
?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z PROC ; IronMan::Core::SDK::UClass::IsAUsingClassArray, COMDAT

; 129  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 130  : 			FClassBaseChain thisClassBaseChain = GetClassBaseChain();

	lea	rdx, QWORD PTR thisClassBaseChain$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ ; IronMan::Core::SDK::UClass::GetClassBaseChain

; 131  : 			FClassBaseChain parentClassBaseChain = Parent.GetClassBaseChain();

	lea	rdx, QWORD PTR parentClassBaseChain$[rsp]
	mov	rcx, QWORD PTR Parent$[rsp]
	call	?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ ; IronMan::Core::SDK::UClass::GetClassBaseChain

; 132  : 			int32_t NumParentClassBasesInChainMinusOne = parentClassBaseChain.NumClassBasesInChainMinusOne;

	mov	eax, DWORD PTR parentClassBaseChain$[rsp+8]
	mov	DWORD PTR NumParentClassBasesInChainMinusOne$[rsp], eax

; 133  : 			return NumParentClassBasesInChainMinusOne <= thisClassBaseChain.NumClassBasesInChainMinusOne &&

	mov	eax, DWORD PTR thisClassBaseChain$[rsp+8]
	cmp	DWORD PTR NumParentClassBasesInChainMinusOne$[rsp], eax
	jg	SHORT $LN3@IsAUsingCl
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv77[rsp], rax
	movsxd	rax, DWORD PTR NumParentClassBasesInChainMinusOne$[rsp]
	mov	rcx, QWORD PTR thisClassBaseChain$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z ; IronMan::DMAHandler::ReadCache<unsigned __int64>
	mov	QWORD PTR tv71[rsp], rax
	mov	rcx, QWORD PTR Parent$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+472
	mov	rcx, QWORD PTR tv71[rsp]
	cmp	rcx, rax
	jne	SHORT $LN3@IsAUsingCl
	mov	DWORD PTR tv86[rsp], 1
	jmp	SHORT $LN4@IsAUsingCl
$LN3@IsAUsingCl:
	mov	DWORD PTR tv86[rsp], 0
$LN4@IsAUsingCl:
	movzx	eax, BYTE PTR tv86[rsp]

; 134  : 				GetDMA().ReadCache<ptr_t>(thisClassBaseChain.ClassBaseChainArray + NumParentClassBasesInChainMinusOne * sizeof(void*))
; 135  : 				== (ptr_t)Parent.GetPtr() + g_PatternData.offset_UClassBaseChainArray;
; 136  : 		}

	add	rsp, 104				; 00000068H
	ret	0
?IsAUsingClassArray@UClass@SDK@Core@IronMan@@QEBA_NAEBV1234@@Z ENDP ; IronMan::Core::SDK::UClass::IsAUsingClassArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Class.h
;	COMDAT ?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ
_TEXT	SEGMENT
tv77 = 32
tv79 = 40
this$ = 64
__$ReturnUdt$ = 72
?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ PROC ; IronMan::Core::SDK::UClass::GetClassBaseChain, COMDAT

; 124  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 125  : 			return GetDMA().ReadCache<FClassBaseChain>((ptr_t)GetPtr() + g_PatternData.offset_UClassBaseChainArray);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+472
	mov	QWORD PTR tv77[rsp], rax
	mov	r8, QWORD PTR tv77[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv79[rsp]
	call	??$ReadCache@UFClassBaseChain@UClass@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AUFClassBaseChain@UClass@SDK@Core@1@_K@Z ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::UClass::FClassBaseChain>
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 126  : 		}

	add	rsp, 56					; 00000038H
	ret	0
?GetClassBaseChain@UClass@SDK@Core@IronMan@@QEBA?BUFClassBaseChain@1234@XZ ENDP ; IronMan::Core::SDK::UClass::GetClassBaseChain
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Class.h
;	COMDAT ??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z
_TEXT	SEGMENT
this$ = 48
object$ = 56
??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z PROC		; IronMan::Core::SDK::UClass::UClass, COMDAT

; 119  : 		UClass(void* object) :UStruct(object) {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR object$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0UStruct@SDK@Core@IronMan@@QEAA@PEAX@Z ; IronMan::Core::SDK::UStruct::UStruct
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UClass@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z ENDP		; IronMan::Core::SDK::UClass::UClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
object$ = 56
?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA PROC ; `IronMan::Core::SDK::UClass::UClass'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA ENDP ; `IronMan::Core::SDK::UClass::UClass'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z PROC		; IronMan::Core::SDK::UStruct::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 200				; 000000c8H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GUStruct@SDK@Core@IronMan@@UEAAPEAXI@Z ENDP		; IronMan::Core::SDK::UStruct::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z PROC ; IronMan::Core::SDK::UStruct::operator=, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+176]
	mov	QWORD PTR [rax+176], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	QWORD PTR [rax+184], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+192]
	mov	DWORD PTR [rax+192], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z ENDP ; IronMan::Core::SDK::UStruct::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z PROC	; IronMan::Core::SDK::UStruct::UStruct, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UStruct@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+176]
	mov	QWORD PTR [rax+176], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	QWORD PTR [rax+184], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+192]
	mov	DWORD PTR [rax+192], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z ENDP	; IronMan::Core::SDK::UStruct::UStruct
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UStruct::UStruct'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UField@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UStruct::UStruct'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z PROC	; IronMan::Core::SDK::UStruct::UStruct, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UStruct@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+176]
	mov	QWORD PTR [rax+176], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	QWORD PTR [rax+184], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+192]
	mov	DWORD PTR [rax+192], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z ENDP	; IronMan::Core::SDK::UStruct::UStruct
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UStruct::UStruct'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UField@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UStruct@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UStruct::UStruct'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1UStruct@SDK@Core@IronMan@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1UStruct@SDK@Core@IronMan@@UEAA@XZ PROC		; IronMan::Core::SDK::UStruct::~UStruct, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UField@SDK@Core@IronMan@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1UStruct@SDK@Core@IronMan@@UEAA@XZ ENDP		; IronMan::Core::SDK::UStruct::~UStruct
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UStruct::~UStruct'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UField@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1UStruct@SDK@Core@IronMan@@UEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UStruct::~UStruct'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUField@SDK@Core@IronMan@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GUField@SDK@Core@IronMan@@UEAAPEAXI@Z PROC		; IronMan::Core::SDK::UField::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UField@SDK@Core@IronMan@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 176				; 000000b0H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GUField@SDK@Core@IronMan@@UEAAPEAXI@Z ENDP		; IronMan::Core::SDK::UField::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z PROC ; IronMan::Core::SDK::UField::operator=, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+168]
	mov	QWORD PTR [rax+168], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??4UField@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z ENDP ; IronMan::Core::SDK::UField::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z PROC	; IronMan::Core::SDK::UField::UField, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UField@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+168]
	mov	QWORD PTR [rax+168], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z ENDP	; IronMan::Core::SDK::UField::UField
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UField::UField'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UField::UField'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z PROC	; IronMan::Core::SDK::UField::UField, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UField@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+168]
	mov	QWORD PTR [rax+168], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z ENDP	; IronMan::Core::SDK::UField::UField
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UField::UField'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UField@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UField::UField'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1UField@SDK@Core@IronMan@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1UField@SDK@Core@IronMan@@UEAA@XZ PROC		; IronMan::Core::SDK::UField::~UField, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1UField@SDK@Core@IronMan@@UEAA@XZ ENDP		; IronMan::Core::SDK::UField::~UField
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA PROC	; `IronMan::Core::SDK::UField::~UField'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1UField@SDK@Core@IronMan@@UEAA@XZ@4HA ENDP	; `IronMan::Core::SDK::UField::~UField'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
tv75 = 32
this$ = 64
_Keyval$ = 72
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>, COMDAT

; 148  :     _NODISCARD size_t operator()(const _Keyty& _Keyval) const noexcept(_Nothrow_hash<_Hasher, _Keyty>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 149  :         // hash _Keyval to size_t value
; 150  :         return static_cast<size_t>(_Mypair._Get_first()(_Keyval));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()

; 151  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$?R_K@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBA_KAEB_K@Z ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::operator()<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z
_TEXT	SEGMENT
buffer$ = 32
this$ = 64
address$ = 72
??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z PROC		; IronMan::DMAHandler::Read<unsigned __int64>, COMDAT

; 187  : 		{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 188  : 			T buffer{};

	mov	QWORD PTR buffer$[rsp], 0

; 189  : 			memset(&buffer, 0, sizeof(T));

	mov	r8d, 8
	xor	edx, edx
	lea	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 190  : 			Read(address, reinterpret_cast<ptr_t>(&buffer), sizeof(T));

	mov	r9d, 8
	lea	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR address$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read

; 191  : 			return buffer;

	mov	rax, QWORD PTR buffer$[rsp]

; 192  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z ENDP		; IronMan::DMAHandler::Read<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ PROC	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK'', COMDAT

; 157  : 	static const VectorRegister QINV_SIGN_MASK = MakeVectorRegister(-1.f, -1.f, -1.f, 1.f);

	sub	rsp, 40					; 00000028H
	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@bf800000
	movss	xmm1, DWORD PTR __real@bf800000
	movss	xmm0, DWORD PTR __real@bf800000
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?QINV_SIGN_MASK@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EQINV_SIGN_MASK@Math@Core@IronMan@@YAXXZ ENDP	; IronMan::Core::Math::`dynamic initializer for 'QINV_SIGN_MASK''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ??__EXYZMask@Math@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__EXYZMask@Math@Core@IronMan@@YAXXZ PROC		; IronMan::Core::Math::`dynamic initializer for 'XYZMask'', COMDAT

; 155  : 	static const VectorRegister XYZMask = MakeVectorRegister((uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0xffffffff, (uint32_t)0x00000000);

	sub	rsp, 40					; 00000028H
	xor	r9d, r9d
	mov	r8d, -1					; ffffffffH
	mov	edx, -1					; ffffffffH
	mov	ecx, -1					; ffffffffH
	call	?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ; IronMan::Core::Math::MakeVectorRegister
	movaps	XMMWORD PTR ?XYZMask@Math@Core@IronMan@@3T__m128@@B, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__EXYZMask@Math@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::Math::`dynamic initializer for 'XYZMask''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z
_TEXT	SEGMENT
$T1 = 0
X$ = 32
Y$ = 40
Z$ = 48
W$ = 56
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 135  : 	{

$LN3:
	movss	DWORD PTR [rsp+32], xmm3
	movss	DWORD PTR [rsp+24], xmm2
	movss	DWORD PTR [rsp+16], xmm1
	movss	DWORD PTR [rsp+8], xmm0
	sub	rsp, 24

; 136  : 		return _mm_setr_ps(X, Y, Z, W);

	movss	xmm0, DWORD PTR W$[rsp]
	movss	xmm1, DWORD PTR Z$[rsp]
	movss	xmm2, DWORD PTR Y$[rsp]
	movss	xmm3, DWORD PTR X$[rsp]
	unpcklps xmm1, xmm0
	unpcklps xmm3, xmm2
	movaps	xmm0, xmm3
	movlhps	xmm0, xmm1
	movaps	XMMWORD PTR $T1[rsp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[rsp]

; 137  : 	}

	add	rsp, 24
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@MMMM@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\Math\Vector.hpp
;	COMDAT ?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z
_TEXT	SEGMENT
$T1 = 0
Tmp$ = 16
__$ArrayPad$ = 32
X$ = 64
Y$ = 72
Z$ = 80
W$ = 88
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z PROC ; IronMan::Core::Math::MakeVectorRegister, COMDAT

; 119  : 	{

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 120  : 		union { VectorRegister v; VectorRegisterInt i; } Tmp;
; 121  : 		Tmp.i = _mm_setr_epi32(X, Y, Z, W);

	movd	xmm0, DWORD PTR W$[rsp]
	movd	xmm1, DWORD PTR Z$[rsp]
	movd	xmm2, DWORD PTR Y$[rsp]
	movd	xmm3, DWORD PTR X$[rsp]
	punpckldq xmm1, xmm0
	punpckldq xmm3, xmm2
	movdqa	xmm0, xmm3
	punpcklqdq xmm0, xmm1
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	movdqa	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR Tmp$[rsp], xmm0

; 122  : 		return Tmp.v;

	movaps	xmm0, XMMWORD PTR Tmp$[rsp]

; 123  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?MakeVectorRegister@Math@Core@IronMan@@YA?AT__m128@@IIII@Z ENDP ; IronMan::Core::Math::MakeVectorRegister
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
ObjectItem$2 = 40
this$ = 80
?Get@FWeakObjectPtr@SDK@Core@IronMan@@QEBAPEAXXZ PROC	; IronMan::Core::SDK::FWeakObjectPtr::Get

; 407  : 	{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 408  : 		if (IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::FWeakObjectPtr::IsValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Get

; 409  : 		{
; 410  : 			auto ObjectItem = ObjectsStore().GetItemById(ObjectIndex);

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	r8, rax
	lea	rdx, QWORD PTR ObjectItem$2[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?GetItemById@ObjectsStore@SDK@Core@IronMan@@QEBA?AVFUObjectItem@234@_K@Z ; IronMan::Core::SDK::ObjectsStore::GetItemById
	npad	1

; 411  : 			if (ObjectItem.Object)

	cmp	QWORD PTR ObjectItem$2[rsp], 0
	je	SHORT $LN3@Get

; 412  : 			{
; 413  : 				return ObjectItem.Object;

	mov	rax, QWORD PTR ObjectItem$2[rsp]
	jmp	SHORT $LN1@Get
$LN3@Get:
$LN2@Get:

; 414  : 			}
; 415  : 		}
; 416  : 		return nullptr;

	xor	eax, eax
$LN1@Get:

; 417  : 	}

	add	rsp, 72					; 00000048H
	ret	0
?Get@FWeakObjectPtr@SDK@Core@IronMan@@QEBAPEAXXZ ENDP	; IronMan::Core::SDK::FWeakObjectPtr::Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
tv87 = 36
ObjectItem$ = 40
this$ = 80
?IsValid@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NXZ PROC	; IronMan::Core::SDK::FWeakObjectPtr::IsValid

; 385  : 	{

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 386  : 		if (ObjectSerialNumber == 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN2@IsValid

; 387  : 		{
; 388  : 			return false;

	xor	al, al
	jmp	$LN1@IsValid
$LN2@IsValid:

; 389  : 		}
; 390  : 		if (ObjectIndex < 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jge	SHORT $LN3@IsValid

; 391  : 		{
; 392  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsValid
$LN3@IsValid:

; 393  : 		}
; 394  : 		auto ObjectItem = ObjectsStore().GetItemById(ObjectIndex);

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax]
	mov	r8, rax
	lea	rdx, QWORD PTR ObjectItem$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?GetItemById@ObjectsStore@SDK@Core@IronMan@@QEBA?AVFUObjectItem@234@_K@Z ; IronMan::Core::SDK::ObjectsStore::GetItemById
	npad	1

; 395  : 		if (!ObjectItem.Object)

	cmp	QWORD PTR ObjectItem$[rsp], 0
	jne	SHORT $LN4@IsValid

; 396  : 		{
; 397  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsValid
$LN4@IsValid:

; 398  : 		}
; 399  : 		if (!SerialNumbersMatch(&ObjectItem))

	lea	rdx, QWORD PTR ObjectItem$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z ; IronMan::Core::SDK::FWeakObjectPtr::SerialNumbersMatch
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@IsValid

; 400  : 		{
; 401  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsValid
$LN5@IsValid:

; 402  : 		}
; 403  : 		return !(ObjectItem.IsUnreachable() || ObjectItem.IsPendingKill());

	lea	rcx, QWORD PTR ObjectItem$[rsp]
	call	?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::FUObjectItem::IsUnreachable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@IsValid
	lea	rcx, QWORD PTR ObjectItem$[rsp]
	call	?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::FUObjectItem::IsPendingKill
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@IsValid
	mov	DWORD PTR tv87[rsp], 1
	jmp	SHORT $LN8@IsValid
$LN7@IsValid:
	mov	DWORD PTR tv87[rsp], 0
$LN8@IsValid:
	movzx	eax, BYTE PTR tv87[rsp]
$LN1@IsValid:

; 404  : 	}

	add	rsp, 72					; 00000048H
	ret	0
?IsValid@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NXZ ENDP	; IronMan::Core::SDK::FWeakObjectPtr::IsValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
ObjectItem$ = 40
?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z PROC ; IronMan::Core::SDK::FWeakObjectPtr::SerialNumbersMatch, COMDAT

; 666  : 		{

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 667  : 			return ObjectItem->SerialNumber == ObjectSerialNumber;

	mov	rax, QWORD PTR ObjectItem$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	cmp	DWORD PTR [rax+16], ecx
	jne	SHORT $LN3@SerialNumb
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@SerialNumb
$LN3@SerialNumb:
	mov	DWORD PTR tv67[rsp], 0
$LN4@SerialNumb:
	movzx	eax, BYTE PTR tv67[rsp]

; 668  : 		}

	add	rsp, 24
	ret	0
?SerialNumbersMatch@FWeakObjectPtr@SDK@Core@IronMan@@QEBA_NPEAVFUObjectItem@234@@Z ENDP ; IronMan::Core::SDK::FWeakObjectPtr::SerialNumbersMatch
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUObject@SDK@Core@IronMan@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GUObject@SDK@Core@IronMan@@UEAAPEAXI@Z PROC		; IronMan::Core::SDK::UObject::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 168				; 000000a8H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GUObject@SDK@Core@IronMan@@UEAAPEAXI@Z ENDP		; IronMan::Core::SDK::UObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z PROC ; IronMan::Core::SDK::UObject::operator=, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax+12], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx
	mov	rax, QWORD PTR __that$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+56], ecx
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 64					; 00000040H
	mov	rdx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 96					; 00000060H
	mov	rdx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 128				; 00000080H
	mov	rdx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+160]
	mov	BYTE PTR [rax+160], cl
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+161]
	mov	BYTE PTR [rax+161], cl
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+162]
	mov	BYTE PTR [rax+162], cl
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+163]
	mov	BYTE PTR [rax+163], cl
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z ENDP ; IronMan::Core::SDK::UObject::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z
_TEXT	SEGMENT
tv88 = 32
tv129 = 40
tv138 = 48
this$ = 80
__that$ = 88
??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z PROC	; IronMan::Core::SDK::UObject::UObject, COMDAT
$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UObject@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax+12], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx
	mov	rax, QWORD PTR __that$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+56], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR tv88[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv88[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	QWORD PTR tv129[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 96					; 00000060H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv129[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv138[rsp], rax
	mov	rax, QWORD PTR __that$[rsp]
	add	rax, 128				; 00000080H
	mov	rdx, rax
	mov	rcx, QWORD PTR tv138[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+160]
	mov	BYTE PTR [rax+160], cl
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+161]
	mov	BYTE PTR [rax+161], cl
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+162]
	mov	BYTE PTR [rax+162], cl
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	movzx	ecx, BYTE PTR [rcx+163]
	mov	BYTE PTR [rax+163], cl
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z ENDP	; IronMan::Core::SDK::UObject::UObject
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv88 = 32
tv129 = 40
tv138 = 48
this$ = 80
__that$ = 88
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv88 = 32
tv129 = 40
tv138 = 48
this$ = 80
__that$ = 88
?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 96					; 00000060H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv88 = 32
tv129 = 40
tv138 = 48
this$ = 80
__that$ = 88
?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEBV0123@@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ
_TEXT	SEGMENT
this$ = 48
?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ PROC	; IronMan::Core::SDK::UObject::GetPtr, COMDAT

; 604  : 		{

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 605  : 			if (!Utils::IsSafeReadPtr((void*)this, 8))

	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetPtr

; 606  : 				return m_self;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	jmp	SHORT $LN1@GetPtr
$LN2@GetPtr:

; 607  : 			return nullptr;

	xor	eax, eax
$LN1@GetPtr:

; 608  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ENDP	; IronMan::Core::SDK::UObject::GetPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
c$ = 48
__$ArrayPad$ = 256
__$ReturnUdt$ = 288
?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ PROC ; IronMan::Core::SDK::UObject::StaticClass

; 373  : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 280				; 00000118H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T2[rsp], 0

; 374  : 		auto c = ObjectsStore().FindClass<"Class CoreUObject.Object"_hash>();

	lea	rdx, QWORD PTR c$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$FindClass@$0?DMEFBHGBNHOJJJDB@@ObjectsStore@SDK@Core@IronMan@@QEBA?AVUClass@123@XZ ; IronMan::Core::SDK::ObjectsStore::FindClass<-4342903124670388529>
	npad	1

; 375  : 		return c;

	lea	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@$$QEAV0123@@Z
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	lea	rcx, QWORD PTR c$[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 376  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 280				; 00000118H
	ret	0
	int	3
?StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ ENDP ; IronMan::Core::SDK::UObject::StaticClass
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
c$ = 48
__$ArrayPad$ = 256
__$ReturnUdt$ = 288
?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::StaticClass'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR c$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::StaticClass'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
c$ = 48
__$ArrayPad$ = 256
__$ReturnUdt$ = 288
?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::StaticClass'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$1
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN5@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??StaticClass@UObject@SDK@Core@IronMan@@SA?AVUClass@234@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::StaticClass'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??BUObject@SDK@Core@IronMan@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 48
??BUObject@SDK@Core@IronMan@@QEAA_NXZ PROC		; IronMan::Core::SDK::UObject::operator bool, COMDAT

; 592  : 		operator bool() { return IsValid(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	add	rsp, 40					; 00000028H
	ret	0
??BUObject@SDK@Core@IronMan@@QEAA_NXZ ENDP		; IronMan::Core::SDK::UObject::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ??CUObject@SDK@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??CUObject@SDK@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::SDK::UObject::operator->, COMDAT

; 591  : 		auto operator->() { return this; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??CUObject@SDK@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::SDK::UObject::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
this$ = 48
function$ = 56
parms$ = 64
?ProcessEvent@UObject@SDK@Core@IronMan@@QEAAXVUFunction@234@PEAX@Z PROC ; IronMan::Core::SDK::UObject::ProcessEvent

; 369  : 	{

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 370  : 	}

	mov	rcx, QWORD PTR function$[rsp]
	call	??1UFunction@SDK@Core@IronMan@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
?ProcessEvent@UObject@SDK@Core@IronMan@@QEAAXVUFunction@234@PEAX@Z ENDP ; IronMan::Core::SDK::UObject::ProcessEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
tv94 = 32
this$ = 64
Type$ = 72
?SetIsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z PROC ; IronMan::Core::SDK::UObject::SetIsA

; 335  : 	{

$LN26:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 336  : 		if (!IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@SetIsA

; 337  : 			return false;

	xor	al, al
	jmp	$LN1@SetIsA
$LN2@SetIsA:

; 338  : 
; 339  : 		if (!bCached || m_type == UObjectType::EUnknown)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+160]
	test	eax, eax
	je	SHORT $LN4@SetIsA
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+56], 10
	jne	$LN3@SetIsA
$LN4@SetIsA:

; 340  : 		{
; 341  : 			if (Type == UObjectType::EPlayer)

	cmp	DWORD PTR Type$[rsp], 0
	jne	SHORT $LN5@SetIsA

; 342  : 				m_type = UObjectType::EPlayer;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 0
	jmp	$LN6@SetIsA
$LN5@SetIsA:

; 343  : 			else if (Type == UObjectType::EVehicle)

	cmp	DWORD PTR Type$[rsp], 1
	jne	SHORT $LN7@SetIsA

; 344  : 				m_type = UObjectType::EVehicle;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 1
	jmp	$LN8@SetIsA
$LN7@SetIsA:

; 345  : 			else if (Type == UObjectType::EBoat)

	cmp	DWORD PTR Type$[rsp], 2
	jne	SHORT $LN9@SetIsA

; 346  : 				m_type = UObjectType::EBoat;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 2
	jmp	$LN10@SetIsA
$LN9@SetIsA:

; 347  : 			else if (Type == UObjectType::EItemGroup)

	cmp	DWORD PTR Type$[rsp], 3
	jne	SHORT $LN11@SetIsA

; 348  : 				m_type = UObjectType::EItemGroup;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 3
	jmp	SHORT $LN12@SetIsA
$LN11@SetIsA:

; 349  : 			else if (Type == UObjectType::EItem)

	cmp	DWORD PTR Type$[rsp], 4
	jne	SHORT $LN13@SetIsA

; 350  : 				m_type = UObjectType::EItem;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 4
	jmp	SHORT $LN14@SetIsA
$LN13@SetIsA:

; 351  : 			else if (Type == UObjectType::EDeathBox)

	cmp	DWORD PTR Type$[rsp], 5
	jne	SHORT $LN15@SetIsA

; 352  : 				m_type = UObjectType::EDeathBox;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 5
	jmp	SHORT $LN16@SetIsA
$LN15@SetIsA:

; 353  : 			else if (Type == UObjectType::EAirdrop)

	cmp	DWORD PTR Type$[rsp], 6
	jne	SHORT $LN17@SetIsA

; 354  : 				m_type = UObjectType::EAirdrop;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 6
	jmp	SHORT $LN18@SetIsA
$LN17@SetIsA:

; 355  : 			else if (Type == UObjectType::EProjectile)

	cmp	DWORD PTR Type$[rsp], 7
	jne	SHORT $LN19@SetIsA

; 356  : 				m_type = UObjectType::EProjectile;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 7
	jmp	SHORT $LN20@SetIsA
$LN19@SetIsA:

; 357  : 			else if (Type == UObjectType::EDroppedItem)

	cmp	DWORD PTR Type$[rsp], 8
	jne	SHORT $LN21@SetIsA

; 358  : 				m_type = UObjectType::EDroppedItem;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 8
	jmp	SHORT $LN22@SetIsA
$LN21@SetIsA:

; 359  : 			else
; 360  : 				return false;

	xor	al, al
	jmp	SHORT $LN1@SetIsA
$LN22@SetIsA:
$LN20@SetIsA:
$LN18@SetIsA:
$LN16@SetIsA:
$LN14@SetIsA:
$LN12@SetIsA:
$LN10@SetIsA:
$LN8@SetIsA:
$LN6@SetIsA:

; 361  : 
; 362  : 			bCached = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+160], 1

; 363  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@SetIsA
$LN3@SetIsA:

; 364  : 		}
; 365  : 		return m_type == Type;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR Type$[rsp]
	cmp	DWORD PTR [rax+56], ecx
	jne	SHORT $LN24@SetIsA
	mov	DWORD PTR tv94[rsp], 1
	jmp	SHORT $LN25@SetIsA
$LN24@SetIsA:
	mov	DWORD PTR tv94[rsp], 0
$LN25@SetIsA:
	movzx	eax, BYTE PTR tv94[rsp]
$LN1@SetIsA:

; 366  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?SetIsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z ENDP ; IronMan::Core::SDK::UObject::SetIsA
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
tv162 = 32
this$ = 64
Type$ = 72
?IsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z PROC ; IronMan::Core::SDK::UObject::IsA

; 301  : 	{

$LN26:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 302  : 		if (!IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsA

; 303  : 			return false;

	xor	al, al
	jmp	$LN1@IsA
$LN2@IsA:

; 304  : 
; 305  : 		if (!bCached || m_type == UObjectType::EUnknown)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+160]
	test	eax, eax
	je	SHORT $LN4@IsA
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+56], 10
	jne	$LN3@IsA
$LN4@IsA:

; 306  : 		{
; 307  : 			if (Type == UObjectType::EPlayer && IsA<ATslCharacter>())

	cmp	DWORD PTR Type$[rsp], 0
	jne	SHORT $LN5@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VATslCharacter@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslCharacter>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@IsA

; 308  : 				m_type = UObjectType::EPlayer;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 0
	jmp	$LN6@IsA
$LN5@IsA:

; 309  : 			else if (Type == UObjectType::EVehicle && IsA<ATslWheeledVehicle>())

	cmp	DWORD PTR Type$[rsp], 1
	jne	SHORT $LN7@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VATslWheeledVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslWheeledVehicle>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@IsA

; 310  : 				m_type = UObjectType::EVehicle;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 1
	jmp	$LN8@IsA
$LN7@IsA:

; 311  : 			else if (Type == UObjectType::EBoat && IsA<ATslFloatingVehicle>())

	cmp	DWORD PTR Type$[rsp], 2
	jne	SHORT $LN9@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VATslFloatingVehicle@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslFloatingVehicle>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@IsA

; 312  : 				m_type = UObjectType::EBoat;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 2
	jmp	$LN10@IsA
$LN9@IsA:

; 313  : 			else if (Type == UObjectType::EItemGroup && IsA<ADroppedItemGroup>())

	cmp	DWORD PTR Type$[rsp], 3
	jne	SHORT $LN11@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VADroppedItemGroup@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItemGroup>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@IsA

; 314  : 				m_type = UObjectType::EItemGroup;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 3
	jmp	$LN12@IsA
$LN11@IsA:

; 315  : 			else if (Type == UObjectType::EItem && IsA<ADroppedItem>())

	cmp	DWORD PTR Type$[rsp], 4
	jne	SHORT $LN13@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VADroppedItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ADroppedItem>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@IsA

; 316  : 				m_type = UObjectType::EItem;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 4
	jmp	$LN14@IsA
$LN13@IsA:

; 317  : 			else if (Type == UObjectType::EDeathBox && IsA<AFloorSnapItemPackage>())

	cmp	DWORD PTR Type$[rsp], 5
	jne	SHORT $LN15@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VAFloorSnapItemPackage@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::AFloorSnapItemPackage>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@IsA

; 318  : 				m_type = UObjectType::EDeathBox;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 5
	jmp	SHORT $LN16@IsA
$LN15@IsA:

; 319  : 			else if (Type == UObjectType::EAirdrop && IsA<ACarePackageItem>())

	cmp	DWORD PTR Type$[rsp], 6
	jne	SHORT $LN17@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VACarePackageItem@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ACarePackageItem>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@IsA

; 320  : 				m_type = UObjectType::EAirdrop;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 6
	jmp	SHORT $LN18@IsA
$LN17@IsA:

; 321  : 			else if (Type == UObjectType::EProjectile && IsA<ATslProjectile>())

	cmp	DWORD PTR Type$[rsp], 7
	jne	SHORT $LN19@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VATslProjectile@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::ATslProjectile>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@IsA

; 322  : 				m_type = UObjectType::EProjectile;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 7
	jmp	SHORT $LN20@IsA
$LN19@IsA:

; 323  : 			else if (Type == UObjectType::EDroppedItem && IsA<UDroppedItemInteractionComponent>())

	cmp	DWORD PTR Type$[rsp], 8
	jne	SHORT $LN21@IsA
	mov	rcx, QWORD PTR this$[rsp]
	call	??$IsA@VUDroppedItemInteractionComponent@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEAA_NXZ ; IronMan::Core::SDK::UObject::IsA<IronMan::Core::SDK::UDroppedItemInteractionComponent>
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@IsA

; 324  : 				m_type = UObjectType::EDroppedItem;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 8
	jmp	SHORT $LN22@IsA
$LN21@IsA:

; 325  : 			else
; 326  : 				return false;

	xor	al, al
	jmp	SHORT $LN1@IsA
$LN22@IsA:
$LN20@IsA:
$LN18@IsA:
$LN16@IsA:
$LN14@IsA:
$LN12@IsA:
$LN10@IsA:
$LN8@IsA:
$LN6@IsA:

; 327  : 
; 328  : 			bCached = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+160], 1

; 329  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsA
$LN3@IsA:

; 330  : 		}
; 331  : 		return m_type == Type;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR Type$[rsp]
	cmp	DWORD PTR [rax+56], ecx
	jne	SHORT $LN24@IsA
	mov	DWORD PTR tv162[rsp], 1
	jmp	SHORT $LN25@IsA
$LN24@IsA:
	mov	DWORD PTR tv162[rsp], 0
$LN25@IsA:
	movzx	eax, BYTE PTR tv162[rsp]
$LN1@IsA:

; 332  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?IsA@UObject@SDK@Core@IronMan@@QEAA_NW4UObjectType@234@@Z ENDP ; IronMan::Core::SDK::UObject::IsA
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; IronMan::Core::SDK::UObject::GetFullName

; 263  : 	{

$LN29:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1400				; 00000578H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 264  : 		if (!IsValid() || !GetClass()->IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@GetFullNam
	lea	rdx, QWORD PTR $T16[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ ; IronMan::Core::SDK::UObject::GetClass
	mov	QWORD PTR tv315[rsp], rax
	mov	rax, QWORD PTR tv315[rsp]
	mov	QWORD PTR tv283[rsp], rax
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rcx, QWORD PTR tv283[rsp]
	call	??CUClass@SDK@Core@IronMan@@QEAA@XZ	; IronMan::Core::SDK::UClass::operator->
	mov	rcx, rax
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@GetFullNam
	mov	DWORD PTR tv83[rsp], 0
	jmp	SHORT $LN13@GetFullNam
$LN12@GetFullNam:
	mov	DWORD PTR tv83[rsp], 1
$LN13@GetFullNam:
	movzx	eax, BYTE PTR tv83[rsp]
	mov	BYTE PTR $T2[rsp], al
	mov	eax, DWORD PTR $T1[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN16@GetFullNam
	and	DWORD PTR $T1[rsp], -2
	lea	rcx, QWORD PTR $T16[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	npad	1
$LN16@GetFullNam:
	movzx	eax, BYTE PTR $T2[rsp]
	test	eax, eax
	je	SHORT $LN5@GetFullNam

; 265  : 			return ("1:(null)");

	lea	rdx, OFFSET FLAT:??_C@_08LPFEODAP@1?3?$CInull?$CJ@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 2
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetFullNam
$LN5@GetFullNam:

; 266  : 
; 267  : 		if (!m_fullName.empty())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@GetFullNam

; 268  : 			return m_fullName;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 2
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetFullNam
$LN6@GetFullNam:

; 269  : 
; 270  : 		std::string temp;

	lea	rcx, QWORD PTR temp$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 271  : 
; 272  : 		auto objectOuter = GetOuter();

	lea	rdx, QWORD PTR objectOuter$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ ; IronMan::Core::SDK::UObject::GetOuter
	npad	1

; 273  : 		if (objectOuter->IsValid())

	lea	rcx, QWORD PTR objectOuter$[rsp]
	call	??CUObject@SDK@Core@IronMan@@QEAA@XZ	; IronMan::Core::SDK::UObject::operator->
	mov	rcx, rax
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	je	$LN7@GetFullNam

; 274  : 		{
; 275  : 			auto findResult = CacheOuterName.find((ptr_t)objectOuter->GetPtr());

	lea	rcx, QWORD PTR objectOuter$[rsp]
	call	??CUObject@SDK@Core@IronMan@@QEAA@XZ	; IronMan::Core::SDK::UObject::operator->
	mov	rcx, rax
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	mov	QWORD PTR $T5[rsp], rax
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR findResult$4[rsp]
	lea	rcx, OFFSET FLAT:?CacheOuterName@SDK@Core@IronMan@@3V?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??$find@X@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>
	npad	1

; 276  : 			if (findResult == CacheOuterName.end())

	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, OFFSET FLAT:?CacheOuterName@SDK@Core@IronMan@@3V?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	?end@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR findResult$4[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	$LN8@GetFullNam

; 277  : 			{
; 278  : 				int i = 0;

	mov	DWORD PTR i$3[rsp], 0

; 279  : 				for (auto outer = GetOuter(); outer.IsValid(); outer = outer.GetOuter())

	lea	rdx, QWORD PTR outer$14[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ ; IronMan::Core::SDK::UObject::GetOuter
	npad	1
	jmp	SHORT $LN4@GetFullNam
$LN2@GetFullNam:
	lea	rdx, QWORD PTR $T15[rsp]
	lea	rcx, QWORD PTR outer$14[rsp]
	call	?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ ; IronMan::Core::SDK::UObject::GetOuter
	mov	QWORD PTR tv178[rsp], rax
	mov	rax, QWORD PTR tv178[rsp]
	mov	QWORD PTR tv295[rsp], rax
	mov	rdx, QWORD PTR tv295[rsp]
	lea	rcx, QWORD PTR outer$14[rsp]
	call	??4UObject@SDK@Core@IronMan@@QEAAAEAV0123@AEBV0123@@Z
	npad	1
	lea	rcx, QWORD PTR $T15[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	npad	1
$LN4@GetFullNam:
	lea	rcx, QWORD PTR outer$14[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	je	$LN3@GetFullNam

; 280  : 				{
; 281  : 					if (i++ > 10)

	mov	eax, DWORD PTR i$3[rsp]
	mov	DWORD PTR tv194[rsp], eax
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
	cmp	DWORD PTR tv194[rsp], 10
	jle	SHORT $LN10@GetFullNam

; 282  : 						return ("2:(null)");

	lea	rdx, OFFSET FLAT:??_C@_08IGNJNPMK@2?3?$CInull?$CJ@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 2
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR outer$14[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	npad	1
	lea	rcx, QWORD PTR objectOuter$[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	npad	1
	lea	rcx, QWORD PTR temp$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetFullNam
$LN10@GetFullNam:

; 283  : 					temp = outer.GetName() + "." + temp;

	mov	r9b, 1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR outer$14[rsp]
	call	?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z ; IronMan::Core::SDK::UObject::GetName
	mov	QWORD PTR tv196[rsp], rax
	mov	rax, QWORD PTR tv196[rsp]
	mov	QWORD PTR tv301[rsp], rax
	lea	r8, OFFSET FLAT:??_C@_01LFCBOECM@?4@
	mov	rdx, QWORD PTR tv301[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv137[rsp], rax
	mov	rax, QWORD PTR tv137[rsp]
	mov	QWORD PTR tv303[rsp], rax
	lea	r8, QWORD PTR temp$[rsp]
	mov	rdx, QWORD PTR tv303[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR tv134[rsp]
	mov	QWORD PTR tv305[rsp], rax
	mov	rdx, QWORD PTR tv305[rsp]
	lea	rcx, QWORD PTR temp$[rsp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	lea	rcx, QWORD PTR $T9[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T10[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T11[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	$LN2@GetFullNam
$LN3@GetFullNam:

; 284  : 				}

	lea	rcx, QWORD PTR outer$14[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	npad	1

; 285  : 				CacheOuterName.emplace((ptr_t)objectOuter->GetPtr(), temp);

	lea	rcx, QWORD PTR objectOuter$[rsp]
	call	??CUObject@SDK@Core@IronMan@@QEAA@XZ	; IronMan::Core::SDK::UObject::operator->
	mov	rcx, rax
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	mov	QWORD PTR $T6[rsp], rax
	lea	r9, QWORD PTR temp$[rsp]
	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, OFFSET FLAT:?CacheOuterName@SDK@Core@IronMan@@3V?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??$emplace@_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	npad	1

; 286  : 			}

	jmp	SHORT $LN7@GetFullNam
$LN8@GetFullNam:

; 287  : 			else
; 288  : 				temp = findResult->second;

	lea	rcx, QWORD PTR findResult$4[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR temp$[rsp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
$LN7@GetFullNam:

; 289  : 		}
; 290  : 
; 291  : 
; 292  : 
; 293  : 		m_fullName = GetClass().GetName();

	lea	rdx, QWORD PTR $T17[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ ; IronMan::Core::SDK::UObject::GetClass
	mov	QWORD PTR tv129[rsp], rax
	mov	rax, QWORD PTR tv129[rsp]
	mov	QWORD PTR tv307[rsp], rax
	mov	rax, QWORD PTR tv307[rsp]
	mov	QWORD PTR tv255[rsp], rax
	mov	r9b, 1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, QWORD PTR tv255[rsp]
	call	?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z ; IronMan::Core::SDK::UObject::GetName
	mov	QWORD PTR tv88[rsp], rax
	mov	rax, QWORD PTR tv88[rsp]
	mov	QWORD PTR tv309[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rdx, QWORD PTR tv309[rsp]
	mov	rcx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	lea	rcx, QWORD PTR $T12[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T17[rsp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	npad	1

; 294  : 		m_fullName += " ";

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5@
	mov	rcx, rax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 295  : 		m_fullName += temp;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	lea	rdx, QWORD PTR temp$[rsp]
	mov	rcx, rax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1

; 296  : 		m_fullName += GetName(false);

	mov	r9b, 1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T13[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z ; IronMan::Core::SDK::UObject::GetName
	mov	QWORD PTR tv316[rsp], rax
	mov	rax, QWORD PTR tv316[rsp]
	mov	QWORD PTR tv311[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rdx, QWORD PTR tv311[rsp]
	mov	rcx, rax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T13[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 297  : 		return m_fullName;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 2
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR objectOuter$[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	npad	1
	lea	rcx, QWORD PTR temp$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetFullNam:

; 298  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1400				; 00000578H
	ret	0
	int	3
?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; IronMan::Core::SDK::UObject::GetFullName
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN15@dtor$0
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T16[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN15@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN18@dtor$1
	and	DWORD PTR $T1[rbp], -3
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN18@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR temp$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR objectOuter$[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR outer$14[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T15[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T11[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T10[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T9[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T17[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T12[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$3 = 40
tv83 = 44
tv194 = 48
findResult$4 = 56
tv315 = 64
tv283 = 72
$T5 = 80
tv178 = 88
tv295 = 96
tv196 = 104
tv301 = 112
tv137 = 120
tv303 = 128
tv134 = 136
tv305 = 144
$T6 = 152
tv129 = 160
tv307 = 168
tv255 = 176
tv88 = 184
tv309 = 192
tv316 = 200
tv311 = 208
$T7 = 216
$T8 = 224
temp$ = 240
$T9 = 272
$T10 = 304
$T11 = 336
$T12 = 368
$T13 = 400
outer$14 = 432
objectOuter$ = 608
$T15 = 784
$T16 = 960
$T17 = 1168
__$ArrayPad$ = 1376
this$ = 1408
__$ReturnUdt$ = 1416
?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$11
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T13[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$11@?0??GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetFullName'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
tv83 = 40
tv165 = 48
tv78 = 56
tv167 = 64
$T2 = 72
c$3 = 112
$T4 = 320
__$ArrayPad$ = 528
this$ = 560
__$ReturnUdt$ = 568
?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; IronMan::Core::SDK::UObject::GetSuperClassName

; 244  : 	{

$LN14:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 552				; 00000228H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 245  : 		if (!IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@GetSuperCl

; 246  : 			return ("(null)");

	lea	rdx, OFFSET FLAT:??_C@_06OJHGLDPL@?$CInull?$CJ@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetSuperCl
$LN5@GetSuperCl:

; 247  : 		if (!m_upperName.empty())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@GetSuperCl

; 248  : 			return m_upperName;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetSuperCl
$LN6@GetSuperCl:

; 249  : 
; 250  : 		//if (this->Is_A<UClass>())
; 251  : 		{
; 252  : 			for (auto c = this->Cast<UStruct>(); c; c = c.GetSuperStruct()) {

	lea	rdx, QWORD PTR c$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$Cast@VUStruct@SDK@Core@IronMan@@@UObject@SDK@Core@IronMan@@QEBA?AVUStruct@123@XZ ; IronMan::Core::SDK::UObject::Cast<IronMan::Core::SDK::UStruct>
	npad	1
	jmp	SHORT $LN4@GetSuperCl
$LN2@GetSuperCl:
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR c$3[rsp]
	call	?GetSuperStruct@UStruct@SDK@Core@IronMan@@QEAA?AV1234@XZ ; IronMan::Core::SDK::UStruct::GetSuperStruct
	mov	QWORD PTR tv83[rsp], rax
	mov	rax, QWORD PTR tv83[rsp]
	mov	QWORD PTR tv165[rsp], rax
	mov	rdx, QWORD PTR tv165[rsp]
	lea	rcx, QWORD PTR c$3[rsp]
	call	??4UStruct@SDK@Core@IronMan@@QEAAAEAV0123@$$QEAV0123@@Z
	npad	1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	npad	1
$LN4@GetSuperCl:
	lea	rcx, QWORD PTR c$3[rsp]
	call	??BUObject@SDK@Core@IronMan@@QEAA_NXZ	; IronMan::Core::SDK::UObject::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN3@GetSuperCl

; 253  : 				if (!m_upperName.empty())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@GetSuperCl

; 254  : 					m_upperName += ("->");

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	lea	rdx, OFFSET FLAT:??_C@_02HBOOOICD@?9?$DO@
	mov	rcx, rax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
$LN7@GetSuperCl:

; 255  : 				m_upperName += c.GetFullName();

	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR c$3[rsp]
	call	?GetFullName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Core::SDK::UObject::GetFullName
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR tv167[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rdx, QWORD PTR tv167[rsp]
	mov	rcx, rax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	$LN2@GetSuperCl
$LN3@GetSuperCl:

; 256  : 			}

	lea	rcx, QWORD PTR c$3[rsp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	npad	1

; 257  : 		}
; 258  : 
; 259  : 		return m_upperName;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetSuperCl:

; 260  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 552				; 00000228H
	ret	0
	int	3
?GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; IronMan::Core::SDK::UObject::GetSuperClassName
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv83 = 40
tv165 = 48
tv78 = 56
tv167 = 64
$T2 = 72
c$3 = 112
$T4 = 320
__$ArrayPad$ = 528
this$ = 560
__$ReturnUdt$ = 568
?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv83 = 40
tv165 = 48
tv78 = 56
tv167 = 64
$T2 = 72
c$3 = 112
$T4 = 320
__$ArrayPad$ = 528
this$ = 560
__$ReturnUdt$ = 568
?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR c$3[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv83 = 40
tv165 = 48
tv78 = 56
tv167 = 64
$T2 = 72
c$3 = 112
$T4 = 320
__$ArrayPad$ = 528
this$ = 560
__$ReturnUdt$ = 568
?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1UStruct@SDK@Core@IronMan@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv83 = 40
tv165 = 48
tv78 = 56
tv167 = 64
$T2 = 72
c$3 = 112
$T4 = 320
__$ArrayPad$ = 528
this$ = 560
__$ReturnUdt$ = 568
?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??GetSuperClassName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetSuperClassName'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
tv88 = 40
tv90 = 48
tv136 = 56
tv138 = 64
tv146 = 72
tv143 = 80
tv278 = 88
tv177 = 96
tv175 = 104
tv188 = 112
tv190 = 120
tv204 = 128
tv206 = 136
tv216 = 144
tv287 = 152
tv281 = 160
tv288 = 168
tv283 = 176
tv248 = 184
tv246 = 192
tv289 = 200
tv286 = 208
tv276 = 216
tv274 = 224
TestName$3 = 232
$T4 = 264
$T5 = 296
$T6 = 328
$T7 = 360
__$ArrayPad$ = 392
this$ = 416
?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ PROC	; IronMan::Core::SDK::UObject::TestName

; 195  : 	{

$LN17:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 408				; 00000198H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 196  : 		if (!IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@TestName

; 197  : 			return 0;

	xor	eax, eax
	jmp	$LN1@TestName
$LN2@TestName:

; 198  : 		if (!m_name.empty())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@TestName

; 199  : 			return 0;

	xor	eax, eax
	jmp	$LN1@TestName
$LN3@TestName:

; 200  : 		if (NamePrivate.CompositeComparisonValue == 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	$LN4@TestName

; 201  : 		{
; 202  : 			if (uNormal == 0)

	cmp	DWORD PTR ?uNormal@SDK@Core@IronMan@@3HA, 0
	jne	$LN6@TestName

; 203  : 			{
; 204  : 				NamePrivate.ComparisonIndex = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectNameComparisonIndex>::STATIC_Get(

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv90[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+408
	mov	QWORD PTR tv88[rsp], rax
	mov	rdx, QWORD PTR tv88[rsp]
	mov	rcx, QWORD PTR tv90[rsp]
	call	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::Read<unsigned int>
	mov	eax, eax
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,1>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 205  : 					GetDMA().Read<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectNameComparisonIndex));
; 206  : 				NamePrivate.Number = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectNameNumber>::STATIC_Get(

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv138[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+400
	mov	QWORD PTR tv136[rsp], rax
	mov	rdx, QWORD PTR tv136[rsp]
	mov	rcx, QWORD PTR tv138[rsp]
	call	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::Read<unsigned int>
	mov	eax, eax
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,2>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 207  : 					GetDMA().Read<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectNameNumber));
; 208  : 				auto TestName = NamePrivate.GetName();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv146[rsp], rax
	lea	rdx, QWORD PTR TestName$3[rsp]
	mov	rcx, QWORD PTR tv146[rsp]
	call	?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Core::SDK::FName::GetName
	npad	1

; 209  : 				if (TestName.find("CoreUObject") != std::string::npos)

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0M@NALCFIBF@CoreUObject@
	lea	rcx, QWORD PTR TestName$3[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	je	$LN7@TestName

; 210  : 				{
; 211  : 					CONSOLE_INFO("1:%s", TestName.c_str());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	rcx, QWORD PTR TestName$3[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv177[rsp], rax
	lea	r8, OFFSET FLAT:??_C@_04JOCPCP@1?3?$CFs@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv143[rsp], rax
	mov	rax, QWORD PTR tv143[rsp]
	mov	QWORD PTR tv278[rsp], rax
	mov	rcx, QWORD PTR tv278[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv175[rsp], rax
	mov	rdx, QWORD PTR tv177[rsp]
	mov	rcx, QWORD PTR tv175[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 212  : 					uNormal = 1;

	mov	DWORD PTR ?uNormal@SDK@Core@IronMan@@3HA, 1

; 213  : 					return 1;

	mov	DWORD PTR $T1[rsp], 1
	lea	rcx, QWORD PTR TestName$3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	jmp	$LN1@TestName

; 214  : 				}

	jmp	$LN8@TestName
$LN7@TestName:

; 215  : 				else
; 216  : 				{
; 217  : 					NamePrivate.Number = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectNameComparisonIndex>::STATIC_Get(

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv190[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+408
	mov	QWORD PTR tv188[rsp], rax
	mov	rdx, QWORD PTR tv188[rsp]
	mov	rcx, QWORD PTR tv190[rsp]
	call	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::Read<unsigned int>
	mov	eax, eax
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,1>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 218  : 						GetDMA().Read<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectNameComparisonIndex));
; 219  : 					NamePrivate.ComparisonIndex = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectNameNumber>::STATIC_Get(

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv206[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+400
	mov	QWORD PTR tv204[rsp], rax
	mov	rdx, QWORD PTR tv204[rsp]
	mov	rcx, QWORD PTR tv206[rsp]
	call	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::Read<unsigned int>
	mov	eax, eax
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,2>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 220  : 						GetDMA().Read<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectNameNumber));
; 221  : 					TestName = NamePrivate.GetName();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv216[rsp], rax
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, QWORD PTR tv216[rsp]
	call	?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Core::SDK::FName::GetName
	mov	QWORD PTR tv287[rsp], rax
	mov	rax, QWORD PTR tv287[rsp]
	mov	QWORD PTR tv281[rsp], rax
	mov	rdx, QWORD PTR tv281[rsp]
	lea	rcx, QWORD PTR TestName$3[rsp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	lea	rcx, QWORD PTR $T5[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 222  : 					if (TestName.find("CoreUObject") != std::string::npos)

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0M@NALCFIBF@CoreUObject@
	lea	rcx, QWORD PTR TestName$3[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	je	$LN9@TestName

; 223  : 					{
; 224  : 						CONSOLE_INFO("2:%s", TestName.c_str());

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	lea	rcx, QWORD PTR TestName$3[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv248[rsp], rax
	lea	r8, OFFSET FLAT:??_C@_04EHDOFFPP@2?3?$CFs@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T6[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv288[rsp], rax
	mov	rax, QWORD PTR tv288[rsp]
	mov	QWORD PTR tv283[rsp], rax
	mov	rcx, QWORD PTR tv283[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv246[rsp], rax
	mov	rdx, QWORD PTR tv248[rsp]
	mov	rcx, QWORD PTR tv246[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 225  : 						uNormal = 2;

	mov	DWORD PTR ?uNormal@SDK@Core@IronMan@@3HA, 2

; 226  : 						return 2;

	mov	DWORD PTR $T2[rsp], 2
	lea	rcx, QWORD PTR TestName$3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[rsp]
	jmp	$LN1@TestName

; 227  : 					}

	jmp	SHORT $LN8@TestName
$LN9@TestName:

; 228  : 					else
; 229  : 					{
; 230  : 						MessageBoxA(0, "Name Error To Find", 0, 0);

	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0BD@EDEEELKD@Name?5Error?5To?5Find@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	npad	1
$LN8@TestName:

; 231  : 						//TerminateProcess(GetCurrentProcess(), -1);
; 232  : 					}
; 233  : 				}
; 234  : 			}

	lea	rcx, QWORD PTR TestName$3[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN6@TestName:

; 235  : 		}

	jmp	$LN5@TestName
$LN4@TestName:

; 236  : 		else
; 237  : 		{
; 238  : 			CONSOLE_INFO("0:%p", NamePrivate.CompositeComparisonValue);

	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	mov	ecx, -11				; fffffff5H
	call	QWORD PTR __imp_GetStdHandle
	mov	dx, 7
	mov	rcx, rax
	call	QWORD PTR __imp_SetConsoleTextAttribute
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv276[rsp], rax
	lea	r8, OFFSET FLAT:??_C@_04BGNDFFFM@0?3?$CFp@
	lea	rdx, OFFSET FLAT:??_C@_0BC@ECCJIJFO@?$FL?h?$LO?$JD?e?$IH?$LK?d?$LP?$KB?f?$IB?$KP?$FN?5?$CFs@
	lea	rcx, QWORD PTR $T7[rsp]
	call	?FormatString@Utils@IronMan@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBDZZ ; IronMan::Utils::FormatString
	mov	QWORD PTR tv289[rsp], rax
	mov	rax, QWORD PTR tv289[rsp]
	mov	QWORD PTR tv286[rsp], rax
	mov	rcx, QWORD PTR tv286[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	QWORD PTR tv274[rsp], rax
	mov	rdx, QWORD PTR tv276[rsp]
	mov	rcx, QWORD PTR tv274[rsp]
	call	?Print@Console@IronMan@@YA_NPEBDZZ	; IronMan::Console::Print
	npad	1
	lea	rcx, QWORD PTR $T7[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN5@TestName:

; 239  : 		}
; 240  : 		return 0;

	xor	eax, eax
$LN1@TestName:

; 241  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 408				; 00000198H
	ret	0
?TestName@UObject@SDK@Core@IronMan@@QEAAHXZ ENDP	; IronMan::Core::SDK::UObject::TestName
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv88 = 40
tv90 = 48
tv136 = 56
tv138 = 64
tv146 = 72
tv143 = 80
tv278 = 88
tv177 = 96
tv175 = 104
tv188 = 112
tv190 = 120
tv204 = 128
tv206 = 136
tv216 = 144
tv287 = 152
tv281 = 160
tv288 = 168
tv283 = 176
tv248 = 184
tv246 = 192
tv289 = 200
tv286 = 208
tv276 = 216
tv274 = 224
TestName$3 = 232
$T4 = 264
$T5 = 296
$T6 = 328
$T7 = 360
__$ArrayPad$ = 392
this$ = 416
?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA PROC ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR TestName$3[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv88 = 40
tv90 = 48
tv136 = 56
tv138 = 64
tv146 = 72
tv143 = 80
tv278 = 88
tv177 = 96
tv175 = 104
tv188 = 112
tv190 = 120
tv204 = 128
tv206 = 136
tv216 = 144
tv287 = 152
tv281 = 160
tv288 = 168
tv283 = 176
tv248 = 184
tv246 = 192
tv289 = 200
tv286 = 208
tv276 = 216
tv274 = 224
TestName$3 = 232
$T4 = 264
$T5 = 296
$T6 = 328
$T7 = 360
__$ArrayPad$ = 392
this$ = 416
?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA PROC ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv88 = 40
tv90 = 48
tv136 = 56
tv138 = 64
tv146 = 72
tv143 = 80
tv278 = 88
tv177 = 96
tv175 = 104
tv188 = 112
tv190 = 120
tv204 = 128
tv206 = 136
tv216 = 144
tv287 = 152
tv281 = 160
tv288 = 168
tv283 = 176
tv248 = 184
tv246 = 192
tv289 = 200
tv286 = 208
tv276 = 216
tv274 = 224
TestName$3 = 232
$T4 = 264
$T5 = 296
$T6 = 328
$T7 = 360
__$ArrayPad$ = 392
this$ = 416
?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA PROC ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv88 = 40
tv90 = 48
tv136 = 56
tv138 = 64
tv146 = 72
tv143 = 80
tv278 = 88
tv177 = 96
tv175 = 104
tv188 = 112
tv190 = 120
tv204 = 128
tv206 = 136
tv216 = 144
tv287 = 152
tv281 = 160
tv288 = 168
tv283 = 176
tv248 = 184
tv246 = 192
tv289 = 200
tv286 = 208
tv276 = 216
tv274 = 224
TestName$3 = 232
$T4 = 264
$T5 = 296
$T6 = 328
$T7 = 360
__$ArrayPad$ = 392
this$ = 416
?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA PROC ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
$T2 = 36
tv88 = 40
tv90 = 48
tv136 = 56
tv138 = 64
tv146 = 72
tv143 = 80
tv278 = 88
tv177 = 96
tv175 = 104
tv188 = 112
tv190 = 120
tv204 = 128
tv206 = 136
tv216 = 144
tv287 = 152
tv281 = 160
tv288 = 168
tv283 = 176
tv248 = 184
tv246 = 192
tv289 = 200
tv286 = 208
tv276 = 216
tv274 = 224
TestName$3 = 232
$T4 = 264
$T5 = 296
$T6 = 328
$T7 = 360
__$ArrayPad$ = 392
this$ = 416
?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA PROC ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0??TestName@UObject@SDK@Core@IronMan@@QEAAHXZ@4HA ENDP ; `IronMan::Core::SDK::UObject::TestName'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
TempV$2 = 36
$T3 = 40
Result$ = 48
pos$ = 56
tv130 = 64
tv132 = 72
tv146 = 80
tv148 = 88
tv162 = 96
tv164 = 104
tv221 = 112
tv78 = 120
tv270 = 128
tv247 = 136
tv262 = 144
$T4 = 152
$T5 = 160
$T6 = 176
__$ArrayPad$ = 208
this$ = 240
__$ReturnUdt$ = 248
number$ = 256
usecache$ = 264
?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z PROC ; IronMan::Core::SDK::UObject::GetName

; 139  : 	{

$LN16:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 140  : 		if (!IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetName

; 141  : 			return ("(null)");

	lea	rdx, OFFSET FLAT:??_C@_06OJHGLDPL@?$CInull?$CJ@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetName
$LN2@GetName:

; 142  : 		if (!m_name.empty())

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@GetName

; 143  : 			return m_name;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@GetName
$LN3@GetName:

; 144  : 		if (NamePrivate.CompositeComparisonValue == 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+32], 0
	jne	$LN4@GetName

; 145  : 		{
; 146  : 			if (usecache)

	movzx	eax, BYTE PTR usecache$[rsp]
	test	eax, eax
	je	$LN5@GetName

; 147  : 			{
; 148  : 				NamePrivate.ComparisonIndex = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectNameComparisonIndex>::STATIC_Get(

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv132[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+408
	mov	QWORD PTR tv130[rsp], rax
	mov	rdx, QWORD PTR tv130[rsp]
	mov	rcx, QWORD PTR tv132[rsp]
	call	??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z ; IronMan::DMAHandler::ReadCache<unsigned int>
	mov	eax, eax
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,1>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 149  : 					GetDMA().ReadCache<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectNameComparisonIndex));
; 150  : 				NamePrivate.Number = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectNameNumber>::STATIC_Get(

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv148[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+400
	mov	QWORD PTR tv146[rsp], rax
	mov	rdx, QWORD PTR tv146[rsp]
	mov	rcx, QWORD PTR tv148[rsp]
	call	??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z ; IronMan::DMAHandler::ReadCache<unsigned int>
	mov	eax, eax
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$01@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,2>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 151  : 					GetDMA().ReadCache<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectNameNumber));
; 152  : 			}

	jmp	SHORT $LN4@GetName
$LN5@GetName:

; 153  : 			else
; 154  : 			{
; 155  : 				NamePrivate.ComparisonIndex = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectNameComparisonIndex>::STATIC_Get(

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv164[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+408
	mov	QWORD PTR tv162[rsp], rax
	mov	rdx, QWORD PTR tv162[rsp]
	mov	rcx, QWORD PTR tv164[rsp]
	call	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::Read<unsigned int>
	mov	eax, eax
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$00@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,1>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 156  : 					GetDMA().Read<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectNameComparisonIndex));
; 157  : 				NamePrivate.Number = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+36], 0
$LN4@GetName:

; 158  : 			}
; 159  : 		}
; 160  : 		if (uNormal != 1)

	cmp	DWORD PTR ?uNormal@SDK@Core@IronMan@@3HA, 1
	je	SHORT $LN7@GetName

; 161  : 		{
; 162  : 			if (NamePrivate.ComparisonIndex == 0 && NamePrivate.Number != 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN7@GetName
	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN7@GetName

; 163  : 			{
; 164  : 				auto TempV = NamePrivate.Number;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR TempV$2[rsp], eax

; 165  : 				NamePrivate.Number = NamePrivate.ComparisonIndex;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+32]
	mov	DWORD PTR [rax+36], ecx

; 166  : 				NamePrivate.ComparisonIndex = TempV;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR TempV$2[rsp]
	mov	DWORD PTR [rax+32], ecx
$LN7@GetName:

; 167  : 			}
; 168  : 		}
; 169  : 
; 170  : 		auto Result = CacheName.find(NamePrivate.ComparisonIndex);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR $T3[rsp], eax
	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR Result$[rsp]
	lea	rcx, OFFSET FLAT:?CacheName@SDK@Core@IronMan@@3V?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??$find@X@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@1@AEBI@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find<void>
	npad	1

; 171  : 		if (Result == CacheName.end())

	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, OFFSET FLAT:?CacheName@SDK@Core@IronMan@@3V?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	?end@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR Result$[rsp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	$LN9@GetName

; 172  : 		{
; 173  : 			m_name = NamePrivate.GetName();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR tv221[rsp], rax
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR tv221[rsp]
	call	?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; IronMan::Core::SDK::FName::GetName
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR tv270[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, QWORD PTR tv270[rsp]
	mov	rcx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	lea	rcx, QWORD PTR $T6[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 174  : 			CacheName.emplace(NamePrivate.ComparisonIndex, m_name);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 32					; 00000020H
	mov	r9, rax
	mov	r8, rcx
	lea	rdx, QWORD PTR $T5[rsp]
	lea	rcx, OFFSET FLAT:?CacheName@SDK@Core@IronMan@@3V?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	??$emplace@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@_N@1@AEAHAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::emplace<int &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	npad	1

; 175  : 		}

	jmp	SHORT $LN10@GetName
$LN9@GetName:

; 176  : 		else
; 177  : 			m_name = Result->second;

	lea	rcx, QWORD PTR Result$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 64					; 00000040H
	mov	rdx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
$LN10@GetName:

; 178  : 		//if (number && NamePrivate.Number > 0)
; 179  : 		//{
; 180  : 		//	m_name += '_' + std::to_string(NamePrivate.Number);
; 181  : 		//}
; 182  : 
; 183  : 
; 184  : 
; 185  : 		auto pos = m_name.rfind('/');

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR tv247[rsp], rax
	mov	r8, -1
	mov	dl, 47					; 0000002fH
	mov	rcx, QWORD PTR tv247[rsp]
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
	mov	QWORD PTR pos$[rsp], rax

; 186  : 		if (pos == std::string::npos)

	cmp	QWORD PTR pos$[rsp], -1
	jne	SHORT $LN11@GetName

; 187  : 		{
; 188  : 			return m_name;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetName
$LN11@GetName:

; 189  : 		}
; 190  : 
; 191  : 		return m_name.substr(pos + 1);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR tv262[rsp], rax
	mov	rax, QWORD PTR pos$[rsp]
	inc	rax
	mov	r9, -1
	mov	r8, rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv262[rsp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetName:

; 192  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	ret	0
	int	3
?GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z ENDP ; IronMan::Core::SDK::UObject::GetName
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
TempV$2 = 36
$T3 = 40
Result$ = 48
pos$ = 56
tv130 = 64
tv132 = 72
tv146 = 80
tv148 = 88
tv162 = 96
tv164 = 104
tv221 = 112
tv78 = 120
tv270 = 128
tv247 = 136
tv262 = 144
$T4 = 152
$T5 = 160
$T6 = 176
__$ArrayPad$ = 208
this$ = 240
__$ReturnUdt$ = 248
number$ = 256
usecache$ = 264
?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA PROC ; `IronMan::Core::SDK::UObject::GetName'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN14@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::GetName'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
TempV$2 = 36
$T3 = 40
Result$ = 48
pos$ = 56
tv130 = 64
tv132 = 72
tv146 = 80
tv148 = 88
tv162 = 96
tv164 = 104
tv221 = 112
tv78 = 120
tv270 = 128
tv247 = 136
tv262 = 144
$T4 = 152
$T5 = 160
$T6 = 176
__$ArrayPad$ = 208
this$ = 240
__$ReturnUdt$ = 248
number$ = 256
usecache$ = 264
?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA PROC ; `IronMan::Core::SDK::UObject::GetName'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GetName@UObject@SDK@Core@IronMan@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N0@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::GetName'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
tv95 = 40
encryptData$2 = 48
tv79 = 56
tv81 = 64
tv90 = 72
tv92 = 80
this$ = 112
__$ReturnUdt$ = 120
?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ PROC	; IronMan::Core::SDK::UObject::GetOuter

; 128  : 	{

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	DWORD PTR $T1[rsp], 0

; 129  : 		if (OuterPrivate == INVALID_POINTER && IsValid())

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA ; IronMan::Core::SDK::INVALID_POINTER
	cmp	QWORD PTR [rax+40], rcx
	jne	$LN2@GetOuter
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	je	$LN2@GetOuter

; 130  : 		{
; 131  : 			auto encryptData = bUseCache ? GetDMA().ReadCache<ptr_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectOuter)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+162]
	test	eax, eax
	je	SHORT $LN5@GetOuter
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+416
	mov	QWORD PTR tv79[rsp], rax
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z ; IronMan::DMAHandler::ReadCache<unsigned __int64>
	mov	QWORD PTR tv95[rsp], rax
	jmp	SHORT $LN6@GetOuter
$LN5@GetOuter:
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+416
	mov	QWORD PTR tv90[rsp], rax
	mov	rdx, QWORD PTR tv90[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z ; IronMan::DMAHandler::Read<unsigned __int64>
	mov	QWORD PTR tv95[rsp], rax
$LN6@GetOuter:
	mov	rax, QWORD PTR tv95[rsp]
	mov	QWORD PTR encryptData$2[rsp], rax

; 132  : 				: GetDMA().Read<ptr_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectOuter);
; 133  : 			if (encryptData)

	cmp	QWORD PTR encryptData$2[rsp], 0
	je	SHORT $LN2@GetOuter

; 134  : 				OuterPrivate = UEEncryptedObjectProperty<void*, DecryptFunc::UObjectOuter>::STATIC_Get(encryptData);

	mov	rcx, QWORD PTR encryptData$2[rsp]
	call	?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$04@SDK@Core@IronMan@@SAPEAX_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,5>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+40], rax
$LN2@GetOuter:

; 135  : 		}
; 136  : 		return UObject(OuterPrivate);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z ; IronMan::Core::SDK::UObject::UObject
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 137  : 	}

	add	rsp, 104				; 00000068H
	ret	0
	int	3
?GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ ENDP	; IronMan::Core::SDK::UObject::GetOuter
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv95 = 40
encryptData$2 = 48
tv79 = 56
tv81 = 64
tv90 = 72
tv92 = 80
this$ = 112
__$ReturnUdt$ = 120
?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetOuter'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
$LN8@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetOuter@UObject@SDK@Core@IronMan@@QEAA?AV1234@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetOuter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
tv95 = 40
encryptData$2 = 48
tv79 = 56
tv81 = 64
tv90 = 72
tv92 = 80
this$ = 112
__$ReturnUdt$ = 120
?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ PROC ; IronMan::Core::SDK::UObject::GetClass

; 116  : 	{

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	DWORD PTR $T1[rsp], 0

; 117  : 		if (ClassPrivate == INVALID_POINTER && IsValid())

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA ; IronMan::Core::SDK::INVALID_POINTER
	cmp	QWORD PTR [rax+16], rcx
	jne	$LN2@GetClass
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	je	$LN2@GetClass

; 118  : 		{
; 119  : 			auto encryptData = bUseCache ? GetDMA().ReadCache<ptr_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectClass)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+162]
	test	eax, eax
	je	SHORT $LN5@GetClass
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+424
	mov	QWORD PTR tv79[rsp], rax
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z ; IronMan::DMAHandler::ReadCache<unsigned __int64>
	mov	QWORD PTR tv95[rsp], rax
	jmp	SHORT $LN6@GetClass
$LN5@GetClass:
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+424
	mov	QWORD PTR tv90[rsp], rax
	mov	rdx, QWORD PTR tv90[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z ; IronMan::DMAHandler::Read<unsigned __int64>
	mov	QWORD PTR tv95[rsp], rax
$LN6@GetClass:
	mov	rax, QWORD PTR tv95[rsp]
	mov	QWORD PTR encryptData$2[rsp], rax

; 120  : 				: GetDMA().Read<ptr_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectClass);
; 121  : 			if (encryptData)

	cmp	QWORD PTR encryptData$2[rsp], 0
	je	SHORT $LN2@GetClass

; 122  : 				ClassPrivate = UEEncryptedObjectProperty<void*, DecryptFunc::UObjectClass>::STATIC_Get(encryptData);

	mov	rcx, QWORD PTR encryptData$2[rsp]
	call	?STATIC_Get@?$UEEncryptedObjectProperty@PEAX$03@SDK@Core@IronMan@@SAPEAX_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<void *,4>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax
$LN2@GetClass:

; 123  : 		}
; 124  : 		return UClass(ClassPrivate);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0UClass@SDK@Core@IronMan@@QEAA@PEAX@Z	; IronMan::Core::SDK::UClass::UClass
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 125  : 	}

	add	rsp, 104				; 00000068H
	ret	0
	int	3
?GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ ENDP ; IronMan::Core::SDK::UObject::GetClass
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 32
tv95 = 40
encryptData$2 = 48
tv79 = 56
tv81 = 64
tv90 = 72
tv92 = 80
this$ = 112
__$ReturnUdt$ = 120
?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::GetClass'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1UClass@SDK@Core@IronMan@@UEAA@XZ
$LN8@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetClass@UObject@SDK@Core@IronMan@@QEAA?AVUClass@234@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::GetClass'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
tv95 = 32
encryptData$1 = 36
tv79 = 40
tv81 = 48
tv90 = 56
tv92 = 64
this$ = 96
?GetIndex@UObject@SDK@Core@IronMan@@QEAA_KXZ PROC	; IronMan::Core::SDK::UObject::GetIndex

; 103  : 	{

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 104  : 		if (!IsValid())

	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetIndex

; 105  : 			return 0;

	xor	eax, eax
	jmp	$LN1@GetIndex
$LN2@GetIndex:

; 106  : 		if (InternalIndex == -1)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+12], -1
	jne	$LN3@GetIndex

; 107  : 		{
; 108  : 			auto encryptData = bUseCache ? GetDMA().ReadCache<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectIndex)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+162]
	test	eax, eax
	je	SHORT $LN6@GetIndex
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+392
	mov	QWORD PTR tv79[rsp], rax
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z ; IronMan::DMAHandler::ReadCache<unsigned int>
	mov	DWORD PTR tv95[rsp], eax
	jmp	SHORT $LN7@GetIndex
$LN6@GetIndex:
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+392
	mov	QWORD PTR tv90[rsp], rax
	mov	rdx, QWORD PTR tv90[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::Read<unsigned int>
	mov	DWORD PTR tv95[rsp], eax
$LN7@GetIndex:
	mov	eax, DWORD PTR tv95[rsp]
	mov	DWORD PTR encryptData$1[rsp], eax

; 109  : 				: GetDMA().Read<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectIndex);
; 110  : 			if (encryptData)

	cmp	DWORD PTR encryptData$1[rsp], 0
	je	SHORT $LN4@GetIndex

; 111  : 				InternalIndex = UEEncryptedObjectProperty<int32_t, DecryptFunc::UObjectIndex>::STATIC_Get(encryptData);

	mov	eax, DWORD PTR encryptData$1[rsp]
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@H$02@SDK@Core@IronMan@@SAH_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<int,3>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+12], eax
$LN4@GetIndex:
$LN3@GetIndex:

; 112  : 		}
; 113  : 		return InternalIndex;

	mov	rax, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rax+12]
$LN1@GetIndex:

; 114  : 	}

	add	rsp, 88					; 00000058H
	ret	0
?GetIndex@UObject@SDK@Core@IronMan@@QEAA_KXZ ENDP	; IronMan::Core::SDK::UObject::GetIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
tv95 = 32
encryptData$1 = 36
tv79 = 40
tv81 = 48
tv90 = 56
tv92 = 64
this$ = 96
?GetObjectFlags@UObject@SDK@Core@IronMan@@QEAA?AW4EObjectFlags@234@XZ PROC ; IronMan::Core::SDK::UObject::GetObjectFlags

; 92   : 	{

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 93   : 		if (ObjectFlags == RF_INVALID && IsValid())

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+8], -1
	jne	$LN2@GetObjectF
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ; IronMan::Core::SDK::UObject::IsValid
	movzx	eax, al
	test	eax, eax
	je	$LN2@GetObjectF

; 94   : 		{
; 95   : 			auto encryptData = bUseCache ? GetDMA().ReadCache<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectFlags)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+162]
	test	eax, eax
	je	SHORT $LN5@GetObjectF
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+384
	mov	QWORD PTR tv79[rsp], rax
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv81[rsp]
	call	??$ReadCache@I@DMAHandler@IronMan@@QEAAI_K@Z ; IronMan::DMAHandler::ReadCache<unsigned int>
	mov	DWORD PTR tv95[rsp], eax
	jmp	SHORT $LN6@GetObjectF
$LN5@GetObjectF:
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv92[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtr@UObject@SDK@Core@IronMan@@QEBAPEAXXZ ; IronMan::Core::SDK::UObject::GetPtr
	add	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+384
	mov	QWORD PTR tv90[rsp], rax
	mov	rdx, QWORD PTR tv90[rsp]
	mov	rcx, QWORD PTR tv92[rsp]
	call	??$Read@I@DMAHandler@IronMan@@QEAAI_K@Z	; IronMan::DMAHandler::Read<unsigned int>
	mov	DWORD PTR tv95[rsp], eax
$LN6@GetObjectF:
	mov	eax, DWORD PTR tv95[rsp]
	mov	DWORD PTR encryptData$1[rsp], eax

; 96   : 				: GetDMA().Read<uint32_t>((ptr_t)GetPtr() + g_PatternData.offset_UObjectFlags);
; 97   : 			if (encryptData)

	cmp	DWORD PTR encryptData$1[rsp], 0
	je	SHORT $LN3@GetObjectF

; 98   : 				ObjectFlags = UEEncryptedObjectProperty<EObjectFlags, DecryptFunc::UObjectFlags>::STATIC_Get(encryptData);

	mov	eax, DWORD PTR encryptData$1[rsp]
	mov	ecx, eax
	call	?STATIC_Get@?$UEEncryptedObjectProperty@W4EObjectFlags@SDK@Core@IronMan@@$0A@@SDK@Core@IronMan@@SA?AW4EObjectFlags@234@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<enum IronMan::Core::SDK::EObjectFlags,0>::STATIC_Get
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+8], eax
$LN3@GetObjectF:
$LN2@GetObjectF:

; 99   : 		}
; 100  : 		return ObjectFlags;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]

; 101  : 	}

	add	rsp, 88					; 00000058H
	ret	0
?GetObjectFlags@UObject@SDK@Core@IronMan@@QEAA?AW4EObjectFlags@234@XZ ENDP ; IronMan::Core::SDK::UObject::GetObjectFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ
_TEXT	SEGMENT
tv76 = 32
this$ = 64
?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ PROC	; IronMan::Core::SDK::UObject::IsValid, COMDAT

; 475  : 		inline bool IsValid() const { return !Utils::IsSafeReadPtr((void*)this, 8) && !bInvalid && IsAddrValid(m_self); }

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsValid
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+163]
	test	eax, eax
	jne	SHORT $LN3@IsValid
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+48], 1048576		; 00100000H
	jb	SHORT $LN4@IsValid
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A
	cmp	QWORD PTR [rax+48], rcx
	jae	SHORT $LN4@IsValid
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN5@IsValid
$LN3@IsValid:
$LN4@IsValid:
	mov	DWORD PTR tv76[rsp], 0
$LN5@IsValid:
	movzx	eax, BYTE PTR tv76[rsp]
	add	rsp, 56					; 00000038H
	ret	0
?IsValid@UObject@SDK@Core@IronMan@@QEBA_NXZ ENDP	; IronMan::Core::SDK::UObject::IsValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
this$ = 48
??1UObject@SDK@Core@IronMan@@UEAA@XZ PROC		; IronMan::Core::SDK::UObject::~UObject

; 87   : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UObject@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx

; 88   : 		//WriteLock.reset();
; 89   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1UObject@SDK@Core@IronMan@@UEAA@XZ ENDP		; IronMan::Core::SDK::UObject::~UObject
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::~UObject'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::~UObject'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::~UObject'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 96					; 00000060H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::~UObject'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::~UObject'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???1UObject@SDK@Core@IronMan@@UEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::~UObject'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
this$ = 48
object$ = 56
??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z PROC		; IronMan::Core::SDK::UObject::UObject

; 82   : 	{

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 81   : 	UObject::UObject(void* object) : UObject()

	mov	rcx, QWORD PTR this$[rsp]
	call	??0UObject@SDK@Core@IronMan@@QEAA@XZ	; IronMan::Core::SDK::UObject::UObject
	npad	1

; 82   : 	{

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UObject@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx

; 83   : 		m_self = object;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR object$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 84   : 		//WriteLock = std::make_shared<WfirstRWLock>();
; 85   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z ENDP		; IronMan::Core::SDK::UObject::UObject
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
object$ = 56
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@PEAX@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
object$1 = 32
__$ArrayPad$ = 208
this$ = 240
newobject$ = 248
??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z PROC	; IronMan::Core::SDK::UObject::UObject

; 60   : 	{

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UObject@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0FName@SDK@Core@IronMan@@QEAA@XZ	; IronMan::Core::SDK::FName::FName
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 61   : 		if (newobject && (ptr_t)this > 0x10000 && (ptr_t)newobject > 0x10000 && !Utils::IsSafeReadPtr((void*)newobject, 1))

	mov	rax, QWORD PTR newobject$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN2@UObject
	cmp	QWORD PTR this$[rsp], 65536		; 00010000H
	jbe	$LN2@UObject
	mov	rax, QWORD PTR newobject$[rsp]
	cmp	QWORD PTR [rax], 65536			; 00010000H
	jbe	$LN2@UObject
	mov	edx, 1
	mov	rax, QWORD PTR newobject$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	jne	$LN2@UObject

; 62   : 		{
; 63   : 			UObject object = (UObject)newobject;

	mov	rdx, QWORD PTR newobject$[rsp]
	lea	rcx, QWORD PTR object$1[rsp]
	call	??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z ; IronMan::Core::SDK::UObject::UObject
	npad	1

; 64   : 			m_self = object.m_self;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR object$1[rsp+48]
	mov	QWORD PTR [rax+48], rcx

; 65   : 			ObjectFlags = object.ObjectFlags;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR object$1[rsp+8]
	mov	DWORD PTR [rax+8], ecx

; 66   : 			InternalIndex = object.InternalIndex;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR object$1[rsp+12]
	mov	DWORD PTR [rax+12], ecx

; 67   : 			ClassPrivate = object.ClassPrivate;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR object$1[rsp+16]
	mov	QWORD PTR [rax+16], rcx

; 68   : 			EncryptClass = object.EncryptClass;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR object$1[rsp+24]
	mov	QWORD PTR [rax+24], rcx

; 69   : 			NamePrivate = object.NamePrivate;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR object$1[rsp+32]
	mov	QWORD PTR [rax+32], rcx

; 70   : 			OuterPrivate = object.OuterPrivate;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR object$1[rsp+40]
	mov	QWORD PTR [rax+40], rcx

; 71   : 			bCached = object.bCached;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR object$1[rsp+160]
	mov	BYTE PTR [rax+160], cl

; 72   : 			bAddObject = object.bAddObject;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR object$1[rsp+161]
	mov	BYTE PTR [rax+161], cl

; 73   : 			bUseCache = object.bUseCache;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR object$1[rsp+162]
	mov	BYTE PTR [rax+162], cl

; 74   : 			bInvalid = object.bInvalid;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR object$1[rsp+163]
	mov	BYTE PTR [rax+163], cl

; 75   : 			m_name = object.m_name;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	lea	rdx, QWORD PTR object$1[rsp+64]
	mov	rcx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 76   : 			m_fullName = object.m_fullName;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	lea	rdx, QWORD PTR object$1[rsp+96]
	mov	rcx, rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 77   : 			m_type = object.m_type;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR object$1[rsp+56]
	mov	DWORD PTR [rax+56], ecx

; 78   : 			//WriteLock = object.WriteLock;
; 79   : 		}

	lea	rcx, QWORD PTR object$1[rsp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	npad	1
$LN2@UObject:

; 80   : 	}

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	ret	0
??0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z ENDP	; IronMan::Core::SDK::UObject::UObject
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
object$1 = 32
__$ArrayPad$ = 208
this$ = 240
newobject$ = 248
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
object$1 = 32
__$ArrayPad$ = 208
this$ = 240
newobject$ = 248
?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 96					; 00000060H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
object$1 = 32
__$ArrayPad$ = 208
this$ = 240
newobject$ = 248
?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
object$1 = 32
__$ArrayPad$ = 208
this$ = 240
newobject$ = 248
?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR object$1[rbp]
	call	??1UObject@SDK@Core@IronMan@@UEAA@XZ	; IronMan::Core::SDK::UObject::~UObject
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0UObject@SDK@Core@IronMan@@QEAA@AEAPEBX@Z@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
this$ = 48
??0UObject@SDK@Core@IronMan@@QEAA@XZ PROC		; IronMan::Core::SDK::UObject::UObject

; 56   : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7UObject@SDK@Core@IronMan@@6B@
	mov	QWORD PTR [rax], rcx

; 43   : 		ObjectFlags(RF_INVALID),

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+8], -1

; 44   : 		InternalIndex(-1),

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+12], -1

; 45   : 		ClassPrivate(INVALID_POINTER),

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA ; IronMan::Core::SDK::INVALID_POINTER
	mov	QWORD PTR [rax+16], rcx

; 46   : 		EncryptClass(INVALID_POINTER),

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA ; IronMan::Core::SDK::INVALID_POINTER
	mov	QWORD PTR [rax+24], rcx

; 47   : 		NamePrivate(),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??0FName@SDK@Core@IronMan@@QEAA@XZ	; IronMan::Core::SDK::FName::FName

; 48   : 		OuterPrivate(INVALID_POINTER),

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA ; IronMan::Core::SDK::INVALID_POINTER
	mov	QWORD PTR [rax+40], rcx

; 42   : 		:m_self(INVALID_POINTER),

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ?INVALID_POINTER@SDK@Core@IronMan@@3PEAXEA ; IronMan::Core::SDK::INVALID_POINTER
	mov	QWORD PTR [rax+48], rcx

; 55   : 		m_type(UObjectType::EUnknown)

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+56], 10

; 53   : 		m_name(),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 64					; 00000040H
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 54   : 		m_fullName(),

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 56   : 	{

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 49   : 		bCached(false),

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+160], 0

; 50   : 		bAddObject(false),

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+161], 0

; 51   : 		bUseCache(true),

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+162], 1

; 52   : 		bInvalid(false),

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+163], 0

; 57   : 		//WriteLock = std::make_shared<WfirstRWLock>();
; 58   : 	}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0UObject@SDK@Core@IronMan@@QEAA@XZ ENDP		; IronMan::Core::SDK::UObject::UObject
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 64					; 00000040H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 96					; 00000060H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
this$ = 48
?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA PROC ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 128				; 00000080H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0UObject@SDK@Core@IronMan@@QEAA@XZ@4HA ENDP ; `IronMan::Core::SDK::UObject::UObject'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 0
this$ = 32
?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ PROC ; IronMan::Core::SDK::FUObjectItem::IsPendingKill, COMDAT

; 121  : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 122  : 			return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::PendingKill));

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $LN3@IsPendingK
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@IsPendingK
$LN3@IsPendingK:
	mov	DWORD PTR tv67[rsp], 0
$LN4@IsPendingK:
	movzx	eax, BYTE PTR tv67[rsp]

; 123  : 		}

	add	rsp, 24
	ret	0
?IsPendingKill@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ ENDP ; IronMan::Core::SDK::FUObjectItem::IsPendingKill
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.h
;	COMDAT ?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 0
this$ = 32
?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ PROC ; IronMan::Core::SDK::FUObjectItem::IsUnreachable, COMDAT

; 117  : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 118  : 			return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::Unreachable));

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $LN3@IsUnreacha
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@IsUnreacha
$LN3@IsUnreacha:
	mov	DWORD PTR tv67[rsp], 0
$LN4@IsUnreacha:
	movzx	eax, BYTE PTR tv67[rsp]

; 119  : 		}

	add	rsp, 24
	ret	0
?IsUnreachable@FUObjectItem@SDK@Core@IronMan@@QEBA_NXZ ENDP ; IronMan::Core::SDK::FUObjectItem::IsUnreachable
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
?ClearObjectCache@SDK@Core@IronMan@@YAXXZ PROC		; IronMan::Core::SDK::ClearObjectCache

; 33   : 	{

$LN3:
	sub	rsp, 40					; 00000028H

; 34   : 		uNormal = 0;

	mov	DWORD PTR ?uNormal@SDK@Core@IronMan@@3HA, 0

; 35   : 		CacheName.clear();

	lea	rcx, OFFSET FLAT:?CacheName@SDK@Core@IronMan@@3V?$unordered_map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@I@2@U?$equal_to@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	?clear@?$_Hash@V?$_Umap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear

; 36   : 		CacheOuterName.clear();

	lea	rcx, OFFSET FLAT:?CacheOuterName@SDK@Core@IronMan@@3V?$unordered_map@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@_K@2@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@A
	call	?clear@?$_Hash@V?$_Umap_traits@_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@2@V?$allocator@U?$pair@$$CB_KV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<unsigned __int64,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
	npad	1

; 37   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?ClearObjectCache@SDK@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::SDK::ClearObjectCache
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ??__ENAME_None@SDK@Core@IronMan@@YAXXZ
text$di	SEGMENT
??__ENAME_None@SDK@Core@IronMan@@YAXXZ PROC		; IronMan::Core::SDK::`dynamic initializer for 'NAME_None'', COMDAT

; 257  : 	static FName NAME_None = 0;

	sub	rsp, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?NAME_None@SDK@Core@IronMan@@3UFName@123@A
	call	??0FName@SDK@Core@IronMan@@QEAA@H@Z	; IronMan::Core::SDK::FName::FName
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__ENAME_None@SDK@Core@IronMan@@YAXXZ ENDP		; IronMan::Core::SDK::`dynamic initializer for 'NAME_None''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ
_TEXT	SEGMENT
this$ = 48
?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get, COMDAT

; 67   : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 68   : 			return STATIC_Get(encryptedData);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::STATIC_Get

; 69   : 		}

	add	rsp, 40					; 00000028H
	ret	0
?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 6
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAPEAPEAVFNameEntry@234@_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ??0?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 8
encrypt$ = 16
??0?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEAA@_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>, COMDAT

; 53   : 		explicit UEEncryptedObjectProperty(uint64_t encrypt = NULL) :encryptedData(encrypt) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR encrypt$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEAA@_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z
_TEXT	SEGMENT
TempChunks$ = 32
ChunkIndex$ = 40
WithinChunkIndex$ = 44
tv194 = 48
tv78 = 56
tv86 = 64
tv134 = 72
tv142 = 80
tv158 = 88
tv166 = 96
tv176 = 104
tv178 = 112
tv189 = 120
tv191 = 128
Chunk$ = 136
this$ = 160
Index$ = 168
?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z PROC ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetItemPtr, COMDAT

; 97   : 		{

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 98   : 			int32_t ChunkIndex = Index / (int32_t)g_PatternData.ElementsPerChunk;

	mov	eax, DWORD PTR Index$[rsp]
	cdq
	idiv	DWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+168
	mov	DWORD PTR ChunkIndex$[rsp], eax

; 99   : 			int32_t WithinChunkIndex = Index % (int32_t)g_PatternData.ElementsPerChunk;

	mov	eax, DWORD PTR Index$[rsp]
	cdq
	idiv	DWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A+168
	mov	eax, edx
	mov	DWORD PTR WithinChunkIndex$[rsp], eax

; 100  : 			UEEncryptedObjectProperty<ElementType***, DecryptFunc::General> TempChunks;

	xor	edx, edx
	lea	rcx, QWORD PTR TempChunks$[rsp]
	call	??0?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEAA@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>
	npad	1

; 101  : 			if (useCache)

	movzx	eax, BYTE PTR ?useCache@@3_NA		; useCache
	test	eax, eax
	je	SHORT $LN2@GetItemPtr

; 102  : 				GetDMA().ReadCache((ptr_t)&this->Chunks, (ptr_t)&TempChunks, 8);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	r9d, 8
	lea	r8, QWORD PTR TempChunks$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv78[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache
	npad	1
	jmp	SHORT $LN3@GetItemPtr
$LN2@GetItemPtr:

; 103  : 			else
; 104  : 				GetDMA().Read((ptr_t)&this->Chunks, (ptr_t)&TempChunks, 8);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv86[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	r9d, 8
	lea	r8, QWORD PTR TempChunks$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv86[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read
	npad	1
$LN3@GetItemPtr:

; 105  : 			if (!IsAddrValid(TempChunks.Get()))

	lea	rcx, QWORD PTR TempChunks$[rsp]
	call	?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
	cmp	rax, 1048576				; 00100000H
	jb	SHORT $LN5@GetItemPtr
	lea	rcx, QWORD PTR TempChunks$[rsp]
	call	?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
	cmp	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A
	jb	$LN4@GetItemPtr
$LN5@GetItemPtr:

; 106  : 			{
; 107  : 				if (useCache)

	movzx	eax, BYTE PTR ?useCache@@3_NA		; useCache
	test	eax, eax
	je	SHORT $LN6@GetItemPtr

; 108  : 					GetDMA().ReadCache((ptr_t)&this->Unknown, (ptr_t)&TempChunks, 8);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv134[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r9d, 8
	lea	r8, QWORD PTR TempChunks$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv134[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache
	npad	1
	jmp	SHORT $LN7@GetItemPtr
$LN6@GetItemPtr:

; 109  : 				else
; 110  : 					GetDMA().Read((ptr_t)&this->Unknown, (ptr_t)&TempChunks, 8);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv142[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	r9d, 8
	lea	r8, QWORD PTR TempChunks$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv142[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read
	npad	1
$LN7@GetItemPtr:

; 111  : 				if (!IsAddrValid(TempChunks.Get()))

	lea	rcx, QWORD PTR TempChunks$[rsp]
	call	?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
	cmp	rax, 1048576				; 00100000H
	jb	SHORT $LN9@GetItemPtr
	lea	rcx, QWORD PTR TempChunks$[rsp]
	call	?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
	cmp	rax, QWORD PTR ?g_PatternData@Core@IronMan@@3UPatternData@12@A
	jb	SHORT $LN8@GetItemPtr
$LN9@GetItemPtr:

; 112  : 				{
; 113  : 					if (useCache)

	movzx	eax, BYTE PTR ?useCache@@3_NA		; useCache
	test	eax, eax
	je	SHORT $LN10@GetItemPtr

; 114  : 						GetDMA().ReadCache((ptr_t)&this->Unknown2, (ptr_t)&TempChunks, 8);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv158[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	r9d, 8
	lea	r8, QWORD PTR TempChunks$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv158[rsp]
	call	?ReadCache@DMAHandler@IronMan@@QEBAH_K00@Z ; IronMan::DMAHandler::ReadCache
	npad	1
	jmp	SHORT $LN11@GetItemPtr
$LN10@GetItemPtr:

; 115  : 					else
; 116  : 						GetDMA().Read((ptr_t)&this->Unknown2, (ptr_t)&TempChunks, 8);

	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv166[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	r9d, 8
	lea	r8, QWORD PTR TempChunks$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv166[rsp]
	call	?Read@DMAHandler@IronMan@@QEBAH_K00@Z	; IronMan::DMAHandler::Read
	npad	1
$LN11@GetItemPtr:
$LN8@GetItemPtr:
$LN4@GetItemPtr:

; 117  : 				}
; 118  : 			}
; 119  : 			ElementType** Chunk = useCache ? (ElementType**)GetDMA().ReadCache<ptr_t>((ptr_t)TempChunks.Get() + ChunkIndex * 8)

	movzx	eax, BYTE PTR ?useCache@@3_NA		; useCache
	test	eax, eax
	je	SHORT $LN13@GetItemPtr
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv178[rsp], rax
	lea	rcx, QWORD PTR TempChunks$[rsp]
	call	?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
	mov	ecx, DWORD PTR ChunkIndex$[rsp]
	shl	ecx, 3
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR tv176[rsp], rax
	mov	rdx, QWORD PTR tv176[rsp]
	mov	rcx, QWORD PTR tv178[rsp]
	call	??$ReadCache@_K@DMAHandler@IronMan@@QEAA_K_K@Z ; IronMan::DMAHandler::ReadCache<unsigned __int64>
	mov	QWORD PTR tv194[rsp], rax
	jmp	SHORT $LN14@GetItemPtr
$LN13@GetItemPtr:
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv191[rsp], rax
	lea	rcx, QWORD PTR TempChunks$[rsp]
	call	?Get@?$UEEncryptedObjectProperty@PEAPEAPEAVFNameEntry@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAPEAPEAVFNameEntry@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::FNameEntry * * *,6>::Get
	mov	ecx, DWORD PTR ChunkIndex$[rsp]
	shl	ecx, 3
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR tv189[rsp], rax
	mov	rdx, QWORD PTR tv189[rsp]
	mov	rcx, QWORD PTR tv191[rsp]
	call	??$Read@_K@DMAHandler@IronMan@@QEAA_K_K@Z ; IronMan::DMAHandler::Read<unsigned __int64>
	mov	QWORD PTR tv194[rsp], rax
$LN14@GetItemPtr:
	mov	rax, QWORD PTR tv194[rsp]
	mov	QWORD PTR Chunk$[rsp], rax

; 120  : 				: (ElementType**)GetDMA().Read<ptr_t>((ptr_t)TempChunks.Get() + ChunkIndex * 8);
; 121  : 			return Chunk + WithinChunkIndex;

	movsxd	rax, DWORD PTR WithinChunkIndex$[rsp]
	mov	rcx, QWORD PTR Chunk$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]

; 122  : 		}

	add	rsp, 152				; 00000098H
	ret	0
?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z ENDP ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetItemPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z
_TEXT	SEGMENT
tv90 = 32
tv73 = 40
tv75 = 48
tv85 = 56
tv87 = 64
$T1 = 72
$T2 = 80
$T3 = 224
__$ArrayPad$ = 368
this$ = 416
__$ReturnUdt$ = 424
index$ = 432
?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z PROC ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetById, COMDAT

; 91   : 		{

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 392				; 00000188H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 92   : 			return useCache ? GetDMA().ReadCache<ElementType>((ptr_t)GetPtrById(index)) : GetDMA().Read<ElementType>((ptr_t)GetPtrById(index));

	movzx	eax, BYTE PTR ?useCache@@3_NA		; useCache
	test	eax, eax
	je	SHORT $LN3@GetById
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv75[rsp], rax
	mov	edx, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetPtrById
	mov	QWORD PTR tv73[rsp], rax
	mov	r8, QWORD PTR tv73[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$ReadCache@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry>
	mov	QWORD PTR tv90[rsp], rax
	jmp	SHORT $LN4@GetById
$LN3@GetById:
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv87[rsp], rax
	mov	edx, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetPtrById
	mov	QWORD PTR tv85[rsp], rax
	mov	r8, QWORD PTR tv85[rsp]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	??$Read@VFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAA?AVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry>
	mov	QWORD PTR tv90[rsp], rax
$LN4@GetById:
	mov	rax, QWORD PTR tv90[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR $T1[rsp]
	mov	ecx, 144				; 00000090H
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 93   : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 392				; 00000188H
	pop	rdi
	pop	rsi
	ret	0
?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z ENDP ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetById
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z
_TEXT	SEGMENT
tv88 = 32
tv72 = 40
tv74 = 48
tv83 = 56
tv85 = 64
this$ = 96
index$ = 104
?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z PROC ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetPtrById, COMDAT

; 86   : 		{

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 87   : 			return useCache ? GetDMA().ReadCache<ElementType*>((ptr_t)GetItemPtr(index)) : GetDMA().Read<ElementType*>((ptr_t)GetItemPtr(index));

	movzx	eax, BYTE PTR ?useCache@@3_NA		; useCache
	test	eax, eax
	je	SHORT $LN3@GetPtrById
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv74[rsp], rax
	mov	edx, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetItemPtr
	mov	QWORD PTR tv72[rsp], rax
	mov	rdx, QWORD PTR tv72[rsp]
	mov	rcx, QWORD PTR tv74[rsp]
	call	??$ReadCache@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::ReadCache<IronMan::Core::SDK::FNameEntry *>
	mov	QWORD PTR tv88[rsp], rax
	jmp	SHORT $LN4@GetPtrById
$LN3@GetPtrById:
	call	?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ	; IronMan::GetDMA
	mov	QWORD PTR tv85[rsp], rax
	mov	edx, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?GetItemPtr@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@AEBAPEAPEAVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetItemPtr
	mov	QWORD PTR tv83[rsp], rax
	mov	rdx, QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR tv85[rsp]
	call	??$Read@PEAVFNameEntry@SDK@Core@IronMan@@@DMAHandler@IronMan@@QEAAPEAVFNameEntry@SDK@Core@1@_K@Z ; IronMan::DMAHandler::Read<IronMan::Core::SDK::FNameEntry *>
	mov	QWORD PTR tv88[rsp], rax
$LN4@GetPtrById:
	mov	rax, QWORD PTR tv88[rsp]

; 88   : 		}

	add	rsp, 88					; 00000058H
	ret	0
?GetPtrById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBAPEAVFNameEntry@234@H@Z ENDP ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetPtrById
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ
_TEXT	SEGMENT
this$ = 48
??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::operator->, COMDAT

; 71   : 		ElementType operator->() const { return Get(); }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::Get
	add	rsp, 40					; 00000028H
	ret	0
??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ
_TEXT	SEGMENT
this$ = 48
?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::Get, COMDAT

; 67   : 		{

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 68   : 			return STATIC_Get(encryptedData);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::STATIC_Get

; 69   : 		}

	add	rsp, 40					; 00000028H
	ret	0
?Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@XZ ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z
_TEXT	SEGMENT
$T1 = 32
func$ = 40
tv81 = 48
enData$ = 80
?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z PROC ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::STATIC_Get, COMDAT

; 56   : 		{

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 57   : 			DECRYPT_FUNC func = reinterpret_cast<DECRYPT_FUNC>(g_DecryptFuncs[Func]->GetFunction());

	mov	DWORD PTR $T1[rsp], 6
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?g_DecryptFuncs@SDK@Core@IronMan@@3V?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@A ; IronMan::Core::SDK::g_DecryptFuncs
	call	??A?$unordered_map@W4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@U?$hash@W4DecryptFunc@SDK@Core@IronMan@@@6@U?$equal_to@W4DecryptFunc@SDK@Core@IronMan@@@6@V?$allocator@U?$pair@$$CBW4DecryptFunc@SDK@Core@IronMan@@V?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@@std@@@6@@std@@QEAAAEAV?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@1@$$QEAW4DecryptFunc@SDK@Core@IronMan@@@Z ; std::unordered_map<enum IronMan::Core::SDK::DecryptFunc,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >,std::hash<enum IronMan::Core::SDK::DecryptFunc>,std::equal_to<enum IronMan::Core::SDK::DecryptFunc>,std::allocator<std::pair<enum IronMan::Core::SDK::DecryptFunc const ,std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> > > > >::operator[]
	mov	rcx, rax
	call	??C?$unique_ptr@VUEDecryptBuilder@SDK@Core@IronMan@@U?$default_delete@VUEDecryptBuilder@SDK@Core@IronMan@@@std@@@std@@QEBAPEAVUEDecryptBuilder@SDK@Core@IronMan@@XZ ; std::unique_ptr<IronMan::Core::SDK::UEDecryptBuilder,std::default_delete<IronMan::Core::SDK::UEDecryptBuilder> >::operator->
	mov	rcx, rax
	call	?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
	mov	QWORD PTR func$[rsp], rax

; 58   : 			if (!func || !enData || Utils::IsSafeReadPtr(func, 1))

	cmp	QWORD PTR func$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	cmp	QWORD PTR enData$[rsp], 0
	je	SHORT $LN3@STATIC_Get
	mov	edx, 1
	mov	rcx, QWORD PTR func$[rsp]
	call	?IsSafeReadPtr@Utils@IronMan@@YA_NPEAX_K@Z ; IronMan::Utils::IsSafeReadPtr
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@STATIC_Get
$LN3@STATIC_Get:

; 59   : 				return (ElementType)(uint64_t)0;

	xor	eax, eax
	jmp	SHORT $LN1@STATIC_Get
$LN2@STATIC_Get:

; 60   : 			return (ElementType)func(enData);

	mov	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR tv81[rsp], rax
	mov	rcx, QWORD PTR enData$[rsp]
	call	QWORD PTR tv81[rsp]
$LN1@STATIC_Get:

; 61   : 		}

	add	rsp, 72					; 00000048H
	ret	0
?STATIC_Get@?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@SAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@234@_K@Z ENDP ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::STATIC_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = 32
tv76 = 36
tv78 = 40
$T2 = 48
__$ArrayPad$ = 192
this$ = 224
__$ReturnUdt$ = 232
?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; IronMan::Core::SDK::FName::GetName, COMDAT

; 197  : 		{

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 198  : 			if (ComparisonIndex >= 0)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jl	SHORT $LN2@GetName

; 199  : 			{
; 200  : 				return GlobalNames->GetById(ComparisonIndex).GetAnsiName();

	lea	rcx, OFFSET FLAT:?GlobalNames@SDK@Core@IronMan@@3U?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@123@A ; IronMan::Core::SDK::GlobalNames
	call	??C?$UEEncryptedObjectProperty@PEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@$05@SDK@Core@IronMan@@QEBAPEAV?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@123@XZ ; IronMan::Core::SDK::UEEncryptedObjectProperty<IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152> *,6>::operator->
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv76[rsp], eax
	mov	r8d, DWORD PTR tv76[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?GetById@?$TStaticIndirectArrayThreadSafeRead@VFNameEntry@SDK@Core@IronMan@@$0CAAAAA@@SDK@Core@IronMan@@QEBA?AVFNameEntry@234@H@Z ; IronMan::Core::SDK::TStaticIndirectArrayThreadSafeRead<IronMan::Core::SDK::FNameEntry,2097152>::GetById
	mov	rcx, rax
	call	?GetAnsiName@FNameEntry@SDK@Core@IronMan@@QEBAPEBDXZ ; IronMan::Core::SDK::FNameEntry::GetAnsiName
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@GetName
$LN2@GetName:

; 201  : 			}
; 202  : 			return "Unknown";

	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@GetName:

; 203  : 		};

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 216				; 000000d8H
	ret	0
	int	3
?GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; IronMan::Core::SDK::FName::GetName
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv76 = 36
tv78 = 40
$T2 = 48
__$ArrayPad$ = 192
this$ = 224
__$ReturnUdt$ = 232
?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `IronMan::Core::SDK::FName::GetName'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetName@FName@SDK@Core@IronMan@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `IronMan::Core::SDK::FName::GetName'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ??0FName@SDK@Core@IronMan@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??0FName@SDK@Core@IronMan@@QEAA@H@Z PROC		; IronMan::Core::SDK::FName::FName, COMDAT

; 161  : 		{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 159  : 			: ComparisonIndex(i),

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rax], ecx

; 160  : 			Number(0)

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0

; 162  : 		};

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FName@SDK@Core@IronMan@@QEAA@H@Z ENDP		; IronMan::Core::SDK::FName::FName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ??0FName@SDK@Core@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0FName@SDK@Core@IronMan@@QEAA@XZ PROC			; IronMan::Core::SDK::FName::FName, COMDAT

; 155  : 		{

	mov	QWORD PTR [rsp+8], rcx

; 153  : 			: ComparisonIndex(0),

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 154  : 			Number(0)

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+4], 0

; 156  : 		};

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0FName@SDK@Core@IronMan@@QEAA@XZ ENDP			; IronMan::Core::SDK::FName::FName
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UnrealNames.h
;	COMDAT ?GetAnsiName@FNameEntry@SDK@Core@IronMan@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?GetAnsiName@FNameEntry@SDK@Core@IronMan@@QEBAPEBDXZ PROC ; IronMan::Core::SDK::FNameEntry::GetAnsiName, COMDAT

; 33   : 		{

	mov	QWORD PTR [rsp+8], rcx

; 34   : 			return AnsiName;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16

; 35   : 		}

	ret	0
?GetAnsiName@FNameEntry@SDK@Core@IronMan@@QEBAPEBDXZ ENDP ; IronMan::Core::SDK::FNameEntry::GetAnsiName
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z PROC	; IronMan::Core::SDK::UEDecryptBuilder::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1UEDecryptBuilder@SDK@Core@IronMan@@QEAA@XZ ; IronMan::Core::SDK::UEDecryptBuilder::~UEDecryptBuilder
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_GUEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAXI@Z ENDP	; IronMan::Core::SDK::UEDecryptBuilder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\UEncrypt.h
;	COMDAT ?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ PROC ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction, COMDAT

; 34   : 		inline uint8_t* GetFunction() { return functionBuf; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	ret	0
?GetFunction@UEDecryptBuilder@SDK@Core@IronMan@@QEAAPEAEXZ ENDP ; IronMan::Core::SDK::UEDecryptBuilder::GetFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
$T1 = 32
endata$ = 64
dedata$ = 72
?CacheDecryptData@SDK@Core@IronMan@@YAX_K0@Z PROC	; IronMan::Core::SDK::CacheDecryptData

; 28   : 	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 29   : 		DecryptCache.emplace(endata, dedata);

	lea	r9, QWORD PTR dedata$[rsp]
	lea	r8, QWORD PTR endata$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?DecryptCache@SDK@Core@IronMan@@3V?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@A ; IronMan::Core::SDK::DecryptCache
	call	??$emplace@AEA_KAEA_K@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@_N@1@AEA_K0@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::emplace<unsigned __int64 &,unsigned __int64 &>
	npad	1

; 30   : 	}

	add	rsp, 56					; 00000038H
	ret	0
?CacheDecryptData@SDK@Core@IronMan@@YAX_K0@Z ENDP	; IronMan::Core::SDK::CacheDecryptData
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\SDK\CoreUObject\Object.cpp
_TEXT	SEGMENT
cache$ = 32
$T1 = 40
encryptData$ = 64
outData$ = 72
?DecryptDataByCache@SDK@Core@IronMan@@YA_N_KAEA_K@Z PROC ; IronMan::Core::SDK::DecryptDataByCache

; 17   : 	{

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 18   : 		auto cache = DecryptCache.find(encryptData);

	lea	r8, QWORD PTR encryptData$[rsp]
	lea	rdx, QWORD PTR cache$[rsp]
	lea	rcx, OFFSET FLAT:?DecryptCache@SDK@Core@IronMan@@3V?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@A ; IronMan::Core::SDK::DecryptCache
	call	??$find@X@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@1@AEB_K@Z ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::find<void>
	npad	1

; 19   : 		if (cache != DecryptCache.end())

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, OFFSET FLAT:?DecryptCache@SDK@Core@IronMan@@3V?$unordered_map@_K_KU?$hash@_K@std@@U?$equal_to@_K@2@V?$allocator@U?$pair@$$CB_K_K@std@@@2@@std@@A ; IronMan::Core::SDK::DecryptCache
	call	?end@?$_Hash@V?$_Umap_traits@_K_KV?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@V?$allocator@U?$pair@$$CB_K_K@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<unsigned __int64,unsigned __int64,std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >,std::allocator<std::pair<unsigned __int64 const ,unsigned __int64> >,0> >::end
	mov	rdx, rax
	lea	rcx, QWORD PTR cache$[rsp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@DecryptDat

; 20   : 		{
; 21   : 			outData = cache->second;

	lea	rcx, QWORD PTR cache$[rsp]
	call	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CB_K_K@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CB_K_K@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<unsigned __int64 const ,unsigned __int64> > > >::operator->
	mov	rcx, QWORD PTR outData$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax

; 22   : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@DecryptDat
$LN2@DecryptDat:

; 23   : 		}
; 24   : 		return false;

	xor	al, al
$LN1@DecryptDat:

; 25   : 	}

	add	rsp, 56					; 00000038H
	ret	0
?DecryptDataByCache@SDK@Core@IronMan@@YA_N_KAEA_K@Z ENDP ; IronMan::Core::SDK::DecryptDataByCache
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$forward@_K@std@@YA$$QEA_KAEA_K@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_K@std@@YA$$QEA_KAEA_K@Z PROC		; std::forward<unsigned __int64>, COMDAT

; 1527 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1528 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1529 : }

	ret	0
??$forward@_K@std@@YA$$QEA_KAEA_K@Z ENDP		; std::forward<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEBAAEBU?$hash@_K@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ PROC ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@_K@std@@M$00@std@@QEBAAEBU?$equal_to@_K@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z
_TEXT	SEGMENT
_Keyval$ = 48
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z PROC		; std::hash<unsigned __int64>::_Do_hash, COMDAT

; 2355 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2356 :         return _Hash_representation(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	??$_Hash_representation@_K@std@@YA_KAEB_K@Z ; std::_Hash_representation<unsigned __int64>

; 2357 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z ENDP		; std::hash<unsigned __int64>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z PROC ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator(), COMDAT

; 2337 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2338 :         return hash<_Kty>::_Do_hash(_Keyval);

	mov	rcx, QWORD PTR _Keyval$[rsp]
	call	?_Do_hash@?$hash@_K@std@@SA_KAEB_K@Z	; std::hash<unsigned __int64>::_Do_hash

; 2339 :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$_Conditionally_enabled_hash@_K$00@std@@QEBA_KAEB_K@Z ENDP ; std::_Conditionally_enabled_hash<unsigned __int64,1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
this$ = 32
_Left$ = 40
_Right$ = 48
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z PROC		; std::equal_to<unsigned __int64>::operator(), COMDAT

; 634  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 635  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv65[rsp]

; 636  :     }

	add	rsp, 24
	ret	0
??R?$equal_to@_K@std@@QEBA_NAEB_K0@Z ENDP		; std::equal_to<unsigned __int64>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size, COMDAT

; 164  :     _NODISCARD const float& _Get_max_bucket_size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 165  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 166  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size, COMDAT

; 160  :     _NODISCARD float& _Get_max_bucket_size() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 161  :         return _Mypair._Myval2._Myval2;

	mov	rax, QWORD PTR this$[rsp]

; 162  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xhash
;	COMDAT ??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 36
tv75 = 40
this$ = 64
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >, COMDAT

; 137  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv75[rsp], rax
	xorps	xmm0, xmm0
	movss	DWORD PTR $T3[rsp], xmm0
	lea	r9, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	movzx	edx, BYTE PTR $T2[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@_K@std@@V?$_Compressed_pair@U?$equal_to@_K@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1>::_Compressed_pair<std::hash<unsigned __int64>,std::_Compressed_pair<std::equal_to<unsigned __int64>,float,1>,1><std::_Zero_then_variadic_args_t,float>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$_Uhash_compare@_KU?$hash@_K@std@@U?$equal_to@_K@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >::_Uhash_compare<unsigned __int64,std::hash<unsigned __int64>,std::equal_to<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ
_TEXT	SEGMENT
?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ PROC		; IronMan::GetDMA, COMDAT

; 312  : 	inline DMAHandler& GetDMA() { return DMAHandler::Instance(); };

$LN3:
	sub	rsp, 40					; 00000028H
	call	?Instance@DMAHandler@IronMan@@SAAEAV12@XZ ; IronMan::DMAHandler::Instance
	add	rsp, 40					; 00000028H
	ret	0
?GetDMA@IronMan@@YAAEAVDMAHandler@1@XZ ENDP		; IronMan::GetDMA
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
text$yd	SEGMENT
??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A ; IronMan::DMAHandler::processInfo
	call	??1BaseProcessInfo@IronMan@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ
text$di	SEGMENT
??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::processInfo'', COMDAT

; 116  : 		static inline BaseProcessInfo processInfo{};

	push	rdi
	sub	rsp, 32					; 00000020H

; 92   : 		DWORD pid = 0;

	mov	DWORD PTR ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A, 0

; 116  : 		static inline BaseProcessInfo processInfo{};

	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+40
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 93   : 		std::string name;
; 94   : 		const wchar_t* wname;
; 95   : 		ptr_t base = 0;

	mov	QWORD PTR ?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+48, 0

; 116  : 		static inline BaseProcessInfo processInfo{};

	lea	rcx, OFFSET FLAT:??__F?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::processInfo''
	call	atexit
	npad	1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::processInfo''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'IronMan::DMAHandler::processInfo'''::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, OFFSET FLAT:?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A+8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???__E?processInfo@DMAHandler@IronMan@@0UBaseProcessInfo@2@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'IronMan::DMAHandler::processInfo'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterReadArray
	call	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::ScatterReadArray'', COMDAT

; 114  : 		static inline std::shared_ptr<std::unordered_map<void*, std::vector<ScatterStruct>>>ScatterReadArray;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:??__F?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterReadArray''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?ScatterReadArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::ScatterReadArray''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A ; IronMan::DMAHandler::ScatterWriteArray
	call	??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::ScatterWriteArray'', COMDAT

; 113  : 		static inline std::shared_ptr < std::unordered_map<void*, std::vector<ScatterStruct>>>ScatterWriteArray;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:??__F?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'IronMan::DMAHandler::ScatterWriteArray''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?ScatterWriteArray@DMAHandler@IronMan@@0V?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::ScatterWriteArray''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >, COMDAT

; 1681 :     ~shared_ptr() noexcept { // release resource

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1682 :         this->_Decref();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
	npad	1

; 1683 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$shared_ptr@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::~shared_ptr<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ PROC ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref, COMDAT

; 1375 :     void _Decref() noexcept { // decrement reference count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1376 :         if (_Rep) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@Decref

; 1377 :             _Rep->_Decref();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?_Decref@_Ref_count_base@std@@QEAAXXZ	; std::_Ref_count_base::_Decref
	npad	1
$LN2@Decref:

; 1378 :         }
; 1379 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decref@?$_Ptr_base@V?$unordered_map@PEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@U?$hash@PEAX@2@U?$equal_to@PEAX@2@V?$allocator@U?$pair@QEAXV?$vector@UScatterStruct@IronMan@@V?$allocator@UScatterStruct@IronMan@@@std@@@std@@@std@@@2@@std@@@std@@IEAAXXZ ENDP ; std::_Ptr_base<std::unordered_map<void *,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void * const,std::vector<IronMan::ScatterStruct,std::allocator<IronMan::ScatterStruct> > > > > >::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Core\DMA\DMAHandler.h
;	COMDAT ??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ
text$di	SEGMENT
??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ PROC ; `dynamic initializer for 'IronMan::DMAHandler::UpdateStartTime'', COMDAT

; 107  : 		static inline std::chrono::time_point<std::chrono::system_clock> UpdateStartTime = std::chrono::system_clock::now();

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A ; IronMan::DMAHandler::UpdateStartTime
	call	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__E?UpdateStartTime@DMAHandler@IronMan@@0V?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'IronMan::DMAHandler::UpdateStartTime''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1BaseProcessInfo@IronMan@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1BaseProcessInfo@IronMan@@QEAA@XZ PROC		; IronMan::BaseProcessInfo::~BaseProcessInfo, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1BaseProcessInfo@IronMan@@QEAA@XZ ENDP		; IronMan::BaseProcessInfo::~BaseProcessInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA PROC	; `IronMan::BaseProcessInfo::~BaseProcessInfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1BaseProcessInfo@IronMan@@QEAA@XZ@4HA ENDP	; `IronMan::BaseProcessInfo::~BaseProcessInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>, COMDAT

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_chrono.hpp
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT

; 212  :         constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 213  :             : _MyDur(_Other) {}

	mov	rax, QWORD PTR _Other$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 88   :         _NODISCARD static time_point now() noexcept { // get current time

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 89   :             return time_point(duration(_Xtime_get_ticks()));

	call	_Xtime_get_ticks
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,0>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 90   :         }

	add	rsp, 56					; 00000038H
	ret	0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Esslinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Esslinit_@detail@httplib@@YAXXZ PROC		; httplib::detail::`dynamic initializer for 'sslinit_'', COMDAT

; 8802 :         static SSLInit sslinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?sslinit_@detail@httplib@@3VSSLInit@12@A
	call	??0SSLInit@detail@httplib@@QEAA@XZ	; httplib::detail::SSLInit::SSLInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Esslinit_@detail@httplib@@YAXXZ ENDP		; httplib::detail::`dynamic initializer for 'sslinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0SSLInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0SSLInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::SSLInit::SSLInit, COMDAT

; 8693 :             SSLInit() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8694 :                 OPENSSL_init_ssl(

	xor	edx, edx
	mov	ecx, 2097154				; 00200002H
	call	OPENSSL_init_ssl
	npad	1

; 8695 :                     OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
; 8696 :             }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0SSLInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::SSLInit::SSLInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fwsinit_@detail@httplib@@YAXXZ
text$yd	SEGMENT
??__Fwsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic atexit destructor for 'wsinit_'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??1WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::~WSInit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Fwsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic atexit destructor for 'wsinit_''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??__Ewsinit_@detail@httplib@@YAXXZ
text$di	SEGMENT
??__Ewsinit_@detail@httplib@@YAXXZ PROC			; httplib::detail::`dynamic initializer for 'wsinit_'', COMDAT

; 5291 :         static WSInit wsinit_;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?wsinit_@detail@httplib@@3VWSInit@12@A
	call	??0WSInit@detail@httplib@@QEAA@XZ	; httplib::detail::WSInit::WSInit
	lea	rcx, OFFSET FLAT:??__Fwsinit_@detail@httplib@@YAXXZ ; httplib::detail::`dynamic atexit destructor for 'wsinit_''
	call	atexit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??__Ewsinit_@detail@httplib@@YAXXZ ENDP			; httplib::detail::`dynamic initializer for 'wsinit_''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??1WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::~WSInit, COMDAT

; 5284 :             ~WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 5285 :                 if (is_valid_) WSACleanup();

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN2@WSInit
	call	QWORD PTR __imp_WSACleanup
	npad	1
$LN2@WSInit:

; 5286 :             }

	add	rsp, 40					; 00000028H
	ret	0
??1WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::~WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\c++\paoda\Helper\HttpLib\httplib.h
;	COMDAT ??0WSInit@detail@httplib@@QEAA@XZ
_TEXT	SEGMENT
wsaData$ = 32
__$ArrayPad$ = 448
this$ = 480
??0WSInit@detail@httplib@@QEAA@XZ PROC			; httplib::detail::WSInit::WSInit, COMDAT

; 5279 :             WSInit() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5283 : 
; 5284 :             ~WSInit() {
; 5285 :                 if (is_valid_) WSACleanup();
; 5286 :             }
; 5287 : 
; 5288 :             bool is_valid_ = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 5280 :                 WSADATA wsaData;
; 5281 :                 if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;

	lea	rdx, QWORD PTR wsaData$[rsp]
	mov	cx, 2
	call	QWORD PTR __imp_WSAStartup
	test	eax, eax
	jne	SHORT $LN2@WSInit
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@WSInit:

; 5282 :             }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	ret	0
??0WSInit@detail@httplib@@QEAA@XZ ENDP			; httplib::detail::WSInit::WSInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3209 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 3210 :     return _STD move(_Left.append(_Right));

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	rcx, rax
	call	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3211 : }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3178 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 3179 :     return _STD move(_Left.append(_Right));

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	rcx, rax
	call	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 3180 : }

	add	rsp, 56					; 00000038H
	ret	0
	int	3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1538 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1540 : }

	ret	0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 102  : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ??$_Hash_representation@I@std@@YA_KAEBI@Z
_TEXT	SEGMENT
_Keyval$ = 48
??$_Hash_representation@I@std@@YA_KAEBI@Z PROC		; std::_Hash_representation<unsigned int>, COMDAT

; 2316 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2317 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	rdx, QWORD PTR _Keyval$[rsp]
	mov	rcx, -3750763034362895579		; cbf29ce484222325H
	call	??$_Fnv1a_append_value@I@std@@YA_K_KAEBI@Z ; std::_Fnv1a_append_value<unsigned int>

; 2318 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Hash_representation@I@std@@YA_KAEBI@Z ENDP		; std::_Hash_representation<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xbit_ops.h
;	COMDAT ?_Ceiling_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Value$ = 48
?_Ceiling_of_log_2@std@@YAK_K@Z PROC			; std::_Ceiling_of_log_2, COMDAT

; 51   : _NODISCARD inline unsigned long _Ceiling_of_log_2(const size_t _Value) noexcept { // returns ceil(log_2(_Value))

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 52   :                                                                                   // pre: _Value > 1
; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	mov	rax, QWORD PTR _Value$[rsp]
	dec	rax
	mov	rcx, rax
	call	?_Floor_of_log_2@std@@YAK_K@Z		; std::_Floor_of_log_2
	inc	eax

; 54   : }

	add	rsp, 40					; 00000028H
	ret	0
?_Ceiling_of_log_2@std@@YAK_K@Z ENDP			; std::_Ceiling_of_log_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xbit_ops.h
;	COMDAT ?_Floor_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Result$ = 0
_Value$ = 32
?_Floor_of_log_2@std@@YAK_K@Z PROC			; std::_Floor_of_log_2, COMDAT

; 24   : _NODISCARD inline unsigned long _Floor_of_log_2(size_t _Value) noexcept { // returns floor(log_2(_Value))

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	mov	rax, QWORD PTR _Value$[rsp]
	or	rax, 1
	mov	QWORD PTR _Value$[rsp], rax

; 26   :     unsigned long _Result;
; 27   : 
; 28   : #ifdef _M_CEE_PURE
; 29   : #ifdef _WIN64
; 30   :     _Result = 63;
; 31   : #else // ^^^ 64-bit / 32-bit vvv
; 32   :     _Result = 31;
; 33   : #endif // ^^^ 32-bit ^^^
; 34   : 
; 35   :     while ((size_t{1} << _Result) > _Value) {
; 36   :         --_Result;
; 37   :     }
; 38   : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 39   : #ifdef _WIN64
; 40   :     // CodeQL [SM02313] _Result is always initialized: the code above guarantees that _Value is non-zero.
; 41   :     _BitScanReverse64(&_Result, _Value);

	mov	rax, QWORD PTR _Value$[rsp]
	bsr	rax, rax
	mov	DWORD PTR _Result$[rsp], eax

; 42   : #else // ^^^ 64-bit / 32-bit vvv
; 43   :     // CodeQL [SM02313] _Result is always initialized: the code above guarantees that _Value is non-zero.
; 44   :     _BitScanReverse(&_Result, _Value);
; 45   : #endif // ^^^ 32-bit ^^^
; 46   : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 47   : 
; 48   :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 49   : }

	add	rsp, 24
	ret	0
?_Floor_of_log_2@std@@YAK_K@Z ENDP			; std::_Floor_of_log_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decwref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT

; 1165 :     void _Decwref() noexcept { // decrement weak reference count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1166 :         if (_MT_DECR(_Weaks) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 12
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decwref

; 1167 :             _Delete_this();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+8]
	npad	1
$LN2@Decwref:

; 1168 :         }
; 1169 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decwref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT

; 1158 :     void _Decref() noexcept { // decrement use count

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1159 :         if (_MT_DECR(_Uses) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decref

; 1160 :             _Destroy();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax]

; 1161 :             _Decwref();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decwref@_Ref_count_base@std@@QEAAXXZ	; std::_Ref_count_base::_Decwref
	npad	1
$LN2@Decref:

; 1162 :         }
; 1163 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Decref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA PROC ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ@4HA ENDP ; `std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1538 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1539 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1534 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1535 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1536 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3074 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3075 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3076 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3070 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3071 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3072 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 32
this$ = 64
_Right$ = 72
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 3066 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3067 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv79[rsp]
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
	npad	1

; 3068 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3045 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3046 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
	npad	1

; 3047 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3048 :             _ASAN_STRING_REMOVE(*this);
; 3049 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3050 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+24]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3051 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3052 :         }
; 3053 : 
; 3054 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3058 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2954 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2955 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 2956 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2941 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2944 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2948 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2952 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT

; 2798 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T2[rsp], 0

; 2799 :         // return [_Off, _Off + _Count) as new string, default-constructing its allocator
; 2800 :         return basic_string{*this, _Off, _Count};

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Count$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 2801 :     }

	add	rsp, 72					; 00000048H
	ret	0
	int	3
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 52
this$ = 80
__$ReturnUdt$ = 88
_Off$ = 96
_Count$ = 104
?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z
_TEXT	SEGMENT
tv79 = 32
tv77 = 40
this$ = 64
_Ch$ = 72
_Off$ = 80
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT

; 2626 :     _NODISCARD _CONSTEXPR20 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2627 :         // look for _Ch before _Off
; 2628 :         return static_cast<size_type>(

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv77[rsp], rax
	movzx	r9d, BYTE PTR _Ch$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv79[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$_Traits_rfind_ch@U?$char_traits@D@std@@@std@@YA_KQEBD_K1D@Z ; std::_Traits_rfind_ch<std::char_traits<char> >

; 2629 :             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
; 2630 :     }

	add	rsp, 56					; 00000038H
	ret	0
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
_TEXT	SEGMENT
tv84 = 48
tv82 = 56
tv80 = 64
this$ = 96
_Ptr$ = 104
_Off$ = 112
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 2583 :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2584 :         // look for [_Ptr, <null>) beginning at or after _Off
; 2585 :         return static_cast<size_type>(_Traits_find<_Traits>(

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	QWORD PTR tv84[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv82[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR tv84[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR tv82[rsp]
	mov	rcx, QWORD PTR tv80[rsp]
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >

; 2586 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 2587 :     }

	add	rsp, 88					; 00000058H
	ret	0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 2457 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2458 :         return _Mypair._Myval2._Mysize == 0;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv68[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv68[rsp]

; 2459 :     }

	add	rsp, 24
	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2349 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2350 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2351 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2352 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2353 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2354 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2355 :         );
; 2356 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2327 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2328 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2329 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Old_ptr$3 = 40
this$ = 64
_Ptr$ = 72
_Count$ = 80
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Count$[rsp], rax
	ja	SHORT $LN2@assign

; 1595 :             _ASAN_STRING_REMOVE(*this);
; 1596 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1597 :             _Mypair._Myval2._Mysize = _Count;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 1598 :             _Traits::move(_Old_ptr, _Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1600 :             _ASAN_STRING_CREATE(*this);
; 1601 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@assign
$LN2@assign:

; 1602 :         }
; 1603 : 
; 1604 :         return _Reallocate_for(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	r9, QWORD PTR _Ptr$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
$LN1@assign:

; 1605 :             _Count,
; 1606 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) _STATIC_CALL_OPERATOR {
; 1607 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1509 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1510 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1511 :     }

	add	rsp, 40					; 00000028H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Ptr$ = 104
_Count$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1486 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 1487 :         // append [_Ptr, _Ptr + _Count)
; 1488 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 1489 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 1490 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1492 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 1493 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 1494 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1495 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 1496 :         }
; 1497 : 
; 1498 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
$LN1@append:

; 1499 :             _Count,
; 1500 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1501 :                 const size_type _Count) _STATIC_CALL_OPERATOR {
; 1502 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1503 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1505 :             },
; 1506 :             _Ptr, _Count);
; 1507 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
tv78 = 32
tv76 = 40
this$ = 64
_Right$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1458 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1459 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv78[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv76[rsp], rax
	mov	r8, QWORD PTR tv78[rsp]
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1460 :     }

	add	rsp, 56					; 00000038H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 1449 :     _CONSTEXPR20 basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1450 :         return append(_Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1451 :     }

	add	rsp, 40					; 00000028H
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 1438 :     _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1439 :         return append(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1440 :     }

	add	rsp, 40					; 00000028H
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
_Right_al$ = 32
_Al$ = 40
tv87 = 48
tv85 = 56
this$ = 80
_Right$ = 88
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 1370 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1371 :         if (this == _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	cmp	QWORD PTR this$[rsp], rax
	jne	SHORT $LN2@operator

; 1372 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 1373 :         }
; 1374 : 
; 1375 :         auto& _Al             = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1376 :         const auto& _Right_al = _Right._Getal();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Right_al$[rsp], rax

; 1377 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1378 :             if (_Al != _Right_al) {
; 1379 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 1380 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 1381 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 1382 : 
; 1383 :                 const size_type _Right_size   = _Right._Mypair._Myval2._Mysize;
; 1384 :                 const _Elem* const _Right_ptr = _Right._Mypair._Myval2._Myptr();
; 1385 :                 if (_Right_size > _Small_string_capacity) {
; 1386 :                     size_type _New_capacity = _Calculate_growth(_Right_size, _Small_string_capacity, _Right.max_size());
; 1387 :                     auto _Right_al_non_const = _Right_al;
; 1388 :                     const pointer _New_ptr   = _Allocate_for_capacity(_Right_al_non_const, _New_capacity); // throws
; 1389 :                     _Traits::copy(_Unfancy(_New_ptr), _Right_ptr, _Right_size + 1);
; 1390 : 
; 1391 :                     _Tidy_deallocate();
; 1392 :                     _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
; 1393 :                     _Mypair._Myval2._Mysize = _Right_size;
; 1394 :                     _Mypair._Myval2._Myres  = _New_capacity;
; 1395 :                     _ASAN_STRING_CREATE(*this);
; 1396 :                 } else {
; 1397 :                     _Tidy_deallocate();
; 1398 :                     _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right_ptr, _Right_size + 1);
; 1399 :                     _Mypair._Myval2._Mysize = _Right_size;
; 1400 :                     _Mypair._Myval2._Myres  = _Small_string_capacity;
; 1401 :                 }
; 1402 : 
; 1403 :                 _Pocca(_Al, _Right_al);
; 1404 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 1405 :                 return *this;
; 1406 :             }
; 1407 :         }
; 1408 : 
; 1409 :         _Pocca(_Al, _Right_al);

	mov	rdx, QWORD PTR _Right_al$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv87[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv85[rsp], rax
	mov	r8, QWORD PTR tv87[rsp]
	mov	rdx, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1411 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN1@operator:

; 1412 :     }

	add	rsp, 72					; 00000048H
	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1359 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1360 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1361 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1362 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1363 :         _Mypair._Myval2._Myproxy = nullptr;
; 1364 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1365 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1366 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Right_data$ = 40
_My_data$ = 48
_Right_data_mem$3 = 56
_My_data_mem$4 = 64
tv148 = 72
this$ = 96
_Right$ = 104
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 1234 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1235 :         // assign by stealing _Right's buffer
; 1236 :         // pre: this != &_Right
; 1237 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1238 :         // pre: *this owns no memory, iterators orphaned
; 1239 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1240 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1241 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 1242 : 
; 1243 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1244 :         if constexpr (_Can_memcpy_val) {
; 1245 : #if _HAS_CXX20
; 1246 :             if (!_STD is_constant_evaluated())
; 1247 : #endif // _HAS_CXX20
; 1248 :             {
; 1249 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1250 :                 if (_Right_data._Large_mode_engaged()) {
; 1251 :                     // take ownership of _Right's iterators along with its buffer
; 1252 :                     _Swap_proxy_and_iterators(_Right);
; 1253 :                 } else {
; 1254 :                     _Right_data._Orphan_all();
; 1255 :                 }
; 1256 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1257 : 
; 1258 :                 const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _My_data_mem$4[rsp], rax

; 1259 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1260 :                 const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _Right_data_mem$3[rsp], rax

; 1261 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$3[rsp]
	mov	rcx, QWORD PTR _My_data_mem$4[rsp]
	call	memcpy

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1266 :                 _Right_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1268 :                 return;

	jmp	$LN1@Take_conte

; 1269 :             }
; 1270 :         }
; 1271 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1272 : 
; 1273 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 1274 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 1275 : 
; 1276 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 1277 :             _Right_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 1278 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1279 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1280 : 
; 1281 :             _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 1282 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv148[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv148[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1
$LN3@Take_conte:

; 1283 :         }
; 1284 : 
; 1285 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 1286 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 1287 : 
; 1288 :         _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 1289 :         _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 1290 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1
$LN1@Take_conte:

; 1291 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
_Pocma_val$ = 32
_Right_al$ = 40
_Al$ = 48
this$ = 80
_Right$ = 88
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 1201 :         noexcept(_Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1202 :         if (this == _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	cmp	QWORD PTR this$[rsp], rax
	jne	SHORT $LN2@operator

; 1203 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 1204 :         }
; 1205 : 
; 1206 :         auto& _Al                 = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1207 :         auto& _Right_al           = _Right._Getal();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Right_al$[rsp], rax

; 1208 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

	mov	DWORD PTR _Pocma_val$[rsp], 0

; 1209 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 1210 :             if (_Al != _Right_al) {
; 1211 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 1212 :                 _Mypair._Myval2._Orphan_all();
; 1213 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1214 :             }
; 1215 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 1216 :             if (_Al != _Right_al) {
; 1217 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 1218 :                 return *this;
; 1219 :             }
; 1220 :         }
; 1221 : 
; 1222 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1223 :         _Pocma(_Al, _Right_al);

	mov	rdx, QWORD PTR _Right_al$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >

; 1224 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 1225 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN1@operator:

; 1226 :     }

	add	rsp, 72					; 00000048H
	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1004 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	mov	QWORD PTR tv75[rsp], rax
	movzx	eax, BYTE PTR $T2[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv75[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 1005 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv89[rsp], rax
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR tv89[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1006 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1007 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
tv75 = 40
tv77 = 48
tv89 = 56
this$ = 80
_Right$ = 88
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
this$ = 64
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 831  :     _CONSTEXPR20 void _Construct_empty() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 832  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 833  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 834  : 
; 835  :         // initialize basic_string data members
; 836  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 838  :         _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 842  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 826  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 827  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 829  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 746  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv130 = 64
tv128 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 711  :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv70[rsp]
	call	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
	npad	1

; 712  :         _Right._Mypair._Myval2._Check_offset(_Roff);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 713  :         _Construct<_Construct_strategy::_From_ptr>(

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv87[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Roff$[rsp]
	mov	rcx, QWORD PTR tv87[rsp]
	call	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
	mov	QWORD PTR tv130[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _Roff$[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	r8, QWORD PTR tv130[rsp]
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 714  :             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
; 715  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv70 = 40
tv78 = 48
tv87 = 56
tv130 = 64
tv128 = 72
this$ = 96
_Right$ = 104
_Roff$ = 112
_Count$ = 120
_Al$ = 128
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 693  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	mov	QWORD PTR tv76[rsp], rax
	movzx	eax, BYTE PTR $T3[rsp]
	mov	BYTE PTR $T1[rsp], al
	mov	r8, QWORD PTR tv76[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv78[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv94[rsp], rax
	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv92[rsp], rax
	mov	r8, QWORD PTR tv94[rsp]
	mov	rdx, QWORD PTR tv92[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
	npad	1

; 695  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 88					; 00000058H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 34
tv76 = 40
tv78 = 48
tv94 = 56
tv92 = 64
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 684  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 685  :         _Construct_empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 686  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Off$ = 72
_Size$ = 80
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Size$[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 469  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 462  :     [[noreturn]] static void _Xran() {

$LN3:
	sub	rsp, 40					; 00000028H

; 463  :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	npad	1
$LN2@Xran:

; 464  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN2@Check_offs

; 451  :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	npad	1
$LN2@Check_offs:
$LN3@Check_offs:

; 452  :         }
; 453  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 416  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 417  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 422  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 750  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 751  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 745  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 984  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 985  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 987  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 978  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 979  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 980  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 982  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 970  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 511  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 512  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 513  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT

; 214  :     constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1449 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1446 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1187 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1182 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1181 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1180 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 221  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 136  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 137  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 109  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA PROC ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_array_new_length@std@@UEAA@XZ@4HA ENDP ; `std::bad_array_new_length::~bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA PROC ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_array_new_length@std@@QEAA@XZ@4HA ENDP ; `std::bad_array_new_length::bad_array_new_length'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@QEAA@AEBV01@@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA PROC		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???1bad_alloc@std@@UEAA@XZ@4HA ENDP		; `std::bad_alloc::~bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Message$ = 56
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA PROC	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0bad_alloc@std@@AEAA@QEBD@Z@4HA ENDP	; `std::bad_alloc::bad_alloc'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z PROC		; std::_Narrow_char_traits<char,int>::eq, COMDAT

; 479  :     _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 24

; 480  :         return _Left == _Right;

	movsx	eax, BYTE PTR _Left$[rsp]
	movsx	ecx, BYTE PTR _Right$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN3@eq
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@eq
$LN3@eq:
	mov	DWORD PTR tv67[rsp], 0
$LN4@eq:
	movzx	eax, BYTE PTR tv67[rsp]

; 481  :     }

	add	rsp, 24
	ret	0
?eq@?$_Narrow_char_traits@DH@std@@SA_NDD@Z ENDP		; std::_Narrow_char_traits<char,int>::eq
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 470  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 471  : #if _HAS_CXX20
; 472  :         if (_STD is_constant_evaluated()) {
; 473  :             return _Primary_char_traits::assign(_Left, _Right);
; 474  :         }
; 475  : #endif // _HAS_CXX20
; 476  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 477  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 438  :         const _Elem& _Ch) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 439  :         // look for _Ch in [_First, _First + _Count)
; 440  : #if _HAS_CXX17
; 441  : #ifdef __cpp_char8_t
; 442  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 443  : #if _HAS_U8_INTRINSICS
; 444  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 445  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 446  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 447  : #endif // ^^^ no u8 intrinsics ^^^
; 448  :         } else
; 449  : #endif // defined(__cpp_char8_t)
; 450  :         {
; 451  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rax, QWORD PTR _Ch$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rsp]
	call	memchr

; 452  :         }
; 453  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 454  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
; 455  : #endif // ^^^ !_HAS_CXX17 ^^^
; 456  :     }

	add	rsp, 40					; 00000028H
	ret	0
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
tv68 = 0
tv67 = 8
_First$ = 32
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 417  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 418  :         // find length of null-terminated string
; 419  : #if _HAS_CXX17
; 420  : #ifdef __cpp_char8_t
; 421  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 422  : #if _HAS_U8_INTRINSICS
; 423  :             return __builtin_u8strlen(_First);
; 424  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 425  :             return _Primary_char_traits::length(_First);
; 426  : #endif // ^^^ no u8 intrinsics ^^^
; 427  :         } else
; 428  : #endif // defined(__cpp_char8_t)
; 429  :         {
; 430  :             return __builtin_strlen(_First);

	mov	rax, QWORD PTR _First$[rsp]
	mov	QWORD PTR tv67[rsp], rax
	mov	QWORD PTR tv68[rsp], -1
$LL3@length:
	inc	QWORD PTR tv68[rsp]
	mov	rax, QWORD PTR tv67[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	BYTE PTR [rax+rcx], 0
	jne	SHORT $LL3@length
	mov	rax, QWORD PTR tv68[rsp]

; 431  :         }
; 432  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 434  : #endif // ^^^ !_HAS_CXX17 ^^^
; 435  :     }

	add	rsp, 24
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z PROC ; std::_Narrow_char_traits<char,int>::compare, COMDAT

; 408  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 409  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 410  : #if _HAS_CXX17
; 411  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcmp

; 412  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 413  :         return _CSTD memcmp(_First1, _First2, _Count);
; 414  : #endif // ^^^ !_HAS_CXX17 ^^^
; 415  :     }

	add	rsp, 40					; 00000028H
	ret	0
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ENDP ; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 110  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 111  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 112  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 113  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 114  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 115  : #if _HAS_CXX20
; 116  :         if (_STD is_constant_evaluated()) {
; 117  :             // dest: [_First1, _First1 + _Count)
; 118  :             // src: [_First2, _First2 + _Count)
; 119  :             // We need to handle overlapping ranges.
; 120  :             // If _First1 is in the src range, we need a backward loop.
; 121  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 122  : 
; 123  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 124  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 125  :             bool _Loop_forward = true;
; 126  : 
; 127  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 128  :                 if (_First1 == _Src) {
; 129  :                     _Loop_forward = false;
; 130  :                     break;
; 131  :                 }
; 132  :             }
; 133  : 
; 134  :             if (_Loop_forward) {
; 135  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 136  :                     _First1[_Idx] = _First2[_Idx];
; 137  :                 }
; 138  :             } else {
; 139  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 140  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 141  :                 }
; 142  :             }
; 143  : 
; 144  :             return _First1;
; 145  :         }
; 146  : #endif // _HAS_CXX20
; 147  : 
; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memmove

; 149  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 150  : 
; 151  :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 152  :     }

	add	rsp, 40					; 00000028H
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 87   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 88   :                 _First1[_Idx] = _First2[_Idx];
; 89   :             }
; 90   : 
; 91   :             return _First1;
; 92   :         }
; 93   : #endif // _HAS_CXX20
; 94   : 
; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 96   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 97   : 
; 98   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 99   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
_TEXT	SEGMENT
_Idx$1 = 0
_Val$ = 32
_First$ = 40
_Count$ = 48
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2290 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2291 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@Fnv1a_appe
$LN2@Fnv1a_appe:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@Fnv1a_appe:
	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Idx$1[rsp], rax
	jae	SHORT $LN3@Fnv1a_appe

; 2292 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Val$[rsp]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2293 :         _Val *= _FNV_prime;

	mov	rax, 1099511628211			; 00000100000001b3H
	mov	rcx, QWORD PTR _Val$[rsp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Val$[rsp], rax

; 2294 :     }

	jmp	SHORT $LN2@Fnv1a_appe
$LN3@Fnv1a_appe:

; 2295 : 
; 2296 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]

; 2297 : }

	add	rsp, 24
	ret	0
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtr1common
;	COMDAT ?_Is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?_Is_constant_evaluated@std@@YA_NXZ PROC		; std::_Is_constant_evaluated, COMDAT

; 178  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 179  : }

	ret	0
?_Is_constant_evaluated@std@@YA_NXZ ENDP		; std::_Is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
tv66 = 32
tv70 = 40
__t$ = 64
__s$ = 72
__n$ = 80
__f$ = 88
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN2@vector:
	mov	rax, QWORD PTR __n$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	mov	rax, QWORD PTR __n$[rsp]
	dec	rax
	mov	QWORD PTR __n$[rsp], rax
	cmp	QWORD PTR tv66[rsp], 0
	jbe	SHORT $LN3@vector
	mov	rax, QWORD PTR __f$[rsp]
	mov	QWORD PTR tv70[rsp], rax
	mov	rcx, QWORD PTR __t$[rsp]
	call	QWORD PTR tv70[rsp]
	mov	rax, QWORD PTR __s$[rsp]
	mov	rcx, QWORD PTR __t$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR __t$[rsp], rax
	jmp	SHORT $LN2@vector
$LN3@vector:
	add	rsp, 56					; 00000038H
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
